/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var jsGlobal = (function () {
    return this || (1, eval)('this//# sourceURL=jsGlobal-getter');
})();
// Our polyfills for some DOM things make testing this slightly more onerous than it ought to be.
var inBrowser = typeof window !== 'undefined' && 'document' in window && 'plugins' in window.document;
var inFirefox = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') >= 0;
// declare let print;
// declare let console;
// declare let performance;
// declare let XMLHttpRequest;
// declare let document;
// declare let getComputedStyle;
/** @define {boolean} */ var release = false;
/** @define {boolean} */ var profile = false;
function dumpLine(line) {
    if (!release && typeof dump !== "undefined") {
        dump(line + "\n");
    }
}
if (!jsGlobal.performance) {
    jsGlobal.performance = {};
}
if (!jsGlobal.performance.now) {
    jsGlobal.performance.now = function () {
        return Date.now();
    };
}
var START_TIME = performance.now();
var Shumway;
(function (Shumway) {
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
    })(CharacterCodes = Shumway.CharacterCodes || (Shumway.CharacterCodes = {}));
    /**
     * The buffer length required to contain any unsigned 32-bit integer.
     */
    /** @const */ Shumway.UINT32_CHAR_BUFFER_LENGTH = 10; // "4294967295".length;
    /** @const */ Shumway.UINT32_MAX = 0xFFFFFFFF;
    /** @const */ Shumway.UINT32_MAX_DIV_10 = 0x19999999; // UINT32_MAX / 10;
    /** @const */ Shumway.UINT32_MAX_MOD_10 = 0x5; // UINT32_MAX % 10
    function isString(value) {
        return typeof value === "string";
    }
    Shumway.isString = isString;
    function isFunction(value) {
        return typeof value === "function";
    }
    Shumway.isFunction = isFunction;
    function isNumber(value) {
        return typeof value === "number";
    }
    Shumway.isNumber = isNumber;
    function isInteger(value) {
        return (value | 0) === value;
    }
    Shumway.isInteger = isInteger;
    function isArray(value) {
        return value instanceof Array;
    }
    Shumway.isArray = isArray;
    function isNumberOrString(value) {
        return typeof value === "number" || typeof value === "string";
    }
    Shumway.isNumberOrString = isNumberOrString;
    function isObject(value) {
        return typeof value === "object" || typeof value === 'function';
    }
    Shumway.isObject = isObject;
    function toNumber(x) {
        return +x;
    }
    Shumway.toNumber = toNumber;
    function isNumericString(value) {
        // ECMAScript 5.1 - 9.8.1 Note 1, this expression is true for all
        // numbers x other than -0.
        return String(Number(value)) === value;
    }
    Shumway.isNumericString = isNumericString;
    /**
     * Whether the specified |value| is a number or the string representation of a number.
     */
    function isNumeric(value) {
        if (typeof value === "number") {
            return true;
        }
        if (typeof value === "string") {
            // |value| is rarely numeric (it's usually an identifier), and the
            // isIndex()/isNumericString() pair is slow and expensive, so we do a
            // quick check for obvious non-numericalness first. Just checking if the
            // first char is a 7-bit identifier char catches most cases.
            var c = value.charCodeAt(0);
            if ((65 <= c && c <= 90) || // 'A'..'Z'
                (97 <= c && c <= 122) || // 'a'..'z'
                (c === 36) || // '$'
                (c === 95)) {
                return false;
            }
            return isIndex(value) || isNumericString(value);
        }
        return false;
    }
    Shumway.isNumeric = isNumeric;
    /**
     * Whether the specified |value| is an unsigned 32 bit number expressed as a number
     * or string.
     */
    function isIndex(value) {
        // js/src/vm/String.cpp JSFlatString::isIndexSlow
        // http://dxr.mozilla.org/mozilla-central/source/js/src/vm/String.cpp#474
        var index = 0;
        if (typeof value === "number") {
            index = (value | 0);
            if (value === index && index >= 0) {
                return true;
            }
            return value >>> 0 === value;
        }
        if (typeof value !== "string") {
            return false;
        }
        var length = value.length;
        if (length === 0) {
            return false;
        }
        if (value === "0") {
            return true;
        }
        // Is there any way this will fit?
        if (length > Shumway.UINT32_CHAR_BUFFER_LENGTH) {
            return false;
        }
        var i = 0;
        index = value.charCodeAt(i++) - 48 /* _0 */;
        if (index < 1 || index > 9) {
            return false;
        }
        var oldIndex = 0;
        var c = 0;
        while (i < length) {
            c = value.charCodeAt(i++) - 48 /* _0 */;
            if (c < 0 || c > 9) {
                return false;
            }
            oldIndex = index;
            index = 10 * index + c;
        }
        /*
         * Look out for "4294967296" and larger-number strings that fit in UINT32_CHAR_BUFFER_LENGTH.
         * Only unsigned 32-bit integers shall pass.
         */
        if ((oldIndex < Shumway.UINT32_MAX_DIV_10) || (oldIndex === Shumway.UINT32_MAX_DIV_10 && c <= Shumway.UINT32_MAX_MOD_10)) {
            return true;
        }
        return false;
    }
    Shumway.isIndex = isIndex;
    function isNullOrUndefined(value) {
        return value == undefined;
    }
    Shumway.isNullOrUndefined = isNullOrUndefined;
    function argumentsToString(args) {
        var resultList = [];
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            try {
                var argStr = void 0;
                if (typeof arg !== 'object' || !arg) {
                    argStr = arg + '';
                }
                else if ('toString' in arg) {
                    argStr = arg.toString();
                }
                else {
                    argStr = Object.prototype.toString.call(arg);
                }
                resultList.push(argStr);
            }
            catch (e) {
                resultList.push('<unprintable value>');
            }
        }
        return resultList.join(', ');
    }
    Shumway.argumentsToString = argumentsToString;
    var Debug;
    (function (Debug) {
        function error(message) {
            console.error(message);
            throw new Error(message);
        }
        Debug.error = error;
        function assert(condition, message) {
            if (message === void 0) { message = "assertion failed"; }
            if (condition === "") {
                condition = true;
            }
            if (!condition) {
                if (typeof console !== 'undefined' && 'assert' in console) {
                    console.assert(false, message);
                    throw new Error(message);
                }
                else {
                    Debug.error(message.toString());
                }
            }
        }
        Debug.assert = assert;
        function assertUnreachable(msg) {
            var location = new Error().stack.split('\n')[1];
            throw new Error("Reached unreachable location " + location + msg);
        }
        Debug.assertUnreachable = assertUnreachable;
        function assertNotImplemented(condition, message) {
            if (!condition) {
                Debug.error("notImplemented: " + message);
            }
        }
        Debug.assertNotImplemented = assertNotImplemented;
        var _warnedCounts = Object.create(null);
        function warning(message, arg1, arg2 /*...messages: any[]*/) {
            if (release) {
                return;
            }
            var key = argumentsToString(arguments);
            if (_warnedCounts[key]) {
                _warnedCounts[key]++;
                if (Shumway.omitRepeatedWarnings.value) {
                    return;
                }
            }
            _warnedCounts[key] = 1;
            console.warn.apply(console, arguments);
        }
        Debug.warning = warning;
        function warnCounts() {
            var list = [];
            for (var key in _warnedCounts) {
                list.push({ key: key, count: _warnedCounts[key] });
            }
            list.sort(function (entry, prev) { return prev.count - entry.count; });
            return list.reduce(function (result, entry) { return (result += '\n' + entry.count + '\t' + entry.key); }, '');
        }
        Debug.warnCounts = warnCounts;
        function notImplemented(message) {
            release || Debug.assert(false, "Not Implemented " + message);
        }
        Debug.notImplemented = notImplemented;
        function dummyConstructor(message) {
            release || Debug.assert(false, "Dummy Constructor: " + message);
        }
        Debug.dummyConstructor = dummyConstructor;
        function abstractMethod(message) {
            release || Debug.assert(false, "Abstract Method " + message);
        }
        Debug.abstractMethod = abstractMethod;
        var somewhatImplementedCache = {};
        function somewhatImplemented(message) {
            if (somewhatImplementedCache[message]) {
                return;
            }
            somewhatImplementedCache[message] = true;
            Debug.warning("somewhatImplemented: " + message);
        }
        Debug.somewhatImplemented = somewhatImplemented;
        function unexpected(message) {
            Debug.assert(false, "Unexpected: " + message);
        }
        Debug.unexpected = unexpected;
        function unexpectedCase(message) {
            Debug.assert(false, "Unexpected Case: " + message);
        }
        Debug.unexpectedCase = unexpectedCase;
    })(Debug = Shumway.Debug || (Shumway.Debug = {}));
    function getTicks() {
        return performance.now();
    }
    Shumway.getTicks = getTicks;
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var assert = Shumway.Debug.assert;
        /**
         * Pops elements from a source array into a destination array. This avoids
         * allocations and should be faster. The elements in the destination array
         * are pushed in the same order as they appear in the source array:
         *
         * popManyInto([1, 2, 3], 2, dst) => dst = [2, 3]
         */
        function popManyInto(src, count, dst) {
            release || assert(src.length >= count);
            for (var i = count - 1; i >= 0; i--) {
                dst[i] = src.pop();
            }
            dst.length = count;
        }
        ArrayUtilities.popManyInto = popManyInto;
        function popMany(array, count) {
            release || assert(array.length >= count);
            var start = array.length - count;
            var result = array.slice(start, this.length);
            array.length = start;
            return result;
        }
        ArrayUtilities.popMany = popMany;
        /**
         * Just deletes several array elements from the end of the list.
         */
        function popManyIntoVoid(array, count) {
            release || assert(array.length >= count);
            array.length = array.length - count;
        }
        ArrayUtilities.popManyIntoVoid = popManyIntoVoid;
        function pushMany(dst, src) {
            for (var i = 0; i < src.length; i++) {
                dst.push(src[i]);
            }
        }
        ArrayUtilities.pushMany = pushMany;
        function top(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.top = top;
        function last(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.last = last;
        function peek(array) {
            release || assert(array.length > 0);
            return array[array.length - 1];
        }
        ArrayUtilities.peek = peek;
        function indexOf(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }
        ArrayUtilities.indexOf = indexOf;
        function equals(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        ArrayUtilities.equals = equals;
        function pushUnique(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            array.push(value);
            return array.length - 1;
        }
        ArrayUtilities.pushUnique = pushUnique;
        function unique(array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                pushUnique(result, array[i]);
            }
            return result;
        }
        ArrayUtilities.unique = unique;
        function copyFrom(dst, src) {
            dst.length = 0;
            ArrayUtilities.pushMany(dst, src);
        }
        ArrayUtilities.copyFrom = copyFrom;
        /**
         * Makes sure that a typed array has the requested capacity. If required, it creates a new
         * instance of the array's class with a power-of-two capacity at least as large as required.
         */
        function ensureTypedArrayCapacity(array, capacity) {
            if (array.length < capacity) {
                var oldArray = array;
                array = new array.constructor(Shumway.IntegerUtilities.nearestPowerOfTwo(capacity));
                array.set(oldArray, 0);
            }
            return array;
        }
        ArrayUtilities.ensureTypedArrayCapacity = ensureTypedArrayCapacity;
        function memCopy(destination, source, doffset, soffset, length) {
            if (doffset === void 0) { doffset = 0; }
            if (soffset === void 0) { soffset = 0; }
            if (length === void 0) { length = 0; }
            if (soffset > 0 || (length > 0 && length < source.length)) {
                if (length <= 0) {
                    length = source.length - soffset;
                }
                destination.set(source.subarray(soffset, soffset + length), doffset);
            }
            else {
                destination.set(source, doffset);
            }
        }
        ArrayUtilities.memCopy = memCopy;
    })(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
    var ObjectUtilities;
    (function (ObjectUtilities) {
        function boxValue(value) {
            if (isNullOrUndefined(value) || isObject(value)) {
                return value;
            }
            return Object(value);
        }
        ObjectUtilities.boxValue = boxValue;
        function toKeyValueArray(object) {
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var array = [];
            for (var k in object) {
                if (hasOwnProperty.call(object, k)) {
                    array.push([k, object[k]]);
                }
            }
            return array;
        }
        ObjectUtilities.toKeyValueArray = toKeyValueArray;
        function isPrototypeWriteable(object) {
            return Object.getOwnPropertyDescriptor(object, "prototype").writable;
        }
        ObjectUtilities.isPrototypeWriteable = isPrototypeWriteable;
        function hasOwnProperty(object, name) {
            return Object.prototype.hasOwnProperty.call(object, name);
        }
        ObjectUtilities.hasOwnProperty = hasOwnProperty;
        function propertyIsEnumerable(object, name) {
            return Object.prototype.propertyIsEnumerable.call(object, name);
        }
        ObjectUtilities.propertyIsEnumerable = propertyIsEnumerable;
        /**
         * Returns a property descriptor for the own or inherited property with the given name, or
         * null if one doesn't exist.
         */
        function getPropertyDescriptor(object, name) {
            do {
                var propDesc = Object.getOwnPropertyDescriptor(object, name);
                if (propDesc) {
                    return propDesc;
                }
                object = Object.getPrototypeOf(object);
            } while (object);
            return null;
        }
        ObjectUtilities.getPropertyDescriptor = getPropertyDescriptor;
        function hasOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && d.get);
        }
        ObjectUtilities.hasOwnGetter = hasOwnGetter;
        function getOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return d ? d.get : null;
        }
        ObjectUtilities.getOwnGetter = getOwnGetter;
        function hasOwnSetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && !!d.set);
        }
        ObjectUtilities.hasOwnSetter = hasOwnSetter;
        function createMap() {
            return Object.create(null);
        }
        ObjectUtilities.createMap = createMap;
        function createArrayMap() {
            return [];
        }
        ObjectUtilities.createArrayMap = createArrayMap;
        function defineReadOnlyProperty(object, name, value) {
            Object.defineProperty(object, name, {
                value: value,
                writable: false,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineReadOnlyProperty = defineReadOnlyProperty;
        function copyProperties(object, template) {
            for (var property in template) {
                object[property] = template[property];
            }
        }
        ObjectUtilities.copyProperties = copyProperties;
        function copyOwnProperties(object, template) {
            for (var property in template) {
                if (hasOwnProperty(template, property)) {
                    object[property] = template[property];
                }
            }
        }
        ObjectUtilities.copyOwnProperties = copyOwnProperties;
        function copyOwnPropertyDescriptors(object, template, filter, overwrite, makeWritable) {
            if (filter === void 0) { filter = null; }
            if (overwrite === void 0) { overwrite = true; }
            if (makeWritable === void 0) { makeWritable = false; }
            for (var property in template) {
                if (hasOwnProperty(template, property) && (!filter || filter(property))) {
                    var descriptor = Object.getOwnPropertyDescriptor(template, property);
                    if (!overwrite && hasOwnProperty(object, property)) {
                        continue;
                    }
                    release || Debug.assert(descriptor);
                    try {
                        if (makeWritable && descriptor.writable === false) {
                            descriptor.writable = true;
                        }
                        Object.defineProperty(object, property, descriptor);
                    }
                    catch (e) {
                        Debug.assert("Can't define: " + property);
                    }
                }
            }
        }
        ObjectUtilities.copyOwnPropertyDescriptors = copyOwnPropertyDescriptors;
        function copyPropertiesByList(object, template, propertyList) {
            for (var i = 0; i < propertyList.length; i++) {
                var property = propertyList[i];
                object[property] = template[property];
            }
        }
        ObjectUtilities.copyPropertiesByList = copyPropertiesByList;
        function defineNonEnumerableGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                get: getter,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableGetter = defineNonEnumerableGetter;
        function defineNonEnumerableProperty(obj, name, value) {
            Object.defineProperty(obj, name, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableProperty = defineNonEnumerableProperty;
    })(ObjectUtilities = Shumway.ObjectUtilities || (Shumway.ObjectUtilities = {}));
    var FunctionUtilities;
    (function (FunctionUtilities) {
        function makeForwardingGetter(target) {
            return new Function("return this[\"" + target + "\"]//# sourceURL=fwd-get-" +
                target + ".as");
        }
        FunctionUtilities.makeForwardingGetter = makeForwardingGetter;
        function makeForwardingSetter(target) {
            return new Function("value", "this[\"" + target + "\"] = value;" +
                "//# sourceURL=fwd-set-" + target + ".as");
        }
        FunctionUtilities.makeForwardingSetter = makeForwardingSetter;
    })(FunctionUtilities = Shumway.FunctionUtilities || (Shumway.FunctionUtilities = {}));
    var StringUtilities;
    (function (StringUtilities) {
        var assert = Shumway.Debug.assert;
        function repeatString(c, n) {
            var s = "";
            for (var i = 0; i < n; i++) {
                s += c;
            }
            return s;
        }
        StringUtilities.repeatString = repeatString;
        function memorySizeToString(value) {
            value |= 0;
            var K = 1024;
            var M = K * K;
            if (value < K) {
                return value + " B";
            }
            else if (value < M) {
                return (value / K).toFixed(2) + "KB";
            }
            else {
                return (value / M).toFixed(2) + "MB";
            }
        }
        StringUtilities.memorySizeToString = memorySizeToString;
        /**
         * Returns a reasonably sized description of the |value|, to be used for debugging purposes.
         */
        function toSafeString(value) {
            if (typeof value === "string") {
                return "\"" + value + "\"";
            }
            if (typeof value === "number" || typeof value === "boolean") {
                return String(value);
            }
            if (value instanceof Array) {
                return "[] " + value.length;
            }
            return typeof value;
        }
        StringUtilities.toSafeString = toSafeString;
        function toSafeArrayString(array) {
            var str = [];
            for (var i = 0; i < array.length; i++) {
                str.push(toSafeString(array[i]));
            }
            return str.join(", ");
        }
        StringUtilities.toSafeArrayString = toSafeArrayString;
        function utf8decode(str) {
            var bytes = new Uint8Array(str.length * 4);
            var b = 0;
            for (var i = 0, j = str.length; i < j; i++) {
                var code = str.charCodeAt(i);
                if (code <= 0x7f) {
                    bytes[b++] = code;
                    continue;
                }
                if (0xD800 <= code && code <= 0xDBFF) {
                    var codeLow = str.charCodeAt(i + 1);
                    if (0xDC00 <= codeLow && codeLow <= 0xDFFF) {
                        // convert only when both high and low surrogates are present
                        code = ((code & 0x3FF) << 10) + (codeLow & 0x3FF) + 0x10000;
                        ++i;
                    }
                }
                if ((code & 0xFFE00000) !== 0) {
                    bytes[b++] = 0xF8 | ((code >>> 24) & 0x03);
                    bytes[b++] = 0x80 | ((code >>> 18) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 12) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                }
                else if ((code & 0xFFFF0000) !== 0) {
                    bytes[b++] = 0xF0 | ((code >>> 18) & 0x07);
                    bytes[b++] = 0x80 | ((code >>> 12) & 0x3F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                }
                else if ((code & 0xFFFFF800) !== 0) {
                    bytes[b++] = 0xE0 | ((code >>> 12) & 0x0F);
                    bytes[b++] = 0x80 | ((code >>> 6) & 0x3F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                }
                else {
                    bytes[b++] = 0xC0 | ((code >>> 6) & 0x1F);
                    bytes[b++] = 0x80 | (code & 0x3F);
                }
            }
            return bytes.subarray(0, b);
        }
        StringUtilities.utf8decode = utf8decode;
        function utf8encode(bytes) {
            var j = 0, str = "";
            while (j < bytes.length) {
                var b1 = bytes[j++] & 0xFF;
                if (b1 <= 0x7F) {
                    str += String.fromCharCode(b1);
                }
                else {
                    var currentPrefix = 0xC0;
                    var validBits = 5;
                    do {
                        var mask = (currentPrefix >> 1) | 0x80;
                        if ((b1 & mask) === currentPrefix)
                            break;
                        currentPrefix = (currentPrefix >> 1) | 0x80;
                        --validBits;
                    } while (validBits >= 0);
                    if (validBits <= 0) {
                        // Invalid UTF8 character -- copying as is
                        str += String.fromCharCode(b1);
                        continue;
                    }
                    var code = (b1 & ((1 << validBits) - 1));
                    var invalid = false;
                    var i = void 0;
                    for (i = 5; i >= validBits; --i) {
                        var bi = bytes[j++];
                        if ((bi & 0xC0) != 0x80) {
                            // Invalid UTF8 character sequence
                            invalid = true;
                            break;
                        }
                        code = (code << 6) | (bi & 0x3F);
                    }
                    if (invalid) {
                        // Copying invalid sequence as is
                        for (var k = j - (7 - i); k < j; ++k) {
                            str += String.fromCharCode(bytes[k] & 255);
                        }
                        continue;
                    }
                    if (code >= 0x10000) {
                        str += String.fromCharCode((((code - 0x10000) >> 10) & 0x3FF) |
                            0xD800, (code & 0x3FF) | 0xDC00);
                    }
                    else {
                        str += String.fromCharCode(code);
                    }
                }
            }
            return str;
        }
        StringUtilities.utf8encode = utf8encode;
        // https://gist.github.com/958841
        function base64EncodeBytes(bytes) {
            var base64 = '';
            var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            var byteLength = bytes.byteLength;
            var byteRemainder = byteLength % 3;
            var mainLength = byteLength - byteRemainder;
            var a, b, c, d;
            var chunk;
            // Main loop deals with bytes in chunks of 3
            for (var i = 0; i < mainLength; i = i + 3) {
                // Combine the three bytes into a single integer
                chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
                // Use bitmasks to extract 6-bit segments from the triplet
                a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
                b = (chunk & 258048) >> 12; // 258048 = (2^6 - 1) << 12
                c = (chunk & 4032) >> 6; // 4032 = (2^6 - 1) << 6
                d = chunk & 63; // 63 = 2^6 - 1
                // Convert the raw binary segments to the appropriate ASCII encoding
                base64 += concat4(encodings[a], encodings[b], encodings[c], encodings[d]);
            }
            // Deal with the remaining bytes and padding
            if (byteRemainder == 1) {
                chunk = bytes[mainLength];
                a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
                // Set the 4 least significant bits to zero
                b = (chunk & 3) << 4; // 3 = 2^2 - 1
                base64 += concat3(encodings[a], encodings[b], '==');
            }
            else if (byteRemainder == 2) {
                chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
                a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
                b = (chunk & 1008) >> 4; // 1008 = (2^6 - 1) << 4
                // Set the 2 least significant bits to zero
                c = (chunk & 15) << 2; // 15 = 2^4 - 1
                base64 += concat4(encodings[a], encodings[b], encodings[c], '=');
            }
            return base64;
        }
        StringUtilities.base64EncodeBytes = base64EncodeBytes;
        var base64DecodeMap = [
            62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            0, 0, 0, 0, 0, 0, 0,
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
            19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0,
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51
        ];
        var base64DecodeMapOffset = 0x2B;
        var base64EOF = 0x3D;
        /**
         * Decodes the result of encoding with base64EncodeBytes, but not necessarily any other
         * base64-encoded data. Note that this also doesn't do any error checking.
         */
        function decodeRestrictedBase64ToBytes(encoded) {
            var ch;
            var code;
            var code2;
            var len = encoded.length;
            var padding = encoded.charAt(len - 2) === '=' ? 2 : encoded.charAt(len - 1) === '=' ? 1 : 0;
            release || assert(encoded.length % 4 === 0);
            var decoded = new Uint8Array((encoded.length >> 2) * 3 - padding);
            for (var i = 0, j = 0; i < encoded.length;) {
                ch = encoded.charCodeAt(i++);
                code = base64DecodeMap[ch - base64DecodeMapOffset];
                ch = encoded.charCodeAt(i++);
                code2 = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = (code << 2) | ((code2 & 0x30) >> 4);
                ch = encoded.charCodeAt(i++);
                if (ch == base64EOF) {
                    return decoded;
                }
                code = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = ((code2 & 0x0f) << 4) | ((code & 0x3c) >> 2);
                ch = encoded.charCodeAt(i++);
                if (ch == base64EOF) {
                    return decoded;
                }
                code2 = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = ((code & 0x03) << 6) | code2;
            }
            return decoded;
        }
        StringUtilities.decodeRestrictedBase64ToBytes = decodeRestrictedBase64ToBytes;
        function escapeString(str) {
            if (str !== undefined) {
                str = str.replace(/[^\w$]/gi, "$");
                /* No dots, colons, dashes and /s */
                if (/^\d/.test(str)) {
                    str = '$' + str;
                }
            }
            return str;
        }
        StringUtilities.escapeString = escapeString;
        /**
         * Workaround for max stack size limit.
         */
        function fromCharCodeArray(buffer) {
            var str = "", SLICE = 1024 * 16;
            for (var i = 0; i < buffer.length; i += SLICE) {
                var chunk = Math.min(buffer.length - i, SLICE);
                str += String.fromCharCode.apply(null, buffer.subarray(i, i + chunk));
            }
            return str;
        }
        StringUtilities.fromCharCodeArray = fromCharCodeArray;
        var _encoding = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_';
        function variableLengthEncodeInt32(n) {
            var e = _encoding;
            var bitCount = (32 - Math.clz32(n));
            release || assert(bitCount <= 32, bitCount);
            var l = Math.ceil(bitCount / 6);
            // Encode length followed by six bit chunks.
            var s = e[l];
            for (var i = l - 1; i >= 0; i--) {
                var offset = (i * 6);
                s += e[(n >> offset) & 0x3F];
            }
            release || assert(StringUtilities.variableLengthDecodeInt32(s) === n, n + " : " + s + " - " + l + " bits: " + bitCount);
            return s;
        }
        StringUtilities.variableLengthEncodeInt32 = variableLengthEncodeInt32;
        function toEncoding(n) {
            return _encoding[n];
        }
        StringUtilities.toEncoding = toEncoding;
        function fromEncoding(c) {
            if (c >= 65 && c <= 90) {
                return c - 65;
            }
            else if (c >= 97 && c <= 122) {
                return c - 71;
            }
            else if (c >= 48 && c <= 57) {
                return c + 4;
            }
            else if (c === 36) {
                return 62;
            }
            else if (c === 95) {
                return 63;
            }
            release || assert(false, "Invalid Encoding");
            return 0;
        }
        StringUtilities.fromEncoding = fromEncoding;
        function variableLengthDecodeInt32(s) {
            var l = StringUtilities.fromEncoding(s.charCodeAt(0));
            var n = 0;
            for (var i = 0; i < l; i++) {
                var offset = ((l - i - 1) * 6);
                n |= StringUtilities.fromEncoding(s.charCodeAt(1 + i)) << offset;
            }
            return n;
        }
        StringUtilities.variableLengthDecodeInt32 = variableLengthDecodeInt32;
        function trimMiddle(s, maxLength) {
            if (s.length <= maxLength) {
                return s;
            }
            var leftHalf = maxLength >> 1;
            var rightHalf = maxLength - leftHalf - 1;
            return s.substr(0, leftHalf) + "\u2026" + s.substr(s.length - rightHalf, rightHalf);
        }
        StringUtilities.trimMiddle = trimMiddle;
        function multiple(s, count) {
            var o = "";
            for (var i = 0; i < count; i++) {
                o += s;
            }
            return o;
        }
        StringUtilities.multiple = multiple;
        function indexOfAny(s, chars, position) {
            var index = s.length;
            for (var i = 0; i < chars.length; i++) {
                var j = s.indexOf(chars[i], position);
                if (j >= 0) {
                    index = Math.min(index, j);
                }
            }
            return index === s.length ? -1 : index;
        }
        StringUtilities.indexOfAny = indexOfAny;
        var _concat3array = new Array(3);
        var _concat4array = new Array(4);
        var _concat9array = new Array(9);
        /**
         * The concatN() functions concatenate multiple strings in a way that
         * avoids creating intermediate strings, unlike String.prototype.concat().
         *
         * Note that these functions don't have identical behaviour to using '+',
         * because they will ignore any arguments that are |undefined| or |null|.
         * This usually doesn't matter.
         */
        function concat3(s0, s1, s2) {
            _concat3array[0] = s0;
            _concat3array[1] = s1;
            _concat3array[2] = s2;
            return _concat3array.join('');
        }
        StringUtilities.concat3 = concat3;
        function concat4(s0, s1, s2, s3) {
            _concat4array[0] = s0;
            _concat4array[1] = s1;
            _concat4array[2] = s2;
            _concat4array[3] = s3;
            return _concat4array.join('');
        }
        StringUtilities.concat4 = concat4;
        function concat9(s0, s1, s2, s3, s4, s5, s6, s7, s8) {
            _concat9array[0] = s0;
            _concat9array[1] = s1;
            _concat9array[2] = s2;
            _concat9array[3] = s3;
            _concat9array[4] = s4;
            _concat9array[5] = s5;
            _concat9array[6] = s6;
            _concat9array[7] = s7;
            _concat9array[8] = s8;
            return _concat9array.join('');
        }
        StringUtilities.concat9 = concat9;
    })(StringUtilities = Shumway.StringUtilities || (Shumway.StringUtilities = {}));
    var HashUtilities;
    (function (HashUtilities) {
        var _md5R = new Uint8Array([
            7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
            5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
            4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
            6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
        ]);
        var _md5K = new Int32Array([
            -680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426,
            -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162,
            1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632,
            643717713, -373897302, -701558691, 38016083, -660478335, -405537848,
            568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784,
            1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556,
            -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222,
            -722521979, 76029189, -640364487, -421815835, 530742520, -995338651,
            -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606,
            -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649,
            -145523070, -1120210379, 718787259, -343485551
        ]);
        function hashBytesTo32BitsMD5(data, offset, length) {
            var r = _md5R;
            var k = _md5K;
            var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
            // pre-processing
            var paddedLength = (length + 72) & ~63; // data + 9 extra bytes
            var padded = new Uint8Array(paddedLength);
            var i, j, n;
            for (i = 0; i < length; ++i) {
                padded[i] = data[offset++];
            }
            padded[i++] = 0x80;
            n = paddedLength - 8;
            while (i < n) {
                padded[i++] = 0;
            }
            padded[i++] = (length << 3) & 0xFF;
            padded[i++] = (length >> 5) & 0xFF;
            padded[i++] = (length >> 13) & 0xFF;
            padded[i++] = (length >> 21) & 0xFF;
            padded[i++] = (length >>> 29) & 0xFF;
            padded[i++] = 0;
            padded[i++] = 0;
            padded[i++] = 0;
            // chunking
            // TODO ArrayBuffer ?
            var w = new Int32Array(16);
            for (i = 0; i < paddedLength;) {
                for (j = 0; j < 16; ++j, i += 4) {
                    w[j] = (padded[i] | (padded[i + 1] << 8) |
                        (padded[i + 2] << 16) | (padded[i + 3] << 24));
                }
                var a = h0, b = h1, c = h2, d = h3, f = void 0, g = void 0;
                for (j = 0; j < 64; ++j) {
                    if (j < 16) {
                        f = (b & c) | ((~b) & d);
                        g = j;
                    }
                    else if (j < 32) {
                        f = (d & b) | ((~d) & c);
                        g = (5 * j + 1) & 15;
                    }
                    else if (j < 48) {
                        f = b ^ c ^ d;
                        g = (3 * j + 5) & 15;
                    }
                    else {
                        f = c ^ (b | (~d));
                        g = (7 * j) & 15;
                    }
                    var tmp = d, rotateArg = (a + f + k[j] + w[g]) | 0, rotate = r[j];
                    d = c;
                    c = b;
                    b = (b + ((rotateArg << rotate) | (rotateArg >>> (32 - rotate)))) | 0;
                    a = tmp;
                }
                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
            }
            return h0;
        }
        HashUtilities.hashBytesTo32BitsMD5 = hashBytesTo32BitsMD5;
        function mixHash(a, b) {
            return (((31 * a) | 0) + b) | 0;
        }
        HashUtilities.mixHash = mixHash;
    })(HashUtilities = Shumway.HashUtilities || (Shumway.HashUtilities = {}));
    /**
     * An extremely naive cache with a maximum size.
     * TODO: LRU
     */
    var Cache = /** @class */ (function () {
        function Cache(maxSize) {
            this._data = Object.create(null);
            this._size = 0;
            this._maxSize = maxSize;
        }
        Cache.prototype.get = function (key) {
            return this._data[key];
        };
        Cache.prototype.set = function (key, value) {
            release || Debug.assert(!(key in this._data)); // Cannot mutate cache entries.
            if (this._size >= this._maxSize) {
                return false;
            }
            this._data[key] = value;
            this._size++;
            return true;
        };
        return Cache;
    }());
    Shumway.Cache = Cache;
    /**
     * Marsaglia's algorithm, adapted from V8. Use this if you want a deterministic random number.
     */
    var Random = /** @class */ (function () {
        function Random() {
        }
        Random.seed = function (seed) {
            Random._state[0] = seed;
            Random._state[1] = seed;
        };
        Random.reset = function () {
            Random._state[0] = 0xDEAD;
            Random._state[1] = 0xBEEF;
        };
        Random.next = function () {
            var s = this._state;
            var r0 = (Math.imul(18273, s[0] & 0xFFFF) + (s[0] >>> 16)) | 0;
            s[0] = r0;
            var r1 = (Math.imul(36969, s[1] & 0xFFFF) + (s[1] >>> 16)) | 0;
            s[1] = r1;
            var x = ((r0 << 16) + (r1 & 0xFFFF)) | 0;
            // Division by 0x100000000 through multiplication by reciprocal.
            return (x < 0 ? (x + 0x100000000) : x) * 2.3283064365386962890625e-10;
        };
        Random._state = new Uint32Array([0xDEAD, 0xBEEF]);
        return Random;
    }());
    Shumway.Random = Random;
    Math.random = function random() {
        return Random.next();
    };
    /**
     * This should only be called if you need fake time.
     */
    function installTimeWarper() {
        var RealDate = Date;
        // Go back in time.
        var fakeTime = 1428107694580; // 3-Apr-2015
        // Overload
        jsGlobal.Date = function (yearOrTimevalue, month, date, hour, minute, second, millisecond) {
            switch (arguments.length) {
                case 0:
                    return new RealDate(fakeTime);
                case 1:
                    return new RealDate(yearOrTimevalue);
                case 2:
                    return new RealDate(yearOrTimevalue, month);
                case 3:
                    return new RealDate(yearOrTimevalue, month, date);
                case 4:
                    return new RealDate(yearOrTimevalue, month, date, hour);
                case 5:
                    return new RealDate(yearOrTimevalue, month, date, hour, minute);
                case 6:
                    return new RealDate(yearOrTimevalue, month, date, hour, minute, second);
                default:
                    return new RealDate(yearOrTimevalue, month, date, hour, minute, second, millisecond);
            }
        };
        // Make date now deterministic.
        jsGlobal.Date.now = function () {
            return fakeTime += 10; // Advance time.
        };
        jsGlobal.Date.UTC = function () {
            return RealDate.UTC.apply(RealDate, arguments);
        };
    }
    Shumway.installTimeWarper = installTimeWarper;
    function polyfillWeakMap() {
        if (typeof jsGlobal.WeakMap === 'function') {
            return; // weak map is supported
        }
        var id = 0;
        function WeakMap() {
            this.id = '$weakmap' + (id++);
        }
        WeakMap.prototype = {
            has: function (obj) {
                return obj.hasOwnProperty(this.id);
            },
            get: function (obj, defaultValue) {
                return obj.hasOwnProperty(this.id) ? obj[this.id] : defaultValue;
            },
            set: function (obj, value) {
                Object.defineProperty(obj, this.id, {
                    value: value,
                    enumerable: false,
                    configurable: true
                });
            },
            delete: function (obj) {
                delete obj[this.id];
            }
        };
        jsGlobal.WeakMap = WeakMap;
    }
    polyfillWeakMap();
    var useReferenceCounting = false;
    var WeakList = /** @class */ (function () {
        function WeakList() {
            if (typeof ShumwayCom !== "undefined" && ShumwayCom.getWeakMapKeys) {
                this._map = new WeakMap();
                this._id = 0;
                this._newAdditions = [];
            }
            else {
                this._list = [];
            }
        }
        WeakList.prototype.clear = function () {
            if (this._map) {
                this._map = new WeakMap();
            }
            else {
                this._list.length = 0;
            }
        };
        WeakList.prototype.push = function (value) {
            if (this._map) {
                release || Debug.assert(!this._map.has(value));
                // We store an increasing id as the value so that keys can be sorted by it.
                this._map.set(value, this._id++);
                this._newAdditions.forEach(function (additions) {
                    additions.push(value);
                });
            }
            else {
                release || Debug.assert(this._list.indexOf(value) === -1);
                this._list.push(value);
            }
        };
        WeakList.prototype.remove = function (value) {
            if (this._map) {
                release || Debug.assert(this._map.has(value));
                this._map.delete(value);
            }
            else {
                release || Debug.assert(this._list.indexOf(value) > -1);
                this._list[this._list.indexOf(value)] = null;
                release || Debug.assert(this._list.indexOf(value) === -1);
            }
        };
        WeakList.prototype.forEach = function (callback) {
            if (this._map) {
                var newAdditionsToKeys = [];
                this._newAdditions.push(newAdditionsToKeys);
                var map_1 = this._map;
                var keys = ShumwayCom.getWeakMapKeys(map_1);
                // The keys returned by ShumwayCom.getWeakMapKeys are not guaranteed to
                // be in insertion order. Therefore we have to sort them manually.
                keys.sort(function (a, b) {
                    return map_1.get(a) - map_1.get(b);
                });
                keys.forEach(function (value) {
                    if (!useReferenceCounting || value._referenceCount !== 0) {
                        callback(value);
                    }
                });
                // ShumwayCom.getWeakMapKeys take snapshot of the keys, but we are also
                // interested in new added keys while keys.forEach was run.
                newAdditionsToKeys.forEach(function (value) {
                    if (!useReferenceCounting || value._referenceCount !== 0) {
                        callback(value);
                    }
                });
                this._newAdditions.splice(this._newAdditions.indexOf(newAdditionsToKeys), 1);
                return;
            }
            var list = this._list;
            var zeroCount = 0;
            for (var i = 0; i < list.length; i++) {
                var value = list[i];
                if (!value) {
                    continue;
                }
                if (useReferenceCounting && value._referenceCount === 0) {
                    list[i] = null;
                    zeroCount++;
                }
                else {
                    callback(value);
                }
            }
            if (zeroCount > 16 && zeroCount > (list.length >> 2)) {
                var newList = [];
                for (var i = 0; i < list.length; i++) {
                    var value = list[i];
                    if (value && value._referenceCount > 0) {
                        newList.push(value);
                    }
                }
                this._list = newList;
            }
        };
        Object.defineProperty(WeakList.prototype, "length", {
            get: function () {
                if (this._map) {
                    // TODO: Implement this.
                    return -1;
                }
                else {
                    return this._list.length;
                }
            },
            enumerable: true,
            configurable: true
        });
        return WeakList;
    }());
    Shumway.WeakList = WeakList;
    var NumberUtilities;
    (function (NumberUtilities) {
        function pow2(exponent) {
            if (exponent === (exponent | 0)) {
                if (exponent < 0) {
                    return 1 / (1 << -exponent);
                }
                return 1 << exponent;
            }
            return Math.pow(2, exponent);
        }
        NumberUtilities.pow2 = pow2;
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        NumberUtilities.clamp = clamp;
        /**
         * Rounds *.5 to the nearest even number.
         * See https://en.wikipedia.org/wiki/Rounding#Round_half_to_even for details.
         */
        function roundHalfEven(value) {
            if (Math.abs(value % 1) === 0.5) {
                var floor = Math.floor(value);
                return floor % 2 === 0 ? floor : Math.ceil(value);
            }
            return Math.round(value);
        }
        NumberUtilities.roundHalfEven = roundHalfEven;
        /**
         * Rounds *.5 up on even occurrences, down on odd occurrences.
         * See https://en.wikipedia.org/wiki/Rounding#Alternating_tie-breaking for details.
         */
        function altTieBreakRound(value, even) {
            if (Math.abs(value % 1) === 0.5 && !even) {
                return value | 0;
            }
            return Math.round(value);
        }
        NumberUtilities.altTieBreakRound = altTieBreakRound;
        function epsilonEquals(value, other) {
            return Math.abs(value - other) < 0.0000001;
        }
        NumberUtilities.epsilonEquals = epsilonEquals;
    })(NumberUtilities = Shumway.NumberUtilities || (Shumway.NumberUtilities = {}));
    var Numbers;
    (function (Numbers) {
        Numbers[Numbers["MaxU16"] = 65535] = "MaxU16";
        Numbers[Numbers["MaxI16"] = 32767] = "MaxI16";
        Numbers[Numbers["MinI16"] = -32768] = "MinI16";
    })(Numbers = Shumway.Numbers || (Shumway.Numbers = {}));
    var IntegerUtilities;
    (function (IntegerUtilities) {
        var sharedBuffer = new ArrayBuffer(8);
        IntegerUtilities.i8 = new Int8Array(sharedBuffer);
        IntegerUtilities.u8 = new Uint8Array(sharedBuffer);
        IntegerUtilities.i32 = new Int32Array(sharedBuffer);
        IntegerUtilities.f32 = new Float32Array(sharedBuffer);
        IntegerUtilities.f64 = new Float64Array(sharedBuffer);
        IntegerUtilities.nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
        /**
         * Convert a float into 32 bits.
         */
        function floatToInt32(v) {
            IntegerUtilities.f32[0] = v;
            return IntegerUtilities.i32[0];
        }
        IntegerUtilities.floatToInt32 = floatToInt32;
        /**
         * Convert 32 bits into a float.
         */
        function int32ToFloat(i) {
            IntegerUtilities.i32[0] = i;
            return IntegerUtilities.f32[0];
        }
        IntegerUtilities.int32ToFloat = int32ToFloat;
        /**
         * Swap the bytes of a 16 bit number.
         */
        function swap16(i) {
            return ((i & 0xFF) << 8) | ((i >> 8) & 0xFF);
        }
        IntegerUtilities.swap16 = swap16;
        /**
         * Swap the bytes of a 32 bit number.
         */
        function swap32(i) {
            return ((i & 0xFF) << 24) | ((i & 0xFF00) << 8) | ((i >> 8) & 0xFF00) | ((i >> 24) & 0xFF);
        }
        IntegerUtilities.swap32 = swap32;
        /**
         * Converts a number to s8.u8 fixed point representation.
         */
        function toS8U8(v) {
            return ((v * 256) << 16) >> 16;
        }
        IntegerUtilities.toS8U8 = toS8U8;
        /**
         * Converts a number from s8.u8 fixed point representation.
         */
        function fromS8U8(i) {
            return i / 256;
        }
        IntegerUtilities.fromS8U8 = fromS8U8;
        /**
         * Round trips a number through s8.u8 conversion.
         */
        function clampS8U8(v) {
            return fromS8U8(toS8U8(v));
        }
        IntegerUtilities.clampS8U8 = clampS8U8;
        /**
         * Converts a number to signed 16 bits.
         */
        function toS16(v) {
            return (v << 16) >> 16;
        }
        IntegerUtilities.toS16 = toS16;
        function bitCount(i) {
            i = i - ((i >> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
            return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
        }
        IntegerUtilities.bitCount = bitCount;
        function ones(i) {
            i = i - ((i >> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
            return ((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
        }
        IntegerUtilities.ones = ones;
        function trailingZeros(i) {
            return IntegerUtilities.ones((i & -i) - 1);
        }
        IntegerUtilities.trailingZeros = trailingZeros;
        function getFlags(i, flags) {
            var str = "";
            for (var i_1 = 0; i_1 < flags.length; i_1++) {
                if ((i_1 & (1 << i_1)) !== 0) {
                    str += flags[i_1] + " ";
                }
            }
            if (str.length === 0) {
                return "";
            }
            return str.trim();
        }
        IntegerUtilities.getFlags = getFlags;
        function isPowerOfTwo(x) {
            return x && ((x & (x - 1)) === 0);
        }
        IntegerUtilities.isPowerOfTwo = isPowerOfTwo;
        function roundToMultipleOfFour(x) {
            return (x + 3) & ~0x3;
        }
        IntegerUtilities.roundToMultipleOfFour = roundToMultipleOfFour;
        function nearestPowerOfTwo(x) {
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            x++;
            return x;
        }
        IntegerUtilities.nearestPowerOfTwo = nearestPowerOfTwo;
        function roundToMultipleOfPowerOfTwo(i, powerOfTwo) {
            var x = (1 << powerOfTwo) - 1;
            return (i + x) & ~x; // Round up to multiple of power of two.
        }
        IntegerUtilities.roundToMultipleOfPowerOfTwo = roundToMultipleOfPowerOfTwo;
        function toHEX(i) {
            i = (i < 0 ? 0xFFFFFFFF + i + 1 : i);
            return "0x" + ("00000000" + i.toString(16)).substr(-8);
        }
        IntegerUtilities.toHEX = toHEX;
        /**
         * Polyfill imul.
         */
        if (!Math.imul) {
            Math.imul = function imul(a, b) {
                var ah = (a >>> 16) & 0xffff;
                var al = a & 0xffff;
                var bh = (b >>> 16) & 0xffff;
                var bl = b & 0xffff;
                // the shift by 0 fixes the sign on the high part
                // the final |0 converts the unsigned value into a signed value
                return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
            };
        }
        /**
         * Polyfill clz32.
         */
        if (!Math.clz32) {
            Math.clz32 = function clz32(i) {
                i |= (i >> 1);
                i |= (i >> 2);
                i |= (i >> 4);
                i |= (i >> 8);
                i |= (i >> 16);
                return 32 - IntegerUtilities.ones(i);
            };
        }
    })(IntegerUtilities = Shumway.IntegerUtilities || (Shumway.IntegerUtilities = {}));
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Error"] = 1] = "Error";
        LogLevel[LogLevel["Warn"] = 2] = "Warn";
        LogLevel[LogLevel["Debug"] = 4] = "Debug";
        LogLevel[LogLevel["Log"] = 8] = "Log";
        LogLevel[LogLevel["Info"] = 16] = "Info";
        LogLevel[LogLevel["All"] = 31] = "All";
    })(LogLevel = Shumway.LogLevel || (Shumway.LogLevel = {}));
    var IndentingWriter = /** @class */ (function () {
        function IndentingWriter(suppressOutput, out) {
            if (suppressOutput === void 0) { suppressOutput = false; }
            this._tab = "  ";
            this._padding = "";
            this._suppressOutput = suppressOutput;
            this._out = out || IndentingWriter._consoleOut;
            this._outNoNewline = out || IndentingWriter._consoleOutNoNewline;
        }
        Object.defineProperty(IndentingWriter.prototype, "suppressOutput", {
            get: function () {
                return this._suppressOutput;
            },
            set: function (val) {
                this._suppressOutput = val;
            },
            enumerable: true,
            configurable: true
        });
        IndentingWriter.prototype.write = function (str, writePadding) {
            if (str === void 0) { str = ""; }
            if (writePadding === void 0) { writePadding = false; }
            if (!this._suppressOutput) {
                this._outNoNewline((writePadding ? this._padding : "") + str);
            }
        };
        IndentingWriter.prototype.writeLn = function (str) {
            if (str === void 0) { str = ""; }
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
        };
        IndentingWriter.prototype.writeObject = function (str, object) {
            if (str === void 0) { str = ""; }
            if (!this._suppressOutput) {
                this._out(this._padding + str, object);
            }
        };
        IndentingWriter.prototype.writeTimeLn = function (str) {
            if (str === void 0) { str = ""; }
            if (!this._suppressOutput) {
                this._out(this._padding + performance.now().toFixed(2) + " " + str);
            }
        };
        IndentingWriter.prototype.writeComment = function (str) {
            var lines = (str || '').split("\n");
            if (lines.length === 1) {
                this.writeLn("// " + lines[0]);
            }
            else {
                this.writeLn("/**");
                for (var i = 0; i < lines.length; i++) {
                    this.writeLn(" * " + lines[i]);
                }
                this.writeLn(" */");
            }
        };
        IndentingWriter.prototype.writeLns = function (str) {
            var lines = (str || '').split("\n");
            for (var i = 0; i < lines.length; i++) {
                this.writeLn(lines[i]);
            }
        };
        IndentingWriter.prototype.errorLn = function (str) {
            if (IndentingWriter.logLevel & 1 /* Error */) {
                this.boldRedLn(str);
            }
        };
        IndentingWriter.prototype.warnLn = function (str) {
            if (IndentingWriter.logLevel & 2 /* Warn */) {
                this.yellowLn(str);
            }
        };
        IndentingWriter.prototype.debugLn = function (str) {
            if (IndentingWriter.logLevel & 4 /* Debug */) {
                this.purpleLn(str);
            }
        };
        IndentingWriter.prototype.logLn = function (str) {
            if (IndentingWriter.logLevel & 8 /* Log */) {
                this.writeLn(str);
            }
        };
        IndentingWriter.prototype.infoLn = function (str) {
            if (IndentingWriter.logLevel & 16 /* Info */) {
                this.writeLn(str);
            }
        };
        IndentingWriter.prototype.yellowLn = function (str) {
            this.colorLn(IndentingWriter.YELLOW, str);
        };
        IndentingWriter.prototype.greenLn = function (str) {
            this.colorLn(IndentingWriter.GREEN, str);
        };
        IndentingWriter.prototype.boldRedLn = function (str) {
            this.colorLn(IndentingWriter.BOLD_RED, str);
        };
        IndentingWriter.prototype.redLn = function (str) {
            this.colorLn(IndentingWriter.RED, str);
        };
        IndentingWriter.prototype.purpleLn = function (str) {
            this.colorLn(IndentingWriter.PURPLE, str);
        };
        IndentingWriter.prototype.colorLn = function (color, str) {
            if (!this._suppressOutput) {
                if (!inBrowser) {
                    this._out(this._padding + color + str + IndentingWriter.ENDC);
                }
                else {
                    this._out(this._padding + str);
                }
            }
        };
        IndentingWriter.prototype.redLns = function (str) {
            this.colorLns(IndentingWriter.RED, str);
        };
        IndentingWriter.prototype.colorLns = function (color, str) {
            var lines = (str || '').split("\n");
            for (var i = 0; i < lines.length; i++) {
                this.colorLn(color, lines[i]);
            }
        };
        IndentingWriter.prototype.enter = function (str) {
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
            this.indent();
        };
        IndentingWriter.prototype.leaveAndEnter = function (str) {
            this.leave(str);
            this.indent();
        };
        IndentingWriter.prototype.leave = function (str) {
            this.outdent();
            if (!this._suppressOutput && str) {
                this._out(this._padding + str);
            }
        };
        IndentingWriter.prototype.indent = function () {
            this._padding += this._tab;
        };
        IndentingWriter.prototype.outdent = function () {
            if (this._padding.length > 0) {
                this._padding = this._padding.substring(0, this._padding.length - this._tab.length);
            }
        };
        IndentingWriter.prototype.writeArray = function (arr, detailed, noNumbers) {
            if (detailed === void 0) { detailed = false; }
            if (noNumbers === void 0) { noNumbers = false; }
            detailed = detailed || false;
            for (var i = 0, j = arr.length; i < j; i++) {
                var prefix = "";
                if (detailed) {
                    if (arr[i] === null) {
                        prefix = "null";
                    }
                    else if (arr[i] === undefined) {
                        prefix = "undefined";
                    }
                    else {
                        prefix = arr[i].constructor.name;
                    }
                    prefix += " ";
                }
                var number = noNumbers ? "" : ("" + i).padRight(' ', 4);
                this.writeLn(number + prefix + arr[i]);
            }
        };
        // public static PURPLE = '\033[94m';
        // public static YELLOW = '\033[93m';
        // public static GREEN = '\033[92m';
        // public static RED = '\033[91m';
        // public static BOLD_RED = '\033[1;91m';
        // public static ENDC = '\033[0m';
        IndentingWriter.PURPLE = '\x1B[94m';
        IndentingWriter.YELLOW = '\x1B[93m';
        IndentingWriter.GREEN = '\x1B[92m';
        IndentingWriter.RED = '\x1B[91m';
        IndentingWriter.BOLD_RED = '\x1B[1;91m';
        IndentingWriter.ENDC = '\x1B[0m';
        IndentingWriter.logLevel = 31 /* All */;
        IndentingWriter._consoleOut = console.log.bind(console);
        IndentingWriter._consoleOutNoNewline = console.log.bind(console);
        return IndentingWriter;
    }());
    Shumway.IndentingWriter = IndentingWriter;
    var CircularBuffer = /** @class */ (function () {
        function CircularBuffer(Type, sizeInBits) {
            if (sizeInBits === void 0) { sizeInBits = 12; }
            this.index = 0;
            this.start = 0;
            this._size = 1 << sizeInBits;
            this._mask = this._size - 1;
            this.array = new Type(this._size);
        }
        CircularBuffer.prototype.get = function (i) {
            return this.array[i];
        };
        CircularBuffer.prototype.forEachInReverse = function (visitor) {
            if (this.isEmpty()) {
                return;
            }
            var i = this.index === 0 ? this._size - 1 : this.index - 1;
            var end = (this.start - 1) & this._mask;
            while (i !== end) {
                if (visitor(this.array[i], i)) {
                    break;
                }
                i = i === 0 ? this._size - 1 : i - 1;
            }
        };
        CircularBuffer.prototype.write = function (value) {
            this.array[this.index] = value;
            this.index = (this.index + 1) & this._mask;
            if (this.index === this.start) {
                this.start = (this.start + 1) & this._mask;
            }
        };
        CircularBuffer.prototype.isFull = function () {
            return ((this.index + 1) & this._mask) === this.start;
        };
        CircularBuffer.prototype.isEmpty = function () {
            return this.index === this.start;
        };
        CircularBuffer.prototype.reset = function () {
            this.index = 0;
            this.start = 0;
        };
        return CircularBuffer;
    }());
    Shumway.CircularBuffer = CircularBuffer;
    var ColorStyle = /** @class */ (function () {
        function ColorStyle() {
        }
        ColorStyle.randomStyle = function () {
            if (!ColorStyle._randomStyleCache) {
                ColorStyle._randomStyleCache = [
                    "#ff5e3a",
                    "#ff9500",
                    "#ffdb4c",
                    "#87fc70",
                    "#52edc7",
                    "#1ad6fd",
                    "#c644fc",
                    "#ef4db6",
                    "#4a4a4a",
                    "#dbddde",
                    "#ff3b30",
                    "#ff9500",
                    "#ffcc00",
                    "#4cd964",
                    "#34aadc",
                    "#007aff",
                    "#5856d6",
                    "#ff2d55",
                    "#8e8e93",
                    "#c7c7cc",
                    "#5ad427",
                    "#c86edf",
                    "#d1eefc",
                    "#e0f8d8",
                    "#fb2b69",
                    "#f7f7f7",
                    "#1d77ef",
                    "#d6cec3",
                    "#55efcb",
                    "#ff4981",
                    "#ffd3e0",
                    "#f7f7f7",
                    "#ff1300",
                    "#1f1f21",
                    "#bdbec2",
                    "#ff3a2d"
                ];
            }
            return ColorStyle._randomStyleCache[(ColorStyle._nextStyle++) % ColorStyle._randomStyleCache.length];
        };
        ColorStyle.gradientColor = function (value) {
            return ColorStyle._gradient[ColorStyle._gradient.length * NumberUtilities.clamp(value, 0, 1) | 0];
        };
        ColorStyle.contrastStyle = function (rgb) {
            // http://www.w3.org/TR/AERT#color-contrast
            var c = parseInt(rgb.substr(1), 16);
            var yiq = (((c >> 16) * 299) + (((c >> 8) & 0xff) * 587) + ((c & 0xff) * 114)) / 1000;
            return (yiq >= 128) ? '#000000' : '#ffffff';
        };
        ColorStyle.reset = function () {
            ColorStyle._nextStyle = 0;
        };
        ColorStyle.TabToolbar = "#252c33";
        ColorStyle.Toolbars = "#343c45";
        ColorStyle.HighlightBlue = "#1d4f73";
        ColorStyle.LightText = "#f5f7fa";
        ColorStyle.ForegroundText = "#b6babf";
        ColorStyle.Black = "#000000";
        ColorStyle.VeryDark = "#14171a";
        ColorStyle.Dark = "#181d20";
        ColorStyle.Light = "#a9bacb";
        ColorStyle.Grey = "#8fa1b2";
        ColorStyle.DarkGrey = "#5f7387";
        ColorStyle.Blue = "#46afe3";
        ColorStyle.Purple = "#6b7abb";
        ColorStyle.Pink = "#df80ff";
        ColorStyle.Red = "#eb5368";
        ColorStyle.Orange = "#d96629";
        ColorStyle.LightOrange = "#d99b28";
        ColorStyle.Green = "#70bf53";
        ColorStyle.BlueGrey = "#5e88b0";
        ColorStyle._nextStyle = 0;
        ColorStyle._gradient = [
            "#FF0000",
            "#FF1100",
            "#FF2300",
            "#FF3400",
            "#FF4600",
            "#FF5700",
            "#FF6900",
            "#FF7B00",
            "#FF8C00",
            "#FF9E00",
            "#FFAF00",
            "#FFC100",
            "#FFD300",
            "#FFE400",
            "#FFF600",
            "#F7FF00",
            "#E5FF00",
            "#D4FF00",
            "#C2FF00",
            "#B0FF00",
            "#9FFF00",
            "#8DFF00",
            "#7CFF00",
            "#6AFF00",
            "#58FF00",
            "#47FF00",
            "#35FF00",
            "#24FF00",
            "#12FF00",
            "#00FF00" // Green
        ];
        return ColorStyle;
    }());
    Shumway.ColorStyle = ColorStyle;
    /**
     * Faster release version of bounds.
     */
    var Bounds = /** @class */ (function () {
        function Bounds(xMin, yMin, xMax, yMax) {
            this.xMin = xMin | 0;
            this.yMin = yMin | 0;
            this.xMax = xMax | 0;
            this.yMax = yMax | 0;
        }
        Bounds.FromUntyped = function (source) {
            return new Bounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        Bounds.FromRectangle = function (source) {
            return new Bounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };
        Bounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };
        Bounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        Bounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax &&
                y < this.yMin !== y < this.yMax;
        };
        Bounds.prototype.unionInPlace = function (other) {
            if (other.isEmpty()) {
                return;
            }
            this.extendByPoint(other.xMin, other.yMin);
            this.extendByPoint(other.xMax, other.yMax);
        };
        Bounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };
        Bounds.prototype.extendByX = function (x) {
            // Exclude default values.
            if (this.xMin === 0x8000000) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };
        Bounds.prototype.extendByY = function (y) {
            // Exclude default values.
            if (this.yMin === 0x8000000) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };
        Bounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect.xMin, toIntersect.yMin) ||
                this.contains(toIntersect.xMax, toIntersect.yMax);
        };
        Bounds.prototype.isEmpty = function () {
            return this.xMax <= this.xMin || this.yMax <= this.yMin;
        };
        Object.defineProperty(Bounds.prototype, "width", {
            get: function () {
                return this.xMax - this.xMin;
            },
            set: function (value) {
                this.xMax = this.xMin + value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds.prototype, "height", {
            get: function () {
                return this.yMax - this.yMin;
            },
            set: function (value) {
                this.yMax = this.yMin + value;
            },
            enumerable: true,
            configurable: true
        });
        Bounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this.xMax - this.xMin) + v * (this.yMax - this.yMin);
        };
        Bounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this.xMax - this.xMin) + u * (this.yMax - this.yMin);
        };
        Bounds.prototype.setEmpty = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 0;
        };
        /**
         * Set all fields to the sentinel value 0x8000000.
         *
         * This is what Flash uses to indicate uninitialized bounds. Important for bounds calculation
         * in `Graphics` instances, which start out with empty bounds but must not just extend them
         * from an 0,0 origin.
         */
        Bounds.prototype.setToSentinels = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 0x8000000;
        };
        Bounds.prototype.clone = function () {
            return new Bounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };
        Bounds.prototype.toString = function () {
            return "{ " +
                "xMin: " + this.xMin + ", " +
                "xMin: " + this.yMin + ", " +
                "xMax: " + this.xMax + ", " +
                "xMax: " + this.yMax +
                " }";
        };
        return Bounds;
    }());
    Shumway.Bounds = Bounds;
    /**
     * Slower debug version of bounds, makes sure that all points have integer coordinates.
     */
    var DebugBounds = /** @class */ (function () {
        function DebugBounds(xMin, yMin, xMax, yMax) {
            Debug.assert(isInteger(xMin));
            Debug.assert(isInteger(yMin));
            Debug.assert(isInteger(xMax));
            Debug.assert(isInteger(yMax));
            this._xMin = xMin | 0;
            this._yMin = yMin | 0;
            this._xMax = xMax | 0;
            this._yMax = yMax | 0;
            this.assertValid();
        }
        DebugBounds.FromUntyped = function (source) {
            return new DebugBounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        DebugBounds.FromRectangle = function (source) {
            return new DebugBounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };
        DebugBounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };
        DebugBounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        DebugBounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax &&
                y < this.yMin !== y < this.yMax;
        };
        DebugBounds.prototype.unionInPlace = function (other) {
            if (other.isEmpty()) {
                return;
            }
            this.extendByPoint(other.xMin, other.yMin);
            this.extendByPoint(other.xMax, other.yMax);
        };
        DebugBounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };
        DebugBounds.prototype.extendByX = function (x) {
            if (this.xMin === 0x8000000) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };
        DebugBounds.prototype.extendByY = function (y) {
            if (this.yMin === 0x8000000) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };
        DebugBounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect._xMin, toIntersect._yMin) ||
                this.contains(toIntersect._xMax, toIntersect._yMax);
        };
        DebugBounds.prototype.isEmpty = function () {
            return this._xMax <= this._xMin || this._yMax <= this._yMin;
        };
        Object.defineProperty(DebugBounds.prototype, "xMin", {
            get: function () {
                return this._xMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMin = value;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, "yMin", {
            get: function () {
                return this._yMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMin = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, "xMax", {
            get: function () {
                return this._xMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, "width", {
            get: function () {
                return this._xMax - this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, "yMax", {
            get: function () {
                return this._yMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, "height", {
            get: function () {
                return this._yMax - this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        DebugBounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this._xMax - this._xMin) + v * (this._yMax - this._yMin);
        };
        DebugBounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this._xMax - this._xMin) + u * (this._yMax - this._yMin);
        };
        DebugBounds.prototype.setEmpty = function () {
            this._xMin = this._yMin = this._xMax = this._yMax = 0;
        };
        DebugBounds.prototype.clone = function () {
            return new DebugBounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };
        DebugBounds.prototype.toString = function () {
            return "{ " +
                "xMin: " + this._xMin + ", " +
                "yMin: " + this._yMin + ", " +
                "xMax: " + this._xMax + ", " +
                "yMax: " + this._yMax +
                " }";
        };
        DebugBounds.prototype.assertValid = function () {
            //      release || assert(this._xMax >= this._xMin);
            //      release || assert(this._yMax >= this._yMin);
        };
        return DebugBounds;
    }());
    Shumway.DebugBounds = DebugBounds;
    /**
     * Override Bounds with a slower by safer version, don't do this in release mode.
     */
    // Shumway.Bounds = DebugBounds;
    var Color = /** @class */ (function () {
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.FromARGB = function (argb) {
            return new Color((argb >> 16 & 0xFF) / 255, (argb >> 8 & 0xFF) / 255, (argb >> 0 & 0xFF) / 255, (argb >> 24 & 0xFF) / 255);
        };
        Color.FromRGBA = function (rgba) {
            return Color.FromARGB(ColorUtilities.RGBAToARGB(rgba));
        };
        Color.prototype.toRGBA = function () {
            return (this.r * 255) << 24 | (this.g * 255) << 16 | (this.b * 255) << 8 | (this.a * 255);
        };
        Color.prototype.toCSSStyle = function () {
            return ColorUtilities.rgbaToCSSStyle(this.toRGBA());
        };
        Color.prototype.set = function (other) {
            this.r = other.r;
            this.g = other.g;
            this.b = other.b;
            this.a = other.a;
        };
        Color.randomColor = function (alpha) {
            if (alpha === void 0) { alpha = 1; }
            return new Color(Math.random(), Math.random(), Math.random(), alpha);
        };
        Color.parseColor = function (color) {
            if (!Color.colorCache) {
                Color.colorCache = Object.create(null);
            }
            if (Color.colorCache[color]) {
                return Color.colorCache[color];
            }
            // TODO: Obviously slow, but it will do for now.
            var span = document.createElement('span');
            document.body.appendChild(span);
            span.style.backgroundColor = color;
            var rgb = getComputedStyle(span).backgroundColor;
            document.body.removeChild(span);
            var m = /^rgb\((\d+), (\d+), (\d+)\)$/.exec(rgb);
            if (!m)
                m = /^rgba\((\d+), (\d+), (\d+), ([\d.]+)\)$/.exec(rgb);
            var result = new Color(0, 0, 0, 0);
            result.r = parseFloat(m[1]) / 255;
            result.g = parseFloat(m[2]) / 255;
            result.b = parseFloat(m[3]) / 255;
            result.a = m[4] ? parseFloat(m[4]) / 255 : 1;
            return Color.colorCache[color] = result;
        };
        Color.Red = new Color(1, 0, 0, 1);
        Color.Green = new Color(0, 1, 0, 1);
        Color.Blue = new Color(0, 0, 1, 1);
        Color.None = new Color(0, 0, 0, 0);
        Color.White = new Color(1, 1, 1, 1);
        Color.Black = new Color(0, 0, 0, 1);
        Color.colorCache = {};
        return Color;
    }());
    Shumway.Color = Color;
    var ColorUtilities;
    (function (ColorUtilities) {
        function RGBAToARGB(rgba) {
            return ((rgba >> 8) & 0x00ffffff) | ((rgba & 0xff) << 24);
        }
        ColorUtilities.RGBAToARGB = RGBAToARGB;
        function ARGBToRGBA(argb) {
            return argb << 8 | ((argb >> 24) & 0xff);
        }
        ColorUtilities.ARGBToRGBA = ARGBToRGBA;
        /**
         * Cache frequently used rgba -> css style conversions.
         */
        var rgbaToCSSStyleCache = new Cache(1024);
        function rgbaToCSSStyle(rgba) {
            var result = rgbaToCSSStyleCache.get(rgba);
            if (typeof result === "string") {
                return result;
            }
            result = Shumway.StringUtilities.concat9('rgba(', rgba >> 24 & 0xff, ',', rgba >> 16 & 0xff, ',', rgba >> 8 & 0xff, ',', (rgba & 0xff) / 0xff, ')');
            rgbaToCSSStyleCache.set(rgba, result);
            return result;
        }
        ColorUtilities.rgbaToCSSStyle = rgbaToCSSStyle;
        /**
         * Cache frequently used css -> rgba styles conversions.
         */
        var cssStyleToRGBACache = new Cache(1024);
        function cssStyleToRGBA(style) {
            var result = cssStyleToRGBACache.get(style);
            if (typeof result === "number") {
                return result;
            }
            result = 0xff0000ff; // Red
            if (style[0] === "#") {
                if (style.length === 7) {
                    result = (parseInt(style.substring(1), 16) << 8) | 0xff;
                }
            }
            else if (style[0] === "r") {
                // We don't parse all types of rgba(....) color styles. We only handle the
                // ones we generate ourselves.
                var values = style.substring(5, style.length - 1).split(",");
                var r = parseInt(values[0]);
                var g = parseInt(values[1]);
                var b = parseInt(values[2]);
                var a = parseFloat(values[3]);
                result = (r & 0xff) << 24 |
                    (g & 0xff) << 16 |
                    (b & 0xff) << 8 |
                    ((a * 255) & 0xff);
            }
            cssStyleToRGBACache.set(style, result);
            return result;
        }
        ColorUtilities.cssStyleToRGBA = cssStyleToRGBA;
        function hexToRGB(color) {
            return parseInt(color.slice(1), 16);
        }
        ColorUtilities.hexToRGB = hexToRGB;
        function rgbToHex(color) {
            return '#' + ('000000' + (color >>> 0).toString(16)).slice(-6);
        }
        ColorUtilities.rgbToHex = rgbToHex;
        function isValidHexColor(value) {
            return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value);
        }
        ColorUtilities.isValidHexColor = isValidHexColor;
        function clampByte(value) {
            return Math.max(0, Math.min(255, value));
        }
        ColorUtilities.clampByte = clampByte;
        /**
         * Unpremultiplies the given |pARGB| color value.
         */
        function unpremultiplyARGB(pARGB) {
            var b = (pARGB >> 0) & 0xff;
            var g = (pARGB >> 8) & 0xff;
            var r = (pARGB >> 16) & 0xff;
            var a = (pARGB >> 24) & 0xff;
            r = Math.imul(255, r) / a & 0xff;
            g = Math.imul(255, g) / a & 0xff;
            b = Math.imul(255, b) / a & 0xff;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.unpremultiplyARGB = unpremultiplyARGB;
        /**
         * Premultiplies the given |pARGB| color value.
         */
        function premultiplyARGB(uARGB) {
            var b = (uARGB >> 0) & 0xff;
            var g = (uARGB >> 8) & 0xff;
            var r = (uARGB >> 16) & 0xff;
            var a = (uARGB >> 24) & 0xff;
            r = ((Math.imul(r, a) + 127) / 255) | 0;
            g = ((Math.imul(g, a) + 127) / 255) | 0;
            b = ((Math.imul(b, a) + 127) / 255) | 0;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.premultiplyARGB = premultiplyARGB;
        var premultiplyTable;
        /**
         * All possible alpha values and colors 256 * 256 = 65536 entries. Experiments
         * indicate that doing unpremultiplication this way is roughly 5x faster.
         *
         * To lookup a color |c| in the table at a given alpha value |a| use:
         * |(a << 8) + c| to compute the index. This layout order was chosen to make
         * table lookups cache friendly, it actually makes a difference.
         *
         * TODO: Figure out if memory / speed tradeoff is worth it.
         */
        var unpremultiplyTable;
        /**
         * Make sure to call this before using the |unpremultiplyARGBUsingTableLookup| or
         * |premultiplyARGBUsingTableLookup| functions. We want to execute this lazily so
         * we don't incur any startup overhead.
         */
        function ensureUnpremultiplyTable() {
            if (!unpremultiplyTable) {
                unpremultiplyTable = new Uint8Array(256 * 256);
                for (var c = 0; c < 256; c++) {
                    for (var a = 0; a < 256; a++) {
                        unpremultiplyTable[(a << 8) + c] = Math.imul(255, c) / a;
                    }
                }
            }
        }
        ColorUtilities.ensureUnpremultiplyTable = ensureUnpremultiplyTable;
        function getUnpremultiplyTable() {
            ensureUnpremultiplyTable();
            return unpremultiplyTable;
        }
        ColorUtilities.getUnpremultiplyTable = getUnpremultiplyTable;
        function tableLookupUnpremultiplyARGB(pARGB) {
            pARGB = pARGB | 0;
            var a = (pARGB >> 24) & 0xff;
            if (a === 0) {
                return 0;
            }
            else if (a === 0xff) {
                return pARGB;
            }
            var b = (pARGB >> 0) & 0xff;
            var g = (pARGB >> 8) & 0xff;
            var r = (pARGB >> 16) & 0xff;
            var o = a << 8;
            var T = unpremultiplyTable;
            r = T[o + r];
            g = T[o + g];
            b = T[o + b];
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.tableLookupUnpremultiplyARGB = tableLookupUnpremultiplyARGB;
        /**
         * The blending equation for unpremultiplied alpha is:
         *
         *   (src.rgb * src.a) + (dst.rgb * (1 - src.a))
         *
         * For premultiplied alpha src.rgb and dst.rgb are already
         * premultiplied by alpha, so the equation becomes:
         *
         *   src.rgb + (dst.rgb * (1 - src.a))
         *
         * TODO: Not sure what to do about the dst.rgb which is
         * premultiplied by its alpah, but this appears to work.
         *
         * We use the "double blend trick" (http://stereopsis.com/doubleblend.html) to
         * compute GA and BR without unpacking them.
         */
        function blendPremultipliedBGRA(tpBGRA, spBGRA) {
            var sA = spBGRA & 0xff;
            var sGA = spBGRA & 0x00ff00ff;
            var sBR = spBGRA >> 8 & 0x00ff00ff;
            var tGA = tpBGRA & 0x00ff00ff;
            var tBR = tpBGRA >> 8 & 0x00ff00ff;
            var A = 256 - sA;
            tGA = Math.imul(tGA, A) >> 8;
            tBR = Math.imul(tBR, A) >> 8;
            return ((sBR + tBR & 0x00ff00ff) << 8) | (sGA + tGA & 0x00ff00ff);
        }
        ColorUtilities.blendPremultipliedBGRA = blendPremultipliedBGRA;
        var swap32 = IntegerUtilities.swap32;
        function convertImage(sourceFormat, targetFormat, source, target) {
            if (source !== target) {
                release || Debug.assert(source.buffer !== target.buffer, "Can't handle overlapping views.");
            }
            var length = source.length;
            if (sourceFormat === targetFormat) {
                if (source === target) {
                    return;
                }
                for (var i = 0; i < length; i++) {
                    target[i] = source[i];
                }
                return;
            }
            // enterTimeline("convertImage", ImageType[sourceFormat] + " to " + ImageType[targetFormat] + " (" + memorySizeToString(source.length));
            if (sourceFormat === ImageType.PremultipliedAlphaARGB &&
                targetFormat === ImageType.StraightAlphaRGBA) {
                Shumway.ColorUtilities.ensureUnpremultiplyTable();
                for (var i = 0; i < length; i++) {
                    var pBGRA = source[i];
                    var a = pBGRA & 0xff;
                    if (a === 0) {
                        target[i] = 0;
                    }
                    else if (a === 0xff) {
                        target[i] = 0xff000000 | ((pBGRA >> 8) & 0x00ffffff);
                    }
                    else {
                        var b = (pBGRA >> 24) & 0xff;
                        var g = (pBGRA >> 16) & 0xff;
                        var r = (pBGRA >> 8) & 0xff;
                        var o = a << 8;
                        var T = unpremultiplyTable;
                        r = T[o + r];
                        g = T[o + g];
                        b = T[o + b];
                        target[i] = a << 24 | b << 16 | g << 8 | r;
                    }
                }
            }
            else if (sourceFormat === ImageType.StraightAlphaARGB &&
                targetFormat === ImageType.StraightAlphaRGBA) {
                for (var i = 0; i < length; i++) {
                    target[i] = swap32(source[i]);
                }
            }
            else if (sourceFormat === ImageType.StraightAlphaRGBA &&
                targetFormat === ImageType.PremultipliedAlphaARGB) {
                for (var i = 0; i < length; i++) {
                    var uABGR = source[i];
                    var uARGB = (uABGR & 0xFF00FF00) | // A_G_
                        (uABGR >> 16) & 0xff | // A_GB
                        (uABGR & 0xff) << 16; // ARGR
                    target[i] = swap32(premultiplyARGB(uARGB));
                }
            }
            else {
                release || Debug.somewhatImplemented("Image Format Conversion: " + ImageType[sourceFormat] + " -> " + ImageType[targetFormat]);
                // Copy the buffer over for now, we should at least get some image output.
                for (var i = 0; i < length; i++) {
                    target[i] = source[i];
                }
            }
            // leaveTimeline("convertImage");
        }
        ColorUtilities.convertImage = convertImage;
    })(ColorUtilities = Shumway.ColorUtilities || (Shumway.ColorUtilities = {}));
    /**
     * Simple pool allocator for ArrayBuffers. This reduces memory usage in data structures
     * that resize buffers.
     */
    var ArrayBufferPool = /** @class */ (function () {
        /**
         * Creates a pool that manages a pool of a |maxSize| number of array buffers.
         */
        function ArrayBufferPool(maxSize) {
            if (maxSize === void 0) { maxSize = 32; }
            this._list = [];
            this._maxSize = maxSize;
        }
        /**
         * Creates or reuses an existing array buffer that is at least the
         * specified |length|.
         */
        ArrayBufferPool.prototype.acquire = function (length) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                for (var i = 0; i < list.length; i++) {
                    var buffer = list[i];
                    if (buffer.byteLength >= length) {
                        list.splice(i, 1);
                        return buffer;
                    }
                }
            }
            return new ArrayBuffer(length);
        };
        /**
         * Releases an array buffer that is no longer needed back to the pool.
         */
        ArrayBufferPool.prototype.release = function (buffer) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                release || Debug.assert(ArrayUtilities.indexOf(list, buffer) < 0);
                if (list.length === this._maxSize) {
                    list.shift();
                }
                list.push(buffer);
            }
        };
        /**
         * Resizes a Uint8Array to have the given length.
         */
        ArrayBufferPool.prototype.ensureUint8ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, ((array.length * 3) >> 1) + 1);
            var newArray = new Uint8Array(this.acquire(newLength), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };
        /**
         * Resizes a Float64Array to have the given length.
         */
        ArrayBufferPool.prototype.ensureFloat64ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, ((array.length * 3) >> 1) + 1);
            var newArray = new Float64Array(this.acquire(newLength * Float64Array.BYTES_PER_ELEMENT), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };
        ArrayBufferPool._enabled = true;
        return ArrayBufferPool;
    }());
    Shumway.ArrayBufferPool = ArrayBufferPool;
    var Telemetry;
    (function (Telemetry) {
        var Feature;
        (function (Feature) {
            Feature[Feature["EXTERNAL_INTERFACE_FEATURE"] = 1] = "EXTERNAL_INTERFACE_FEATURE";
            Feature[Feature["CLIPBOARD_FEATURE"] = 2] = "CLIPBOARD_FEATURE";
            Feature[Feature["SHAREDOBJECT_FEATURE"] = 3] = "SHAREDOBJECT_FEATURE";
            Feature[Feature["VIDEO_FEATURE"] = 4] = "VIDEO_FEATURE";
            Feature[Feature["SOUND_FEATURE"] = 5] = "SOUND_FEATURE";
            Feature[Feature["NETCONNECTION_FEATURE"] = 6] = "NETCONNECTION_FEATURE";
        })(Feature = Telemetry.Feature || (Telemetry.Feature = {}));
        var ErrorTypes;
        (function (ErrorTypes) {
            ErrorTypes[ErrorTypes["AVM1_ERROR"] = 1] = "AVM1_ERROR";
            ErrorTypes[ErrorTypes["AVM2_ERROR"] = 2] = "AVM2_ERROR";
        })(ErrorTypes = Telemetry.ErrorTypes || (Telemetry.ErrorTypes = {}));
        var LoadResource;
        (function (LoadResource) {
            LoadResource[LoadResource["LoadSource"] = 0] = "LoadSource";
            LoadResource[LoadResource["LoadWhitelistAllowed"] = 1] = "LoadWhitelistAllowed";
            LoadResource[LoadResource["LoadWhitelistDenied"] = 2] = "LoadWhitelistDenied";
            LoadResource[LoadResource["StreamAllowed"] = 3] = "StreamAllowed";
            LoadResource[LoadResource["StreamDenied"] = 4] = "StreamDenied";
            LoadResource[LoadResource["StreamCrossdomain"] = 5] = "StreamCrossdomain";
        })(LoadResource = Telemetry.LoadResource || (Telemetry.LoadResource = {}));
    })(Telemetry = Shumway.Telemetry || (Shumway.Telemetry = {}));
    var FileLoadingService;
    (function (FileLoadingService) {
    })(FileLoadingService = Shumway.FileLoadingService || (Shumway.FileLoadingService = {}));
    var SystemResourceId;
    (function (SystemResourceId) {
        SystemResourceId[SystemResourceId["BuiltinAbc"] = 0] = "BuiltinAbc";
        SystemResourceId[SystemResourceId["PlayerglobalAbcs"] = 1] = "PlayerglobalAbcs";
        SystemResourceId[SystemResourceId["PlayerglobalManifest"] = 2] = "PlayerglobalManifest";
        SystemResourceId[SystemResourceId["ShellAbc"] = 3] = "ShellAbc";
    })(SystemResourceId = Shumway.SystemResourceId || (Shumway.SystemResourceId = {}));
    var SystemResourcesLoadingService;
    (function (SystemResourcesLoadingService) {
    })(SystemResourcesLoadingService = Shumway.SystemResourcesLoadingService || (Shumway.SystemResourcesLoadingService = {}));
    function registerCSSFont(id, data, forceFontInit) {
        if (!inBrowser) {
            Debug.warning('Cannot register CSS font outside the browser');
            return;
        }
        var head = document.head;
        head.insertBefore(document.createElement('style'), head.firstChild);
        var style = document.styleSheets[0];
        var rule = '@font-face{font-family:swffont' + id + ';src:url(data:font/opentype;base64,' +
            Shumway.StringUtilities.base64EncodeBytes(data) + ')' + '}';
        style.insertRule(rule, style.cssRules.length);
        // In at least Chrome, the browser only decodes a font once it's used in the page at all.
        // Because it still does so asynchronously, we create a with some text using the font, take
        // some measurement from it (which will turn out wrong because the font isn't yet available),
        // and then remove the node again. Then, magic happens. After a bit of time for said magic to
        // take hold, the font is available for actual use on canvas.
        // TODO: remove the need for magic by implementing this in terms of the font loading API.
        if (forceFontInit) {
            var node = document.createElement('div');
            node.style.fontFamily = 'swffont' + id;
            node.innerHTML = 'hello';
            document.body.appendChild(node);
            var dummyHeight = node.clientHeight;
            document.body.removeChild(node);
        }
    }
    Shumway.registerCSSFont = registerCSSFont;
    var ExternalInterfaceService;
    (function (ExternalInterfaceService) {
        ExternalInterfaceService.instance = {
            enabled: false,
            initJS: function (callback) {
                // ...
            },
            registerCallback: function (functionName) {
                // ...
            },
            unregisterCallback: function (functionName) {
                // ...
            },
            eval: function (expression) {
                // ...
            },
            call: function (request) {
                // ...
            },
            getId: function () {
                return null;
            }
        };
    })(ExternalInterfaceService = Shumway.ExternalInterfaceService || (Shumway.ExternalInterfaceService = {}));
    var LocalConnectionConnectResult;
    (function (LocalConnectionConnectResult) {
        LocalConnectionConnectResult[LocalConnectionConnectResult["InvalidCallback"] = -3] = "InvalidCallback";
        LocalConnectionConnectResult[LocalConnectionConnectResult["AlreadyTaken"] = -2] = "AlreadyTaken";
        LocalConnectionConnectResult[LocalConnectionConnectResult["InvalidName"] = -1] = "InvalidName";
        LocalConnectionConnectResult[LocalConnectionConnectResult["Success"] = 0] = "Success";
    })(LocalConnectionConnectResult = Shumway.LocalConnectionConnectResult || (Shumway.LocalConnectionConnectResult = {}));
    var LocalConnectionCloseResult;
    (function (LocalConnectionCloseResult) {
        LocalConnectionCloseResult[LocalConnectionCloseResult["NotConnected"] = -1] = "NotConnected";
        LocalConnectionCloseResult[LocalConnectionCloseResult["Success"] = 0] = "Success";
    })(LocalConnectionCloseResult = Shumway.LocalConnectionCloseResult || (Shumway.LocalConnectionCloseResult = {}));
    var LocalConnectionService;
    (function (LocalConnectionService) {
    })(LocalConnectionService = Shumway.LocalConnectionService || (Shumway.LocalConnectionService = {}));
    var ClipboardService;
    (function (ClipboardService) {
        ClipboardService.instance = {
            setClipboard: function (data) {
                Debug.notImplemented('setClipboard');
            }
        };
    })(ClipboardService = Shumway.ClipboardService || (Shumway.ClipboardService = {}));
    var Callback = /** @class */ (function () {
        function Callback() {
            this._queues = {};
        }
        Callback.prototype.register = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (queue) {
                if (queue.indexOf(callback) > -1) {
                    return;
                }
            }
            else {
                queue = this._queues[type] = [];
            }
            queue.push(callback);
        };
        Callback.prototype.unregister = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            var i = queue.indexOf(callback);
            if (i !== -1) {
                queue.splice(i, 1);
            }
            if (queue.length === 0) {
                this._queues[type] = null;
            }
        };
        Callback.prototype.notify = function (type, args_) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            var args = Array.prototype.slice.call(arguments, 0);
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback.apply(null, args);
            }
        };
        Callback.prototype.notify1 = function (type, value) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback(type, value);
            }
        };
        return Callback;
    }());
    Shumway.Callback = Callback;
    var ImageType;
    (function (ImageType) {
        ImageType[ImageType["None"] = 0] = "None";
        /**
         * Premultiplied ARGB (byte-order).
         */
        ImageType[ImageType["PremultipliedAlphaARGB"] = 1] = "PremultipliedAlphaARGB";
        /**
         * Unpremultiplied ARGB (byte-order).
         */
        ImageType[ImageType["StraightAlphaARGB"] = 2] = "StraightAlphaARGB";
        /**
         * Unpremultiplied RGBA (byte-order), this is what putImageData expects.
         */
        ImageType[ImageType["StraightAlphaRGBA"] = 3] = "StraightAlphaRGBA";
        ImageType[ImageType["JPEG"] = 4] = "JPEG";
        ImageType[ImageType["PNG"] = 5] = "PNG";
        ImageType[ImageType["GIF"] = 6] = "GIF";
    })(ImageType = Shumway.ImageType || (Shumway.ImageType = {}));
    function getMIMETypeForImageType(type) {
        switch (type) {
            case ImageType.JPEG:
                return "image/jpeg";
            case ImageType.PNG:
                return "image/png";
            case ImageType.GIF:
                return "image/gif";
            default:
                return "text/plain";
        }
    }
    Shumway.getMIMETypeForImageType = getMIMETypeForImageType;
    var UI;
    (function (UI) {
        /*
         * Converts a |MouseCursor| number to a CSS |cursor| property value.
         */
        function toCSSCursor(mouseCursor) {
            switch (mouseCursor) {
                case 0:// MouseCursor.AUTO
                    return 'auto';
                case 2:// MouseCursor.BUTTON
                    return 'pointer';
                case 3:// MouseCursor.HAND
                    return 'grab';
                case 4:// MouseCursor.IBEAM
                    return 'text';
                case 1: // MouseCursor.ARROW
                default:
                    return 'default';
            }
        }
        UI.toCSSCursor = toCSSCursor;
    })(UI = Shumway.UI || (Shumway.UI = {}));
    var PromiseWrapper = /** @class */ (function () {
        function PromiseWrapper() {
            this.promise = new Promise(function (resolve, reject) {
                this.resolve = resolve;
                this.reject = reject;
            }.bind(this));
        }
        PromiseWrapper.prototype.then = function (onFulfilled, onRejected) {
            return this.promise.then(onFulfilled, onRejected);
        };
        return PromiseWrapper;
    }());
    Shumway.PromiseWrapper = PromiseWrapper;
})(Shumway || (Shumway = {}));
/**
 * Extend builtin prototypes.
 *
 * TODO: Go through the code and remove all references to these.
 */
(function () {
    function extendBuiltin(prototype, property, value) {
        if (!prototype[property]) {
            Object.defineProperty(prototype, property, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
    }
    function removeColors(s) {
        return s.replace(/\033\[[0-9]*m/g, "");
    }
    extendBuiltin(String.prototype, "padRight", function (c, n) {
        var str = this;
        var length = removeColors(str).length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str += c;
        }
        return str;
    });
    extendBuiltin(String.prototype, "padLeft", function (c, n) {
        var str = this;
        var length = str.length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str = c + str;
        }
        return str;
    });
    extendBuiltin(String.prototype, "trim", function () {
        return this.replace(/^\s+|\s+$/g, "");
    });
    extendBuiltin(String.prototype, "endsWith", function (str) {
        return this.indexOf(str, this.length - str.length) !== -1;
    });
    extendBuiltin(Array.prototype, "replace", function (x, y) {
        if (x === y) {
            return 0;
        }
        var count = 0;
        for (var i = 0; i < this.length; i++) {
            if (this[i] === x) {
                this[i] = y;
                count++;
            }
        }
        return count;
    });
})();
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Option and Argument Management
 *
 * Options are configuration settings sprinkled throughout the code. They can be grouped into sets of
 * options called |OptionSets| which can form a hierarchy of options. For instance:
 *
 * let set = new OptionSet();
 * let opt = set.register(new Option("v", "verbose", "boolean", false, "Enables verbose logging."));
 *
 * creates an option set with one option in it. The option can be changed directly using |opt.value = true| or
 * automatically using the |ArgumentParser|:
 *
 * let parser = new ArgumentParser();
 * parser.addBoundOptionSet(set);
 * parser.parse(["-v"]);
 *
 * The |ArgumentParser| can also be used directly:
 *
 * let parser = new ArgumentParser();
 * argumentParser.addArgument("h", "help", "boolean", {parse: function (x) {
 *   printUsage();
 * }});
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var Options;
    (function (Options) {
        var isObject = Shumway.isObject;
        var assert = Shumway.Debug.assert;
        var Argument = /** @class */ (function () {
            function Argument(shortName, longName, type, options) {
                this.shortName = shortName;
                this.longName = longName;
                this.type = type;
                options = options || {};
                this.positional = options.positional;
                this.parseFn = options.parse;
                this.value = options.defaultValue;
            }
            Argument.prototype.parse = function (value) {
                if (this.type === "boolean") {
                    release || assert(typeof value === "boolean");
                    this.value = value;
                }
                else if (this.type === "number") {
                    release || assert(!isNaN(value), value + " is not a number");
                    this.value = parseInt(value, 10);
                }
                else {
                    this.value = value;
                }
                if (this.parseFn) {
                    this.parseFn(this.value);
                }
            };
            return Argument;
        }());
        Options.Argument = Argument;
        var ArgumentParser = /** @class */ (function () {
            function ArgumentParser() {
                this.args = [];
            }
            ArgumentParser.prototype.addArgument = function (shortName, longName, type, options) {
                var argument = new Argument(shortName, longName, type, options);
                this.args.push(argument);
                return argument;
            };
            ArgumentParser.prototype.addBoundOption = function (option) {
                var options = {
                    parse: function (x) {
                        option.value = x;
                    }
                };
                this.args.push(new Argument(option.shortName, option.longName, option.type, options));
            };
            ArgumentParser.prototype.addBoundOptionSet = function (optionSet) {
                var self = this;
                optionSet.options.forEach(function (x) {
                    if (OptionSet.isOptionSet(x)) {
                        self.addBoundOptionSet(x);
                    }
                    else {
                        release || assert(x);
                        self.addBoundOption(x);
                    }
                });
            };
            ArgumentParser.prototype.getUsage = function () {
                var str = "";
                this.args.forEach(function (x) {
                    if (!x.positional) {
                        str += "[-" + x.shortName + "|--" + x.longName + (x.type === "boolean" ? "" : " " + x.type[0].toUpperCase()) + "]";
                    }
                    else {
                        str += x.longName;
                    }
                    str += " ";
                });
                return str;
            };
            ArgumentParser.prototype.parse = function (args) {
                var nonPositionalArgumentMap = {};
                var positionalArgumentList = [];
                this.args.forEach(function (x) {
                    if (x.positional) {
                        positionalArgumentList.push(x);
                    }
                    else {
                        nonPositionalArgumentMap["-" + x.shortName] = x;
                        nonPositionalArgumentMap["--" + x.longName] = x;
                    }
                });
                var leftoverArguments = [];
                while (args.length) {
                    var argString = args.shift();
                    var argument = null, value = argString;
                    if (argString == '--') {
                        leftoverArguments = leftoverArguments.concat(args);
                        break;
                    }
                    else if (argString.slice(0, 1) == '-' || argString.slice(0, 2) == '--') {
                        argument = nonPositionalArgumentMap[argString];
                        // release || assert(argument, "Argument " + argString + " is unknown.");
                        if (!argument) {
                            continue;
                        }
                        if (argument.type !== "boolean") {
                            value = args.shift();
                            release || assert(value !== "-" && value !== "--", "Argument " + argString + " must have a value.");
                        }
                        else {
                            if (args.length && ["yes", "no", "true", "false", "t", "f"].indexOf(args[0]) >= 0) {
                                value = ["yes", "true", "t"].indexOf(args.shift()) >= 0;
                            }
                            else {
                                value = true;
                            }
                        }
                    }
                    else if (positionalArgumentList.length) {
                        argument = positionalArgumentList.shift();
                    }
                    else {
                        leftoverArguments.push(value);
                    }
                    if (argument) {
                        argument.parse(value);
                    }
                }
                release || assert(positionalArgumentList.length === 0, "Missing positional arguments.");
                return leftoverArguments;
            };
            return ArgumentParser;
        }());
        Options.ArgumentParser = ArgumentParser;
        var OptionSet = /** @class */ (function () {
            function OptionSet(name, settings) {
                if (settings === void 0) { settings = null; }
                this.open = false;
                this.name = name;
                this.settings = settings || {};
                this.options = [];
            }
            OptionSet.isOptionSet = function (obj) {
                // We will be getting options from different iframe, so this function will
                // check if the obj somewhat like OptionSet.
                if (obj instanceof OptionSet) {
                    return true;
                }
                if (typeof obj !== 'object' || obj === null ||
                    obj instanceof Option) {
                    return false;
                }
                return ('options' in obj) && ('name' in obj) && ('settings' in obj);
            };
            OptionSet.prototype.register = function (option) {
                if (OptionSet.isOptionSet(option)) {
                    // check for duplicate option sets (bail if found)
                    for (var i = 0; i < this.options.length; i++) {
                        var optionSet = this.options[i];
                        if (OptionSet.isOptionSet(optionSet) && optionSet.name === option.name) {
                            return optionSet;
                        }
                    }
                }
                this.options.push(option);
                if (this.settings) {
                    if (OptionSet.isOptionSet(option)) {
                        var optionSettings = this.settings[option.name];
                        if (isObject(optionSettings)) {
                            option.settings = optionSettings.settings;
                            option.open = optionSettings.open;
                        }
                    }
                    else {
                        // build_bundle chokes on this:
                        // if (!isNullOrUndefined(this.settings[option.longName])) {
                        if (typeof this.settings[option.longName] !== "undefined") {
                            switch (option.type) {
                                case "boolean":
                                    option.value = !!this.settings[option.longName];
                                    break;
                                case "number":
                                    option.value = +this.settings[option.longName];
                                    break;
                                default:
                                    option.value = this.settings[option.longName];
                                    break;
                            }
                        }
                    }
                }
                return option;
            };
            OptionSet.prototype.trace = function (writer) {
                writer.enter(this.name + " {");
                this.options.forEach(function (option) {
                    option.trace(writer);
                });
                writer.leave("}");
            };
            OptionSet.prototype.getSettings = function () {
                var settings = {};
                this.options.forEach(function (option) {
                    if (OptionSet.isOptionSet(option)) {
                        settings[option.name] = {
                            settings: option.getSettings(),
                            open: option.open
                        };
                    }
                    else {
                        settings[option.longName] = option.value;
                    }
                });
                return settings;
            };
            OptionSet.prototype.setSettings = function (settings) {
                if (!settings) {
                    return;
                }
                this.options.forEach(function (option) {
                    if (OptionSet.isOptionSet(option)) {
                        if (option.name in settings) {
                            option.setSettings(settings[option.name].settings);
                        }
                    }
                    else {
                        if (option.longName in settings) {
                            option.value = settings[option.longName];
                        }
                    }
                });
            };
            return OptionSet;
        }());
        Options.OptionSet = OptionSet;
        var Option = /** @class */ (function () {
            // config:
            //  { range: { min: 1, max: 5, step: 1 } }
            //  { list: [ "item 1", "item 2", "item 3" ] }
            //  { choices: { "choice 1": 1, "choice 2": 2, "choice 3": 3 } }
            function Option(shortName, longName, type, defaultValue, description, config) {
                if (config === void 0) { config = null; }
                this.longName = longName;
                this.shortName = shortName;
                this.type = type;
                this.defaultValue = defaultValue;
                this.value = defaultValue;
                this.description = description;
                this.config = config;
            }
            Option.prototype.parse = function (value) {
                this.value = value;
            };
            Option.prototype.trace = function (writer) {
                writer.writeLn(("-" + this.shortName + "|--" + this.longName).padRight(" ", 30) +
                    " = " + this.type + " " + this.value + " [" + this.defaultValue + "]" +
                    " (" + this.description + ")");
            };
            return Option;
        }());
        Options.Option = Option;
    })(Options = Shumway.Options || (Shumway.Options = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var Settings;
    (function (Settings) {
        Settings.ROOT = "Shumway Options";
        Settings.shumwayOptions = new Shumway.Options.OptionSet(Settings.ROOT);
        function setSettings(settings) {
            Settings.shumwayOptions.setSettings(settings);
        }
        Settings.setSettings = setSettings;
        function getSettings() {
            return Settings.shumwayOptions.getSettings();
        }
        Settings.getSettings = getSettings;
    })(Settings = Shumway.Settings || (Shumway.Settings = {}));
    var Option = Shumway.Options.Option;
    var OptionSet = Shumway.Options.OptionSet;
    var shumwayOptions = Shumway.Settings.shumwayOptions;
    Shumway.loggingOptions = shumwayOptions.register(new OptionSet("Logging Options"));
    Shumway.omitRepeatedWarnings = Shumway.loggingOptions.register(new Option("wo", "warnOnce", "boolean", true, 'Omit Repeated Warnings'));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var Metrics;
    (function (Metrics) {
        var Timer = /** @class */ (function () {
            function Timer(parent, name) {
                this._parent = parent;
                this._timers = Shumway.ObjectUtilities.createMap();
                this._name = name;
                this._begin = 0;
                this._last = 0;
                this._total = 0;
                this._count = 0;
            }
            Timer.time = function (name, fn) {
                Timer.start(name);
                fn();
                Timer.stop();
            };
            Timer.start = function (name) {
                Timer._top = Timer._top._timers[name] || (Timer._top._timers[name] = new Timer(Timer._top, name));
                Timer._top.start();
                var tmp = Timer._flat._timers[name] || (Timer._flat._timers[name] = new Timer(Timer._flat, name));
                tmp.start();
                Timer._flatStack.push(tmp);
            };
            Timer.stop = function () {
                Timer._top.stop();
                Timer._top = Timer._top._parent;
                Timer._flatStack.pop().stop();
            };
            Timer.stopStart = function (name) {
                Timer.stop();
                Timer.start(name);
            };
            Timer.prototype.start = function () {
                this._begin = Shumway.getTicks();
            };
            Timer.prototype.stop = function () {
                this._last = Shumway.getTicks() - this._begin;
                this._total += this._last;
                this._count += 1;
            };
            Timer.prototype.toJSON = function () {
                return { name: this._name, total: this._total, timers: this._timers };
            };
            Timer.prototype.trace = function (writer) {
                writer.enter(this._name + ": " + this._total.toFixed(2) + " ms" +
                    ", count: " + this._count +
                    ", average: " + (this._total / this._count).toFixed(2) + " ms");
                for (var name_1 in this._timers) {
                    this._timers[name_1].trace(writer);
                }
                writer.outdent();
            };
            Timer.trace = function (writer) {
                Timer._base.trace(writer);
                Timer._flat.trace(writer);
            };
            Timer._base = new Timer(null, "Total");
            Timer._top = Timer._base;
            Timer._flat = new Timer(null, "Flat");
            Timer._flatStack = [];
            return Timer;
        }());
        Metrics.Timer = Timer;
        /**
         * Quick way to count named events.
         */
        var Counter = /** @class */ (function () {
            function Counter(enabled) {
                this._enabled = enabled;
                this.clear();
            }
            Object.defineProperty(Counter.prototype, "counts", {
                get: function () {
                    return this._counts;
                },
                enumerable: true,
                configurable: true
            });
            Counter.prototype.setEnabled = function (enabled) {
                this._enabled = enabled;
            };
            Counter.prototype.clear = function () {
                this._counts = Shumway.ObjectUtilities.createMap();
                this._times = Shumway.ObjectUtilities.createMap();
            };
            Counter.prototype.toJSON = function () {
                return {
                    counts: this._counts,
                    times: this._times
                };
            };
            Counter.prototype.count = function (name, increment, time) {
                if (increment === void 0) { increment = 1; }
                if (time === void 0) { time = 0; }
                if (!this._enabled) {
                    return 0;
                }
                if (this._counts[name] === undefined) {
                    this._counts[name] = 0;
                    this._times[name] = 0;
                }
                this._counts[name] += increment;
                this._times[name] += time;
                return this._counts[name];
            };
            Counter.prototype.trace = function (writer) {
                for (var name_2 in this._counts) {
                    writer.writeLn(name_2 + ": " + this._counts[name_2]);
                }
            };
            Counter.prototype._pairToString = function (times, pair) {
                var name = pair[0];
                var count = pair[1];
                var time = times[name];
                var line = name + ": " + count;
                if (time) {
                    line += ", " + time.toFixed(4);
                    if (count > 1) {
                        line += " (" + (time / count).toFixed(4) + ")";
                    }
                }
                return line;
            };
            Counter.prototype.toStringSorted = function () {
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name_3 in this._counts) {
                    pairs.push([name_3, this._counts[name_3]]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                return (pairs.map(function (pair) {
                    return self._pairToString(times, pair);
                }).join(", "));
            };
            Counter.prototype.traceSorted = function (writer, inline) {
                if (inline === void 0) { inline = false; }
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name_4 in this._counts) {
                    pairs.push([name_4, this._counts[name_4]]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                if (inline) {
                    writer.writeLn(pairs.map(function (pair) {
                        return self._pairToString(times, pair);
                    }).join(", "));
                }
                else {
                    pairs.forEach(function (pair) {
                        writer.writeLn(self._pairToString(times, pair));
                    });
                }
            };
            Counter.instance = new Counter(true);
            return Counter;
        }());
        Metrics.Counter = Counter;
        var Average = /** @class */ (function () {
            function Average(max) {
                this._samples = new Float64Array(max);
                this._count = 0;
                this._index = 0;
            }
            Average.prototype.push = function (sample) {
                if (this._count < this._samples.length) {
                    this._count++;
                }
                this._index++;
                this._samples[this._index % this._samples.length] = sample;
            };
            Average.prototype.average = function () {
                var sum = 0;
                for (var i = 0; i < this._count; i++) {
                    sum += this._samples[i];
                }
                return sum / this._count;
            };
            return Average;
        }());
        Metrics.Average = Average;
    })(Metrics = Shumway.Metrics || (Shumway.Metrics = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var InflateState;
        (function (InflateState) {
            InflateState[InflateState["INIT"] = 0] = "INIT";
            InflateState[InflateState["BLOCK_0"] = 1] = "BLOCK_0";
            InflateState[InflateState["BLOCK_1"] = 2] = "BLOCK_1";
            InflateState[InflateState["BLOCK_2_PRE"] = 3] = "BLOCK_2_PRE";
            InflateState[InflateState["BLOCK_2"] = 4] = "BLOCK_2";
            InflateState[InflateState["DONE"] = 5] = "DONE";
            InflateState[InflateState["ERROR"] = 6] = "ERROR";
            InflateState[InflateState["VERIFY_HEADER"] = 7] = "VERIFY_HEADER";
        })(InflateState || (InflateState = {}));
        var WINDOW_SIZE = 32768;
        var WINDOW_SHIFT_POSITION = 65536;
        var MAX_WINDOW_SIZE = WINDOW_SHIFT_POSITION + 258;
        var Inflate = /** @class */ (function () {
            function Inflate(verifyHeader) {
                //
            }
            Inflate.prototype.push = function (data) {
                Shumway.Debug.abstractMethod('Inflate.push');
            };
            Inflate.prototype.close = function () {
                //
            };
            Inflate.create = function (verifyHeader) {
                if (typeof ShumwayCom !== 'undefined' && ShumwayCom.createSpecialInflate) {
                    return new SpecialInflateAdapter(verifyHeader, ShumwayCom.createSpecialInflate);
                }
                return new BasicInflate(verifyHeader);
            };
            Inflate.prototype._processZLibHeader = function (buffer, start, end) {
                /* returns -1 - bad header, 0 - not enough data, 1+ - number of bytes processed */
                var ZLIB_HEADER_SIZE = 2;
                if (start + ZLIB_HEADER_SIZE > end) {
                    return 0;
                }
                var header = (buffer[start] << 8) | buffer[start + 1];
                var error = null;
                if ((header & 0x0f00) !== 0x0800) {
                    error = 'inflate: unknown compression method';
                }
                else if ((header % 31) !== 0) {
                    error = 'inflate: bad FCHECK';
                }
                else if ((header & 0x20) !== 0) {
                    error = 'inflate: FDICT bit set';
                }
                if (error) {
                    if (this.onError) {
                        this.onError(error);
                    }
                    return -1;
                }
                else {
                    return ZLIB_HEADER_SIZE;
                }
            };
            Inflate.inflate = function (data, expectedLength, zlibHeader) {
                var output = new Uint8Array(expectedLength);
                var position = 0;
                var inflate = Inflate.create(zlibHeader);
                inflate.onData = function (data) {
                    // Make sure we don't cause an exception here when trying to set out-of-bound data by clamping the number of
                    // bytes to write to the remaining space in our output buffer. The Flash Player ignores data that goes over the
                    // expected length, so should we.
                    var length = Math.min(data.length, output.length - position);
                    if (length) {
                        ArrayUtilities.memCopy(output, data, position, 0, length);
                    }
                    position += length;
                };
                inflate.onError = function (error) {
                    throw new Error(error);
                };
                inflate.push(data);
                inflate.close();
                return output;
            };
            return Inflate;
        }());
        ArrayUtilities.Inflate = Inflate;
        var BasicInflate = /** @class */ (function (_super) {
            __extends(BasicInflate, _super);
            function BasicInflate(verifyHeader) {
                var _this = _super.call(this, verifyHeader) || this;
                _this._buffer = null;
                _this._bufferSize = 0;
                _this._bufferPosition = 0;
                _this._bitBuffer = 0;
                _this._bitLength = 0;
                _this._window = new Uint8Array(MAX_WINDOW_SIZE);
                _this._windowPosition = 0;
                _this._state = verifyHeader ? InflateState.VERIFY_HEADER : InflateState.INIT;
                _this._isFinalBlock = false;
                _this._literalTable = null;
                _this._distanceTable = null;
                _this._block0Read = 0;
                _this._block2State = null;
                _this._copyState = {
                    state: 0,
                    len: 0,
                    lenBits: 0,
                    dist: 0,
                    distBits: 0
                };
                if (!areTablesInitialized) {
                    initializeTables();
                    areTablesInitialized = true;
                }
                return _this;
            }
            BasicInflate.prototype.push = function (data) {
                if (!this._buffer || this._buffer.length < this._bufferSize + data.length) {
                    var newBuffer = new Uint8Array(this._bufferSize + data.length);
                    if (this._buffer) {
                        newBuffer.set(this._buffer);
                    }
                    this._buffer = newBuffer;
                }
                this._buffer.set(data, this._bufferSize);
                this._bufferSize += data.length;
                this._bufferPosition = 0;
                var incomplete = false;
                do {
                    var lastPosition = this._windowPosition;
                    if (this._state === InflateState.INIT) {
                        incomplete = this._decodeInitState();
                        if (incomplete) {
                            break;
                        }
                    }
                    switch (this._state) {
                        case InflateState.BLOCK_0:
                            incomplete = this._decodeBlock0();
                            break;
                        case InflateState.BLOCK_2_PRE:
                            incomplete = this._decodeBlock2Pre();
                            if (incomplete) {
                                break;
                            }
                        /* fall through */
                        case InflateState.BLOCK_1:
                        case InflateState.BLOCK_2:
                            incomplete = this._decodeBlock();
                            break;
                        case InflateState.ERROR:
                        case InflateState.DONE:
                            // skipping all data
                            this._bufferPosition = this._bufferSize;
                            break;
                        case InflateState.VERIFY_HEADER:
                            var processed = this._processZLibHeader(this._buffer, this._bufferPosition, this._bufferSize);
                            if (processed > 0) {
                                this._bufferPosition += processed;
                                this._state = InflateState.INIT;
                            }
                            else if (processed === 0) {
                                incomplete = true;
                            }
                            else {
                                this._state = InflateState.ERROR;
                            }
                            break;
                    }
                    var decoded = this._windowPosition - lastPosition;
                    if (decoded > 0) {
                        this.onData(this._window.subarray(lastPosition, this._windowPosition));
                    }
                    if (this._windowPosition >= WINDOW_SHIFT_POSITION) {
                        // shift window
                        if ('copyWithin' in this._buffer) {
                            this._window['copyWithin'](0, this._windowPosition - WINDOW_SIZE, this._windowPosition);
                        }
                        else {
                            this._window.set(this._window.subarray(this._windowPosition - WINDOW_SIZE, this._windowPosition));
                        }
                        this._windowPosition = WINDOW_SIZE;
                    }
                } while (!incomplete && this._bufferPosition < this._bufferSize);
                if (this._bufferPosition < this._bufferSize) {
                    // shift buffer
                    if ('copyWithin' in this._buffer) {
                        this._buffer['copyWithin'](0, this._bufferPosition, this._bufferSize);
                    }
                    else {
                        this._buffer.set(this._buffer.subarray(this._bufferPosition, this._bufferSize));
                    }
                    this._bufferSize -= this._bufferPosition;
                }
                else {
                    this._bufferSize = 0;
                }
            };
            BasicInflate.prototype._decodeInitState = function () {
                if (this._isFinalBlock) {
                    this._state = InflateState.DONE;
                    return false;
                }
                var buffer = this._buffer, bufferSize = this._bufferSize;
                var bitBuffer = this._bitBuffer, bitLength = this._bitLength;
                var state;
                var position = this._bufferPosition;
                if (((bufferSize - position) << 3) + bitLength < 3) {
                    return true;
                }
                if (bitLength < 3) {
                    bitBuffer |= buffer[position++] << bitLength;
                    bitLength += 8;
                }
                var type = bitBuffer & 7;
                bitBuffer >>= 3;
                bitLength -= 3;
                switch (type >> 1) {
                    case 0:
                        bitBuffer = 0;
                        bitLength = 0;
                        if (bufferSize - position < 4) {
                            return true;
                        }
                        var length_1 = buffer[position] | (buffer[position + 1] << 8);
                        var length2 = buffer[position + 2] | (buffer[position + 3] << 8);
                        position += 4;
                        if ((length_1 ^ length2) !== 0xFFFF) {
                            this._error('inflate: invalid block 0 length');
                            state = InflateState.ERROR;
                            break;
                        }
                        if (length_1 === 0) {
                            state = InflateState.INIT;
                        }
                        else {
                            this._block0Read = length_1;
                            state = InflateState.BLOCK_0;
                        }
                        break;
                    case 1:
                        state = InflateState.BLOCK_1;
                        this._literalTable = fixedLiteralTable;
                        this._distanceTable = fixedDistanceTable;
                        break;
                    case 2:
                        if (((bufferSize - position) << 3) + bitLength < 14 + 3 * 4) {
                            return true;
                        }
                        while (bitLength < 14) {
                            bitBuffer |= buffer[position++] << bitLength;
                            bitLength += 8;
                        }
                        var numLengthCodes = ((bitBuffer >> 10) & 15) + 4;
                        if (((bufferSize - position) << 3) + bitLength < 14 + 3 * numLengthCodes) {
                            return true;
                        }
                        var block2State = {
                            numLiteralCodes: (bitBuffer & 31) + 257,
                            numDistanceCodes: ((bitBuffer >> 5) & 31) + 1,
                            codeLengthTable: undefined,
                            bitLengths: undefined,
                            codesRead: 0,
                            dupBits: 0
                        };
                        bitBuffer >>= 14;
                        bitLength -= 14;
                        var codeLengths = new Uint8Array(19);
                        var i = void 0;
                        for (i = 0; i < numLengthCodes; ++i) {
                            if (bitLength < 3) {
                                bitBuffer |= buffer[position++] << bitLength;
                                bitLength += 8;
                            }
                            codeLengths[codeLengthOrder[i]] = bitBuffer & 7;
                            bitBuffer >>= 3;
                            bitLength -= 3;
                        }
                        for (; i < 19; i++) {
                            codeLengths[codeLengthOrder[i]] = 0;
                        }
                        block2State.bitLengths =
                            new Uint8Array(block2State.numLiteralCodes + block2State.numDistanceCodes);
                        block2State.codeLengthTable = makeHuffmanTable(codeLengths);
                        this._block2State = block2State;
                        state = InflateState.BLOCK_2_PRE;
                        break;
                    default:
                        this._error('inflate: unsupported block type');
                        state = InflateState.ERROR;
                        return false;
                }
                this._isFinalBlock = !!(type & 1);
                this._state = state;
                this._bufferPosition = position;
                this._bitBuffer = bitBuffer;
                this._bitLength = bitLength;
                return false;
            };
            BasicInflate.prototype._error = function (e) {
                if (this.onError) {
                    this.onError(e);
                }
            };
            BasicInflate.prototype._decodeBlock0 = function () {
                var position = this._bufferPosition;
                var windowPosition = this._windowPosition;
                var toRead = this._block0Read;
                var leftInWindow = MAX_WINDOW_SIZE - windowPosition;
                var leftInBuffer = this._bufferSize - position;
                var incomplete = leftInBuffer < toRead;
                var canFit = Math.min(leftInWindow, leftInBuffer, toRead);
                this._window.set(this._buffer.subarray(position, position + canFit), windowPosition);
                this._windowPosition = windowPosition + canFit;
                this._bufferPosition = position + canFit;
                this._block0Read = toRead - canFit;
                if (toRead === canFit) {
                    this._state = InflateState.INIT;
                    return false;
                }
                return incomplete && leftInWindow < leftInBuffer;
            };
            BasicInflate.prototype._readBits = function (size) {
                var bitBuffer = this._bitBuffer;
                var bitLength = this._bitLength;
                if (size > bitLength) {
                    var pos = this._bufferPosition;
                    var end = this._bufferSize;
                    do {
                        if (pos >= end) {
                            this._bufferPosition = pos;
                            this._bitBuffer = bitBuffer;
                            this._bitLength = bitLength;
                            return -1;
                        }
                        bitBuffer |= this._buffer[pos++] << bitLength;
                        bitLength += 8;
                    } while (size > bitLength);
                    this._bufferPosition = pos;
                }
                this._bitBuffer = bitBuffer >> size;
                this._bitLength = bitLength - size;
                return bitBuffer & ((1 << size) - 1);
            };
            BasicInflate.prototype._readCode = function (codeTable) {
                var bitBuffer = this._bitBuffer;
                var bitLength = this._bitLength;
                var maxBits = codeTable.maxBits;
                if (maxBits > bitLength) {
                    var pos = this._bufferPosition;
                    var end = this._bufferSize;
                    do {
                        if (pos >= end) {
                            this._bufferPosition = pos;
                            this._bitBuffer = bitBuffer;
                            this._bitLength = bitLength;
                            return -1;
                        }
                        bitBuffer |= this._buffer[pos++] << bitLength;
                        bitLength += 8;
                    } while (maxBits > bitLength);
                    this._bufferPosition = pos;
                }
                var code = codeTable.codes[bitBuffer & ((1 << maxBits) - 1)];
                var len = code >> 16;
                if ((code & 0x8000)) {
                    this._error('inflate: invalid encoding');
                    this._state = InflateState.ERROR;
                    return -1;
                }
                this._bitBuffer = bitBuffer >> len;
                this._bitLength = bitLength - len;
                return code & 0xffff;
            };
            BasicInflate.prototype._decodeBlock2Pre = function () {
                var block2State = this._block2State;
                var numCodes = block2State.numLiteralCodes + block2State.numDistanceCodes;
                var bitLengths = block2State.bitLengths;
                var i = block2State.codesRead;
                var prev = i > 0 ? bitLengths[i - 1] : 0;
                var codeLengthTable = block2State.codeLengthTable;
                var j;
                if (block2State.dupBits > 0) {
                    j = this._readBits(block2State.dupBits);
                    if (j < 0) {
                        return true;
                    }
                    while (j--) {
                        bitLengths[i++] = prev;
                    }
                    block2State.dupBits = 0;
                }
                while (i < numCodes) {
                    var sym = this._readCode(codeLengthTable);
                    if (sym < 0) {
                        block2State.codesRead = i;
                        return true;
                    }
                    else if (sym < 16) {
                        bitLengths[i++] = (prev = sym);
                        continue;
                    }
                    var j_1 = void 0, dupBits = void 0;
                    switch (sym) {
                        case 16:
                            dupBits = 2;
                            j_1 = 3;
                            sym = prev;
                            break;
                        case 17:
                            dupBits = 3;
                            j_1 = 3;
                            sym = 0;
                            break;
                        case 18:
                            dupBits = 7;
                            j_1 = 11;
                            sym = 0;
                            break;
                    }
                    while (j_1--) {
                        bitLengths[i++] = sym;
                    }
                    j_1 = this._readBits(dupBits);
                    if (j_1 < 0) {
                        block2State.codesRead = i;
                        block2State.dupBits = dupBits;
                        return true;
                    }
                    while (j_1--) {
                        bitLengths[i++] = sym;
                    }
                    prev = sym;
                }
                this._literalTable = makeHuffmanTable(bitLengths.subarray(0, block2State.numLiteralCodes));
                this._distanceTable = makeHuffmanTable(bitLengths.subarray(block2State.numLiteralCodes));
                this._state = InflateState.BLOCK_2;
                this._block2State = null;
                return false;
            };
            BasicInflate.prototype._decodeBlock = function () {
                var literalTable = this._literalTable, distanceTable = this._distanceTable;
                var output = this._window, pos = this._windowPosition;
                var copyState = this._copyState;
                var i, j, sym;
                var len, lenBits, dist, distBits;
                if (copyState.state !== 0) {
                    // continuing len/distance operation
                    switch (copyState.state) {
                        case 1:
                            j = 0;
                            if ((j = this._readBits(copyState.lenBits)) < 0) {
                                return true;
                            }
                            copyState.len += j;
                            copyState.state = 2;
                        /* fall through */
                        case 2:
                            if ((sym = this._readCode(distanceTable)) < 0) {
                                return true;
                            }
                            copyState.distBits = distanceExtraBits[sym];
                            copyState.dist = distanceCodes[sym];
                            copyState.state = 3;
                        /* fall through */
                        case 3:
                            j = 0;
                            if (copyState.distBits > 0 && (j = this._readBits(copyState.distBits)) < 0) {
                                return true;
                            }
                            dist = copyState.dist + j;
                            len = copyState.len;
                            i = pos - dist;
                            while (len--) {
                                output[pos++] = output[i++];
                            }
                            copyState.state = 0;
                            if (pos >= WINDOW_SHIFT_POSITION) {
                                this._windowPosition = pos;
                                return false;
                            }
                            break;
                    }
                }
                do {
                    sym = this._readCode(literalTable);
                    if (sym < 0) {
                        this._windowPosition = pos;
                        return true;
                    }
                    else if (sym < 256) {
                        output[pos++] = sym;
                    }
                    else if (sym > 256) {
                        this._windowPosition = pos;
                        sym -= 257;
                        lenBits = lengthExtraBits[sym];
                        len = lengthCodes[sym];
                        j = lenBits === 0 ? 0 : this._readBits(lenBits);
                        if (j < 0) {
                            copyState.state = 1;
                            copyState.len = len;
                            copyState.lenBits = lenBits;
                            return true;
                        }
                        len += j;
                        sym = this._readCode(distanceTable);
                        if (sym < 0) {
                            copyState.state = 2;
                            copyState.len = len;
                            return true;
                        }
                        distBits = distanceExtraBits[sym];
                        dist = distanceCodes[sym];
                        j = distBits === 0 ? 0 : this._readBits(distBits);
                        if (j < 0) {
                            copyState.state = 3;
                            copyState.len = len;
                            copyState.dist = dist;
                            copyState.distBits = distBits;
                            return true;
                        }
                        dist += j;
                        i = pos - dist;
                        while (len--) {
                            output[pos++] = output[i++];
                        }
                    }
                    else {
                        this._state = InflateState.INIT;
                        break; // end of block
                    }
                } while (pos < WINDOW_SHIFT_POSITION);
                this._windowPosition = pos;
                return false;
            };
            return BasicInflate;
        }(Inflate));
        var codeLengthOrder;
        var distanceCodes;
        var distanceExtraBits;
        var fixedDistanceTable;
        var lengthCodes;
        var lengthExtraBits;
        var fixedLiteralTable;
        var areTablesInitialized = false;
        function initializeTables() {
            codeLengthOrder = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
            distanceCodes = new Uint16Array(30);
            distanceExtraBits = new Uint8Array(30);
            for (var i = 0, j = 0, code = 1; i < 30; ++i) {
                distanceCodes[i] = code;
                code += 1 << (distanceExtraBits[i] = ~~((j += (i > 2 ? 1 : 0)) / 2));
            }
            var bitLengths = new Uint8Array(288);
            for (var i = 0; i < 32; ++i) {
                bitLengths[i] = 5;
            }
            fixedDistanceTable = makeHuffmanTable(bitLengths.subarray(0, 32));
            lengthCodes = new Uint16Array(29);
            lengthExtraBits = new Uint8Array(29);
            for (var i = 0, j = 0, code = 3; i < 29; ++i) {
                lengthCodes[i] = code - (i == 28 ? 1 : 0);
                code += 1 << (lengthExtraBits[i] = ~~(((j += (i > 4 ? 1 : 0)) / 4) % 6));
            }
            for (var i = 0; i < 288; ++i) {
                bitLengths[i] = i < 144 || i > 279 ? 8 : (i < 256 ? 9 : 7);
            }
            fixedLiteralTable = makeHuffmanTable(bitLengths);
        }
        function makeHuffmanTable(bitLengths) {
            var maxBits = Math.max.apply(null, bitLengths);
            var numLengths = bitLengths.length;
            var size = 1 << maxBits;
            var codes = new Uint32Array(size);
            // avoiding len == 0: using max number of bits
            var dummyCode = (maxBits << 16) | 0xFFFF;
            for (var j = 0; j < size; j++) {
                codes[j] = dummyCode;
            }
            for (var code = 0, len = 1, skip = 2; len <= maxBits; code <<= 1, ++len, skip <<= 1) {
                for (var val = 0; val < numLengths; ++val) {
                    if (bitLengths[val] === len) {
                        var lsb = 0;
                        for (var i = 0; i < len; ++i)
                            lsb = (lsb * 2) + ((code >> i) & 1);
                        for (var i = lsb; i < size; i += skip)
                            codes[i] = (len << 16) | val;
                        ++code;
                    }
                }
            }
            return { codes: codes, maxBits: maxBits };
        }
        var SpecialInflateAdapter = /** @class */ (function (_super) {
            __extends(SpecialInflateAdapter, _super);
            function SpecialInflateAdapter(verifyHeader, createSpecialInflate) {
                var _this = _super.call(this, verifyHeader) || this;
                _this._verifyHeader = verifyHeader;
                _this._specialInflate = createSpecialInflate();
                _this._specialInflate.setDataCallback(function (data) {
                    this.onData(data);
                }.bind(_this));
                return _this;
            }
            SpecialInflateAdapter.prototype.push = function (data) {
                if (this._verifyHeader) {
                    var buffer = void 0;
                    if (this._buffer) {
                        buffer = new Uint8Array(this._buffer.length + data.length);
                        buffer.set(this._buffer);
                        buffer.set(data, this._buffer.length);
                        this._buffer = null;
                    }
                    else {
                        buffer = new Uint8Array(data);
                    }
                    var processed = this._processZLibHeader(buffer, 0, buffer.length);
                    if (processed === 0) {
                        this._buffer = buffer;
                        return;
                    }
                    this._verifyHeader = true;
                    if (processed > 0) {
                        data = buffer.subarray(processed);
                    }
                }
                this._specialInflate.push(data);
            };
            SpecialInflateAdapter.prototype.close = function () {
                if (this._specialInflate) {
                    this._specialInflate.close();
                    this._specialInflate = null;
                }
            };
            return SpecialInflateAdapter;
        }(Inflate));
        var DeflateState;
        (function (DeflateState) {
            DeflateState[DeflateState["WRITE"] = 0] = "WRITE";
            DeflateState[DeflateState["DONE"] = 1] = "DONE";
            DeflateState[DeflateState["ZLIB_HEADER"] = 2] = "ZLIB_HEADER";
        })(DeflateState || (DeflateState = {}));
        var Adler32 = /** @class */ (function () {
            function Adler32() {
                this.a = 1;
                this.b = 0;
            }
            Adler32.prototype.update = function (data, start, end) {
                var a = this.a;
                var b = this.b;
                for (var i = start; i < end; ++i) {
                    a = (a + (data[i] & 0xff)) % 65521;
                    b = (b + a) % 65521;
                }
                this.a = a;
                this.b = b;
            };
            Adler32.prototype.getChecksum = function () {
                return (this.b << 16) | this.a;
            };
            return Adler32;
        }());
        ArrayUtilities.Adler32 = Adler32;
        var Deflate = /** @class */ (function () {
            function Deflate(writeZlibHeader) {
                this._writeZlibHeader = writeZlibHeader;
                this._state = writeZlibHeader ? DeflateState.ZLIB_HEADER : DeflateState.WRITE;
                this._adler32 = writeZlibHeader ? new Adler32() : null;
            }
            Deflate.prototype.push = function (data) {
                if (this._state === DeflateState.ZLIB_HEADER) {
                    this.onData(new Uint8Array([0x78, 0x9C]));
                    this._state = DeflateState.WRITE;
                }
                // simple non-compressing algorithm for now
                var len = data.length;
                var outputSize = len + Math.ceil(len / 0xFFFF) * 5;
                var output = new Uint8Array(outputSize);
                var outputPos = 0;
                var pos = 0;
                while (len > 0xFFFF) {
                    output.set(new Uint8Array([
                        0x00,
                        0xFF, 0xFF,
                        0x00, 0x00
                    ]), outputPos);
                    outputPos += 5;
                    output.set(data.subarray(pos, pos + 0xFFFF), outputPos);
                    pos += 0xFFFF;
                    outputPos += 0xFFFF;
                    len -= 0xFFFF;
                }
                output.set(new Uint8Array([
                    0x00,
                    (len & 0xff), ((len >> 8) & 0xff),
                    ((~len) & 0xff), (((~len) >> 8) & 0xff)
                ]), outputPos);
                outputPos += 5;
                output.set(data.subarray(pos, len), outputPos);
                this.onData(output);
                if (this._adler32) {
                    this._adler32.update(data, 0, len);
                }
            };
            Deflate.prototype.close = function () {
                this._state = DeflateState.DONE;
                this.onData(new Uint8Array([
                    0x01,
                    0x00, 0x00,
                    0xFF, 0xFF
                ]));
                if (this._adler32) {
                    var checksum = this._adler32.getChecksum();
                    this.onData(new Uint8Array([
                        checksum & 0xff, (checksum >> 8) & 0xff,
                        (checksum >> 16) & 0xff, (checksum >>> 24) & 0xff
                    ]));
                }
            };
            return Deflate;
        }());
        ArrayUtilities.Deflate = Deflate;
    })(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The code derived from:
/* LzmaSpec.c -- LZMA Reference Decoder
 2013-07-28 : Igor Pavlov : Public domain */
var Shumway;
(function (Shumway) {
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var InputStream = /** @class */ (function () {
            function InputStream() {
                this.available = 0;
                this.pos = 0;
                this.buffer = new Uint8Array(2000);
            }
            InputStream.prototype.append = function (data) {
                var length = this.pos + this.available;
                var needLength = length + data.length;
                if (needLength > this.buffer.length) {
                    var newLength = this.buffer.length * 2;
                    while (newLength < needLength) {
                        newLength *= 2;
                    }
                    var newBuffer = new Uint8Array(newLength);
                    newBuffer.set(this.buffer);
                    this.buffer = newBuffer;
                }
                this.buffer.set(data, length);
                this.available += data.length;
            };
            InputStream.prototype.compact = function () {
                if (this.available === 0) {
                    return;
                }
                this.buffer.set(this.buffer.subarray(this.pos, this.pos + this.available), 0);
                this.pos = 0;
            };
            InputStream.prototype.readByte = function () {
                if (this.available <= 0) {
                    throw new Error("Unexpected end of file");
                }
                this.available--;
                return this.buffer[this.pos++];
            };
            return InputStream;
        }());
        var OutputStream = /** @class */ (function () {
            function OutputStream(onData) {
                this.onData = onData;
                this.processed = 0;
            }
            OutputStream.prototype.writeBytes = function (data) {
                this.onData.call(null, data);
                this.processed += data.length;
            };
            return OutputStream;
        }());
        var OutWindow = /** @class */ (function () {
            function OutWindow(outStream) {
                this.outStream = outStream;
                this.buf = null;
                this.pos = 0;
                this.size = 0;
                this.isFull = false;
                this.writePos = 0;
                this.totalPos = 0;
            }
            OutWindow.prototype.create = function (dictSize) {
                this.buf = new Uint8Array(dictSize);
                this.pos = 0;
                this.size = dictSize;
                this.isFull = false;
                this.writePos = 0;
                this.totalPos = 0;
            };
            OutWindow.prototype.putByte = function (b) {
                this.totalPos++;
                this.buf[this.pos++] = b;
                if (this.pos === this.size) {
                    this.flush();
                    this.pos = 0;
                    this.isFull = true;
                }
            };
            OutWindow.prototype.getByte = function (dist) {
                return this.buf[dist <= this.pos ? this.pos - dist : this.size - dist + this.pos];
            };
            OutWindow.prototype.flush = function () {
                if (this.writePos < this.pos) {
                    this.outStream.writeBytes(this.buf.subarray(this.writePos, this.pos));
                    this.writePos = this.pos === this.size ? 0 : this.pos;
                }
            };
            OutWindow.prototype.copyMatch = function (dist, len) {
                var pos = this.pos;
                var size = this.size;
                var buffer = this.buf;
                var getPos = dist <= pos ? pos - dist : size - dist + pos;
                var left = len;
                while (left > 0) {
                    var chunk = Math.min(Math.min(left, size - pos), size - getPos);
                    for (var i = 0; i < chunk; i++) {
                        var b = buffer[getPos++];
                        buffer[pos++] = b;
                    }
                    if (pos === size) {
                        this.pos = pos;
                        this.flush();
                        pos = 0;
                        this.isFull = true;
                    }
                    if (getPos === size) {
                        getPos = 0;
                    }
                    left -= chunk;
                }
                this.pos = pos;
                this.totalPos += len;
            };
            OutWindow.prototype.checkDistance = function (dist) {
                return dist <= this.pos || this.isFull;
            };
            OutWindow.prototype.isEmpty = function () {
                return this.pos === 0 && !this.isFull;
            };
            return OutWindow;
        }());
        var kNumBitModelTotalBits = 11;
        var kNumMoveBits = 5;
        var PROB_INIT_VAL = ((1 << kNumBitModelTotalBits) >> 1);
        function createProbsArray(length) {
            var p = new Uint16Array(length);
            for (var i = 0; i < length; i++) {
                p[i] = PROB_INIT_VAL;
            }
            return p;
        }
        var kTopValue = 1 << 24;
        var RangeDecoder = /** @class */ (function () {
            function RangeDecoder(inStream) {
                this.inStream = inStream;
                this.range = 0;
                this.code = 0;
                this.corrupted = false;
            }
            RangeDecoder.prototype.init = function () {
                if (this.inStream.readByte() !== 0) {
                    this.corrupted = true;
                }
                this.range = 0xFFFFFFFF | 0;
                var code = 0;
                for (var i = 0; i < 4; i++) {
                    code = (code << 8) | this.inStream.readByte();
                }
                if (code === this.range) {
                    this.corrupted = true;
                }
                this.code = code;
            };
            RangeDecoder.prototype.isFinishedOK = function () {
                return this.code === 0;
            };
            RangeDecoder.prototype.decodeDirectBits = function (numBits) {
                var res = 0;
                var range = this.range;
                var code = this.code;
                do {
                    range = (range >>> 1) | 0;
                    code = (code - range) | 0;
                    var t = code >> 31; // if high bit set -1, otherwise 0
                    code = (code + (range & t)) | 0;
                    if (code === range) {
                        this.corrupted = true;
                    }
                    if (range >= 0 && range < kTopValue) {
                        range = range << 8;
                        code = (code << 8) | this.inStream.readByte();
                    }
                    res = ((res << 1) + t + 1) | 0;
                } while (--numBits);
                this.range = range;
                this.code = code;
                return res;
            };
            RangeDecoder.prototype.decodeBit = function (prob, index) {
                var range = this.range;
                var code = this.code;
                var v = prob[index];
                var bound = (range >>> kNumBitModelTotalBits) * v; // keep unsigned
                var symbol;
                if ((code >>> 0) < bound) {
                    v = (v + (((1 << kNumBitModelTotalBits) - v) >> kNumMoveBits)) | 0;
                    range = bound | 0;
                    symbol = 0;
                }
                else {
                    v = (v - (v >> kNumMoveBits)) | 0;
                    code = (code - bound) | 0;
                    range = (range - bound) | 0;
                    symbol = 1;
                }
                prob[index] = v & 0xFFFF;
                if (range >= 0 && range < kTopValue) {
                    range = range << 8;
                    code = (code << 8) | this.inStream.readByte();
                }
                this.range = range;
                this.code = code;
                return symbol;
            };
            return RangeDecoder;
        }());
        function bitTreeReverseDecode(probs, offset, numBits, rc) {
            var m = 1;
            var symbol = 0;
            for (var i = 0; i < numBits; i++) {
                var bit = rc.decodeBit(probs, m + offset);
                m = (m << 1) + bit;
                symbol |= bit << i;
            }
            return symbol;
        }
        var BitTreeDecoder = /** @class */ (function () {
            function BitTreeDecoder(numBits) {
                this.numBits = numBits;
                this.probs = createProbsArray(1 << numBits);
            }
            BitTreeDecoder.prototype.decode = function (rc) {
                var m = 1;
                for (var i = 0; i < this.numBits; i++) {
                    m = (m << 1) + rc.decodeBit(this.probs, m);
                }
                return m - (1 << this.numBits);
            };
            BitTreeDecoder.prototype.reverseDecode = function (rc) {
                return bitTreeReverseDecode(this.probs, 0, this.numBits, rc);
            };
            return BitTreeDecoder;
        }());
        function createBitTreeDecoderArray(numBits, length) {
            var p = [];
            p.length = length;
            for (var i = 0; i < length; i++) {
                p[i] = new BitTreeDecoder(numBits);
            }
            return p;
        }
        var kNumPosBitsMax = 4;
        var kNumStates = 12;
        var kNumLenToPosStates = 4;
        var kNumAlignBits = 4;
        var kStartPosModelIndex = 4;
        var kEndPosModelIndex = 14;
        var kNumFullDistances = 1 << (kEndPosModelIndex >> 1);
        var kMatchMinLen = 2;
        var LenDecoder = /** @class */ (function () {
            function LenDecoder() {
                this.choice = createProbsArray(2);
                this.lowCoder = createBitTreeDecoderArray(3, 1 << kNumPosBitsMax);
                this.midCoder = createBitTreeDecoderArray(3, 1 << kNumPosBitsMax);
                this.highCoder = new BitTreeDecoder(8);
            }
            LenDecoder.prototype.decode = function (rc, posState) {
                if (rc.decodeBit(this.choice, 0) === 0) {
                    return this.lowCoder[posState].decode(rc);
                }
                if (rc.decodeBit(this.choice, 1) === 0) {
                    return 8 + this.midCoder[posState].decode(rc);
                }
                return 16 + this.highCoder.decode(rc);
            };
            return LenDecoder;
        }());
        function updateState_Literal(state) {
            if (state < 4) {
                return 0;
            }
            else if (state < 10) {
                return state - 3;
            }
            else {
                return state - 6;
            }
        }
        function updateState_Match(state) {
            return state < 7 ? 7 : 10;
        }
        function updateState_Rep(state) {
            return state < 7 ? 8 : 11;
        }
        function updateState_ShortRep(state) {
            return state < 7 ? 9 : 11;
        }
        var LZMA_DIC_MIN = 1 << 12;
        var MAX_DECODE_BITS_CALLS = 48;
        var LzmaDecoderInternal = /** @class */ (function () {
            function LzmaDecoderInternal(inStream, outStream) {
                this.rangeDec = new RangeDecoder(inStream);
                this.outWindow = new OutWindow(outStream);
                this.markerIsMandatory = false;
                this.lc = 0;
                this.pb = 0;
                this.lp = 0;
                this.dictSize = 0;
                this.dictSizeInProperties = 0;
                this.unpackSize = undefined;
                this.leftToUnpack = undefined;
                this.reps = new Int32Array(4);
                this.state = 0;
            }
            LzmaDecoderInternal.prototype.decodeProperties = function (properties) {
                var d = properties[0];
                if (d >= (9 * 5 * 5)) {
                    throw new Error("Incorrect LZMA properties");
                }
                this.lc = d % 9;
                d = (d / 9) | 0;
                this.pb = (d / 5) | 0;
                this.lp = d % 5;
                this.dictSizeInProperties = 0;
                for (var i = 0; i < 4; i++) {
                    this.dictSizeInProperties |= properties[i + 1] << (8 * i);
                }
                this.dictSize = this.dictSizeInProperties;
                if (this.dictSize < LZMA_DIC_MIN) {
                    this.dictSize = LZMA_DIC_MIN;
                }
            };
            LzmaDecoderInternal.prototype.create = function () {
                this.outWindow.create(this.dictSize);
                this.init();
                this.rangeDec.init();
                this.reps[0] = 0;
                this.reps[1] = 0;
                this.reps[2] = 0;
                this.reps[3] = 0;
                this.state = 0;
                this.leftToUnpack = this.unpackSize;
            };
            LzmaDecoderInternal.prototype.decodeLiteral = function (state, rep0) {
                var outWindow = this.outWindow;
                var rangeDec = this.rangeDec;
                var prevByte = 0;
                if (!outWindow.isEmpty()) {
                    prevByte = outWindow.getByte(1);
                }
                var symbol = 1;
                var litState = ((outWindow.totalPos & ((1 << this.lp) - 1)) << this.lc) + (prevByte >> (8 - this.lc));
                var probsIndex = 0x300 * litState;
                if (state >= 7) {
                    var matchByte = outWindow.getByte(rep0 + 1);
                    do {
                        var matchBit = (matchByte >> 7) & 1;
                        matchByte <<= 1;
                        var bit = rangeDec.decodeBit(this.litProbs, probsIndex + (((1 + matchBit) << 8) + symbol));
                        symbol = (symbol << 1) | bit;
                        if (matchBit !== bit) {
                            break;
                        }
                    } while (symbol < 0x100);
                }
                while (symbol < 0x100) {
                    symbol =
                        (symbol << 1) | rangeDec.decodeBit(this.litProbs, probsIndex + symbol);
                }
                return (symbol - 0x100) & 0xFF;
            };
            LzmaDecoderInternal.prototype.decodeDistance = function (len) {
                var lenState = len;
                if (lenState > kNumLenToPosStates - 1) {
                    lenState = kNumLenToPosStates - 1;
                }
                var rangeDec = this.rangeDec;
                var posSlot = this.posSlotDecoder[lenState].decode(rangeDec);
                if (posSlot < 4) {
                    return posSlot;
                }
                var numDirectBits = (posSlot >> 1) - 1;
                var dist = (2 | (posSlot & 1)) << numDirectBits;
                if (posSlot < kEndPosModelIndex) {
                    dist =
                        (dist + bitTreeReverseDecode(this.posDecoders, dist - posSlot, numDirectBits, rangeDec)) | 0;
                }
                else {
                    dist =
                        (dist + (rangeDec.decodeDirectBits(numDirectBits - kNumAlignBits) << kNumAlignBits)) | 0;
                    dist = (dist + this.alignDecoder.reverseDecode(rangeDec)) | 0;
                }
                return dist;
            };
            LzmaDecoderInternal.prototype.init = function () {
                this.litProbs = createProbsArray(0x300 << (this.lc + this.lp));
                this.posSlotDecoder = createBitTreeDecoderArray(6, kNumLenToPosStates);
                this.alignDecoder = new BitTreeDecoder(kNumAlignBits);
                this.posDecoders =
                    createProbsArray(1 + kNumFullDistances - kEndPosModelIndex);
                this.isMatch = createProbsArray(kNumStates << kNumPosBitsMax);
                this.isRep = createProbsArray(kNumStates);
                this.isRepG0 = createProbsArray(kNumStates);
                this.isRepG1 = createProbsArray(kNumStates);
                this.isRepG2 = createProbsArray(kNumStates);
                this.isRep0Long = createProbsArray(kNumStates << kNumPosBitsMax);
                this.lenDecoder = new LenDecoder();
                this.repLenDecoder = new LenDecoder();
            };
            LzmaDecoderInternal.prototype.decode = function (notFinal) {
                var rangeDec = this.rangeDec;
                var outWindow = this.outWindow;
                var pb = this.pb;
                var dictSize = this.dictSize;
                var markerIsMandatory = this.markerIsMandatory;
                var leftToUnpack = this.leftToUnpack;
                var isMatch = this.isMatch;
                var isRep = this.isRep;
                var isRepG0 = this.isRepG0;
                var isRepG1 = this.isRepG1;
                var isRepG2 = this.isRepG2;
                var isRep0Long = this.isRep0Long;
                var lenDecoder = this.lenDecoder;
                var repLenDecoder = this.repLenDecoder;
                var rep0 = this.reps[0];
                var rep1 = this.reps[1];
                var rep2 = this.reps[2];
                var rep3 = this.reps[3];
                var state = this.state;
                while (true) {
                    // Based on worse case scenario one byte consumed per decodeBit calls,
                    // reserving keeping some amount of bytes in the input stream for
                    // non-final data blocks.
                    if (notFinal && rangeDec.inStream.available < MAX_DECODE_BITS_CALLS) {
                        this.outWindow.flush();
                        break;
                    }
                    if (leftToUnpack === 0 && !markerIsMandatory) {
                        this.outWindow.flush();
                        if (rangeDec.isFinishedOK()) {
                            return LZMA_RES_FINISHED_WITHOUT_MARKER;
                        }
                    }
                    var posState = outWindow.totalPos & ((1 << pb) - 1);
                    if (rangeDec.decodeBit(isMatch, (state << kNumPosBitsMax) + posState) === 0) {
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        outWindow.putByte(this.decodeLiteral(state, rep0));
                        state = updateState_Literal(state);
                        leftToUnpack--;
                        continue;
                    }
                    var len = void 0;
                    if (rangeDec.decodeBit(isRep, state) !== 0) {
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        if (outWindow.isEmpty()) {
                            return LZMA_RES_ERROR;
                        }
                        if (rangeDec.decodeBit(isRepG0, state) === 0) {
                            if (rangeDec.decodeBit(isRep0Long, (state << kNumPosBitsMax) + posState) === 0) {
                                state = updateState_ShortRep(state);
                                outWindow.putByte(outWindow.getByte(rep0 + 1));
                                leftToUnpack--;
                                continue;
                            }
                        }
                        else {
                            var dist = void 0;
                            if (rangeDec.decodeBit(isRepG1, state) === 0) {
                                dist = rep1;
                            }
                            else {
                                if (rangeDec.decodeBit(isRepG2, state) === 0) {
                                    dist = rep2;
                                }
                                else {
                                    dist = rep3;
                                    rep3 = rep2;
                                }
                                rep2 = rep1;
                            }
                            rep1 = rep0;
                            rep0 = dist;
                        }
                        len = repLenDecoder.decode(rangeDec, posState);
                        state = updateState_Rep(state);
                    }
                    else {
                        rep3 = rep2;
                        rep2 = rep1;
                        rep1 = rep0;
                        len = lenDecoder.decode(rangeDec, posState);
                        state = updateState_Match(state);
                        rep0 = this.decodeDistance(len);
                        if (rep0 === -1) {
                            this.outWindow.flush();
                            return rangeDec.isFinishedOK() ?
                                LZMA_RES_FINISHED_WITH_MARKER :
                                LZMA_RES_ERROR;
                        }
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        if (rep0 >= dictSize || !outWindow.checkDistance(rep0)) {
                            return LZMA_RES_ERROR;
                        }
                    }
                    len += kMatchMinLen;
                    var isError = false;
                    if (leftToUnpack !== undefined && leftToUnpack < len) {
                        len = leftToUnpack;
                        isError = true;
                    }
                    outWindow.copyMatch(rep0 + 1, len);
                    leftToUnpack -= len;
                    if (isError) {
                        return LZMA_RES_ERROR;
                    }
                }
                this.state = state;
                this.reps[0] = rep0;
                this.reps[1] = rep1;
                this.reps[2] = rep2;
                this.reps[3] = rep3;
                this.leftToUnpack = leftToUnpack;
                return LZMA_RES_NOT_COMPLETE;
            };
            LzmaDecoderInternal.prototype.flushOutput = function () {
                this.outWindow.flush();
            };
            return LzmaDecoderInternal;
        }());
        var LZMA_RES_ERROR = 0;
        var LZMA_RES_FINISHED_WITH_MARKER = 1;
        var LZMA_RES_FINISHED_WITHOUT_MARKER = 2;
        var LZMA_RES_NOT_COMPLETE = 3;
        var SWF_LZMA_HEADER_LENGTH = 17;
        var STANDARD_LZMA_HEADER_LENGTH = 13;
        var EXTRA_LZMA_BYTES_NEEDED = 5;
        var LzmaDecoderState;
        (function (LzmaDecoderState) {
            LzmaDecoderState[LzmaDecoderState["WAIT_FOR_LZMA_HEADER"] = 0] = "WAIT_FOR_LZMA_HEADER";
            LzmaDecoderState[LzmaDecoderState["WAIT_FOR_SWF_HEADER"] = 1] = "WAIT_FOR_SWF_HEADER";
            LzmaDecoderState[LzmaDecoderState["PROCESS_DATA"] = 2] = "PROCESS_DATA";
            LzmaDecoderState[LzmaDecoderState["CLOSED"] = 3] = "CLOSED";
            LzmaDecoderState[LzmaDecoderState["ERROR"] = 4] = "ERROR";
        })(LzmaDecoderState || (LzmaDecoderState = {}));
        var LzmaDecoder = /** @class */ (function () {
            function LzmaDecoder(swfHeader) {
                if (swfHeader === void 0) { swfHeader = false; }
                this._state = swfHeader ? LzmaDecoderState.WAIT_FOR_SWF_HEADER :
                    LzmaDecoderState.WAIT_FOR_LZMA_HEADER;
                this.buffer = null;
            }
            LzmaDecoder.prototype.push = function (data) {
                if (this._state < LzmaDecoderState.PROCESS_DATA) {
                    var buffered = this.buffer ? this.buffer.length : 0;
                    var headerBytesExpected = (this._state === LzmaDecoderState.WAIT_FOR_SWF_HEADER ?
                        SWF_LZMA_HEADER_LENGTH : STANDARD_LZMA_HEADER_LENGTH) +
                        EXTRA_LZMA_BYTES_NEEDED;
                    if (buffered + data.length < headerBytesExpected) {
                        var newBuffer = new Uint8Array(buffered + data.length);
                        if (buffered > 0) {
                            newBuffer.set(this.buffer);
                        }
                        newBuffer.set(data, buffered);
                        this.buffer = newBuffer;
                        return;
                    }
                    var header = new Uint8Array(headerBytesExpected);
                    if (buffered > 0) {
                        header.set(this.buffer);
                    }
                    header.set(data.subarray(0, headerBytesExpected - buffered), buffered);
                    this._inStream = new InputStream();
                    this._inStream.append(header.subarray(headerBytesExpected - EXTRA_LZMA_BYTES_NEEDED));
                    this._outStream = new OutputStream(function (data) {
                        this.onData.call(null, data);
                    }.bind(this));
                    this._decoder = new LzmaDecoderInternal(this._inStream, this._outStream);
                    // See http://helpx.adobe.com/flash-player/kb/exception-thrown-you-decompress-lzma-compressed.html
                    if (this._state === LzmaDecoderState.WAIT_FOR_SWF_HEADER) {
                        this._decoder.decodeProperties(header.subarray(12, 17));
                        this._decoder.markerIsMandatory = false;
                        this._decoder.unpackSize = ((header[4] | (header[5] << 8) |
                            (header[6] << 16) | (header[7] << 24)) >>> 0) - 8;
                    }
                    else {
                        this._decoder.decodeProperties(header.subarray(0, 5));
                        var unpackSize = 0;
                        var unpackSizeDefined = false;
                        for (var i = 0; i < 8; i++) {
                            var b = header[5 + i];
                            if (b !== 0xFF) {
                                unpackSizeDefined = true;
                            }
                            unpackSize |= b << (8 * i);
                        }
                        this._decoder.markerIsMandatory = !unpackSizeDefined;
                        this._decoder.unpackSize = unpackSizeDefined ? unpackSize : undefined;
                    }
                    this._decoder.create();
                    data = data.subarray(headerBytesExpected);
                    this._state = LzmaDecoderState.PROCESS_DATA;
                }
                else if (this._state !== LzmaDecoderState.PROCESS_DATA) {
                    return;
                }
                try {
                    this._inStream.append(data);
                    var res = this._decoder.decode(true);
                    this._inStream.compact();
                    if (res !== LZMA_RES_NOT_COMPLETE) {
                        this._checkError(res);
                    }
                }
                catch (e) {
                    this._decoder.flushOutput();
                    this._decoder = null;
                    this._error(e);
                }
            };
            LzmaDecoder.prototype.close = function () {
                if (this._state !== LzmaDecoderState.PROCESS_DATA) {
                    return;
                }
                this._state = LzmaDecoderState.CLOSED;
                try {
                    var res = this._decoder.decode(false);
                    this._checkError(res);
                }
                catch (e) {
                    this._decoder.flushOutput();
                    this._error(e);
                }
                this._decoder = null;
            };
            LzmaDecoder.prototype._error = function (error) {
                // Stopping processing any data if an error occurs.
                this._state = LzmaDecoderState.ERROR;
                if (this.onError) {
                    this.onError(error);
                }
            };
            LzmaDecoder.prototype._checkError = function (res) {
                var error;
                if (res === LZMA_RES_ERROR) {
                    error = "LZMA decoding error";
                }
                else if (res === LZMA_RES_NOT_COMPLETE) {
                    error = "Decoding is not complete";
                }
                else if (res === LZMA_RES_FINISHED_WITH_MARKER) {
                    if (this._decoder.unpackSize !== undefined &&
                        this._decoder.unpackSize !== this._outStream.processed) {
                        error = "Finished with end marker before than specified size";
                    }
                }
                else {
                    error = "Internal LZMA Error";
                }
                if (error) {
                    this._error(error);
                }
            };
            return LzmaDecoder;
        }());
        ArrayUtilities.LzmaDecoder = LzmaDecoder;
    })(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var notImplemented = Shumway.Debug.notImplemented;
        var assert = Shumway.Debug.assert;
        var utf8decode = Shumway.StringUtilities.utf8decode;
        var utf8encode = Shumway.StringUtilities.utf8encode;
        var clamp = Shumway.NumberUtilities.clamp;
        function axCoerceString(x) {
            if (typeof x === "string") {
                return x;
            }
            else if (x == undefined) {
                return null;
            }
            return x + '';
        }
        var PlainObjectDataBuffer = /** @class */ (function () {
            function PlainObjectDataBuffer(buffer, length, littleEndian) {
                this.buffer = buffer;
                this.length = length;
                this.littleEndian = littleEndian;
            }
            return PlainObjectDataBuffer;
        }());
        ArrayUtilities.PlainObjectDataBuffer = PlainObjectDataBuffer;
        var bitMasks = new Uint32Array(33);
        for (var i = 1, mask = 0; i <= 32; i++) {
            bitMasks[i] = mask = (mask << 1) | 1;
        }
        var TypedArrayViewFlags;
        (function (TypedArrayViewFlags) {
            TypedArrayViewFlags[TypedArrayViewFlags["U8"] = 1] = "U8";
            TypedArrayViewFlags[TypedArrayViewFlags["I32"] = 2] = "I32";
            TypedArrayViewFlags[TypedArrayViewFlags["F32"] = 4] = "F32";
        })(TypedArrayViewFlags || (TypedArrayViewFlags = {}));
        var DataBuffer = /** @class */ (function () {
            function DataBuffer(initialSize) {
                if (initialSize === void 0) { initialSize = DataBuffer.INITIAL_SIZE; }
                this._buffer = initialSize >= 0 ? new ArrayBuffer(initialSize) : null;
                this._length = 0;
                this._position = 0;
                this._resetViews();
                this._littleEndian = DataBuffer._nativeLittleEndian;
                this._bitBuffer = 0;
                this._bitLength = 0;
            }
            DataBuffer.FromArrayBuffer = function (buffer, length) {
                if (length === void 0) { length = -1; }
                var dataBuffer = Object.create(DataBuffer.prototype);
                dataBuffer._buffer = buffer;
                dataBuffer._length = length === -1 ? buffer.byteLength : length;
                dataBuffer._position = 0;
                dataBuffer._resetViews();
                dataBuffer._littleEndian = DataBuffer._nativeLittleEndian;
                dataBuffer._bitBuffer = 0;
                dataBuffer._bitLength = 0;
                return dataBuffer;
            };
            DataBuffer.FromPlainObject = function (source) {
                var dataBuffer = DataBuffer.FromArrayBuffer(source.buffer, source.length);
                dataBuffer._littleEndian = source.littleEndian;
                return dataBuffer;
            };
            DataBuffer.prototype.toPlainObject = function () {
                return new PlainObjectDataBuffer(this._buffer, this._length, this._littleEndian);
            };
            /**
             * Clone the DataBuffer in a way that guarantees the underlying ArrayBuffer to be copied
             * into an instance of the current global's ArrayBuffer.
             *
             * Important if the underlying buffer comes from a different global, in which case accessing
             * its elements is excruiciatingly slow.
             */
            DataBuffer.prototype.clone = function () {
                var clone = DataBuffer.FromArrayBuffer(new Uint8Array(this._u8).buffer, this._length);
                clone._position = this._position;
                clone._littleEndian = this._littleEndian;
                clone._bitBuffer = this._bitBuffer;
                clone._bitLength = this._bitLength;
                return clone;
            };
            /**
             * By default, we only have a byte view. All other views are |null|.
             */
            DataBuffer.prototype._resetViews = function () {
                this._u8 = new Uint8Array(this._buffer);
                this._i32 = null;
                this._f32 = null;
            };
            /**
             * We don't want to eagerly allocate views if we won't ever need them. You must call this method
             * before using a view of a certain type to make sure it's available. Once a view is allocated,
             * it is not re-allocated unless the view becomes |null| as a result of a call to |resetViews|.
             */
            DataBuffer.prototype._requestViews = function (flags) {
                if ((this._buffer.byteLength & 0x3) === 0) {
                    if (this._i32 === null && flags & TypedArrayViewFlags.I32) {
                        this._i32 = new Int32Array(this._buffer);
                    }
                    if (this._f32 === null && flags & TypedArrayViewFlags.F32) {
                        this._f32 = new Float32Array(this._buffer);
                    }
                }
            };
            DataBuffer.prototype.getBytes = function () {
                return new Uint8Array(this._buffer, 0, this._length);
            };
            DataBuffer.prototype._ensureCapacity = function (length) {
                var currentBuffer = this._buffer;
                if (currentBuffer.byteLength >= length) {
                    return;
                }
                var newLength = Math.max(currentBuffer.byteLength, 1);
                while (newLength < length) {
                    newLength *= 2;
                }
                if (newLength > 0xFFFFFFFF) {
                    release || assert(this.sec);
                    this.sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                }
                var newBuffer = DataBuffer._arrayBufferPool.acquire(newLength);
                var curentView = this._u8;
                this._buffer = newBuffer;
                this._resetViews();
                this._u8.set(curentView);
                var u8 = this._u8;
                // Zero out the rest of the buffer, since the arrayBufferPool doesn't
                // always give us a empty buffer.
                for (var i = curentView.length; i < u8.length; i++) {
                    u8[i] = 0;
                }
                DataBuffer._arrayBufferPool.release(currentBuffer);
            };
            DataBuffer.prototype.clear = function () {
                this._length = 0;
                this._position = 0;
            };
            DataBuffer.prototype.readBoolean = function () {
                return this.readUnsignedByte() !== 0;
            };
            DataBuffer.prototype.readByte = function () {
                return this.readUnsignedByte() << 24 >> 24;
            };
            DataBuffer.prototype.readUnsignedByte = function () {
                if (this._position + 1 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                return this._u8[this._position++];
            };
            DataBuffer.prototype.readBytes = function (bytes, offset /*uint*/, length /*uint*/) {
                var position = this._position;
                offset = offset >>> 0;
                length = length >>> 0;
                if (length === 0) {
                    length = this._length - position;
                }
                if (position + length > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                if (bytes.length < offset + length) {
                    bytes._ensureCapacity(offset + length);
                    bytes.length = offset + length;
                }
                bytes._u8.set(new Uint8Array(this._buffer, position, length), offset);
                this._position += length;
            };
            DataBuffer.prototype.readShort = function () {
                return this.readUnsignedShort() << 16 >> 16;
            };
            DataBuffer.prototype.readUnsignedShort = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 2 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                var a = u8[position + 0];
                var b = u8[position + 1];
                this._position = position + 2;
                return this._littleEndian ? (b << 8) | a : (a << 8) | b;
            };
            DataBuffer.prototype.readInt = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 4 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                var a = u8[position + 0];
                var b = u8[position + 1];
                var c = u8[position + 2];
                var d = u8[position + 3];
                this._position = position + 4;
                return this._littleEndian ?
                    (d << 24) | (c << 16) | (b << 8) | a :
                    (a << 24) | (b << 16) | (c << 8) | d;
            };
            DataBuffer.prototype.readUnsignedInt = function () {
                return this.readInt() >>> 0;
            };
            DataBuffer.prototype.readFloat = function () {
                var position = this._position;
                if (position + 4 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                this._position = position + 4;
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian && (position & 0x3) === 0 && this._f32) {
                    return this._f32[position >> 2];
                }
                else {
                    var u8 = this._u8;
                    var t8 = Shumway.IntegerUtilities.u8;
                    if (this._littleEndian) {
                        t8[0] = u8[position + 0];
                        t8[1] = u8[position + 1];
                        t8[2] = u8[position + 2];
                        t8[3] = u8[position + 3];
                    }
                    else {
                        t8[3] = u8[position + 0];
                        t8[2] = u8[position + 1];
                        t8[1] = u8[position + 2];
                        t8[0] = u8[position + 3];
                    }
                    return Shumway.IntegerUtilities.f32[0];
                }
            };
            DataBuffer.prototype.readDouble = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 8 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                var t8 = Shumway.IntegerUtilities.u8;
                if (this._littleEndian) {
                    t8[0] = u8[position + 0];
                    t8[1] = u8[position + 1];
                    t8[2] = u8[position + 2];
                    t8[3] = u8[position + 3];
                    t8[4] = u8[position + 4];
                    t8[5] = u8[position + 5];
                    t8[6] = u8[position + 6];
                    t8[7] = u8[position + 7];
                }
                else {
                    t8[0] = u8[position + 7];
                    t8[1] = u8[position + 6];
                    t8[2] = u8[position + 5];
                    t8[3] = u8[position + 4];
                    t8[4] = u8[position + 3];
                    t8[5] = u8[position + 2];
                    t8[6] = u8[position + 1];
                    t8[7] = u8[position + 0];
                }
                this._position = position + 8;
                return Shumway.IntegerUtilities.f64[0];
            };
            DataBuffer.prototype.writeBoolean = function (value) {
                this.writeByte(!!value ? 1 : 0);
            };
            DataBuffer.prototype.writeByte = function (value /*int*/) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._u8[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeUnsignedByte = function (value /*uint*/) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._u8[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeRawBytes = function (bytes) {
                var length = this._position + bytes.length;
                this._ensureCapacity(length);
                this._u8.set(bytes, this._position);
                this._position = length;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeBytes = function (bytes, offset /*uint*/, length /*uint*/) {
                if (Shumway.isNullOrUndefined(bytes)) {
                    release || assert(this.sec);
                    this.sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'bytes');
                }
                offset = offset >>> 0;
                length = length >>> 0;
                if (arguments.length < 2) {
                    offset = 0;
                }
                if (arguments.length < 3) {
                    length = 0;
                }
                if (offset !== clamp(offset, 0, bytes.length) ||
                    offset + length !== clamp(offset + length, 0, bytes.length)) {
                    release || assert(this.sec);
                    this.sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                }
                if (length === 0) {
                    length = bytes.length - offset;
                }
                this.writeRawBytes(new Int8Array(bytes._buffer, offset, length));
            };
            DataBuffer.prototype.writeShort = function (value /*int*/) {
                this.writeUnsignedShort(value);
            };
            DataBuffer.prototype.writeUnsignedShort = function (value /*uint*/) {
                var position = this._position;
                this._ensureCapacity(position + 2);
                var u8 = this._u8;
                if (this._littleEndian) {
                    u8[position + 0] = value;
                    u8[position + 1] = value >> 8;
                }
                else {
                    u8[position + 0] = value >> 8;
                    u8[position + 1] = value;
                }
                position += 2;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.writeInt = function (value /*int*/) {
                this.writeUnsignedInt(value);
            };
            DataBuffer.prototype.write2Ints = function (a, b) {
                this.write2UnsignedInts(a, b);
            };
            DataBuffer.prototype.write4Ints = function (a, b, c, d) {
                this.write4UnsignedInts(a, b, c, d);
            };
            DataBuffer.prototype.writeUnsignedInt = function (value /*uint*/) {
                var position = this._position;
                this._ensureCapacity(position + 4);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._i32) {
                    this._i32[position >> 2] = value;
                }
                else {
                    var u8 = this._u8;
                    if (this._littleEndian) {
                        u8[position + 0] = value;
                        u8[position + 1] = value >> 8;
                        u8[position + 2] = value >> 16;
                        u8[position + 3] = value >> 24;
                    }
                    else {
                        u8[position + 0] = value >> 24;
                        u8[position + 1] = value >> 16;
                        u8[position + 2] = value >> 8;
                        u8[position + 3] = value;
                    }
                }
                position += 4;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.write2UnsignedInts = function (a, b) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._i32) {
                    this._i32[(position >> 2) + 0] = a;
                    this._i32[(position >> 2) + 1] = b;
                    position += 8;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                }
                else {
                    this.writeUnsignedInt(a);
                    this.writeUnsignedInt(b);
                }
            };
            DataBuffer.prototype.write4UnsignedInts = function (a, b, c, d) {
                var position = this._position;
                this._ensureCapacity(position + 16);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._i32) {
                    this._i32[(position >> 2) + 0] = a;
                    this._i32[(position >> 2) + 1] = b;
                    this._i32[(position >> 2) + 2] = c;
                    this._i32[(position >> 2) + 3] = d;
                    position += 16;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                }
                else {
                    this.writeUnsignedInt(a);
                    this.writeUnsignedInt(b);
                    this.writeUnsignedInt(c);
                    this.writeUnsignedInt(d);
                }
            };
            DataBuffer.prototype.writeFloat = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 4);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._f32) {
                    this._f32[position >> 2] = value;
                }
                else {
                    var u8 = this._u8;
                    Shumway.IntegerUtilities.f32[0] = value;
                    var t8 = Shumway.IntegerUtilities.u8;
                    if (this._littleEndian) {
                        u8[position + 0] = t8[0];
                        u8[position + 1] = t8[1];
                        u8[position + 2] = t8[2];
                        u8[position + 3] = t8[3];
                    }
                    else {
                        u8[position + 0] = t8[3];
                        u8[position + 1] = t8[2];
                        u8[position + 2] = t8[1];
                        u8[position + 3] = t8[0];
                    }
                }
                position += 4;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.write2Floats = function (a, b) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._f32) {
                    this._f32[(position >> 2) + 0] = a;
                    this._f32[(position >> 2) + 1] = b;
                    position += 8;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                }
                else {
                    this.writeFloat(a);
                    this.writeFloat(b);
                }
            };
            DataBuffer.prototype.write6Floats = function (a, b, c, d, e, f) {
                var position = this._position;
                this._ensureCapacity(position + 24);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 0x3) === 0 && this._f32) {
                    this._f32[(position >> 2) + 0] = a;
                    this._f32[(position >> 2) + 1] = b;
                    this._f32[(position >> 2) + 2] = c;
                    this._f32[(position >> 2) + 3] = d;
                    this._f32[(position >> 2) + 4] = e;
                    this._f32[(position >> 2) + 5] = f;
                    position += 24;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                }
                else {
                    this.writeFloat(a);
                    this.writeFloat(b);
                    this.writeFloat(c);
                    this.writeFloat(d);
                    this.writeFloat(e);
                    this.writeFloat(f);
                }
            };
            DataBuffer.prototype.writeDouble = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                var u8 = this._u8;
                Shumway.IntegerUtilities.f64[0] = value;
                var t8 = Shumway.IntegerUtilities.u8;
                if (this._littleEndian) {
                    u8[position + 0] = t8[0];
                    u8[position + 1] = t8[1];
                    u8[position + 2] = t8[2];
                    u8[position + 3] = t8[3];
                    u8[position + 4] = t8[4];
                    u8[position + 5] = t8[5];
                    u8[position + 6] = t8[6];
                    u8[position + 7] = t8[7];
                }
                else {
                    u8[position + 0] = t8[7];
                    u8[position + 1] = t8[6];
                    u8[position + 2] = t8[5];
                    u8[position + 3] = t8[4];
                    u8[position + 4] = t8[3];
                    u8[position + 5] = t8[2];
                    u8[position + 6] = t8[1];
                    u8[position + 7] = t8[0];
                }
                position += 8;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.readRawBytes = function () {
                return new Int8Array(this._buffer, 0, this._length);
            };
            DataBuffer.prototype.writeUTF = function (value) {
                value = axCoerceString(value);
                var bytes = utf8decode(value);
                this.writeShort(bytes.length);
                this.writeRawBytes(bytes);
            };
            DataBuffer.prototype.writeUTFBytes = function (value) {
                value = axCoerceString(value);
                var bytes = utf8decode(value);
                this.writeRawBytes(bytes);
            };
            DataBuffer.prototype.readUTF = function () {
                return this.readUTFBytes(this.readShort());
            };
            DataBuffer.prototype.readUTFBytes = function (length /*uint*/) {
                length = length >>> 0;
                var pos = this._position;
                if (pos + length > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                }
                this._position += length;
                return utf8encode(new Int8Array(this._buffer, pos, length));
            };
            Object.defineProperty(DataBuffer.prototype, "length", {
                get: function () {
                    return this._length;
                },
                set: function (value /*uint*/) {
                    value = value >>> 0;
                    var capacity = this._buffer.byteLength;
                    /* XXX: Do we need to zero the difference if length <= cap? */
                    if (value > capacity) {
                        this._ensureCapacity(value);
                    }
                    this._length = value;
                    this._position = clamp(this._position, 0, this._length);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "bytesAvailable", {
                get: function () {
                    return this._length - this._position;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (position /*uint*/) {
                    this._position = position >>> 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "buffer", {
                get: function () {
                    return this._buffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "bytes", {
                get: function () {
                    return this._u8;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "ints", {
                get: function () {
                    this._requestViews(TypedArrayViewFlags.I32);
                    return this._i32;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "objectEncoding", {
                get: function () {
                    return this._objectEncoding;
                },
                set: function (version /*uint*/) {
                    version = version >>> 0;
                    this._objectEncoding = version;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, "endian", {
                get: function () {
                    return this._littleEndian ? "littleEndian" : "bigEndian";
                },
                set: function (type) {
                    type = axCoerceString(type);
                    if (type === "auto") {
                        this._littleEndian = DataBuffer._nativeLittleEndian;
                    }
                    else {
                        this._littleEndian = type === "littleEndian";
                    }
                },
                enumerable: true,
                configurable: true
            });
            DataBuffer.prototype.toString = function () {
                return utf8encode(new Int8Array(this._buffer, 0, this._length));
            };
            DataBuffer.prototype.toBlob = function (type) {
                return new Blob([new Int8Array(this._buffer, this._position, this._length)], { type: type });
            };
            DataBuffer.prototype.writeMultiByte = function (value, charSet) {
                value = axCoerceString(value);
                charSet = axCoerceString(charSet);
                release || release || notImplemented("packageInternal flash.utils.ObjectOutput::writeMultiByte");
                return;
            };
            DataBuffer.prototype.readMultiByte = function (length /*uint*/, charSet) {
                length = length >>> 0;
                charSet = axCoerceString(charSet);
                release || release || notImplemented("packageInternal flash.utils.ObjectInput::readMultiByte");
                return "";
            };
            DataBuffer.prototype.getValue = function (name) {
                name = name | 0;
                if (name >= this._length) {
                    return undefined;
                }
                return this._u8[name];
            };
            DataBuffer.prototype.setValue = function (name, value) {
                name = name | 0;
                var length = name + 1;
                this._ensureCapacity(length);
                this._u8[name] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.readFixed = function () {
                return this.readInt() / 65536;
            };
            DataBuffer.prototype.readFixed8 = function () {
                return this.readShort() / 256;
            };
            DataBuffer.prototype.readFloat16 = function () {
                var uint16 = this.readUnsignedShort();
                var sign = uint16 >> 15 ? -1 : 1;
                var exponent = (uint16 & 0x7c00) >> 10;
                var fraction = uint16 & 0x03ff;
                if (!exponent) {
                    return sign * Math.pow(2, -14) * (fraction / 1024);
                }
                if (exponent === 0x1f) {
                    return fraction ? NaN : sign * Infinity;
                }
                return sign * Math.pow(2, exponent - 15) * (1 + (fraction / 1024));
            };
            DataBuffer.prototype.readEncodedU32 = function () {
                var value = this.readUnsignedByte();
                if (!(value & 0x080)) {
                    return value;
                }
                value = (value & 0x7f) | this.readUnsignedByte() << 7;
                if (!(value & 0x4000)) {
                    return value;
                }
                value = (value & 0x3fff) | this.readUnsignedByte() << 14;
                if (!(value & 0x200000)) {
                    return value;
                }
                value = (value & 0x1FFFFF) | this.readUnsignedByte() << 21;
                if (!(value & 0x10000000)) {
                    return value;
                }
                return (value & 0xFFFFFFF) | (this.readUnsignedByte() << 28);
            };
            DataBuffer.prototype.readBits = function (size) {
                return (this.readUnsignedBits(size) << (32 - size)) >> (32 - size);
            };
            DataBuffer.prototype.readUnsignedBits = function (size) {
                var buffer = this._bitBuffer;
                var length = this._bitLength;
                while (size > length) {
                    buffer = (buffer << 8) | this.readUnsignedByte();
                    length += 8;
                }
                length -= size;
                var value = (buffer >>> length) & bitMasks[size];
                this._bitBuffer = buffer;
                this._bitLength = length;
                return value;
            };
            DataBuffer.prototype.readFixedBits = function (size) {
                return this.readBits(size) / 65536;
            };
            DataBuffer.prototype.readString = function (length) {
                var position = this._position;
                if (length) {
                    if (position + length > this._length) {
                        release || assert(this.sec);
                        this.sec.throwError('flash.errors.EOFError', Shumway.Errors.EOFError);
                    }
                    this._position += length;
                }
                else {
                    length = 0;
                    for (var i = position; i < this._length && this._u8[i]; i++) {
                        length++;
                    }
                    this._position += length + 1;
                }
                return utf8encode(new Int8Array(this._buffer, position, length));
            };
            DataBuffer.prototype.align = function () {
                this._bitBuffer = 0;
                this._bitLength = 0;
            };
            DataBuffer.prototype.deflate = function () {
                this.compress('deflate');
            };
            DataBuffer.prototype.inflate = function () {
                this.uncompress('deflate');
            };
            DataBuffer.prototype.compress = function (algorithm) {
                if (arguments.length === 0) {
                    algorithm = 'zlib';
                }
                else {
                    algorithm = axCoerceString(algorithm);
                }
                var deflate;
                switch (algorithm) {
                    case 'zlib':
                        deflate = new ArrayUtilities.Deflate(true);
                        break;
                    case 'deflate':
                        deflate = new ArrayUtilities.Deflate(false);
                        break;
                    default:
                        return;
                }
                var output = new DataBuffer();
                deflate.onData = output.writeRawBytes.bind(output);
                deflate.push(this._u8.subarray(0, this._length));
                deflate.close();
                this._ensureCapacity(output._u8.length);
                this._u8.set(output._u8);
                this.length = output.length;
                this._position = 0;
            };
            DataBuffer.prototype.uncompress = function (algorithm) {
                if (arguments.length === 0) {
                    algorithm = 'zlib';
                }
                else {
                    algorithm = axCoerceString(algorithm);
                }
                var inflate;
                switch (algorithm) {
                    case 'zlib':
                        inflate = ArrayUtilities.Inflate.create(true);
                        break;
                    case 'deflate':
                        inflate = ArrayUtilities.Inflate.create(false);
                        break;
                    case 'lzma':
                        inflate = new ArrayUtilities.LzmaDecoder(false);
                        break;
                    default:
                        return;
                }
                var output = new DataBuffer();
                var error;
                inflate.onData = output.writeRawBytes.bind(output);
                inflate.onError = function (e) { return error = e; };
                inflate.push(this._u8.subarray(0, this._length));
                if (error) {
                    release || assert(this.sec);
                    this.sec.throwError('IOError', Shumway.Errors.CompressedDataError);
                }
                inflate.close();
                this._ensureCapacity(output._u8.length);
                this._u8.set(output._u8);
                this.length = output.length;
                this._position = 0;
            };
            DataBuffer._nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
            /* The initial size of the backing, in bytes. Doubled every OOM. */
            DataBuffer.INITIAL_SIZE = 128;
            DataBuffer._arrayBufferPool = new Shumway.ArrayBufferPool();
            return DataBuffer;
        }());
        ArrayUtilities.DataBuffer = DataBuffer;
    })(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Serialization format for shape data:
 * (canonical, update this instead of anything else!)
 *
 * Shape data is serialized into a set of three buffers:
 * - `commands`: a Uint8Array for commands
 *  - valid values: [1-11] (i.e. one of the PathCommand enum values)
 * - `coordinates`: an Int32Array for path coordinates*
 *                  OR uint8 thickness iff the current command is PathCommand.LineStyleSolid
 *  - valid values: the full range of 32bit numbers, representing x,y coordinates in twips
 * - `styles`: a DataBuffer for style definitions
 *  - valid values: structs for the various style definitions as described below
 *
 * (*: with one exception: to make various things faster, stroke widths are stored in the
 * coordinates buffer, too.)
 *
 * All entries always contain all fields, default values aren't omitted.
 *
 * the various commands write the following sets of values into the various buffers:
 *
 * moveTo:
 * commands:      PathCommand.MoveTo
 * coordinates:   target x coordinate, in twips
 *                target y coordinate, in twips
 * styles:        n/a
 *
 * lineTo:
 * commands:      PathCommand.LineTo
 * coordinates:   target x coordinate, in twips
 *                target y coordinate, in twips
 * styles:        n/a
 *
 * curveTo:
 * commands:      PathCommand.CurveTo
 * coordinates:   control point x coordinate, in twips
 *                control point y coordinate, in twips
 *                target x coordinate, in twips
 *                target y coordinate, in twips
 * styles:        n/a
 *
 * cubicCurveTo:
 * commands:      PathCommand.CubicCurveTo
 * coordinates:   control point 1 x coordinate, in twips
 *                control point 1 y coordinate, in twips
 *                control point 2 x coordinate, in twips
 *                control point 2 y coordinate, in twips
 *                target x coordinate, in twips
 *                target y coordinate, in twips
 * styles:        n/a
 *
 * beginFill:
 * commands:      PathCommand.BeginSolidFill
 * coordinates:   n/a
 * styles:        uint32 - RGBA color
 *
 * beginGradientFill:
 * commands:      PathCommand.BeginGradientFill
 * coordinates:   n/a
 * Note: the style fields are ordered this way to optimize performance in the rendering backend
 * Note: the style record has a variable length depending on the number of color stops
 * styles:        uint8  - GradientType.{LINEAR,RADIAL}
 *                fix8   - focalPoint [-128.0xff,127.0xff]
 *                matrix - transform (see Matrix#writeExternal for details)
 *                uint8  - colorStops (Number of color stop records that follow)
 *                list of uint8,uint32 pairs:
 *                    uint8  - ratio [0-0xff]
 *                    uint32 - RGBA color
 *                uint8  - SpreadMethod.{PAD,REFLECT,REPEAT}
 *                uint8  - InterpolationMethod.{RGB,LINEAR_RGB}
 *
 * beginBitmapFill:
 * commands:      PathCommand.BeginBitmapFill
 * coordinates:   n/a
 * styles:        uint32 - Index of the bitmapData object in the Graphics object's `textures`
 *                         array
 *                matrix - transform (see Matrix#writeExternal for details)
 *                bool   - repeat
 *                bool   - smooth
 *
 * lineStyle:
 * commands:      PathCommand.LineStyleSolid
 * coordinates:   uint32 - thickness (!)
 * style:         uint32 - RGBA color
 *                bool   - pixelHinting
 *                uint8  - LineScaleMode, [0-3] see LineScaleMode.fromNumber for meaning
 *                uint8  - CapsStyle, [0-2] see CapsStyle.fromNumber for meaning
 *                uint8  - JointStyle, [0-2] see JointStyle.fromNumber for meaning
 *                uint8  - miterLimit
 *
 * lineGradientStyle:
 * commands:      PathCommand.LineStyleGradient
 * coordinates:   n/a
 * Note: the style fields are ordered this way to optimize performance in the rendering backend
 * Note: the style record has a variable length depending on the number of color stops
 * styles:        uint8  - GradientType.{LINEAR,RADIAL}
 *                int8   - focalPoint [-128,127]
 *                matrix - transform (see Matrix#writeExternal for details)
 *                uint8  - colorStops (Number of color stop records that follow)
 *                list of uint8,uint32 pairs:
 *                    uint8  - ratio [0-0xff]
 *                    uint32 - RGBA color
 *                uint8  - SpreadMethod.{PAD,REFLECT,REPEAT}
 *                uint8  - InterpolationMethod.{RGB,LINEAR_RGB}
 *
 * lineBitmapStyle:
 * commands:      PathCommand.LineBitmapStyle
 * coordinates:   n/a
 * styles:        uint32 - Index of the bitmapData object in the Graphics object's `textures`
 *                         array
 *                matrix - transform (see Matrix#writeExternal for details)
 *                bool   - repeat
 *                bool   - smooth
 *
 * lineEnd:
 * Note: emitted for invalid `lineStyle` calls
 * commands:      PathCommand.LineEnd
 * coordinates:   n/a
 * styles:        n/a
 *
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ensureTypedArrayCapacity = Shumway.ArrayUtilities.ensureTypedArrayCapacity;
    var assert = Shumway.Debug.assert;
    /**
     * Used for (de-)serializing Graphics path data in defineShape, flash.display.Graphics
     * and the renderer.
     */
    var PathCommand;
    (function (PathCommand) {
        PathCommand[PathCommand["BeginSolidFill"] = 1] = "BeginSolidFill";
        PathCommand[PathCommand["BeginGradientFill"] = 2] = "BeginGradientFill";
        PathCommand[PathCommand["BeginBitmapFill"] = 3] = "BeginBitmapFill";
        PathCommand[PathCommand["EndFill"] = 4] = "EndFill";
        PathCommand[PathCommand["LineStyleSolid"] = 5] = "LineStyleSolid";
        PathCommand[PathCommand["LineStyleGradient"] = 6] = "LineStyleGradient";
        PathCommand[PathCommand["LineStyleBitmap"] = 7] = "LineStyleBitmap";
        PathCommand[PathCommand["LineEnd"] = 8] = "LineEnd";
        PathCommand[PathCommand["MoveTo"] = 9] = "MoveTo";
        PathCommand[PathCommand["LineTo"] = 10] = "LineTo";
        PathCommand[PathCommand["CurveTo"] = 11] = "CurveTo";
        PathCommand[PathCommand["CubicCurveTo"] = 12] = "CubicCurveTo";
    })(PathCommand = Shumway.PathCommand || (Shumway.PathCommand = {}));
    var GradientType;
    (function (GradientType) {
        GradientType[GradientType["Linear"] = 16] = "Linear";
        GradientType[GradientType["Radial"] = 18] = "Radial";
    })(GradientType = Shumway.GradientType || (Shumway.GradientType = {}));
    var GradientSpreadMethod;
    (function (GradientSpreadMethod) {
        GradientSpreadMethod[GradientSpreadMethod["Pad"] = 0] = "Pad";
        GradientSpreadMethod[GradientSpreadMethod["Reflect"] = 1] = "Reflect";
        GradientSpreadMethod[GradientSpreadMethod["Repeat"] = 2] = "Repeat";
    })(GradientSpreadMethod = Shumway.GradientSpreadMethod || (Shumway.GradientSpreadMethod = {}));
    var GradientInterpolationMethod;
    (function (GradientInterpolationMethod) {
        GradientInterpolationMethod[GradientInterpolationMethod["RGB"] = 0] = "RGB";
        GradientInterpolationMethod[GradientInterpolationMethod["LinearRGB"] = 1] = "LinearRGB";
    })(GradientInterpolationMethod = Shumway.GradientInterpolationMethod || (Shumway.GradientInterpolationMethod = {}));
    var LineScaleMode;
    (function (LineScaleMode) {
        LineScaleMode[LineScaleMode["None"] = 0] = "None";
        LineScaleMode[LineScaleMode["Normal"] = 1] = "Normal";
        LineScaleMode[LineScaleMode["Vertical"] = 2] = "Vertical";
        LineScaleMode[LineScaleMode["Horizontal"] = 3] = "Horizontal";
    })(LineScaleMode = Shumway.LineScaleMode || (Shumway.LineScaleMode = {}));
    var PlainObjectShapeData = /** @class */ (function () {
        function PlainObjectShapeData(commands, commandsPosition, coordinates, morphCoordinates, coordinatesPosition, styles, stylesLength, morphStyles, morphStylesLength, hasFills, hasLines) {
            this.commands = commands;
            this.commandsPosition = commandsPosition;
            this.coordinates = coordinates;
            this.morphCoordinates = morphCoordinates;
            this.coordinatesPosition = coordinatesPosition;
            this.styles = styles;
            this.stylesLength = stylesLength;
            this.morphStyles = morphStyles;
            this.morphStylesLength = morphStylesLength;
            this.hasFills = hasFills;
            this.hasLines = hasLines;
        }
        return PlainObjectShapeData;
    }());
    Shumway.PlainObjectShapeData = PlainObjectShapeData;
    var DefaultSize;
    (function (DefaultSize) {
        DefaultSize[DefaultSize["Commands"] = 32] = "Commands";
        DefaultSize[DefaultSize["Coordinates"] = 128] = "Coordinates";
        DefaultSize[DefaultSize["Styles"] = 16] = "Styles";
    })(DefaultSize || (DefaultSize = {}));
    var ShapeData = /** @class */ (function () {
        function ShapeData(initialize) {
            if (initialize === void 0) { initialize = true; }
            if (initialize) {
                this.clear();
            }
        }
        ShapeData.FromPlainObject = function (source) {
            var data = new ShapeData(false);
            data.commands = source.commands;
            data.coordinates = source.coordinates;
            data.morphCoordinates = source.morphCoordinates;
            data.commandsPosition = source.commandsPosition;
            data.coordinatesPosition = source.coordinatesPosition;
            data.styles = DataBuffer.FromArrayBuffer(source.styles, source.stylesLength);
            data.styles.endian = 'auto';
            if (source.morphStyles) {
                data.morphStyles = DataBuffer.FromArrayBuffer(source.morphStyles, source.morphStylesLength);
                data.morphStyles.endian = 'auto';
            }
            data.hasFills = source.hasFills;
            data.hasLines = source.hasLines;
            return data;
        };
        ShapeData.prototype.moveTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 9 /* MoveTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.lineTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 10 /* LineTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
            this.ensurePathCapacities(1, 4);
            this.commands[this.commandsPosition++] = 11 /* CurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX;
            this.coordinates[this.coordinatesPosition++] = controlY;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };
        ShapeData.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            this.ensurePathCapacities(1, 6);
            this.commands[this.commandsPosition++] = 12 /* CubicCurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX1;
            this.coordinates[this.coordinatesPosition++] = controlY1;
            this.coordinates[this.coordinatesPosition++] = controlX2;
            this.coordinates[this.coordinatesPosition++] = controlY2;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };
        ShapeData.prototype.beginFill = function (color) {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 1 /* BeginSolidFill */;
            this.styles.writeUnsignedInt(color);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphFill = function (color) {
            this.morphStyles.writeUnsignedInt(color);
        };
        ShapeData.prototype.endFill = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 4 /* EndFill */;
        };
        ShapeData.prototype.endLine = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 8 /* LineEnd */;
        };
        ShapeData.prototype.lineStyle = function (thickness, color, pixelHinting, scaleMode, caps, joints, miterLimit) {
            release || assert(thickness === (thickness | 0), thickness >= 0 && thickness <= 0xff * 20);
            this.ensurePathCapacities(2, 0);
            this.commands[this.commandsPosition++] = 5 /* LineStyleSolid */;
            this.coordinates[this.coordinatesPosition++] = thickness;
            var styles = this.styles;
            styles.writeUnsignedInt(color);
            styles.writeBoolean(pixelHinting);
            styles.writeUnsignedByte(scaleMode);
            styles.writeUnsignedByte(caps);
            styles.writeUnsignedByte(joints);
            styles.writeUnsignedByte(miterLimit);
            this.hasLines = true;
        };
        ShapeData.prototype.writeMorphLineStyle = function (thickness, color) {
            this.morphCoordinates[this.coordinatesPosition - 1] = thickness;
            this.morphStyles.writeUnsignedInt(color);
        };
        /**
         * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
         * be one of BeginBitmapFill and LineStyleBitmap.
         */
        ShapeData.prototype.beginBitmap = function (pathCommand, bitmapId, matrix, repeat, smooth) {
            release || assert(pathCommand === 3 /* BeginBitmapFill */ ||
                pathCommand === 7 /* LineStyleBitmap */);
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedInt(bitmapId);
            this._writeStyleMatrix(matrix, false);
            styles.writeBoolean(repeat);
            styles.writeBoolean(smooth);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphBitmap = function (matrix) {
            this._writeStyleMatrix(matrix, true);
        };
        /**
         * Gradients are specified the same for fills and strokes, so we only need to serialize them
         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
         * be one of BeginGradientFill and LineStyleGradient.
         */
        ShapeData.prototype.beginGradient = function (pathCommand, colors, ratios, gradientType, matrix, spread, interpolation, focalPointRatio) {
            release || assert(pathCommand === 2 /* BeginGradientFill */ ||
                pathCommand === 6 /* LineStyleGradient */);
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedByte(gradientType);
            release || assert(focalPointRatio === (focalPointRatio | 0));
            styles.writeShort(focalPointRatio);
            this._writeStyleMatrix(matrix, false);
            var colorStops = colors.length;
            styles.writeByte(colorStops);
            for (var i = 0; i < colorStops; i++) {
                // Ratio must be valid, otherwise we'd have bailed above.
                styles.writeUnsignedByte(ratios[i]);
                // Colors are coerced to uint32, with the highest byte stripped.
                styles.writeUnsignedInt(colors[i]);
            }
            styles.writeUnsignedByte(spread);
            styles.writeUnsignedByte(interpolation);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphGradient = function (colors, ratios, matrix) {
            this._writeStyleMatrix(matrix, true);
            var styles = this.morphStyles;
            for (var i = 0; i < colors.length; i++) {
                // Ratio must be valid, otherwise we'd have bailed above.
                styles.writeUnsignedByte(ratios[i]);
                // Colors are coerced to uint32, with the highest byte stripped.
                styles.writeUnsignedInt(colors[i]);
            }
        };
        ShapeData.prototype.writeCommandAndCoordinates = function (command, x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = command;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.writeCoordinates = function (x, y) {
            this.ensurePathCapacities(0, 2);
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.writeMorphCoordinates = function (x, y) {
            this.morphCoordinates = ensureTypedArrayCapacity(this.morphCoordinates, this.coordinatesPosition);
            this.morphCoordinates[this.coordinatesPosition - 2] = x;
            this.morphCoordinates[this.coordinatesPosition - 1] = y;
        };
        ShapeData.prototype.clear = function () {
            this.commandsPosition = this.coordinatesPosition = 0;
            this.commands = new Uint8Array(DefaultSize.Commands);
            this.coordinates = new Int32Array(DefaultSize.Coordinates);
            this.styles = new DataBuffer(DefaultSize.Styles);
            this.styles.endian = 'auto';
            this.hasFills = this.hasLines = false;
        };
        ShapeData.prototype.isEmpty = function () {
            return this.commandsPosition === 0;
        };
        ShapeData.prototype.clone = function () {
            var copy = new ShapeData(false);
            copy.commands = new Uint8Array(this.commands);
            copy.commandsPosition = this.commandsPosition;
            copy.coordinates = new Int32Array(this.coordinates);
            copy.coordinatesPosition = this.coordinatesPosition;
            copy.styles = new DataBuffer(this.styles.length);
            copy.styles.writeRawBytes(this.styles.bytes.subarray(0, this.styles.length));
            if (this.morphStyles) {
                copy.morphStyles = new DataBuffer(this.morphStyles.length);
                copy.morphStyles.writeRawBytes(this.morphStyles.bytes.subarray(0, this.morphStyles.length));
            }
            copy.hasFills = this.hasFills;
            copy.hasLines = this.hasLines;
            return copy;
        };
        ShapeData.prototype.toPlainObject = function () {
            return new PlainObjectShapeData(this.commands, this.commandsPosition, this.coordinates, this.morphCoordinates, this.coordinatesPosition, this.styles.buffer, this.styles.length, this.morphStyles && this.morphStyles.buffer, this.morphStyles ? this.morphStyles.length : 0, this.hasFills, this.hasLines);
        };
        Object.defineProperty(ShapeData.prototype, "buffers", {
            get: function () {
                var buffers = [this.commands.buffer, this.coordinates.buffer, this.styles.buffer];
                if (this.morphCoordinates) {
                    buffers.push(this.morphCoordinates.buffer);
                }
                if (this.morphStyles) {
                    buffers.push(this.morphStyles.buffer);
                }
                return buffers;
            },
            enumerable: true,
            configurable: true
        });
        ShapeData.prototype._writeStyleMatrix = function (matrix, isMorph) {
            var styles = isMorph ? this.morphStyles : this.styles;
            styles.write6Floats(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        };
        ShapeData.prototype.ensurePathCapacities = function (numCommands, numCoordinates) {
            // ensureTypedArrayCapacity will hopefully be inlined, in which case the field writes
            // will be optimized out.
            this.commands = ensureTypedArrayCapacity(this.commands, this.commandsPosition + numCommands);
            this.coordinates = ensureTypedArrayCapacity(this.coordinates, this.coordinatesPosition + numCoordinates);
        };
        return ShapeData;
    }());
    Shumway.ShapeData = ShapeData;
})(Shumway || (Shumway = {}));
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var SwfTagCode;
            (function (SwfTagCode) {
                SwfTagCode[SwfTagCode["CODE_END"] = 0] = "CODE_END";
                SwfTagCode[SwfTagCode["CODE_SHOW_FRAME"] = 1] = "CODE_SHOW_FRAME";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SHAPE"] = 2] = "CODE_DEFINE_SHAPE";
                SwfTagCode[SwfTagCode["CODE_FREE_CHARACTER"] = 3] = "CODE_FREE_CHARACTER";
                SwfTagCode[SwfTagCode["CODE_PLACE_OBJECT"] = 4] = "CODE_PLACE_OBJECT";
                SwfTagCode[SwfTagCode["CODE_REMOVE_OBJECT"] = 5] = "CODE_REMOVE_OBJECT";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS"] = 6] = "CODE_DEFINE_BITS";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BUTTON"] = 7] = "CODE_DEFINE_BUTTON";
                SwfTagCode[SwfTagCode["CODE_JPEG_TABLES"] = 8] = "CODE_JPEG_TABLES";
                SwfTagCode[SwfTagCode["CODE_SET_BACKGROUND_COLOR"] = 9] = "CODE_SET_BACKGROUND_COLOR";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT"] = 10] = "CODE_DEFINE_FONT";
                SwfTagCode[SwfTagCode["CODE_DEFINE_TEXT"] = 11] = "CODE_DEFINE_TEXT";
                SwfTagCode[SwfTagCode["CODE_DO_ACTION"] = 12] = "CODE_DO_ACTION";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT_INFO"] = 13] = "CODE_DEFINE_FONT_INFO";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SOUND"] = 14] = "CODE_DEFINE_SOUND";
                SwfTagCode[SwfTagCode["CODE_START_SOUND"] = 15] = "CODE_START_SOUND";
                SwfTagCode[SwfTagCode["CODE_STOP_SOUND"] = 16] = "CODE_STOP_SOUND";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BUTTON_SOUND"] = 17] = "CODE_DEFINE_BUTTON_SOUND";
                SwfTagCode[SwfTagCode["CODE_SOUND_STREAM_HEAD"] = 18] = "CODE_SOUND_STREAM_HEAD";
                SwfTagCode[SwfTagCode["CODE_SOUND_STREAM_BLOCK"] = 19] = "CODE_SOUND_STREAM_BLOCK";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS_LOSSLESS"] = 20] = "CODE_DEFINE_BITS_LOSSLESS";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS_JPEG2"] = 21] = "CODE_DEFINE_BITS_JPEG2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SHAPE2"] = 22] = "CODE_DEFINE_SHAPE2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BUTTON_CXFORM"] = 23] = "CODE_DEFINE_BUTTON_CXFORM";
                SwfTagCode[SwfTagCode["CODE_PROTECT"] = 24] = "CODE_PROTECT";
                SwfTagCode[SwfTagCode["CODE_PATHS_ARE_POSTSCRIPT"] = 25] = "CODE_PATHS_ARE_POSTSCRIPT";
                SwfTagCode[SwfTagCode["CODE_PLACE_OBJECT2"] = 26] = "CODE_PLACE_OBJECT2";
                // INVALID                             = 27,
                SwfTagCode[SwfTagCode["CODE_REMOVE_OBJECT2"] = 28] = "CODE_REMOVE_OBJECT2";
                SwfTagCode[SwfTagCode["CODE_SYNC_FRAME"] = 29] = "CODE_SYNC_FRAME";
                // INVALID                             = 30,
                SwfTagCode[SwfTagCode["CODE_FREE_ALL"] = 31] = "CODE_FREE_ALL";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SHAPE3"] = 32] = "CODE_DEFINE_SHAPE3";
                SwfTagCode[SwfTagCode["CODE_DEFINE_TEXT2"] = 33] = "CODE_DEFINE_TEXT2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BUTTON2"] = 34] = "CODE_DEFINE_BUTTON2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS_JPEG3"] = 35] = "CODE_DEFINE_BITS_JPEG3";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS_LOSSLESS2"] = 36] = "CODE_DEFINE_BITS_LOSSLESS2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_EDIT_TEXT"] = 37] = "CODE_DEFINE_EDIT_TEXT";
                SwfTagCode[SwfTagCode["CODE_DEFINE_VIDEO"] = 38] = "CODE_DEFINE_VIDEO";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SPRITE"] = 39] = "CODE_DEFINE_SPRITE";
                SwfTagCode[SwfTagCode["CODE_NAME_CHARACTER"] = 40] = "CODE_NAME_CHARACTER";
                SwfTagCode[SwfTagCode["CODE_PRODUCT_INFO"] = 41] = "CODE_PRODUCT_INFO";
                SwfTagCode[SwfTagCode["CODE_DEFINE_TEXT_FORMAT"] = 42] = "CODE_DEFINE_TEXT_FORMAT";
                SwfTagCode[SwfTagCode["CODE_FRAME_LABEL"] = 43] = "CODE_FRAME_LABEL";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BEHAVIOUR"] = 44] = "CODE_DEFINE_BEHAVIOUR";
                SwfTagCode[SwfTagCode["CODE_SOUND_STREAM_HEAD2"] = 45] = "CODE_SOUND_STREAM_HEAD2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_MORPH_SHAPE"] = 46] = "CODE_DEFINE_MORPH_SHAPE";
                SwfTagCode[SwfTagCode["CODE_GENERATE_FRAME"] = 47] = "CODE_GENERATE_FRAME";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT2"] = 48] = "CODE_DEFINE_FONT2";
                SwfTagCode[SwfTagCode["CODE_GEN_COMMAND"] = 49] = "CODE_GEN_COMMAND";
                SwfTagCode[SwfTagCode["CODE_DEFINE_COMMAND_OBJECT"] = 50] = "CODE_DEFINE_COMMAND_OBJECT";
                SwfTagCode[SwfTagCode["CODE_CHARACTER_SET"] = 51] = "CODE_CHARACTER_SET";
                SwfTagCode[SwfTagCode["CODE_EXTERNAL_FONT"] = 52] = "CODE_EXTERNAL_FONT";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FUNCTION"] = 53] = "CODE_DEFINE_FUNCTION";
                SwfTagCode[SwfTagCode["CODE_PLACE_FUNCTION"] = 54] = "CODE_PLACE_FUNCTION";
                SwfTagCode[SwfTagCode["CODE_GEN_TAG_OBJECTS"] = 55] = "CODE_GEN_TAG_OBJECTS";
                SwfTagCode[SwfTagCode["CODE_EXPORT_ASSETS"] = 56] = "CODE_EXPORT_ASSETS";
                SwfTagCode[SwfTagCode["CODE_IMPORT_ASSETS"] = 57] = "CODE_IMPORT_ASSETS";
                SwfTagCode[SwfTagCode["CODE_ENABLE_DEBUGGER"] = 58] = "CODE_ENABLE_DEBUGGER";
                SwfTagCode[SwfTagCode["CODE_DO_INIT_ACTION"] = 59] = "CODE_DO_INIT_ACTION";
                SwfTagCode[SwfTagCode["CODE_DEFINE_VIDEO_STREAM"] = 60] = "CODE_DEFINE_VIDEO_STREAM";
                SwfTagCode[SwfTagCode["CODE_VIDEO_FRAME"] = 61] = "CODE_VIDEO_FRAME";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT_INFO2"] = 62] = "CODE_DEFINE_FONT_INFO2";
                SwfTagCode[SwfTagCode["CODE_DEBUG_ID"] = 63] = "CODE_DEBUG_ID";
                SwfTagCode[SwfTagCode["CODE_ENABLE_DEBUGGER2"] = 64] = "CODE_ENABLE_DEBUGGER2";
                SwfTagCode[SwfTagCode["CODE_SCRIPT_LIMITS"] = 65] = "CODE_SCRIPT_LIMITS";
                SwfTagCode[SwfTagCode["CODE_SET_TAB_INDEX"] = 66] = "CODE_SET_TAB_INDEX";
                // CODE_DEFINE_SHAPE4                  = 67,
                // INVALID                             = 68,
                SwfTagCode[SwfTagCode["CODE_FILE_ATTRIBUTES"] = 69] = "CODE_FILE_ATTRIBUTES";
                SwfTagCode[SwfTagCode["CODE_PLACE_OBJECT3"] = 70] = "CODE_PLACE_OBJECT3";
                SwfTagCode[SwfTagCode["CODE_IMPORT_ASSETS2"] = 71] = "CODE_IMPORT_ASSETS2";
                SwfTagCode[SwfTagCode["CODE_DO_ABC_DEFINE"] = 72] = "CODE_DO_ABC_DEFINE";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT_ALIGN_ZONES"] = 73] = "CODE_DEFINE_FONT_ALIGN_ZONES";
                SwfTagCode[SwfTagCode["CODE_CSM_TEXT_SETTINGS"] = 74] = "CODE_CSM_TEXT_SETTINGS";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT3"] = 75] = "CODE_DEFINE_FONT3";
                SwfTagCode[SwfTagCode["CODE_SYMBOL_CLASS"] = 76] = "CODE_SYMBOL_CLASS";
                SwfTagCode[SwfTagCode["CODE_METADATA"] = 77] = "CODE_METADATA";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SCALING_GRID"] = 78] = "CODE_DEFINE_SCALING_GRID";
                // INVALID                             = 79,
                // INVALID                             = 80,
                // INVALID                             = 81,
                SwfTagCode[SwfTagCode["CODE_DO_ABC"] = 82] = "CODE_DO_ABC";
                SwfTagCode[SwfTagCode["CODE_DEFINE_SHAPE4"] = 83] = "CODE_DEFINE_SHAPE4";
                SwfTagCode[SwfTagCode["CODE_DEFINE_MORPH_SHAPE2"] = 84] = "CODE_DEFINE_MORPH_SHAPE2";
                // INVALID                             = 85,
                SwfTagCode[SwfTagCode["CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA"] = 86] = "CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BINARY_DATA"] = 87] = "CODE_DEFINE_BINARY_DATA";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT_NAME"] = 88] = "CODE_DEFINE_FONT_NAME";
                SwfTagCode[SwfTagCode["CODE_START_SOUND2"] = 89] = "CODE_START_SOUND2";
                SwfTagCode[SwfTagCode["CODE_DEFINE_BITS_JPEG4"] = 90] = "CODE_DEFINE_BITS_JPEG4";
                SwfTagCode[SwfTagCode["CODE_DEFINE_FONT4"] = 91] = "CODE_DEFINE_FONT4";
                SwfTagCode[SwfTagCode["CODE_TELEMETRY"] = 93] = "CODE_TELEMETRY";
            })(SwfTagCode = Parser.SwfTagCode || (Parser.SwfTagCode = {}));
            var SwfTagCodeNames = ["CODE_END", "CODE_SHOW_FRAME", "CODE_DEFINE_SHAPE", "CODE_FREE_CHARACTER", "CODE_PLACE_OBJECT", "CODE_REMOVE_OBJECT", "CODE_DEFINE_BITS", "CODE_DEFINE_BUTTON", "CODE_JPEG_TABLES", "CODE_SET_BACKGROUND_COLOR", "CODE_DEFINE_FONT", "CODE_DEFINE_TEXT", "CODE_DO_ACTION", "CODE_DEFINE_FONT_INFO", "CODE_DEFINE_SOUND", "CODE_START_SOUND", "CODE_STOP_SOUND", "CODE_DEFINE_BUTTON_SOUND", "CODE_SOUND_STREAM_HEAD", "CODE_SOUND_STREAM_BLOCK", "CODE_DEFINE_BITS_LOSSLESS", "CODE_DEFINE_BITS_JPEG2", "CODE_DEFINE_SHAPE2", "CODE_DEFINE_BUTTON_CXFORM", "CODE_PROTECT", "CODE_PATHS_ARE_POSTSCRIPT", "CODE_PLACE_OBJECT2", "INVALID", "CODE_REMOVE_OBJECT2", "CODE_SYNC_FRAME", "INVALID", "CODE_FREE_ALL", "CODE_DEFINE_SHAPE3", "CODE_DEFINE_TEXT2", "CODE_DEFINE_BUTTON2", "CODE_DEFINE_BITS_JPEG3", "CODE_DEFINE_BITS_LOSSLESS2", "CODE_DEFINE_EDIT_TEXT", "CODE_DEFINE_VIDEO", "CODE_DEFINE_SPRITE", "CODE_NAME_CHARACTER", "CODE_PRODUCT_INFO", "CODE_DEFINE_TEXT_FORMAT", "CODE_FRAME_LABEL", "CODE_DEFINE_BEHAVIOUR", "CODE_SOUND_STREAM_HEAD2", "CODE_DEFINE_MORPH_SHAPE", "CODE_GENERATE_FRAME", "CODE_DEFINE_FONT2", "CODE_GEN_COMMAND", "CODE_DEFINE_COMMAND_OBJECT", "CODE_CHARACTER_SET", "CODE_EXTERNAL_FONT", "CODE_DEFINE_FUNCTION", "CODE_PLACE_FUNCTION", "CODE_GEN_TAG_OBJECTS", "CODE_EXPORT_ASSETS", "CODE_IMPORT_ASSETS", "CODE_ENABLE_DEBUGGER", "CODE_DO_INIT_ACTION", "CODE_DEFINE_VIDEO_STREAM", "CODE_VIDEO_FRAME", "CODE_DEFINE_FONT_INFO2", "CODE_DEBUG_ID", "CODE_ENABLE_DEBUGGER2", "CODE_SCRIPT_LIMITS", "CODE_SET_TAB_INDEX", "CODE_DEFINE_SHAPE4", "INVALID", "CODE_FILE_ATTRIBUTES", "CODE_PLACE_OBJECT3", "CODE_IMPORT_ASSETS2", "CODE_DO_ABC_DEFINE", "CODE_DEFINE_FONT_ALIGN_ZONES", "CODE_CSM_TEXT_SETTINGS", "CODE_DEFINE_FONT3", "CODE_SYMBOL_CLASS", "CODE_METADATA", "CODE_DEFINE_SCALING_GRID", "INVALID", "INVALID", "INVALID", "CODE_DO_ABC", "CODE_DEFINE_SHAPE4", "CODE_DEFINE_MORPH_SHAPE2", "INVALID", "CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA", "CODE_DEFINE_BINARY_DATA", "CODE_DEFINE_FONT_NAME", "CODE_START_SOUND2", "CODE_DEFINE_BITS_JPEG4", "CODE_DEFINE_FONT4", "CODE_TELEMETRY"];
            function getSwfTagCodeName(tagCode) {
                return release ? "SwfTagCode: " + tagCode : SwfTagCodeNames[tagCode];
            }
            Parser.getSwfTagCodeName = getSwfTagCodeName;
            var DefinitionTags;
            (function (DefinitionTags) {
                DefinitionTags[DefinitionTags["CODE_DEFINE_SHAPE"] = 2] = "CODE_DEFINE_SHAPE";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS"] = 6] = "CODE_DEFINE_BITS";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BUTTON"] = 7] = "CODE_DEFINE_BUTTON";
                DefinitionTags[DefinitionTags["CODE_DEFINE_FONT"] = 10] = "CODE_DEFINE_FONT";
                DefinitionTags[DefinitionTags["CODE_DEFINE_TEXT"] = 11] = "CODE_DEFINE_TEXT";
                DefinitionTags[DefinitionTags["CODE_DEFINE_SOUND"] = 14] = "CODE_DEFINE_SOUND";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS_LOSSLESS"] = 20] = "CODE_DEFINE_BITS_LOSSLESS";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS_JPEG2"] = 21] = "CODE_DEFINE_BITS_JPEG2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_SHAPE2"] = 22] = "CODE_DEFINE_SHAPE2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_SHAPE3"] = 32] = "CODE_DEFINE_SHAPE3";
                DefinitionTags[DefinitionTags["CODE_DEFINE_TEXT2"] = 33] = "CODE_DEFINE_TEXT2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BUTTON2"] = 34] = "CODE_DEFINE_BUTTON2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS_JPEG3"] = 35] = "CODE_DEFINE_BITS_JPEG3";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS_LOSSLESS2"] = 36] = "CODE_DEFINE_BITS_LOSSLESS2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_EDIT_TEXT"] = 37] = "CODE_DEFINE_EDIT_TEXT";
                DefinitionTags[DefinitionTags["CODE_DEFINE_SPRITE"] = 39] = "CODE_DEFINE_SPRITE";
                DefinitionTags[DefinitionTags["CODE_DEFINE_MORPH_SHAPE"] = 46] = "CODE_DEFINE_MORPH_SHAPE";
                DefinitionTags[DefinitionTags["CODE_DEFINE_FONT2"] = 48] = "CODE_DEFINE_FONT2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_VIDEO_STREAM"] = 60] = "CODE_DEFINE_VIDEO_STREAM";
                DefinitionTags[DefinitionTags["CODE_DEFINE_FONT3"] = 75] = "CODE_DEFINE_FONT3";
                DefinitionTags[DefinitionTags["CODE_DEFINE_SHAPE4"] = 83] = "CODE_DEFINE_SHAPE4";
                DefinitionTags[DefinitionTags["CODE_DEFINE_MORPH_SHAPE2"] = 84] = "CODE_DEFINE_MORPH_SHAPE2";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BINARY_DATA"] = 87] = "CODE_DEFINE_BINARY_DATA";
                DefinitionTags[DefinitionTags["CODE_DEFINE_BITS_JPEG4"] = 90] = "CODE_DEFINE_BITS_JPEG4";
                DefinitionTags[DefinitionTags["CODE_DEFINE_FONT4"] = 91] = "CODE_DEFINE_FONT4";
            })(DefinitionTags = Parser.DefinitionTags || (Parser.DefinitionTags = {}));
            var ImageDefinitionTags;
            (function (ImageDefinitionTags) {
                ImageDefinitionTags[ImageDefinitionTags["CODE_DEFINE_BITS"] = 6] = "CODE_DEFINE_BITS";
                ImageDefinitionTags[ImageDefinitionTags["CODE_DEFINE_BITS_JPEG2"] = 21] = "CODE_DEFINE_BITS_JPEG2";
                ImageDefinitionTags[ImageDefinitionTags["CODE_DEFINE_BITS_JPEG3"] = 35] = "CODE_DEFINE_BITS_JPEG3";
                ImageDefinitionTags[ImageDefinitionTags["CODE_DEFINE_BITS_JPEG4"] = 90] = "CODE_DEFINE_BITS_JPEG4";
            })(ImageDefinitionTags = Parser.ImageDefinitionTags || (Parser.ImageDefinitionTags = {}));
            var FontDefinitionTags;
            (function (FontDefinitionTags) {
                FontDefinitionTags[FontDefinitionTags["CODE_DEFINE_FONT"] = 10] = "CODE_DEFINE_FONT";
                FontDefinitionTags[FontDefinitionTags["CODE_DEFINE_FONT2"] = 48] = "CODE_DEFINE_FONT2";
                FontDefinitionTags[FontDefinitionTags["CODE_DEFINE_FONT3"] = 75] = "CODE_DEFINE_FONT3";
                FontDefinitionTags[FontDefinitionTags["CODE_DEFINE_FONT4"] = 91] = "CODE_DEFINE_FONT4";
            })(FontDefinitionTags = Parser.FontDefinitionTags || (Parser.FontDefinitionTags = {}));
            var ControlTags;
            (function (ControlTags) {
                ControlTags[ControlTags["CODE_PLACE_OBJECT"] = 4] = "CODE_PLACE_OBJECT";
                ControlTags[ControlTags["CODE_PLACE_OBJECT2"] = 26] = "CODE_PLACE_OBJECT2";
                ControlTags[ControlTags["CODE_PLACE_OBJECT3"] = 70] = "CODE_PLACE_OBJECT3";
                ControlTags[ControlTags["CODE_REMOVE_OBJECT"] = 5] = "CODE_REMOVE_OBJECT";
                ControlTags[ControlTags["CODE_REMOVE_OBJECT2"] = 28] = "CODE_REMOVE_OBJECT2";
                ControlTags[ControlTags["CODE_START_SOUND"] = 15] = "CODE_START_SOUND";
                ControlTags[ControlTags["CODE_START_SOUND2"] = 89] = "CODE_START_SOUND2";
                ControlTags[ControlTags["CODE_VIDEO_FRAME"] = 61] = "CODE_VIDEO_FRAME";
            })(ControlTags = Parser.ControlTags || (Parser.ControlTags = {}));
            var PlaceObjectFlags;
            (function (PlaceObjectFlags) {
                PlaceObjectFlags[PlaceObjectFlags["Move"] = 1] = "Move";
                PlaceObjectFlags[PlaceObjectFlags["HasCharacter"] = 2] = "HasCharacter";
                PlaceObjectFlags[PlaceObjectFlags["HasMatrix"] = 4] = "HasMatrix";
                PlaceObjectFlags[PlaceObjectFlags["HasColorTransform"] = 8] = "HasColorTransform";
                PlaceObjectFlags[PlaceObjectFlags["HasRatio"] = 16] = "HasRatio";
                PlaceObjectFlags[PlaceObjectFlags["HasName"] = 32] = "HasName";
                PlaceObjectFlags[PlaceObjectFlags["HasClipDepth"] = 64] = "HasClipDepth";
                PlaceObjectFlags[PlaceObjectFlags["HasClipActions"] = 128] = "HasClipActions";
                PlaceObjectFlags[PlaceObjectFlags["HasFilterList"] = 256] = "HasFilterList";
                PlaceObjectFlags[PlaceObjectFlags["HasBlendMode"] = 512] = "HasBlendMode";
                PlaceObjectFlags[PlaceObjectFlags["HasCacheAsBitmap"] = 1024] = "HasCacheAsBitmap";
                PlaceObjectFlags[PlaceObjectFlags["HasClassName"] = 2048] = "HasClassName";
                PlaceObjectFlags[PlaceObjectFlags["HasImage"] = 4096] = "HasImage";
                PlaceObjectFlags[PlaceObjectFlags["HasVisible"] = 8192] = "HasVisible";
                PlaceObjectFlags[PlaceObjectFlags["OpaqueBackground"] = 16384] = "OpaqueBackground";
                PlaceObjectFlags[PlaceObjectFlags["Reserved"] = 32768] = "Reserved";
            })(PlaceObjectFlags = Parser.PlaceObjectFlags || (Parser.PlaceObjectFlags = {}));
            var AVM1ClipEvents;
            (function (AVM1ClipEvents) {
                AVM1ClipEvents[AVM1ClipEvents["Load"] = 1] = "Load";
                AVM1ClipEvents[AVM1ClipEvents["EnterFrame"] = 2] = "EnterFrame";
                AVM1ClipEvents[AVM1ClipEvents["Unload"] = 4] = "Unload";
                AVM1ClipEvents[AVM1ClipEvents["MouseMove"] = 8] = "MouseMove";
                AVM1ClipEvents[AVM1ClipEvents["MouseDown"] = 16] = "MouseDown";
                AVM1ClipEvents[AVM1ClipEvents["MouseUp"] = 32] = "MouseUp";
                AVM1ClipEvents[AVM1ClipEvents["KeyDown"] = 64] = "KeyDown";
                AVM1ClipEvents[AVM1ClipEvents["KeyUp"] = 128] = "KeyUp";
                AVM1ClipEvents[AVM1ClipEvents["Data"] = 256] = "Data";
                AVM1ClipEvents[AVM1ClipEvents["Initialize"] = 512] = "Initialize";
                AVM1ClipEvents[AVM1ClipEvents["Press"] = 1024] = "Press";
                AVM1ClipEvents[AVM1ClipEvents["Release"] = 2048] = "Release";
                AVM1ClipEvents[AVM1ClipEvents["ReleaseOutside"] = 4096] = "ReleaseOutside";
                AVM1ClipEvents[AVM1ClipEvents["RollOver"] = 8192] = "RollOver";
                AVM1ClipEvents[AVM1ClipEvents["RollOut"] = 16384] = "RollOut";
                AVM1ClipEvents[AVM1ClipEvents["DragOver"] = 32768] = "DragOver";
                AVM1ClipEvents[AVM1ClipEvents["DragOut"] = 65536] = "DragOut";
                AVM1ClipEvents[AVM1ClipEvents["KeyPress"] = 131072] = "KeyPress";
                AVM1ClipEvents[AVM1ClipEvents["Construct"] = 262144] = "Construct";
            })(AVM1ClipEvents = Parser.AVM1ClipEvents || (Parser.AVM1ClipEvents = {}));
            var ButtonCharacterFlags;
            (function (ButtonCharacterFlags) {
                ButtonCharacterFlags[ButtonCharacterFlags["StateUp"] = 1] = "StateUp";
                ButtonCharacterFlags[ButtonCharacterFlags["StateOver"] = 2] = "StateOver";
                ButtonCharacterFlags[ButtonCharacterFlags["StateDown"] = 4] = "StateDown";
                ButtonCharacterFlags[ButtonCharacterFlags["StateHitTest"] = 8] = "StateHitTest";
                ButtonCharacterFlags[ButtonCharacterFlags["HasFilterList"] = 16] = "HasFilterList";
                ButtonCharacterFlags[ButtonCharacterFlags["HasBlendMode"] = 32] = "HasBlendMode";
            })(ButtonCharacterFlags = Parser.ButtonCharacterFlags || (Parser.ButtonCharacterFlags = {}));
            var FontFlags;
            (function (FontFlags) {
                FontFlags[FontFlags["Bold"] = 1] = "Bold";
                FontFlags[FontFlags["Italic"] = 2] = "Italic";
                FontFlags[FontFlags["WideOrHasFontData"] = 4] = "WideOrHasFontData";
                FontFlags[FontFlags["WideOffset"] = 8] = "WideOffset";
                FontFlags[FontFlags["Ansi"] = 16] = "Ansi";
                FontFlags[FontFlags["SmallText"] = 32] = "SmallText";
                FontFlags[FontFlags["ShiftJis"] = 64] = "ShiftJis";
                FontFlags[FontFlags["HasLayout"] = 128] = "HasLayout";
            })(FontFlags = Parser.FontFlags || (Parser.FontFlags = {}));
            var TextRecordFlags;
            (function (TextRecordFlags) {
                TextRecordFlags[TextRecordFlags["HasMoveX"] = 1] = "HasMoveX";
                TextRecordFlags[TextRecordFlags["HasMoveY"] = 2] = "HasMoveY";
                TextRecordFlags[TextRecordFlags["HasColor"] = 4] = "HasColor";
                TextRecordFlags[TextRecordFlags["HasFont"] = 8] = "HasFont";
            })(TextRecordFlags = Parser.TextRecordFlags || (Parser.TextRecordFlags = {}));
            var SoundInfoFlags;
            (function (SoundInfoFlags) {
                SoundInfoFlags[SoundInfoFlags["HasInPoint"] = 1] = "HasInPoint";
                SoundInfoFlags[SoundInfoFlags["HasOutPoint"] = 2] = "HasOutPoint";
                SoundInfoFlags[SoundInfoFlags["HasLoops"] = 4] = "HasLoops";
                SoundInfoFlags[SoundInfoFlags["HasEnvelope"] = 8] = "HasEnvelope";
                SoundInfoFlags[SoundInfoFlags["NoMultiple"] = 16] = "NoMultiple";
                SoundInfoFlags[SoundInfoFlags["Stop"] = 32] = "Stop";
            })(SoundInfoFlags = Parser.SoundInfoFlags || (Parser.SoundInfoFlags = {}));
            var TextFlags;
            (function (TextFlags) {
                TextFlags[TextFlags["HasFont"] = 1] = "HasFont";
                TextFlags[TextFlags["HasMaxLength"] = 2] = "HasMaxLength";
                TextFlags[TextFlags["HasColor"] = 4] = "HasColor";
                TextFlags[TextFlags["ReadOnly"] = 8] = "ReadOnly";
                TextFlags[TextFlags["Password"] = 16] = "Password";
                TextFlags[TextFlags["Multiline"] = 32] = "Multiline";
                TextFlags[TextFlags["WordWrap"] = 64] = "WordWrap";
                TextFlags[TextFlags["HasText"] = 128] = "HasText";
                TextFlags[TextFlags["UseOutlines"] = 256] = "UseOutlines";
                TextFlags[TextFlags["Html"] = 512] = "Html";
                TextFlags[TextFlags["WasStatic"] = 1024] = "WasStatic";
                TextFlags[TextFlags["Border"] = 2048] = "Border";
                TextFlags[TextFlags["NoSelect"] = 4096] = "NoSelect";
                TextFlags[TextFlags["HasLayout"] = 8192] = "HasLayout";
                TextFlags[TextFlags["AutoSize"] = 16384] = "AutoSize";
                TextFlags[TextFlags["HasFontClass"] = 32768] = "HasFontClass";
            })(TextFlags = Parser.TextFlags || (Parser.TextFlags = {}));
            var ShapeFlags;
            (function (ShapeFlags) {
                ShapeFlags[ShapeFlags["UsesScalingStrokes"] = 1] = "UsesScalingStrokes";
                ShapeFlags[ShapeFlags["UsesNonScalingStrokes"] = 2] = "UsesNonScalingStrokes";
                ShapeFlags[ShapeFlags["UsesFillWindingRule"] = 4] = "UsesFillWindingRule";
                ShapeFlags[ShapeFlags["IsMorph"] = 8] = "IsMorph";
            })(ShapeFlags = Parser.ShapeFlags || (Parser.ShapeFlags = {}));
            var ShapeRecordFlags;
            (function (ShapeRecordFlags) {
                ShapeRecordFlags[ShapeRecordFlags["Move"] = 1] = "Move";
                ShapeRecordFlags[ShapeRecordFlags["HasFillStyle0"] = 2] = "HasFillStyle0";
                ShapeRecordFlags[ShapeRecordFlags["HasFillStyle1"] = 4] = "HasFillStyle1";
                ShapeRecordFlags[ShapeRecordFlags["HasLineStyle"] = 8] = "HasLineStyle";
                ShapeRecordFlags[ShapeRecordFlags["HasNewStyles"] = 16] = "HasNewStyles";
                ShapeRecordFlags[ShapeRecordFlags["IsStraight"] = 32] = "IsStraight";
                ShapeRecordFlags[ShapeRecordFlags["IsGeneral"] = 64] = "IsGeneral";
                ShapeRecordFlags[ShapeRecordFlags["IsVertical"] = 128] = "IsVertical";
            })(ShapeRecordFlags = Parser.ShapeRecordFlags || (Parser.ShapeRecordFlags = {}));
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var unexpected = Shumway.Debug.unexpected;
    var BinaryFileReader = /** @class */ (function () {
        function BinaryFileReader(url, method, mimeType, data) {
            this.url = url;
            this.method = method;
            this.mimeType = mimeType;
            this.data = data;
        }
        BinaryFileReader.prototype.readAll = function (progress, complete) {
            var url = this.url;
            var xhr = this.xhr = new XMLHttpRequest({ mozSystem: true });
            var async = true;
            xhr.open(this.method || "GET", this.url, async);
            xhr.responseType = "arraybuffer";
            if (progress) {
                xhr.onprogress = function (event) {
                    progress(xhr.response, event.loaded, event.total);
                };
            }
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 4) {
                    if (xhr.status !== 200 && xhr.status !== 0 || xhr.response === null) {
                        unexpected("Path: " + url + " not found.");
                        complete(null, xhr.statusText);
                        return;
                    }
                    complete(xhr.response);
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader("Content-Type", this.mimeType);
            }
            xhr.send(this.data || null);
        };
        BinaryFileReader.prototype.readChunked = function (chunkSize /* int */, ondata, onerror, onopen, oncomplete, onhttpstatus) {
            if (chunkSize <= 0) {
                this.readAsync(ondata, onerror, onopen, oncomplete, onhttpstatus);
                return;
            }
            var position = 0;
            var buffer = new Uint8Array(chunkSize);
            var read = 0, total;
            this.readAsync(function (data, progress) {
                total = progress.total;
                var left = data.length, offset = 0;
                while (position + left >= chunkSize) {
                    var tailSize = chunkSize - position;
                    buffer.set(data.subarray(offset, offset + tailSize), position);
                    offset += tailSize;
                    left -= tailSize;
                    read += chunkSize;
                    ondata(buffer, { loaded: read, total: total });
                    position = 0;
                }
                buffer.set(data.subarray(offset), position);
                position += left;
            }, onerror, onopen, function () {
                if (position > 0) {
                    read += position;
                    ondata(buffer.subarray(0, position), { loaded: read, total: total });
                    position = 0;
                }
                oncomplete && oncomplete();
            }, onhttpstatus);
        };
        BinaryFileReader.prototype.readAsync = function (ondata, onerror, onopen, oncomplete, onhttpstatus) {
            var xhr = this.xhr = new XMLHttpRequest({ mozSystem: true });
            var url = this.url;
            var loaded = 0;
            var total = 0;
            xhr.open(this.method || "GET", url, true);
            xhr.responseType = 'moz-chunked-arraybuffer';
            var isNotProgressive = xhr.responseType !== 'moz-chunked-arraybuffer';
            if (isNotProgressive) {
                xhr.responseType = 'arraybuffer';
            }
            xhr.onprogress = function (e) {
                if (isNotProgressive) {
                    return;
                }
                loaded = e.loaded;
                total = e.total;
                var bytes = new Uint8Array(xhr.response);
                // The event's `loaded` and `total` properties are sometimes lower than the actual
                // number of loaded bytes. In that case, increase them to that value.
                loaded = Math.max(loaded, bytes.byteLength);
                total = Math.max(total, bytes.byteLength);
                ondata(bytes, { loaded: loaded, total: total });
            };
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 2 && onhttpstatus) {
                    onhttpstatus(url, xhr.status, xhr.getAllResponseHeaders());
                }
                if (xhr.readyState === 4) {
                    // Failed loads can be detected through either the status code or the fact that nothing
                    // has been loaded.
                    // Note: Just checking that `xhr.response` is set doesn't work, as Firefox enables
                    // chunked loading, and in that mode `response` is only set in the `onprogress` handler.
                    if (xhr.status !== 200 && xhr.status !== 0 ||
                        xhr.response === null && (total === 0 || loaded !== total)) {
                        onerror(xhr.statusText);
                        return;
                    }
                    if (isNotProgressive) {
                        var buffer = xhr.response;
                        ondata(new Uint8Array(buffer), { loaded: buffer.byteLength, total: buffer.byteLength });
                    }
                }
            };
            xhr.onload = function () {
                if (oncomplete) {
                    oncomplete();
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader("Content-Type", this.mimeType);
            }
            xhr.send(this.data || null);
            if (onopen) {
                onopen();
            }
        };
        BinaryFileReader.prototype.abort = function () {
            if (this.xhr) {
                this.xhr.abort();
                this.xhr = null;
            }
        };
        return BinaryFileReader;
    }());
    Shumway.BinaryFileReader = BinaryFileReader;
})(Shumway || (Shumway = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    // Produces similar output as flashlog.txt It can be produced by the
    // debug builds of Flash Player.
    // See https://github.com/mozilla/shumway/wiki/Trace-Output-with-Flash-Player-Debugger
    var FlashLog = /** @class */ (function () {
        function FlashLog() {
            this.isAS3TraceOn = true;
            this._startTime = Date.now();
        }
        Object.defineProperty(FlashLog.prototype, "currentTimestamp", {
            get: function () {
                return Date.now() - this._startTime;
            },
            enumerable: true,
            configurable: true
        });
        FlashLog.prototype._writeLine = function (line) {
            Shumway.Debug.abstractMethod('FlashLog._writeLine');
        };
        FlashLog.prototype.writeAS3Trace = function (msg) {
            if (this.isAS3TraceOn) {
                this._writeLine(this.currentTimestamp + ' AVMINF: ' + msg);
            }
        };
        return FlashLog;
    }());
    Shumway.FlashLog = FlashLog;
    Shumway.flashlog = null;
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Remoting;
    (function (Remoting) {
        /**
         * Remoting phases.
         */
        var RemotingPhase;
        (function (RemotingPhase) {
            /**
             * Objects are serialized. During this phase all reachable remotable objects (all objects
             * reachable from a root set) that are dirty are remoted. This includes all dirty object
             * properties except for dirty references.
             */
            RemotingPhase[RemotingPhase["Objects"] = 0] = "Objects";
            /**
             * Object references are serialized. All objects that are referred to have already been
             * remoted at this point.
             */
            RemotingPhase[RemotingPhase["References"] = 1] = "References";
        })(RemotingPhase = Remoting.RemotingPhase || (Remoting.RemotingPhase = {}));
        var MessageBits;
        (function (MessageBits) {
            MessageBits[MessageBits["HasMatrix"] = 1] = "HasMatrix";
            MessageBits[MessageBits["HasBounds"] = 2] = "HasBounds";
            MessageBits[MessageBits["HasChildren"] = 4] = "HasChildren";
            MessageBits[MessageBits["HasColorTransform"] = 8] = "HasColorTransform";
            MessageBits[MessageBits["HasClipRect"] = 16] = "HasClipRect";
            MessageBits[MessageBits["HasMiscellaneousProperties"] = 32] = "HasMiscellaneousProperties";
            MessageBits[MessageBits["HasMask"] = 64] = "HasMask";
            MessageBits[MessageBits["HasClip"] = 128] = "HasClip";
        })(MessageBits = Remoting.MessageBits || (Remoting.MessageBits = {}));
        var IDMask;
        (function (IDMask) {
            IDMask[IDMask["None"] = 0] = "None";
            IDMask[IDMask["Asset"] = 134217728] = "Asset";
        })(IDMask = Remoting.IDMask || (Remoting.IDMask = {}));
        /**
         * Serialization Format. All commands start with a message tag.
         */
        var MessageTag;
        (function (MessageTag) {
            MessageTag[MessageTag["EOF"] = 0] = "EOF";
            /**
             * id                   int32,
             * hasBits              int32,
             * matrix               Matrix,
             * colorMatrix          ColorMatrix,
             * mask                 int32,
             * misc
             *   blendMode          int32,
             *   visible            int32
             *
             * @type {number}
             */
            MessageTag[MessageTag["UpdateFrame"] = 100] = "UpdateFrame";
            MessageTag[MessageTag["UpdateGraphics"] = 101] = "UpdateGraphics";
            MessageTag[MessageTag["UpdateBitmapData"] = 102] = "UpdateBitmapData";
            MessageTag[MessageTag["UpdateTextContent"] = 103] = "UpdateTextContent";
            MessageTag[MessageTag["UpdateStage"] = 104] = "UpdateStage";
            MessageTag[MessageTag["UpdateNetStream"] = 105] = "UpdateNetStream";
            MessageTag[MessageTag["RequestBitmapData"] = 106] = "RequestBitmapData";
            MessageTag[MessageTag["UpdateCurrentMouseTarget"] = 107] = "UpdateCurrentMouseTarget";
            MessageTag[MessageTag["DrawToBitmap"] = 200] = "DrawToBitmap";
            MessageTag[MessageTag["MouseEvent"] = 300] = "MouseEvent";
            MessageTag[MessageTag["KeyboardEvent"] = 301] = "KeyboardEvent";
            MessageTag[MessageTag["FocusEvent"] = 302] = "FocusEvent";
        })(MessageTag = Remoting.MessageTag || (Remoting.MessageTag = {}));
        var FilterType;
        (function (FilterType) {
            FilterType[FilterType["Blur"] = 0] = "Blur";
            FilterType[FilterType["DropShadow"] = 1] = "DropShadow";
            FilterType[FilterType["ColorMatrix"] = 2] = "ColorMatrix";
        })(FilterType = Remoting.FilterType || (Remoting.FilterType = {}));
        /**
         * Dictates how color transforms are encoded. The majority of color transforms are
         * either identity or only modify the alpha multiplier, so we can encode these more
         * efficiently.
         */
        var ColorTransformEncoding;
        (function (ColorTransformEncoding) {
            /**
             * Identity, no need to serialize all the fields.
             */
            ColorTransformEncoding[ColorTransformEncoding["Identity"] = 0] = "Identity";
            /**
             * Identity w/ AlphaMultiplier, only the alpha multiplier is serialized.
             */
            ColorTransformEncoding[ColorTransformEncoding["AlphaMultiplierOnly"] = 1] = "AlphaMultiplierOnly";
            /**
             * Offsets w/ AlphaMultiplier.
             */
            ColorTransformEncoding[ColorTransformEncoding["AlphaMultiplierWithOffsets"] = 2] = "AlphaMultiplierWithOffsets";
            /**
             * All fields are serialized.
             */
            ColorTransformEncoding[ColorTransformEncoding["All"] = 3] = "All";
        })(ColorTransformEncoding = Remoting.ColorTransformEncoding || (Remoting.ColorTransformEncoding = {}));
        /**
         * Dictates how matrices are encoded.
         */
        var MatrixEncoding;
        (function (MatrixEncoding) {
            /**
             * Translation only.
             */
            MatrixEncoding[MatrixEncoding["TranslationOnly"] = 0] = "TranslationOnly";
            /**
             * Scale and translation only.
             */
            MatrixEncoding[MatrixEncoding["ScaleAndTranslationOnly"] = 1] = "ScaleAndTranslationOnly";
            /**
             * Uniform scale in the x and y direction and translation only.
             */
            MatrixEncoding[MatrixEncoding["UniformScaleAndTranslationOnly"] = 2] = "UniformScaleAndTranslationOnly";
            /**
             * All fields are serialized.
             */
            MatrixEncoding[MatrixEncoding["All"] = 3] = "All";
        })(MatrixEncoding = Remoting.MatrixEncoding || (Remoting.MatrixEncoding = {}));
        var VideoPlaybackEvent;
        (function (VideoPlaybackEvent) {
            VideoPlaybackEvent[VideoPlaybackEvent["Initialized"] = 0] = "Initialized";
            VideoPlaybackEvent[VideoPlaybackEvent["Metadata"] = 1] = "Metadata";
            VideoPlaybackEvent[VideoPlaybackEvent["PlayStart"] = 2] = "PlayStart";
            VideoPlaybackEvent[VideoPlaybackEvent["PlayStop"] = 3] = "PlayStop";
            VideoPlaybackEvent[VideoPlaybackEvent["BufferEmpty"] = 4] = "BufferEmpty";
            VideoPlaybackEvent[VideoPlaybackEvent["BufferFull"] = 5] = "BufferFull";
            VideoPlaybackEvent[VideoPlaybackEvent["Pause"] = 6] = "Pause";
            VideoPlaybackEvent[VideoPlaybackEvent["Unpause"] = 7] = "Unpause";
            VideoPlaybackEvent[VideoPlaybackEvent["Seeking"] = 8] = "Seeking";
            VideoPlaybackEvent[VideoPlaybackEvent["Seeked"] = 9] = "Seeked";
            VideoPlaybackEvent[VideoPlaybackEvent["Progress"] = 10] = "Progress";
            VideoPlaybackEvent[VideoPlaybackEvent["Error"] = 11] = "Error";
        })(VideoPlaybackEvent = Remoting.VideoPlaybackEvent || (Remoting.VideoPlaybackEvent = {}));
        var VideoControlEvent;
        (function (VideoControlEvent) {
            VideoControlEvent[VideoControlEvent["Init"] = 1] = "Init";
            VideoControlEvent[VideoControlEvent["Pause"] = 2] = "Pause";
            VideoControlEvent[VideoControlEvent["Seek"] = 3] = "Seek";
            VideoControlEvent[VideoControlEvent["GetTime"] = 4] = "GetTime";
            VideoControlEvent[VideoControlEvent["GetBufferLength"] = 5] = "GetBufferLength";
            VideoControlEvent[VideoControlEvent["SetSoundLevels"] = 6] = "SetSoundLevels";
            VideoControlEvent[VideoControlEvent["GetBytesLoaded"] = 7] = "GetBytesLoaded";
            VideoControlEvent[VideoControlEvent["GetBytesTotal"] = 8] = "GetBytesTotal";
            VideoControlEvent[VideoControlEvent["EnsurePlaying"] = 9] = "EnsurePlaying";
        })(VideoControlEvent = Remoting.VideoControlEvent || (Remoting.VideoControlEvent = {}));
        var StageScaleMode;
        (function (StageScaleMode) {
            StageScaleMode[StageScaleMode["ShowAll"] = 0] = "ShowAll";
            StageScaleMode[StageScaleMode["ExactFit"] = 1] = "ExactFit";
            StageScaleMode[StageScaleMode["NoBorder"] = 2] = "NoBorder";
            StageScaleMode[StageScaleMode["NoScale"] = 4] = "NoScale";
        })(StageScaleMode = Remoting.StageScaleMode || (Remoting.StageScaleMode = {}));
        var StageAlignFlags;
        (function (StageAlignFlags) {
            StageAlignFlags[StageAlignFlags["None"] = 0] = "None";
            StageAlignFlags[StageAlignFlags["Top"] = 1] = "Top";
            StageAlignFlags[StageAlignFlags["Bottom"] = 2] = "Bottom";
            StageAlignFlags[StageAlignFlags["Left"] = 4] = "Left";
            StageAlignFlags[StageAlignFlags["Right"] = 8] = "Right";
            StageAlignFlags[StageAlignFlags["TopLeft"] = 5] = "TopLeft";
            StageAlignFlags[StageAlignFlags["BottomLeft"] = 6] = "BottomLeft";
            StageAlignFlags[StageAlignFlags["BottomRight"] = 10] = "BottomRight";
            StageAlignFlags[StageAlignFlags["TopRight"] = 9] = "TopRight";
        })(StageAlignFlags = Remoting.StageAlignFlags || (Remoting.StageAlignFlags = {}));
        Remoting.MouseEventNames = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseup',
            'mouseover',
            'mouseout'
        ];
        Remoting.KeyboardEventNames = [
            'keydown',
            'keypress',
            'keyup'
        ];
        var KeyboardEventFlags;
        (function (KeyboardEventFlags) {
            KeyboardEventFlags[KeyboardEventFlags["CtrlKey"] = 1] = "CtrlKey";
            KeyboardEventFlags[KeyboardEventFlags["AltKey"] = 2] = "AltKey";
            KeyboardEventFlags[KeyboardEventFlags["ShiftKey"] = 4] = "ShiftKey";
        })(KeyboardEventFlags = Remoting.KeyboardEventFlags || (Remoting.KeyboardEventFlags = {}));
        var FocusEventType;
        (function (FocusEventType) {
            FocusEventType[FocusEventType["DocumentHidden"] = 0] = "DocumentHidden";
            FocusEventType[FocusEventType["DocumentVisible"] = 1] = "DocumentVisible";
            FocusEventType[FocusEventType["WindowBlur"] = 2] = "WindowBlur";
            FocusEventType[FocusEventType["WindowFocus"] = 3] = "WindowFocus";
        })(FocusEventType = Remoting.FocusEventType || (Remoting.FocusEventType = {}));
        /**
         * Implementation of ITransportPeer that uses standard DOM postMessage and
         * events to exchange data between messaging peers.
         */
        var WindowTransportPeer = /** @class */ (function () {
            function WindowTransportPeer(window, target) {
                this.window = window;
                this.target = target;
                //
            }
            Object.defineProperty(WindowTransportPeer.prototype, "onAsyncMessage", {
                set: function (callback) {
                    this.window.addEventListener('message', function (e) {
                        Promise.resolve(e.data).then(function (msg) {
                            callback(msg);
                        });
                    });
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WindowTransportPeer.prototype, "onSyncMessage", {
                set: function (callback) {
                    this.window.addEventListener('syncmessage', function (e) {
                        var wrappedMessage = e.detail;
                        wrappedMessage.result = callback(wrappedMessage.msg);
                    });
                },
                enumerable: true,
                configurable: true
            });
            WindowTransportPeer.prototype.postAsyncMessage = function (msg, transfers) {
                this.target.postMessage(msg, '*', transfers);
            };
            WindowTransportPeer.prototype.sendSyncMessage = function (msg, transfers) {
                var event = this.target.document.createEvent('CustomEvent');
                var wrappedMessage = {
                    msg: msg,
                    result: undefined
                };
                event.initCustomEvent('syncmessage', false, false, wrappedMessage);
                this.target.dispatchEvent(event);
                return wrappedMessage.result;
            };
            return WindowTransportPeer;
        }());
        Remoting.WindowTransportPeer = WindowTransportPeer;
        /**
         * Implementation of ITransportPeer that uses ShumwayCom API to exchange data
         * between messaging peers.
         */
        var ShumwayComTransportPeer = /** @class */ (function () {
            function ShumwayComTransportPeer() {
            }
            Object.defineProperty(ShumwayComTransportPeer.prototype, "onAsyncMessage", {
                set: function (callback) {
                    ShumwayCom.setAsyncMessageCallback(callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComTransportPeer.prototype, "onSyncMessage", {
                set: function (callback) {
                    ShumwayCom.setSyncMessageCallback(callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComTransportPeer.prototype.postAsyncMessage = function (msg, transfers) {
                ShumwayCom.postAsyncMessage(msg);
            };
            ShumwayComTransportPeer.prototype.sendSyncMessage = function (msg, transfers) {
                return ShumwayCom.sendSyncMessage(msg);
            };
            return ShumwayComTransportPeer;
        }());
        Remoting.ShumwayComTransportPeer = ShumwayComTransportPeer;
    })(Remoting = Shumway.Remoting || (Shumway.Remoting = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ShumwayEnvironment = {
    DEBUG: 'test',
    DEVELOPMENT: 'dev',
    RELEASE: 'release',
    TEST: 'test'
};
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            system._currentDomain = null;
            system._currentSymbol = null;
            function currentDomain() {
                return this._currentDomain;
            }
            system.currentDomain = currentDomain;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    Shumway.Errors = {
        /**
         * AVM2 Error Codes
         */
        //  OutOfMemoryError                     : {code: 1000, message: "The system is out of memory."},
        NotImplementedError: { code: 1001, message: "The method %1 is not implemented." },
        InvalidPrecisionError: { code: 1002, message: "Number.toPrecision has a range of 1 to 21. Number.toFixed and Number.toExponential have a range of 0 to 20. Specified value is not within expected range." },
        InvalidRadixError: { code: 1003, message: "The radix argument must be between 2 and 36; got %1." },
        InvokeOnIncompatibleObjectError: { code: 1004, message: "Method %1 was invoked on an incompatible object." },
        ArrayIndexNotIntegerError: { code: 1005, message: "Array index is not a positive integer (%1)." },
        CallOfNonFunctionError: { code: 1006, message: "%1 is not a function." },
        ConstructOfNonFunctionError: { code: 1007, message: "Instantiation attempted on a non-constructor." },
        //  AmbiguousBindingError                : {code: 1008, message: "%1 is ambiguous; Found more than one matching binding."},
        ConvertNullToObjectError: { code: 1009, message: "Cannot access a property or method of a null object reference." },
        ConvertUndefinedToObjectError: { code: 1010, message: "A term is undefined and has no properties." },
        //  IllegalOpcodeError                   : {code: 1011, message: "Method %1 contained illegal opcode %2 at offset %3."},
        //  LastInstExceedsCodeSizeError         : {code: 1012, message: "The last instruction exceeded code size."},
        //  FindVarWithNoScopeError              : {code: 1013, message: "Cannot call OP_findproperty when scopeDepth is 0."},
        ClassNotFoundError: { code: 1014, message: "Class %1 could not be found." },
        //  IllegalSetDxns                       : {code: 1015, message: "Method %1 cannot set default xml namespace"},
        DescendentsError: { code: 1016, message: "Descendants operator (..) not supported on type %1." },
        //  ScopeStackOverflowError              : {code: 1017, message: "Scope stack overflow occurred."},
        //  ScopeStackUnderflowError             : {code: 1018, message: "Scope stack underflow occurred."},
        //  GetScopeObjectBoundsError            : {code: 1019, message: "Getscopeobject %1 is out of bounds."},
        //  CannotFallOffMethodError             : {code: 1020, message: "Code cannot fall off the end of a method."},
        //  InvalidBranchTargetError             : {code: 1021, message: "At least one branch target was not on a valid instruction in the method."},
        //  IllegalVoidError                     : {code: 1022, message: "Type void may only be used as a function return type."},
        StackOverflowError: { code: 1023, message: "Stack overflow occurred." },
        //  StackUnderflowError                  : {code: 1024, message: "Stack underflow occurred."},
        //  InvalidRegisterError                 : {code: 1025, message: "An invalid register %1 was accessed."},
        //  SlotExceedsCountError                : {code: 1026, message: "Slot %1 exceeds slotCount=%2 of %3."},
        //  MethodInfoExceedsCountError          : {code: 1027, message: "Method_info %1 exceeds method_count=%2."},
        //  DispIdExceedsCountError              : {code: 1028, message: "Disp_id %1 exceeds max_disp_id=%2 of %3."},
        //  DispIdUndefinedError                 : {code: 1029, message: "Disp_id %1 is undefined on %2."},
        //  StackDepthUnbalancedError            : {code: 1030, message: "Stack depth is unbalanced. %1 != %2."},
        //  ScopeDepthUnbalancedError            : {code: 1031, message: "Scope depth is unbalanced. %1 != %2."},
        CpoolIndexRangeError: { code: 1032, message: "Cpool index %1 is out of range %2." },
        CpoolEntryWrongTypeError: { code: 1033, message: "Cpool entry %1 is wrong type." },
        CheckTypeFailedError: { code: 1034, message: "Type Coercion failed: cannot convert %1 to %2." },
        //  IllegalSuperCallError                : {code: 1035, message: "Illegal super expression found in method %1."},
        CannotAssignToMethodError: { code: 1037, message: "Cannot assign to a method %1 on %2." },
        //  RedefinedError                       : {code: 1038, message: "%1 is already defined."},
        //  CannotVerifyUntilReferencedError     : {code: 1039, message: "Cannot verify method until it is referenced."},
        CantUseInstanceofOnNonObjectError: { code: 1040, message: "The right-hand side of instanceof must be a class or function." },
        IsTypeMustBeClassError: { code: 1041, message: "The right-hand side of operator must be a class." },
        InvalidMagicError: { code: 1042, message: "Not an ABC file.  major_version=%1 minor_version=%2." },
        //  InvalidCodeLengthError               : {code: 1043, message: "Invalid code_length=%1."},
        //  InvalidMethodInfoFlagsError          : {code: 1044, message: "MethodInfo-%1 unsupported flags=%2."},
        UnsupportedTraitsKindError: { code: 1045, message: "Unsupported traits kind=%1." },
        //  MethodInfoOrderError                 : {code: 1046, message: "MethodInfo-%1 referenced before definition."},
        //  MissingEntryPointError               : {code: 1047, message: "No entry point was found."},
        PrototypeTypeError: { code: 1049, message: "Prototype objects must be vanilla Objects." },
        ConvertToPrimitiveError: { code: 1050, message: "Cannot convert %1 to primitive." },
        //  IllegalEarlyBindingError             : {code: 1051, message: "Illegal early binding access to %1."},
        InvalidURIError: { code: 1052, message: "Invalid URI passed to %1 function." },
        //  IllegalOverrideError                 : {code: 1053, message: "Illegal override of %1 in %2."},
        //  IllegalExceptionHandlerError         : {code: 1054, message: "Illegal range or target offsets in exception handler."},
        WriteSealedError: { code: 1056, message: "Cannot create property %1 on %2." },
        //  IllegalSlotError                     : {code: 1057, message: "%1 can only contain methods."},
        //  IllegalOperandTypeError              : {code: 1058, message: "Illegal operand type: %1 must be %2."},
        //  ClassInfoOrderError                  : {code: 1059, message: "ClassInfo-%1 is referenced before definition."},
        //  ClassInfoExceedsCountError           : {code: 1060, message: "ClassInfo %1 exceeds class_count=%2."},
        //  NumberOutOfRangeError                : {code: 1061, message: "The value %1 cannot be converted to %2 without losing precision."},
        WrongArgumentCountError: { code: 1063, message: "Argument count mismatch on %1. Expected %2, got %3." },
        //  CannotCallMethodAsConstructor        : {code: 1064, message: "Cannot call method %1 as constructor."},
        UndefinedVarError: { code: 1065, message: "Variable %1 is not defined." },
        //  FunctionConstructorError             : {code: 1066, message: "The form function('function body') is not supported."},
        //  IllegalNativeMethodBodyError         : {code: 1067, message: "Native method %1 has illegal method body."},
        //  CannotMergeTypesError                : {code: 1068, message: "%1 and %2 cannot be reconciled."},
        ReadSealedError: { code: 1069, message: "Property %1 not found on %2 and there is no default value." },
        //  CallNotFoundError                    : {code: 1070, message: "Method %1 not found on %2"},
        //  AlreadyBoundError                    : {code: 1071, message: "Function %1 has already been bound to %2."},
        //  ZeroDispIdError                      : {code: 1072, message: "Disp_id 0 is illegal."},
        //  DuplicateDispIdError                 : {code: 1073, message: "Non-override method %1 replaced because of duplicate disp_id %2."},
        ConstWriteError: { code: 1074, message: "Illegal write to read-only property %1 on %2." },
        //  MathNotFunctionError                 : {code: 1075, message: "Math is not a function."},
        //  MathNotConstructorError              : {code: 1076, message: "Math is not a constructor."},
        //  WriteOnlyError                       : {code: 1077, message: "Illegal read of write-only property %1 on %2."},
        //  IllegalOpMultinameError              : {code: 1078, message: "Illegal opcode/multiname combination: %1<%2>."},
        //  IllegalNativeMethodError             : {code: 1079, message: "Native methods are not allowed in loaded code."},
        //  IllegalNamespaceError                : {code: 1080, message: "Illegal value for namespace."},
        //  ReadSealedErrorNs                    : {code: 1081, message: "Property %1 not found on %2 and there is no default value."},
        //  NoDefaultNamespaceError              : {code: 1082, message: "No default namespace has been set."},
        XMLPrefixNotBound: { code: 1083, message: "The prefix \"%1\" for element \"%2\" is not bound." },
        //  XMLBadQName                          : {code: 1084, message: "Element or attribute (\"%1\") does not match QName production: QName::=(NCName':')?NCName."},
        XMLUnterminatedElementTag: { code: 1085, message: "The element type \"%1\" must be terminated by the matching end-tag \"</%2>\"." },
        XMLOnlyWorksWithOneItemLists: { code: 1086, message: "The %1 method only works on lists containing one item." },
        XMLAssignmentToIndexedXMLNotAllowed: { code: 1087, message: "Assignment to indexed XML is not allowed." },
        XMLMarkupMustBeWellFormed: { code: 1088, message: "The markup in the document following the root element must be well-formed." },
        XMLAssigmentOneItemLists: { code: 1089, message: "Assignment to lists with more than one item is not supported." },
        XMLMalformedElement: { code: 1090, message: "XML parser failure: element is malformed." },
        XMLUnterminatedCData: { code: 1091, message: "XML parser failure: Unterminated CDATA section." },
        XMLUnterminatedXMLDecl: { code: 1092, message: "XML parser failure: Unterminated XML declaration." },
        XMLUnterminatedDocTypeDecl: { code: 1093, message: "XML parser failure: Unterminated DOCTYPE declaration." },
        XMLUnterminatedComment: { code: 1094, message: "XML parser failure: Unterminated comment." },
        //  XMLUnterminatedAttribute             : {code: 1095, message: "XML parser failure: Unterminated attribute."},
        XMLUnterminatedElement: { code: 1096, message: "XML parser failure: Unterminated element." },
        //  XMLUnterminatedProcessingInstruction : {code: 1097, message: "XML parser failure: Unterminated processing instruction."},
        XMLNamespaceWithPrefixAndNoURI: { code: 1098, message: "Illegal prefix %1 for no namespace." },
        RegExpFlagsArgumentError: { code: 1100, message: "Cannot supply flags when constructing one RegExp from another." },
        //  NoScopeError                         : {code: 1101, message: "Cannot verify method %1 with unknown scope."},
        //  IllegalDefaultValue                  : {code: 1102, message: "Illegal default value for type %1."},
        //  CannotExtendFinalClass               : {code: 1103, message: "Class %1 cannot extend final base class."},
        //  XMLDuplicateAttribute                : {code: 1104, message: "Attribute \"%1\" was already specified for element \"%2\"."},
        //  CorruptABCError                      : {code: 1107, message: "The ABC data is corrupt, attempt to read out of bounds."},
        InvalidBaseClassError: { code: 1108, message: "The OP_newclass opcode was used with the incorrect base class." },
        //  DanglingFunctionError                : {code: 1109, message: "Attempt to directly call unbound function %1 from method %2."},
        //  CannotExtendError                    : {code: 1110, message: "%1 cannot extend %2."},
        //  CannotImplementError                 : {code: 1111, message: "%1 cannot implement %2."},
        //  CoerceArgumentCountError             : {code: 1112, message: "Argument count mismatch on class coercion.  Expected 1, got %1."},
        //  InvalidNewActivationError            : {code: 1113, message: "OP_newactivation used in method without NEED_ACTIVATION flag."},
        //  NoGlobalScopeError                   : {code: 1114, message: "OP_getglobalslot or OP_setglobalslot used with no global scope."},
        //  NotConstructorError                  : {code: 1115, message: "%1 is not a constructor."},
        //  ApplyError                           : {code: 1116, message: "second argument to Function.prototype.apply must be an array."},
        XMLInvalidName: { code: 1117, message: "Invalid XML name: %1." },
        XMLIllegalCyclicalLoop: { code: 1118, message: "Illegal cyclical loop between nodes." },
        //  DeleteTypeError                      : {code: 1119, message: "Delete operator is not supported with operand of type %1."},
        //  DeleteSealedError                    : {code: 1120, message: "Cannot delete property %1 on %2."},
        //  DuplicateMethodBodyError             : {code: 1121, message: "Method %1 has a duplicate method body."},
        //  IllegalInterfaceMethodBodyError      : {code: 1122, message: "Interface method %1 has illegal method body."},
        FilterError: { code: 1123, message: "Filter operator not supported on type %1." },
        //  InvalidHasNextError                  : {code: 1124, message: "OP_hasnext2 requires object and index to be distinct registers."},
        OutOfRangeError: { code: 1125, message: "The index %1 is out of range %2." },
        VectorFixedError: { code: 1126, message: "Cannot change the length of a fixed Vector." },
        TypeAppOfNonParamType: { code: 1127, message: "Type application attempted on a non-parameterized type." },
        WrongTypeArgCountError: { code: 1128, message: "Incorrect number of type parameters for %1. Expected %2, got %3." },
        JSONCyclicStructure: { code: 1129, message: "Cyclic structure cannot be converted to JSON string." },
        JSONInvalidReplacer: { code: 1131, message: "Replacer argument to JSON stringifier must be an array or a two parameter function." },
        JSONInvalidParseInput: { code: 1132, message: "Invalid JSON parse input." },
        //  FileOpenError                        : {code: 1500, message: "Error occurred opening file %1."},
        //  FileWriteError                       : {code: 1501, message: "Error occurred writing to file %1."},
        //  ScriptTimeoutError                   : {code: 1502, message: "A script has executed for longer than the default timeout period of 15 seconds."},
        //  ScriptTerminatedError                : {code: 1503, message: "A script failed to exit after 30 seconds and was terminated."},
        //  EndOfFileError                       : {code: 1504, message: "End of file."},
        //  StringIndexOutOfBoundsError          : {code: 1505, message: "The string index %1 is out of bounds; must be in range %2 to %3."},
        InvalidRangeError: { code: 1506, message: "The specified range is invalid." },
        NullArgumentError: { code: 1507, message: "Argument %1 cannot be null." },
        InvalidArgumentError: { code: 1508, message: "The value specified for argument %1 is invalid." },
        ArrayFilterNonNullObjectError: { code: 1510, message: "When the callback argument is a method of a class, the optional this argument must be null." },
        InvalidParamError: { code: 2004, message: "One of the parameters is invalid." },
        ParamRangeError: { code: 2006, message: "The supplied index is out of bounds." },
        NullPointerError: { code: 2007, message: "Parameter %1 must be non-null." },
        InvalidEnumError: { code: 2008, message: "Parameter %1 must be one of the accepted values." },
        CantInstantiateError: { code: 2012, message: "%1 class cannot be instantiated." },
        InvalidBitmapData: { code: 2015, message: "Invalid BitmapData." },
        EOFError: { code: 2030, message: "End of file was encountered.", fqn: 'flash.errors.EOFError' },
        CompressedDataError: { code: 2058, message: "There was an error decompressing the data.", fqn: 'flash.errors.IOError' },
        EmptyStringError: { code: 2085, message: "Parameter %1 must be non-empty string." },
        ProxyGetPropertyError: { code: 2088, message: "The Proxy class does not implement getProperty. It must be overridden by a subclass." },
        ProxySetPropertyError: { code: 2089, message: "The Proxy class does not implement setProperty. It must be overridden by a subclass." },
        ProxyCallPropertyError: { code: 2090, message: "The Proxy class does not implement callProperty. It must be overridden by a subclass." },
        ProxyHasPropertyError: { code: 2091, message: "The Proxy class does not implement hasProperty. It must be overridden by a subclass." },
        ProxyDeletePropertyError: { code: 2092, message: "The Proxy class does not implement deleteProperty. It must be overridden by a subclass." },
        ProxyGetDescendantsError: { code: 2093, message: "The Proxy class does not implement getDescendants. It must be overridden by a subclass." },
        ProxyNextNameIndexError: { code: 2105, message: "The Proxy class does not implement nextNameIndex. It must be overridden by a subclass." },
        ProxyNextNameError: { code: 2106, message: "The Proxy class does not implement nextName. It must be overridden by a subclass." },
        ProxyNextValueError: { code: 2107, message: "The Proxy class does not implement nextValue. It must be overridden by a subclass." },
        //  InvalidArrayLengthError              : {code: 2108, message: "The value %1 is not a valid Array length."},
        //  ReadExternalNotImplementedError      : {code: 2173, message: "Unable to read object in stream.  The class %1 does not implement flash.utils.IExternalizable but is aliased to an externalizable class."},
        /**
         * Player Error Codes
         */
        //  NoSecurityContextError                                    : { code: 2000, message: "No active security context."},
        TooFewArgumentsError: { code: 2001, message: "Too few arguments were specified; got %1, %2 expected." },
        //  InvalidSocketError                                        : { code: 2002, message: "Operation attempted on invalid socket."},
        //  InvalidSocketPortError                                    : { code: 2003, message: "Invalid socket port number specified."},
        ParamTypeError: { code: 2005, message: "Parameter %1 is of the incorrect type. Should be type %2." },
        //  HasStyleSheetError                                        : { code: 2009, message: "This method cannot be used on a text field with a style sheet."},
        //  SocketLocalFileSecurityError                              : { code: 2010, message: "Local-with-filesystem SWF files are not permitted to use sockets."},
        SocketConnectError: { code: 2011, message: "Socket connection failed to %1:%2." },
        //  AuthoringOnlyFeatureError                                 : { code: 2013, message: "Feature can only be used in Flash Authoring."},
        //  FeatureNotAvailableError                                  : { code: 2014, message: "Feature is not available at this time."},
        //  InvalidBitmapDataError                                    : { code: 2015, message: "Invalid BitmapData."},
        //  SystemExitSecurityError                                   : { code: 2017, message: "Only trusted local files may cause the Flash Player to exit."},
        //  SystemExitUnsupportedError                                : { code: 2018, message: "System.exit is only available in the standalone Flash Player."},
        //  InvalidDepthError                                         : { code: 2019, message: "Depth specified is invalid."},
        //  MovieClipSwapError                                        : { code: 2020, message: "MovieClips objects with different parents cannot be swapped."},
        //  ObjectCreationError                                       : { code: 2021, message: "Object creation failed."},
        //  NotDisplayObjectError                                     : { code: 2022, message: "Class %1 must inherit from DisplayObject to link to a symbol."},
        //  NotSpriteError                                            : { code: 2023, message: "Class %1 must inherit from Sprite to link to the root."},
        CantAddSelfError: { code: 2024, message: "An object cannot be added as a child of itself." },
        NotAChildError: { code: 2025, message: "The supplied DisplayObject must be a child of the caller." },
        //  NavigateURLError                                          : { code: 2026, message: "An error occurred navigating to the URL %1."},
        //  MustBeNonNegativeError                                    : { code: 2027, message: "Parameter %1 must be a non-negative number; got %2."},
        //  LocalSecurityError                                        : { code: 2028, message: "Local-with-filesystem SWF file %1 cannot access Internet URL %2."},
        //  InvalidStreamError                                        : { code: 2029, message: "This URLStream object does not have a stream opened."},
        //  SocketError                                               : { code: 2031, message: "Socket Error."},
        //  StreamError                                               : { code: 2032, message: "Stream Error."},
        //  KeyGenerationError                                        : { code: 2033, message: "Key Generation Failed."},
        //  InvalidKeyError                                           : { code: 2034, message: "An invalid digest was supplied."},
        //  URLNotFoundError                                          : { code: 2035, message: "URL Not Found."},
        //  LoadNeverCompletedError                                   : { code: 2036, message: "Load Never Completed."},
        //  InvalidCallError                                          : { code: 2037, message: "Functions called in incorrect sequence, or earlier call was unsuccessful."},
        //  FileIOError                                               : { code: 2038, message: "File I/O Error."},
        //  RemoteURLError                                            : { code: 2039, message: "Invalid remote URL protocol. The remote URL protocol must be HTTP or HTTPS."},
        //  BrowseInProgressError                                     : { code: 2041, message: "Only one file browsing session may be performed at a time."},
        //  DigestNotSupportedError                                   : { code: 2042, message: "The digest property is not supported by this load operation."},
        UnhandledError: { code: 2044, message: "Unhandled %1:." },
        //  FileVerificationError                                     : { code: 2046, message: "The loaded file did not have a valid signature."},
        //  DisplayListSecurityError                                  : { code: 2047, message: "Security sandbox violation: %1: %2 cannot access %3."},
        //  DownloadSecurityError                                     : { code: 2048, message: "Security sandbox violation: %1 cannot load data from %2."},
        //  UploadSecurityError                                       : { code: 2049, message: "Security sandbox violation: %1 cannot upload data to %2."},
        //  OutboundScriptingSecurityError                            : { code: 2051, message: "Security sandbox violation: %1 cannot evaluate scripting URLs within %2 (allowScriptAccess is %3). Attempted URL was %4."},
        AllowDomainArgumentError: { code: 2052, message: "Only String arguments are permitted for allowDomain and allowInsecureDomain." },
        //  IntervalSecurityError                                     : { code: 2053, message: "Security sandbox violation: %1 cannot clear an interval timer set by %2."},
        //  ExactSettingsError                                        : { code: 2054, message: "The value of Security.exactSettings cannot be changed after it has been used."},
        //  PrintJobStartError                                        : { code: 2055, message: "The print job could not be started."},
        //  PrintJobSendError                                         : { code: 2056, message: "The print job could not be sent to the printer."},
        //  PrintJobAddPageError                                      : { code: 2057, message: "The page could not be added to the print job."},
        //  ExternalCallbackSecurityError                             : { code: 2059, message: "Security sandbox violation: %1 cannot overwrite an ExternalInterface callback added by %2."},
        //  ExternalInterfaceSecurityError                            : { code: 2060, message: "Security sandbox violation: ExternalInterface caller %1 cannot access %2."},
        //  ExternalInterfaceNoCallbackError                          : { code: 2061, message: "No ExternalInterface callback %1 registered."},
        //  NoCloneMethodError                                        : { code: 2062, message: "Children of Event must override clone() {return new MyEventClass (...);}."},
        //  IMEError                                                  : { code: 2063, message: "Error attempting to execute IME command."},
        //  FocusNotSetError                                          : { code: 2065, message: "The focus cannot be set for this target."},
        DelayRangeError: { code: 2066, message: "The Timer delay specified is out of range." },
        ExternalInterfaceNotAvailableError: { code: 2067, message: "The ExternalInterface is not available in this container. ExternalInterface requires Internet Explorer ActiveX, Firefox, Mozilla 1.7.5 and greater, or other browsers that support NPRuntime." },
        //  InvalidSoundError                                         : { code: 2068, message: "Invalid sound."},
        InvalidLoaderMethodError: { code: 2069, message: "The Loader class does not implement this method." },
        //  StageOwnerSecurityError                                   : { code: 2070, message: "Security sandbox violation: caller %1 cannot access Stage owned by %2."},
        InvalidStageMethodError: { code: 2071, message: "The Stage class does not implement this property or method." },
        //  ProductManagerDiskError                                   : { code: 2073, message: "There was a problem saving the application to disk."},
        //  ProductManagerStageError                                  : { code: 2074, message: "The stage is too small to fit the download ui."},
        //  ProductManagerVerifyError                                 : { code: 2075, message: "The downloaded file is invalid."},
        //  FilterFailedError                                         : { code: 2077, message: "This filter operation cannot be performed with the specified input parameters."},
        TimelineObjectNameSealedError: { code: 2078, message: "The name property of a Timeline-placed object cannot be modified." },
        //  BitmapNotAssociatedWithBitsCharError                      : { code: 2079, message: "Classes derived from Bitmap can only be associated with defineBits characters (bitmaps)."},
        AlreadyConnectedError: { code: 2082, message: "Connect failed because the object is already connected." },
        CloseNotConnectedError: { code: 2083, message: "Close failed because the object is not connected." },
        ArgumentSizeError: { code: 2084, message: "The AMF encoding of the arguments cannot exceed 40K." },
        //  FileReferenceProhibitedError                              : { code: 2086, message: "A setting in the mms.cfg file prohibits this FileReference request."},
        //  DownloadFileNameProhibitedError                           : { code: 2087, message: "The FileReference.download() file name contains prohibited characters."},
        //  EventDispatchRecursionError                               : { code: 2094, message: "Event dispatch recursion overflow."},
        AsyncError: { code: 2095, message: "%1 was unable to invoke callback %2." },
        //  DisallowedHTTPHeaderError                                 : { code: 2096, message: "The HTTP request header %1 cannot be set via ActionScript."},
        //  FileFilterError                                           : { code: 2097, message: "The FileFilter Array is not in the correct format."},
        LoadingObjectNotSWFError: { code: 2098, message: "The loading object is not a .swf file, you cannot request SWF properties from it." },
        LoadingObjectNotInitializedError: { code: 2099, message: "The loading object is not sufficiently loaded to provide this information." },
        //  EmptyByteArrayError                                       : { code: 2100, message: "The ByteArray parameter in Loader.loadBytes() must have length greater than 0."},
        DecodeParamError: { code: 2101, message: "The String passed to URLVariables.decode() must be a URL-encoded query string containing name/value pairs." },
        //  NotAnXMLChildError                                        : { code: 2102, message: "The before XMLNode parameter must be a child of the caller."},
        //  XMLRecursionError                                         : { code: 2103, message: "XML recursion failure: new child would create infinite loop."},
        SceneNotFoundError: { code: 2108, message: "Scene %1 was not found." },
        FrameLabelNotFoundError: { code: 2109, message: "Frame label %1 not found in scene %2." },
        //  DisableAVM1LoadingError                                   : { code: 2110, message: "The value of Security.disableAVM1Loading cannot be set unless the caller can access the stage and is in an ActionScript 3.0 SWF file."},
        //  AVM1LoadingError                                          : { code: 2111, message: "Security.disableAVM1Loading is true so the current load of the ActionScript 1.0/2.0 SWF file has been blocked."},
        //  ApplicationDomainSecurityError                            : { code: 2112, message: "Provided parameter LoaderContext.ApplicationDomain is from a disallowed domain."},
        //  SecurityDomainSecurityError                               : { code: 2113, message: "Provided parameter LoaderContext.SecurityDomain is from a disallowed domain."},
        //  NonNullPointerError                                       : { code: 2114, message: "Parameter %1 must be null."},
        //  TrueParamError                                            : { code: 2115, message: "Parameter %1 must be false."},
        //  FalseParamError                                           : { code: 2116, message: "Parameter %1 must be true."},
        InvalidLoaderInfoMethodError: { code: 2118, message: "The LoaderInfo class does not implement this method." },
        //  LoaderInfoAppDomainSecurityError                          : { code: 2119, message: "Security sandbox violation: caller %1 cannot access LoaderInfo.applicationDomain owned by %2."},
        SecuritySwfNotAllowedError: { code: 2121, message: "Security sandbox violation: %1: %2 cannot access %3. This may be worked around by calling Security.allowDomain." },
        //  SecurityNonSwfIncompletePolicyFilesError                  : { code: 2122, message: "Security sandbox violation: %1: %2 cannot access %3. A policy file is required, but the checkPolicyFile flag was not set when this media was loaded."},
        //  SecurityNonSwfNotAllowedError                             : { code: 2123, message: "Security sandbox violation: %1: %2 cannot access %3. No policy files granted access."},
        UnknownFileTypeError: { code: 2124, message: "Loaded file is an unknown type." },
        //  SecurityCrossVMNotAllowedError                            : { code: 2125, message: "Security sandbox violation: %1 cannot use Runtime Shared Library %2 because crossing the boundary between ActionScript 3.0 and ActionScript 1.0/2.0 objects is not allowed."},
        //  NotConnectedError                                         : { code: 2126, message: "NetConnection object must be connected."},
        //  FileRefBadPostDataTypeError                               : { code: 2127, message: "FileReference POST data cannot be type ByteArray."},
        //  NetConnectionConnectError                                 : { code: 2129, message: "Connection to %1 failed."},
        //  SharedObjectFlushFailedError                              : { code: 2130, message: "Unable to flush SharedObject."},
        //  DefinitionNotFoundError                                   : { code: 2131, message: "Definition %1 cannot be found."},
        //  NetConnectionInvalidConnectFromNetStatusEventError        : { code: 2132, message: "NetConnection.connect cannot be called from a netStatus event handler."},
        //  CallbackNotRegisteredError                                : { code: 2133, message: "Callback %1 is not registered."},
        //  SharedObjectCreateError                                   : { code: 2134, message: "Cannot create SharedObject."},
        //  InvalidSWFError                                           : { code: 2136, message: "The SWF file %1 contains invalid data."},
        //  NavigationSecurityError                                   : { code: 2137, message: "Security sandbox violation: %1 cannot navigate window %2 within %3 (allowScriptAccess is %4). Attempted URL was %5."},
        //  NonParsableRichTextXMLError                               : { code: 2138, message: "Rich text XML could not be parsed."},
        //  SharedObjectConnectError                                  : { code: 2139, message: "SharedObject could not connect."},
        //  LocalSecurityLoadingError                                 : { code: 2140, message: "Security sandbox violation: %1 cannot load %2. Local-with-filesystem and local-with-networking SWF files cannot load each other."},
        //  MultiplePrintJobsError                                    : { code: 2141, message: "Only one PrintJob may be in use at a time."},
        //  LocalImportSecurityError                                  : { code: 2142, message: "Security sandbox violation: local SWF files cannot use the LoaderContext.sec property. %1 was attempting to load %2."},
        //  AccOverrideRole                                           : { code: 2143, message: "AccessibilityImplementation.get_accRole() must be overridden from its default."},
        //  AccOverrideState                                          : { code: 2144, message: "AccessibilityImplementation.get_accState() must be overridden from its default."},
        //  URLRequestHeaderInvalidLengthError                        : { code: 2145, message: "Cumulative length of requestHeaders must be less than 8192 characters."},
        //  AllowNetworkingSecurityError                              : { code: 2146, message: "Security sandbox violation: %1 cannot call %2 because the HTML/container parameter allowNetworking has the value %3."},
        //  ForbiddenProtocolError                                    : { code: 2147, message: "Forbidden protocol in URL %1."},
        //  RemoteToLocalSecurityError                                : { code: 2148, message: "SWF file %1 cannot access local resource %2. Only local-with-filesystem and trusted local SWF files may access local resources."},
        //  FsCommandSecurityError                                    : { code: 2149, message: "Security sandbox violation: %1 cannot make fscommand calls to %2 (allowScriptAccess is %3)."},
        CantAddParentError: { code: 2150, message: "An object cannot be added as a child to one of it's children (or children's children, etc.)." },
        //  FullScreenSecurityError                                   : { code: 2151, message: "You cannot enter full screen mode when the settings dialog is visible."},
        //  FullScreenNotAllowedError                                 : { code: 2152, message: "Full screen mode is not allowed."},
        //  URLRequestInvalidHeader                                   : { code: 2153, message: "The URLRequest.requestHeaders array must contain only non-NULL URLRequestHeader objects."},
        //  InvalidNetStreamObject                                    : { code: 2154, message: "The NetStream Object is invalid.  This may be due to a failed NetConnection."},
        //  InvalidFunctionName                                       : { code: 2155, message: "The ExternalInterface.call functionName parameter is invalid.  Only alphanumeric characters are supported."},
        //  ForbiddenPortForProtocolError                             : { code: 2156, message: "Port %1 may not be accessed using protocol %2. Calling SWF was %3."},
        //  NoAsfunctionErrror                                        : { code: 2157, message: "Rejecting URL %1 because the 'asfunction:' protocol may only be used for link targets, not for networking APIs."},
        //  InvalidNetConnectionObject                                : { code: 2158, message: "The NetConnection Object is invalid.  This may be due to a dropped NetConnection."},
        //  InvalidSharedObject                                       : { code: 2159, message: "The SharedObject Object is invalid."},
        //  InvalidTextLineError                                      : { code: 2160, message: "The TextLine is INVALID and cannot be used to access the current state of the TextBlock."},
        //  TextLayoutError                                           : { code: 2161, message: "An internal error occured while laying out the text."},
        //  FragmentOutputType                                        : { code: 2162, message: "The Shader output type is not compatible for this operation."},
        //  FragmentInputType                                         : { code: 2163, message: "The Shader input type %1 is not compatible for this operation."},
        //  FragmentInputMissing                                      : { code: 2164, message: "The Shader input %1 is missing or an unsupported type."},
        //  FragmentInputTooSmall                                     : { code: 2165, message: "The Shader input %1 does not have enough data."},
        //  FragmentInputNoDimension                                  : { code: 2166, message: "The Shader input %1 lacks valid dimensions."},
        //  FragmentNotEnoughInput                                    : { code: 2167, message: "The Shader does not have the required number of inputs for this operation."},
        //  StaticTextLineError                                       : { code: 2168, message: "Static text lines have no atoms and no reference to a text block."},
        //  SecurityQuestionableBrowserScriptingError                 : { code: 2169, message: "The method %1 may not be used for browser scripting.  The URL %2 requested by %3 is being ignored.  If you intend to call browser script, use navigateToURL instead."},
        //  HeaderSecurityError                                       : { code: 2170, message: "Security sandbox violation: %1 cannot send HTTP headers to %2."},
        //  FragmentMissing                                           : { code: 2171, message: "The Shader object contains no byte code to execute."},
        //  FragmentAlreadyRunning                                    : { code: 2172, message: "The ShaderJob is already running or finished."},
        //  FileReferenceBusyError                                    : { code: 2174, message: "Only one download, upload, load or save operation can be active at a time on each FileReference."},
        //  UnformattedElementError                                   : { code: 2175, message: "One or more elements of the content of the TextBlock has a null ElementFormat."},
        //  UserActionRequiredError                                   : { code: 2176, message: "Certain actions, such as those that display a pop-up window, may only be invoked upon user interaction, for example by a mouse click or button press."},
        //  FragmentInputTooLarge                                     : { code: 2177, message: "The Shader input %1 is too large."},
        //  ClipboardConstNotAllowed                                  : { code: 2178, message: "The Clipboard.generalClipboard object must be used instead of creating a new Clipboard."},
        //  ClipboardDisallowedRead                                   : { code: 2179, message: "The Clipboard.generalClipboard object may only be read while processing a flash.events.Event.PASTE event."},
        //  CantMoveAVM1ContentLoadedIntoAVM2                         : { code: 2180, message: "It is illegal to move AVM1 content (AS1 or AS2) to a different part of the displayList when it has been loaded into AVM2 (AS3) content."},
        //  InvalidTextLineMethodError                                : { code: 2181, message: "The TextLine class does not implement this property or method."},
        //  PerspectiveFieldOfViewValueInvalid                        : { code: 2182, message: "Invalid fieldOfView value.  The value must be greater than 0 and less than 180."},
        //  Invalid3DScale                                            : { code: 2183, message: "Scale values must not be zero."},
        //  LockedElementFormatError                                  : { code: 2184, message: "The ElementFormat object is locked and cannot be modified."},
        //  LockedFontDescriptionError                                : { code: 2185, message: "The FontDescription object is locked and cannot be modified."},
        //  PerspectiveFocalLengthInvalid                             : { code: 2186, message: "Invalid focalLength %1."},
        //  Matrix3DDecomposeTypeInvalid                              : { code: 2187, message: "Invalid orientation style %1.  Value must be one of 'Orientation3D.EULER_ANGLES', 'Orientation3D.AXIS_ANGLE', or 'Orientation3D.QUATERNION'."},
        //  MatrixNonInvertibleError                                  : { code: 2188, message: "Invalid raw matrix. Matrix must be invertible."},
        Matrix3DRefCannontBeShared: { code: 2189, message: "A Matrix3D can not be assigned to more than one DisplayObject." },
        //  ForceDownloadSecurityError                                : { code: 2190, message: "The attempted load of %1 failed as it had a Content-Disposition of attachment set."},
        //  ClipboardDisallowedWrite                                  : { code: 2191, message: "The Clipboard.generalClipboard object may only be written to as the result of user interaction, for example by a mouse click or button press."},
        //  MalformedUnicodeError                                     : { code: 2192, message: "An unpaired Unicode surrogate was encountered in the input."},
        //  SecurityContentAccessDeniedError                          : { code: 2193, message: "Security sandbox violation: %1: %2 cannot access %3."},
        //  LoaderParamError                                          : { code: 2194, message: "Parameter %1 cannot be a Loader."},
        //  LoaderAsyncError                                          : { code: 2195, message: "Error thrown as Loader called %1."},
        ObjectWithStringsParamError: { code: 2196, message: "Parameter %1 must be an Object with only String values." },
        //  SystemUpdaterPlayerNotSupportedError                      : { code: 2200, message: "The SystemUpdater class is not supported by this player."},
        //  SystemUpdaterOSNotSupportedError                          : { code: 2201, message: "The requested update type is not supported on this operating system."},
        //  SystemUpdaterBusy                                         : { code: 2202, message: "Only one SystemUpdater action is allowed at a time."},
        //  SystemUpdaterFailed                                       : { code: 2203, message: "The requested SystemUpdater action cannot be completed."},
        //  SystemUpdaterCannotCancel                                 : { code: 2204, message: "This operation cannot be canceled because it is waiting for user interaction."},
        //  SystemUpdaterUnknownTarget                                : { code: 2205, message: "Invalid update type %1."},
        //  SignedSWfLoadingError                                     : { code: 2500, message: "An error occurred decrypting the signed swf file. The swf will not be loaded."},
        //  NotScreenSharingError                                     : { code: 2501, message: "This property can only be accessed during screen sharing."},
        //  NotSharingMonitorError                                    : { code: 2502, message: "This property can only be accessed if sharing the entire screen."},
        //  FileBadPathName                                           : { code: 3000, message: "Illegal path name."},
        //  FileAccessDenied                                          : { code: 3001, message: "File or directory access denied."},
        //  FileExists                                                : { code: 3002, message: "File or directory exists."},
        //  FileDoesNotExist                                          : { code: 3003, message: "File or directory does not exist."},
        //  FileInsufficientSpace                                     : { code: 3004, message: "Insufficient file space."},
        //  FileSystemResources                                       : { code: 3005, message: "Insufficient system resources."},
        //  FileNotAFile                                              : { code: 3006, message: "Not a file."},
        //  FileNotADir                                               : { code: 3007, message: "Not a directory."},
        //  FileReadOnlyFileSys                                       : { code: 3008, message: "Read-only or write-protected media."},
        //  FileNotSameDevice                                         : { code: 3009, message: "Cannot move file or directory to a different device."},
        //  DirNotEmpty                                               : { code: 3010, message: "Directory is not empty."},
        //  FileDestinationExists                                     : { code: 3011, message: "Move or copy destination already exists."},
        //  FileCantDelete                                            : { code: 3012, message: "Cannot delete file or directory."},
        //  FileInUse                                                 : { code: 3013, message: "File or directory is in use."},
        //  FileCopyMoveAncestor                                      : { code: 3014, message: "Cannot copy or move a file or directory to overwrite a containing directory."},
        //  LoadBytesCodeExecutionSecurityError                       : { code: 3015, message: "Loader.loadBytes() is not permitted to load content with executable code."},
        //  FileApplicationNotFound                                   : { code: 3016, message: "No application was found that can open this file."},
        //  SQLConnectionCannotClose                                  : { code: 3100, message: "A SQLConnection cannot be closed while statements are still executing."},
        //  SQLConnectionAlreadyOpen                                  : { code: 3101, message: "Database connection is already open."},
        //  SQLConnectionInvalidName                                  : { code: 3102, message: "Name argument specified was invalid. It must not be null or empty."},
        //  SQLConnectionInTransaction                                : { code: 3103, message: "Operation cannot be performed while there is an open transaction on this connection."},
        //  SQLConnectionNotOpen                                      : { code: 3104, message: "A SQLConnection must be open to perform this operation."},
        //  SQLConnectionNoOpenTransaction                            : { code: 3105, message: "Operation is only allowed if a connection has an open transaction."},
        //  SQLStatementIsExecutingProperty                           : { code: 3106, message: "Property cannot be changed while SQLStatement.executing is true."},
        //  SQLStatementIvalidCall                                    : { code: 3107, message: "%1 may not be called unless SQLResult.complete is false."},
        //  SQLStatementInvalidText                                   : { code: 3108, message: "Operation is not permitted when the SQLStatement.text property is not set."},
        //  SQLStatementInvalidConnection                             : { code: 3109, message: "Operation is not permitted when the SQLStatement.sqlConnection property is not set."},
        //  SQLStatementIsExecutingCall                               : { code: 3110, message: "Operation cannot be performed while SQLStatement.executing is true."},
        //  SQLStatementInvalidSchemaType                             : { code: 3111, message: "An invalid schema type was specified."},
        //  SQLConnectionInvalidLockType                              : { code: 3112, message: "An invalid transaction lock type was specified."},
        //  SQLConnectionNotFileReference                             : { code: 3113, message: "Reference specified is not of type File."},
        //  SQLConnectionInvalidModeSpecified                         : { code: 3114, message: "An invalid open mode was specified."},
        //  SQLGeneralEngineError                                     : { code: 3115, message: "SQL Error."},
        //  SQLInternalEngineError                                    : { code: 3116, message: "An internal logic error occurred."},
        //  SQLPermissionError                                        : { code: 3117, message: "Access permission denied."},
        //  SQLOperationAbortedError                                  : { code: 3118, message: "Operation aborted."},
        //  SQLDatabaseLockedError                                    : { code: 3119, message: "Database file is currently locked."},
        //  SQLTableLockedError                                       : { code: 3120, message: "Table is locked."},
        //  SQLOutOfMemoryError                                       : { code: 3121, message: "Out of memory."},
        //  SQLDatabaseIsReadonlyError                                : { code: 3122, message: "Attempt to write a readonly database."},
        //  SQLDatabaseCorruptError                                   : { code: 3123, message: "Database disk image is malformed."},
        //  SQLDatabaseFullError                                      : { code: 3124, message: "Insertion failed because database is full."},
        //  SQLCannotOpenDatabaseError                                : { code: 3125, message: "Unable to open the database file."},
        //  SQLLockingProtocolError                                   : { code: 3126, message: "Database lock protocol error."},
        //  SQLDatabaseEmptyError                                     : { code: 3127, message: "Database is empty."},
        //  SQLDiskIOError                                            : { code: 3128, message: "Disk I/O error occurred."},
        //  SQLSchemaChangedError                                     : { code: 3129, message: "The database schema changed."},
        //  SQLTooMuchDataError                                       : { code: 3130, message: "Too much data for one row of a table."},
        //  SQLConstraintError                                        : { code: 3131, message: "Abort due to constraint violation."},
        //  SQLDataTypeMismatchError                                  : { code: 3132, message: "Data type mismatch."},
        //  SQLConcurrencyError                                       : { code: 3133, message: "An internal error occurred."},
        //  SQLNotSupportedOnOSError                                  : { code: 3134, message: "Feature not supported on this operating system."},
        //  SQLAuthorizationDeniedError                               : { code: 3135, message: "Authorization denied."},
        //  SQLAuxDatabaseFormatError                                 : { code: 3136, message: "Auxiliary database format error."},
        //  SQLBindingRangeError                                      : { code: 3137, message: "An index specified for a parameter was out of range."},
        //  SQLInvalidDatabaseFileError                               : { code: 3138, message: "File opened is not a database file."},
        //  SQLInvalidPageSizeError                                   : { code: 3139, message: "The page size specified was not valid for this operation."},
        //  SQLInvalidKeySizeError                                    : { code: 3140, message: "The encryption key size specified was not valid for this operation. Keys must be exactly 16 bytes in length"},
        //  SQLInvalidConfigurationError                              : { code: 3141, message: "The requested database configuration is not supported."},
        //  SQLCannotRekeyNonKeyedDatabase                            : { code: 3143, message: "Unencrypted databases may not be reencrypted."},
        //  NativeWindowClosedError                                   : { code: 3200, message: "Cannot perform operation on closed window."},
        //  PDFNoReaderInstalled                                      : { code: 3201, message: "Adobe Reader cannot be found."},
        //  PDFOldReaderInstalled                                     : { code: 3202, message: "Adobe Reader 8.1 or later cannot be found."},
        //  PDFOldDefaultText                                         : { code: 3203, message: "Default Adobe Reader must be version 8.1 or later."},
        //  PDFCannotLoadReader                                       : { code: 3204, message: "An error ocurred trying to load Adobe Reader."},
        //  ApplicationFeatureSecurityError                           : { code: 3205, message: "Only application-sandbox content can access this feature."},
        //  LoaderInfoDoorSecurityError                               : { code: 3206, message: "Caller %1 cannot set LoaderInfo property %2."},
        //  ApplicationNonFeatureSecurityError                        : { code: 3207, message: "Application-sandbox content cannot access this feature."},
        //  InvalidClipboardAccess                                    : { code: 3208, message: "Attempt to access invalid clipboard."},
        //  DeadClipboardAccess                                       : { code: 3209, message: "Attempt to access dead clipboard."},
        //  DeadJavaScriptObjectAccess                                : { code: 3210, message: "The application attempted to reference a JavaScript object in a HTML page that is no longer loaded."},
        //  FilePromiseIOError                                        : { code: 3211, message: "Drag and Drop File Promise error: %1"},
        //  NativeProcessNotRunning                                   : { code: 3212, message: "Cannot perform operation on a NativeProcess that is not running."},
        //  NativeProcessAlreadyRunning                               : { code: 3213, message: "Cannot perform operation on a NativeProcess that is already running."},
        //  NativeProcessBadExecutable                                : { code: 3214, message: "NativeProcessStartupInfo.executable does not specify a valid executable file."},
        //  NativeProcessBadWorkingDirectory                          : { code: 3215, message: "NativeProcessStartupInfo.workingDirectory does not specify a valid directory."},
        //  NativeProcessStdOutReadError                              : { code: 3216, message: "Error while reading data from NativeProcess.standardOutput."},
        //  NativeProcessStdErrReadError                              : { code: 3217, message: "Error while reading data from NativeProcess.standardError."},
        //  NativeProcessStdInWriteError                              : { code: 3218, message: "Error while writing data to NativeProcess.standardInput."},
        //  NativeProcessNotStarted                                   : { code: 3219, message: "The NativeProcess could not be started. '%1'"},
        //  ActionNotAllowedSecurityError                             : { code: 3220, message: "Action '%1' not allowed in current security context '%2'."},
        //  SWFNoPlayerInstalled                                      : { code: 3221, message: "Adobe Flash Player cannot be found."},
        //  SWFOldPlayerInstalled                                     : { code: 3222, message: "The installed version of Adobe Flash Player is too old."},
        //  DNSResolverLookupError                                    : { code: 3223, message: "DNS lookup error: platform error %1"},
        //  SocketMessageTooLongError                                 : { code: 3224, message: "Socket message too long"},
        //  SocketCannotSendDataToAddressAfterConnect                 : { code: 3225, message: "Cannot send data to a location when connected."},
        AllowCodeImportError: { code: 3226, message: "Cannot import a SWF file when LoaderContext.allowCodeImport is false." },
        //  BackgroundLaunchError                                     : { code: 3227, message: "Cannot launch another application from background."},
        //  StageWebViewLoadError                                     : { code: 3228, message: "StageWebView encountered an error during the load operation."},
        //  StageWebViewProtocolNotSupported                          : { code: 3229, message: "The protocol is not supported.:"},
        //  BrowseOperationUnsupported                                : { code: 3230, message: "The browse operation is unsupported."},
        //  InvalidVoucher                                            : { code: 3300, message: "Voucher is invalid."},
        //  AuthenticationFailed                                      : { code: 3301, message: "User authentication failed."},
        //  RequireSSLError                                           : { code: 3302, message: "Flash Access server does not support SSL."},
        //  ContentExpiredError                                       : { code: 3303, message: "Content expired."},
        //  AuthorizationFailed                                       : { code: 3304, message: "User authorization failed (for example, the user has not purchased the content)."},
        //  ServerConnectionFailed                                    : { code: 3305, message: "Can't connect to the server."},
        //  ClientUpdateRequired                                      : { code: 3306, message: "Client update required (Flash Access server requires new client)."},
        //  InternalError                                             : { code: 3307, message: "Generic internal Flash Access failure."},
        //  WrongVoucherKey                                           : { code: 3308, message: "Wrong voucher key."},
        //  CorruptedFLV                                              : { code: 3309, message: "Video content is corrupted."},
        //  AppIDMismatch                                             : { code: 3310, message: "The AIR application or Flash Player SWF does not match the one specified in the DRM policy."},
        //  AppVersionMismatch                                        : { code: 3311, message: "The version of the application does not match the one specified in the DRM policy."},
        //  VoucherIntegrityError                                     : { code: 3312, message: "Verification of voucher failed."},
        //  WriteFileSystemFailed                                     : { code: 3313, message: "Write to the file system failed."},
        //  FLVHeaderIntegrityFailed                                  : { code: 3314, message: "Verification of FLV/F4V header file failed."},
        PermissionDenied: { code: 3315, message: "The current security context does not allow this operation." },
        //  LocalConnectionUserScopedLocked                           : { code: 3316, message: "The value of LocalConnection.isPerUser cannot be changed because it has already been locked by a call to LocalConnection.connect, .send, or .close."},
        //  LoadAdobeCPFailed                                         : { code: 3317, message: "Failed to load Flash Access module."},
        //  IncompatibleAdobeCPVersion                                : { code: 3318, message: "Incompatible version of Flash Access module found."},
        //  MissingAdobeCPEntryPoint                                  : { code: 3319, message: "Missing Flash Access module API entry point."},
        //  InternalErrorHA                                           : { code: 3320, message: "Generic internal Flash Access failure."},
        //  IndividualizationFailed                                   : { code: 3321, message: "Individualization failed."},
        //  DeviceBindingFailed                                       : { code: 3322, message: "Device binding failed."},
        //  CorruptStore                                              : { code: 3323, message: "The internal stores are corrupted."},
        //  MachineTokenInvalid                                       : { code: 3324, message: "Reset license files and the client will fetch a new machine token."},
        //  CorruptServerStateStore                                   : { code: 3325, message: "Internal stores are corrupt."},
        //  TamperingDetected                                         : { code: 3326, message: "Call customer support."},
        //  ClockTamperingDetected                                    : { code: 3327, message: "Clock tampering detected."},
        //  ServerErrorTryAgain                                       : { code: 3328, message: "Server error; retry the request."},
        //  ApplicationSpecificError                                  : { code: 3329, message: "Error in application-specific namespace."},
        //  NeedAuthentication                                        : { code: 3330, message: "Need to authenticate the user and reacquire the voucher."},
        //  ContentNotYetValid                                        : { code: 3331, message: "Content is not yet valid."},
        //  CachedVoucherExpired                                      : { code: 3332, message: "Cached voucher has expired. Reacquire the voucher from the server."},
        //  PlaybackWindowExpired                                     : { code: 3333, message: "The playback window for this policy has expired."},
        //  InvalidDRMPlatform                                        : { code: 3334, message: "This platform is not allowed to play this content."},
        //  InvalidDRMVersion                                         : { code: 3335, message: "Invalid version of Flash Access module. Upgrade AIR or Flash Access module for the Flash Player."},
        //  InvalidRuntimePlatform                                    : { code: 3336, message: "This platform is not allowed to play this content."},
        //  InvalidRuntimeVersion                                     : { code: 3337, message: "Upgrade Flash Player or AIR  and retry playback."},
        //  UnknownConnectionType                                     : { code: 3338, message: "Unknown connection type."},
        //  NoAnalogPlaybackAllowed                                   : { code: 3339, message: "Can't play back on analog device. Connect to a digital device."},
        //  NoAnalogProtectionAvail                                   : { code: 3340, message: "Can't play back because connected analog device doesn't have the correct capabilities."},
        //  NoDigitalPlaybackAllowed                                  : { code: 3341, message: "Can't play back on digital device."},
        //  NoDigitalProtectionAvail                                  : { code: 3342, message: "The connected digital device doesn't have the correct capabilities."},
        InternalErrorIV: { code: 3343, message: "Internal Error." }
        //  MissingAdobeCPModule                                      : { code: 3344, message: "Missing Flash Access module."},
        //  DRMNoAccessError                                          : { code: 3345, message: "This operation is not permitted with content protected using Flash Access."},
        //  DRMDataMigrationFailed                                    : { code: 3346, message: "Failed migrating local DRM data, all locally cached DRM vouchers are lost."},
        //  DRMInsufficientDeviceCapabilites                          : { code: 3347, message: "The device does not meet the Flash Access server's playback device constraints."},
        //  DRMHardStopIntervalExpired                                : { code: 3348, message: "This protected content is expired."},
        //  DRMServerVersionTooHigh                                   : { code: 3349, message: "The Flash Access server is running at a version that's higher than the max supported by this runtime."},
        //  DRMServerVersionTooLow                                    : { code: 3350, message: "The Flash Access server is running at a version that's lower than the min supported by this runtime."},
        //  DRMDeviceGroupTokenInvalid                                : { code: 3351, message: "Device Group registration token is corrupted, please refresh the token by registering again to the DRMDeviceGroup."},
        //  DRMDeviceGroupTokenTooOld                                 : { code: 3352, message: "The server is using a newer version of the registration token for this Device Group. Please refresh the token by registering again to the DRMDeviceGroup."},
        //  DRMDeviceGroupTokenTooNew                                 : { code: 3353, message: "the server is using an older version of the registration token for this Device Group."},
        //  DRMDeviceGroupTokenExpired                                : { code: 3354, message: "Device Group registration is expired, please refresh the token by registering again to the DRMDeviceGroup."},
        //  JoinDRMDeviceGroupFailed                                  : { code: 3355, message: "The server denied this Device Group registration request."},
        //  DRMVoucherHasNoCorrespondingRoot                          : { code: 3356, message: "The root voucher for this content's DRMVoucher was not found."},
        //  NoValidEmbeddedDRMVoucher                                 : { code: 3357, message: "The DRMContentData provides no valid embedded voucher and no Flash Access server url to acquire the voucher from."},
        //  NoACPProtectionAvailable                                  : { code: 3358, message: "ACP protection is not available on the device but required to playback the content."},
        //  NoCGMSAProtectionAvailable                                : { code: 3359, message: "CGMSA protection is not available on the device but required to playback the content."},
        //  DRMDeviceGroupRegistrationRequired                        : { code: 3360, message: "Device Group registration is required before doing this operation."},
        //  DeviceIsNotRegisteredToDRMDeviceGroup                     : { code: 3361, message: "The device is not registered to this Device Group."},
        //  ScriptBridgeError                                         : { code: 3400, message: "An error occured while executing JavaScript code."},
        //  ScriptBridgeNameAccessSecurityError                       : { code: 3401, message: "Security sandbox violation: An object with this name has already been registered from another security domain."},
        //  ScriptBridgeBrowserAccessSecurityError                    : { code: 3402, message: "Security sandbox violation: Bridge caller %1 cannot access %2."},
        //  ExtensionContextNoSuchMethod                              : { code: 3500, message: "The extension context does not have a method with the name %1."},
        //  ExtensionContextAlreadyDisposed                           : { code: 3501, message: "The extension context has already been disposed."},
        //  ExtensionContextInvalidReturnValue                        : { code: 3502, message: "The extension returned an invalid value."},
        //  ExtensionContextInvalidState                              : { code: 3503, message: "The extension was left in an invalid state."},
        //  NoValidProgramSet                                         : { code: 3600, message: "No valid program set."},
        //  NoValidIndexBufferSet                                     : { code: 3601, message: "No valid index buffer set."},
        //  SanityCheckOnParametersFailed                             : { code: 3602, message: "Sanity check on parameters failed, %1 triangles and %2 index offset."},
        //  NotEnoughIndicesInThisBuffer                              : { code: 3603, message: "Not enough indices in this buffer. %1 triangles at offset %2, but there are only %3 indices in buffer."},
        //  SampleBindsTextureAlsoBoundToRender                       : { code: 3604, message: "Sampler %1 binds a texture that is also bound for render to texture."},
        //  SampleBindsInvalidTexture                                 : { code: 3605, message: "Sampler %1 binds an invalid texture."},
        //  SamplerFormatDoesNotMatchTextureFormat                    : { code: 3606, message: "Sampler %1 format does not match texture format."},
        //  StreamIsNotUsed                                           : { code: 3607, message: "Stream %1 is set but not used by the current vertex program."},
        //  StreamIsInvalid                                           : { code: 3608, message: "Stream %1 is invalid."},
        //  StreamDoesNotHaveEnoughVertices                           : { code: 3609, message: "Stream %1 does not have enough vertices."},
        //  StreamVertexOffsetOutOfBounds                             : { code: 3610, message: "Stream %1 vertex offset is out of bounds"},
        //  StreamReadButNotSet                                       : { code: 3611, message: "Stream %1 is read by the current vertex program but not set."},
        //  ProgramMustBeLittleEndian                                 : { code: 3612, message: "Programs must be in little endian format."},
        //  NativeShaderCompilationFailed                             : { code: 3613, message: "The native shader compilation failed."},
        //  NativeShaderCompilationFailedOpenGL                       : { code: 3614, message: "The native shader compilation failed.enGL specific: %1"},
        //  AgalProgramTooSmall                                       : { code: 3615, message: "AGAL validation failed: Program size below minimum length for %1 program."},
        //  NotAnAgalProgram                                          : { code: 3616, message: "AGAL validation failed: Not an AGAL program. Wrong magic byte for %1 program."},
        //  BadAgalVersion                                            : { code: 3617, message: "AGAL validation failed: Bad AGAL version for %1 program. Current version is %2."},
        //  BadAgalProgramType                                        : { code: 3618, message: "AGAL validation failed: Bad AGAL program type identifier for %1 program."},
        //  BadAgalShadertype                                         : { code: 3619, message: "AGAL validation failed: Shader type must be either fragment or vertex for %1 program."},
        //  InvalidAgalOpcodeOutOfRange                               : { code: 3620, message: "AGAL validation failed: Invalid opcode, value out of range: %2 at token %3 of %1 program."},
        //  InvalidAgalOpcodeNotImplemented                           : { code: 3621, message: "AGAL validation failed: Invalid opcode, %2 is not implemented in this version at token %3 of %1 program."},
        //  AgalOpcodeOnlyAllowedInFragmentProgram                    : { code: 3622, message: "AGAL validation failed: Opcode %2 only allowed in fragment programs at token %3 of %1 program."},
        //  OpenConditionNesting                                      : { code: 3623, message: "AGAL validation failed: Open condition nesting (close without open) at token %2 of %1 program."},
        //  ConditionNestingTooDeep                                   : { code: 3624, message: "AGAL validation failed: Condition nesting (%2) too deep at token %3 of %1 program."},
        //  BadAgalSourceOperands                                     : { code: 3625, message: "AGAL validation failed: Bad AGAL source operands. Both are constants (this must be precomputed) at token %2 of %1 program."},
        //  BothOperandsAreIndirectReads                              : { code: 3626, message: "AGAL validation failed: Opcode %2, both operands are indirect reads at token %3 of %1 program."},
        //  OpcodeDestinationMustBeAllZero                            : { code: 3627, message: "AGAL validation failed: Opcode %2 destination operand must be all zero at token %3 of %1 program."},
        //  OpcodeDestinationMustUseMask                              : { code: 3628, message: "AGAL validation failed: The destination operand for the %2 instruction must mask w (use .xyz or less) at token %3 of %1 program."},
        //  TooManyTokens                                             : { code: 3629, message: "AGAL validation failed: Too many tokens (%2) for %1 program."},
        //  FragmentShaderType                                        : { code: 3630, message: "Fragment shader type is not fragment."},
        //  VertexShaderType                                          : { code: 3631, message: "Vertex shader type is not vertex."},
        //  VaryingReadButNotWrittenTo                                : { code: 3632, message: "AGAL linkage: Varying %1 is read in the fragment shader but not written to by the vertex shader."},
        //  VaryingPartialWrite                                       : { code: 3633, message: "AGAL linkage: Varying %1 is only partially written to. Must write all four components."},
        //  FragmentWriteAllComponents                                : { code: 3634, message: "AGAL linkage: Fragment output needs to write to all components."},
        //  VertexWriteAllComponents                                  : { code: 3635, message: "AGAL linkage: Vertex output needs to write to all components."},
        //  UnusedOperand                                             : { code: 3636, message: "AGAL validation failed: Unused operand is not set to zero for %2 at token %3 of %1 program."},
        //  SamplerRegisterOnlyInFragment                             : { code: 3637, message: "AGAL validation failed: Sampler registers only allowed in fragment programs for %2 at token %3 of %1 program."},
        //  SamplerRegisterSecondOperand                              : { code: 3638, message: "AGAL validation failed: Sampler register only allowed as second operand in texture instructions for %2 at token %3 of %1 program."},
        //  IndirectOnlyAllowedInVertex                               : { code: 3639, message: "AGAL validation failed: Indirect addressing only allowed in vertex programs for %2 at token %3 of %1 program."},
        //  IndirectOnlyIntoConstantRegisters                         : { code: 3640, message: "AGAL validation failed: Indirect addressing only allowed into constant registers for %2 at token %3 of %1 program."},
        //  IndirectNotAllowed                                        : { code: 3641, message: "AGAL validation failed: Indirect addressing not allowed for this operand in this instruction for %2 at token %3 of %1 program."},
        //  IndirectSourceType                                        : { code: 3642, message: "AGAL validation failed: Indirect source type must be attribute, constant or temporary for %2 at token %3 of %1 program."},
        //  IndirectAddressingFieldsMustBeZero                        : { code: 3643, message: "AGAL validation failed: Indirect addressing fields must be zero for direct adressing for %2 at token %3 of %1 program."},
        //  VaryingRegistersOnlyReadInFragment                        : { code: 3644, message: "AGAL validation failed: Varying registers can only be read in fragment programs for %2 at token %3 of %1 program."},
        //  AttributeRegistersOnlyReadInVertex                        : { code: 3645, message: "AGAL validation failed: Attribute registers can only be read in vertex programs for %2 at token %3 of %1 program."},
        //  CanNotReadOutputRegister                                  : { code: 3646, message: "AGAL validation failed: Can not read from output register for %2 at token %3 of %1 program."},
        //  TempRegisterReadWithoutWrite                              : { code: 3647, message: "AGAL validation failed: Temporary register read without being written to for %2 at token %3 of %1 program."},
        //  TempRegisterComponentReadWithoutWrite                     : { code: 3648, message: "AGAL validation failed: Temporary register component read without being written to for %2 at token %3 of %1 program."},
        //  SamplerRegisterCannotBeWrittenTo                          : { code: 3649, message: "AGAL validation failed: Sampler registers can not be written to for %2 at token %3 of %1 program."},
        //  VaryingRegistersWrite                                     : { code: 3650, message: "AGAL validation failed: Varying registers can only be written in vertex programs for %2 at token %3 of %1 program."},
        //  AttributeRegisterCannotBeWrittenTo                        : { code: 3651, message: "AGAL validation failed: Attribute registers can not be written to for %2 at token %3 of %1 program."},
        //  ConstantRegisterCannotBeWrittenTo                         : { code: 3652, message: "AGAL validation failed: Constant registers can not be written to for %2 at token %3 of %1 program."},
        //  DestinationWritemaskIsZero                                : { code: 3653, message: "AGAL validation failed: Destination writemask is zero for %2 at token %3 of %1 program."},
        //  AGALReservedBitsShouldBeZero                              : { code: 3654, message: "AGAL validation failed: Reserve bits should be zero for %2 at token %3 of %1 program."},
        //  UnknownRegisterType                                       : { code: 3655, message: "AGAL validation failed: Unknown register type for %2 at token %3 of %1 program."},
        //  SamplerRegisterOutOfBounds                                : { code: 3656, message: "AGAL validation failed: Sampler register index out of bounds for %2 at token %3 of %1 program."},
        //  VaryingRegisterOutOfBounds                                : { code: 3657, message: "AGAL validation failed: Varying register index out of bounds for %2 at token %3 of %1 program."},
        //  AttributeRegisterOutOfBounds                              : { code: 3658, message: "AGAL validation failed: Attribute register index out of bounds for %2 at token %3 of %1 program."},
        //  ConstantRegisterOutOfBounds                               : { code: 3659, message: "AGAL validation failed: Constant register index out of bounds for %2 at token %3 of %1 program."},
        //  OutputRegisterOutOfBounds                                 : { code: 3660, message: "AGAL validation failed: Output register index out of bounds for %2 at token %3 of %1 program."},
        //  TemporaryRegisterOutOfBounds                              : { code: 3661, message: "AGAL validation failed: Temporary register index out of bounds for %2 at token %3 of %1 program."},
        //  CubeMapSamplerMustUseClamp                                : { code: 3662, message: "AGAL validation failed: Cube map samplers must set wrapping to clamp mode for %2 at token %3 of %1 program."},
        //  SampleBindsUndefinedTexture                               : { code: 3663, message: "Sampler %1 binds an undefined texture."},
        //  UnknownSamplerDimension                                   : { code: 3664, message: "AGAL validation failed: Unknown sampler dimension %4 for %2 at token %3 of %1 program."},
        //  UnknownFilterMode                                         : { code: 3665, message: "AGAL validation failed: Unknown filter mode in sampler: %4 for %2 at token %3 of %1 program."},
        //  UnknownMipmapMode                                         : { code: 3666, message: "AGAL validation failed: Unknown mipmap mode in sampler: %4 for %2 at token %3 of %1 program."},
        //  UnknownWrappingMode                                       : { code: 3667, message: "AGAL validation failed: Unknown wrapping mode in sampler: %4 for %2 at token %3 of %1 program."},
        //  UnknownSpecialFlag                                        : { code: 3668, message: "AGAL validation failed: Unknown special flag used in sampler: %4 for %2 at token %3 of %1 program."},
        //  BadInputSize                                              : { code: 3669, message: "Bad input size."},
        //  BufferTooBig                                              : { code: 3670, message: "Buffer too big."},
        //  BufferHasZeroSize                                         : { code: 3671, message: "Buffer has zero size."},
        //  BufferCreationFailed                                      : { code: 3672, message: "Buffer creation failed. Internal error."},
        //  InvalidCubeSide                                           : { code: 3673, message: "Cube side must be [0..5]."},
        //  MiplevelTooLarge                                          : { code: 3674, message: "Miplevel too large."},
        //  TextureFormatMismatch                                     : { code: 3675, message: "Texture format mismatch."},
        //  PlatformDoesNotSupportTextureFormat                       : { code: 3676, message: "Platform does not support desired texture format."},
        //  TextureDecodingFailed                                     : { code: 3677, message: "Texture decoding failed. Internal error."},
        //  TextureNeedsToBeSquare                                    : { code: 3678, message: "Texture needs to be square."},
        //  TextureSizeDoesNotMatch                                   : { code: 3679, message: "Texture size does not match."},
        //  DepthTextureNotImplemented                                : { code: 3680, message: "Depth texture not implemented yet."},
        //  TextureSizeIsZero                                         : { code: 3681, message: "Texture size is zero."},
        //  TextureNotPowerOfTwo                                      : { code: 3682, message: "Texture size not a power of two."},
        //  TextureTooBig                                             : { code: 3683, message: "Texture too big (max is 2048x2048)."},
        //  TextureCreationFailed                                     : { code: 3684, message: "Texture creation failed. Internal error."},
        //  CouldNotCreateRenderer                                    : { code: 3685, message: "Could not create renderer."},
        //  DisabledFormatNeedsNullVertexBuffer                       : { code: 3686, message: "'disabled' format only valid with a null vertex buffer."},
        //  NullVertexBufferNeedsDisabledFormat                       : { code: 3687, message: "Null vertex buffers require the 'disabled' format."},
        //  NeedListenerToRequestContext                              : { code: 3688, message: "You must add an event listener for the context3DCreate event before requesting a new Context3D."},
        //  CantSwizzle2ndSource                                      : { code: 3689, message: "You can not swizzle second operand for %2 at token %3 of %1 program."},
        //  TooManyDrawCalls                                          : { code: 3690, message: "Too many draw calls before calling present."},
        //  ResourceLimitExceeded                                     : { code: 3691, message: "Resource limit for this resource type exceeded."},
        //  NeedToClearBeforeDraw                                     : { code: 3692, message: "All buffers need to be cleared every frame before drawing."},
        //  SecondOperandMustBeSamplerRegister                        : { code: 3693, message: "AGAL validation failed: Sampler register must be used for second operand in texture instructions for %2 at token %3 of %1 program."},
        //  ObjectDisposed                                            : { code: 3694, message: "The object was disposed by an earlier call of dispose() on it."},
        //  SameTextureNeedsSameSamplerParams                         : { code: 3695, message: "A texture can only be bound to multiple samplers if the samplers also have the exact same properties. Mismatch at samplers %1 and %2."},
        //  SecondUseOfSamplerMustHaveSameParams                      : { code: 3696, message: "AGAL validation failed: Second use of sampler register needs to specify the exact same properties. At token %3 of %1 program."},
        //  TextureBoundButNotUsed                                    : { code: 3697, message: "A texture is bound on sampler %1 but not used by the fragment program."},
        //  BackBufferNotConfigured                                   : { code: 3698, message: "The back buffer is not configured."},
        //  OperationFailed                                           : { code: 3699, message: "Requested Operation failed to complete"},
        //  TextureMipchainIsNotComplete                              : { code: 3700, message: "A texture sampler binds an incomplete texture. Make sure to upload(). All miplevels are required when mipmapping is enabled."},
        //  OutputColorNotMaskable                                    : { code: 3701, message: "The output color register can not use a write mask. All components must be written."},
        //  Context3DNotAvailable                                     : { code: 3702, message: "Context3D not available."},
        //  SwizzleMustBeScalar                                       : { code: 3703, message: "AGAL validation failed: Source swizzle must be scalar (one of: xxxx, yyyy, zzzz, wwww) for %2 at token %3 of %1 program."},
        //  CubeMapSamplerMustUseMipmap                               : { code: 3704, message: "AGAL validation failed: Cube map samplers must enable mipmapping for %2 at token %3 of %1 program."}
    };
    for (var k in Shumway.Errors) {
        var error = Shumway.Errors[k];
        error.typeName = k;
        Shumway.Errors[error.code] = error;
    }
    function getErrorMessage(index) {
        var message = "Error #" + index;
        // if (!Shumway.AVM2.Runtime.debuggerMode.value) {
        //   return message;
        // }
        var error = Shumway.Errors[index];
        return message + ": " + (error && error.message || "(unknown)");
    }
    Shumway.getErrorMessage = getErrorMessage;
    function getErrorInfo(index) {
        return Shumway.Errors[index];
    }
    Shumway.getErrorInfo = getErrorInfo;
    function formatErrorMessage(error) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var message = error.message;
        args.forEach(function (x, i) {
            message = message.replace("%" + (i + 1), x);
        });
        return "Error #" + error.code + ": " + message;
    }
    Shumway.formatErrorMessage = formatErrorMessage;
    function translateErrorMessage(error) {
        if (error.type) {
            switch (error.type) {
                case "undefined_method":
                    return formatErrorMessage(Shumway.Errors.CallOfNonFunctionError, "value");
                default:
                    throw Shumway.Debug.notImplemented(error.type);
            }
        }
        else {
            if (error.message.indexOf("is not a function") >= 0) {
                return formatErrorMessage(Shumway.Errors.CallOfNonFunctionError, "value");
            }
            return error.message;
        }
    }
    Shumway.translateErrorMessage = translateErrorMessage;
    function sliceArguments(args, offset) {
        return Array.prototype.slice.call(args, offset);
    }
    Shumway.sliceArguments = sliceArguments;
    function checkNullParameter(argument, name, sec) {
        if (argument == undefined) {
            sec.throwError('TypeError', Shumway.Errors.NullPointerError, name);
        }
    }
    Shumway.checkNullParameter = checkNullParameter;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var LegacyEntity = /** @class */ (function () {
            function LegacyEntity() {
                this._sec = flash.system._currentDomain;
                this._symbol = this._symbolProto || flash.system._currentSymbol;
            }
            return LegacyEntity;
        }());
        flash.LegacyEntity = LegacyEntity;
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var LegacyNamespace = /** @class */ (function (_super) {
                __extends(LegacyNamespace, _super);
                function LegacyNamespace() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.key = null;
                    return _this;
                }
                LegacyNamespace.prototype._registerClass = function (cl) {
                    this.classMap[cl.key] = cl;
                };
                return LegacyNamespace;
            }(flash.LegacyEntity));
            system.LegacyNamespace = LegacyNamespace;
            function checkParameterType(argument, name, type) {
                if (argument == null) {
                    type._sec.throwError('TypeError', Shumway.Errors.NullPointerError, name);
                }
                if (!type.axIsType(argument)) {
                    type._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, argument, type.key);
                }
            }
            system.checkParameterType = checkParameterType;
            var LegacyClass = /** @class */ (function (_super) {
                __extends(LegacyClass, _super);
                function LegacyClass(jsClass) {
                    var _this = _super.call(this) || this;
                    _this.key = null;
                    _this.jsClass = jsClass;
                    return _this;
                }
                LegacyClass.prototype.create = function (args) {
                    // new (Function.prototype.bind.apply(cls, [cls].concat(args)));
                    var oldDomain = system._currentDomain;
                    var cls = this.jsClass;
                    if (oldDomain === this._sec && !system._currentSymbol) {
                        if (args) {
                            return new (Function.prototype.bind.apply(cls, [cls].concat(args)));
                        }
                        return new cls();
                    }
                    system._currentDomain = this._sec;
                    try {
                        if (args) {
                            return new (Function.prototype.bind.apply(cls, [cls].concat(args)));
                        }
                        return new cls();
                    }
                    catch (e) {
                        this._sec.throwError("LegacyEntity.create", e);
                        return null;
                    }
                    finally {
                        system._currentSymbol = null;
                        system._currentDomain = oldDomain;
                    }
                };
                LegacyClass.prototype.createObject = function () {
                    var obj = Object.create(this.jsClass.prototype);
                    obj._sec = this._sec;
                    return obj;
                };
                LegacyClass.prototype.axIsType = function (obj) {
                    return obj instanceof (this.jsClass) && obj._sec === this._sec;
                };
                LegacyClass.prototype.setSymbolResolver = function (resolver) {
                    Object.defineProperty(this.jsClass.prototype, "_symbolProto", {
                        'get': resolver,
                        configurable: true
                    });
                };
                LegacyClass.prototype.setSymbol = function (symbol) {
                    Object.defineProperty(this.jsClass.prototype, "_symbolProto", { value: symbol });
                };
                LegacyClass.prototype.isSymbol = function (symbolClass) {
                    return this === symbolClass;
                };
                LegacyClass.prototype.isSymbolPrototype = function (symbolClass) {
                    return this.jsClass.prototype.isPrototypeOf(symbolClass.jsClass.jsClass);
                };
                LegacyClass.prototype.FromUntyped = function (obj) {
                    return null;
                };
                LegacyClass.prototype.checkParameterType = function (argument, name) {
                    checkParameterType(argument, name, this);
                };
                return LegacyClass;
            }(flash.LegacyEntity));
            system.LegacyClass = LegacyClass;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var assert = Shumway.Debug.assert;
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var AMFEncoding;
            (function (AMFEncoding) {
                AMFEncoding[AMFEncoding["AMF0"] = 0] = "AMF0";
                AMFEncoding[AMFEncoding["AMF3"] = 3] = "AMF3";
                AMFEncoding[AMFEncoding["DEFAULT"] = 3] = "DEFAULT";
            })(AMFEncoding = net.AMFEncoding || (net.AMFEncoding = {}));
            var ObjectEncoding;
            (function (ObjectEncoding) {
                ObjectEncoding[ObjectEncoding["AMF0"] = 0] = "AMF0";
                ObjectEncoding[ObjectEncoding["AMF3"] = 3] = "AMF3";
                ObjectEncoding[ObjectEncoding["DEFAULT"] = 3] = "DEFAULT";
            })(ObjectEncoding = net.ObjectEncoding || (net.ObjectEncoding = {}));
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
    (function (flash) {
        var system;
        (function (system) {
            var ByteArrayClass = /** @class */ (function (_super) {
                __extends(ByteArrayClass, _super);
                function ByteArrayClass() {
                    var _this = _super.call(this, flash.utils.ByteArray) || this;
                    _this.key = "flash.utils.ByteArray";
                    return _this;
                }
                ByteArrayClass.prototype.readObject = function (arr) {
                    this._sec.throwError(this.key, "Not implemented");
                    // switch (this._objectEncoding) {
                    // 	case flash.net.ObjectEncoding.AMF0:
                    // 		return AMF0.read(this);
                    // 	case flash.net.ObjectEncoding.AMF3:
                    // 		return AMF3.read(this);
                    // 	default:
                    // 		unexpected("Object Encoding");
                    // }
                };
                ByteArrayClass.prototype.writeObject = function (arr, obj) {
                    this._sec.throwError(this.key, "Not implemented");
                    // switch (this._objectEncoding) {
                    // 	case flash.net.ObjectEncoding.AMF0:
                    // 		return AMF0.write(this, object);
                    // 	case flash.net.ObjectEncoding.AMF3:
                    // 		return AMF3.write(this, object);
                    // 	default:
                    // 		unexpected("Object Encoding");
                    // }
                };
                return ByteArrayClass;
            }(system.LegacyClass));
            system.ByteArrayClass = ByteArrayClass;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
    (function (flash) {
        var utils;
        (function (utils) {
            var ByteArray = /** @class */ (function (_super) {
                __extends(ByteArray, _super);
                function ByteArray(source) {
                    var _this = _super.call(this, -1) || this;
                    _this._sec = flash.system._currentDomain;
                    if (_this._symbol) {
                        source = _this._symbol;
                    }
                    var buffer;
                    var length = 0;
                    if (source) {
                        if (source instanceof ArrayBuffer) {
                            buffer = source.slice(0);
                        }
                        else if (Array.isArray(source)) {
                            buffer = new Uint8Array(source).buffer;
                        }
                        else if ('buffer' in source) {
                            if (source.buffer instanceof ArrayBuffer) {
                                buffer = new Uint8Array(source.buffer).buffer;
                            }
                            else if (source.buffer instanceof Uint8Array) {
                                var begin = source.buffer.byteOffset;
                                buffer = source.buffer.buffer.slice(begin, begin + source.buffer.length);
                            }
                            else {
                                release || assert(source.buffer instanceof ArrayBuffer);
                                buffer = source.buffer.slice();
                            }
                        }
                        else {
                            Shumway.Debug.unexpected("Source type.");
                        }
                        length = buffer.byteLength;
                    }
                    else {
                        buffer = new ArrayBuffer(ByteArray.INITIAL_SIZE);
                    }
                    _this._buffer = buffer;
                    _this._length = length;
                    _this._position = 0;
                    _this._resetViews();
                    _this._objectEncoding = ByteArray.defaultObjectEncoding;
                    _this._littleEndian = false; // AS3 is bigEndian by default.
                    _this._bitBuffer = 0;
                    _this._bitLength = 0;
                    return _this;
                }
                Object.defineProperty(ByteArray, "defaultObjectEncoding", {
                    get: function () {
                        return this._defaultObjectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        this._defaultObjectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                ByteArray.prototype.toJSON = function () {
                    return "ByteArray";
                };
                // private _buffer: ArrayBuffer;
                ByteArray.prototype.readObject = function () {
                    return this._sec.utils.ByteArray.readObject(this);
                };
                ByteArray.prototype.writeObject = function (obj) {
                    this._sec.utils.ByteArray.writeObject(this, obj);
                };
                ByteArray._defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;
                return ByteArray;
            }(DataBuffer));
            utils.ByteArray = ByteArray;
        })(utils = flash.utils || (flash.utils = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='utilities.ts' />
///<reference path='options.ts' />
///<reference path='settings.ts'/>
///<reference path='metrics.ts' />
///<reference path='deflate.ts' />
///<reference path='lzma.ts' />
///<reference path='dataBuffer.ts' />
///<reference path='ShapeData.ts' />
///<reference path='SWFTags.ts' />
///<reference path='binaryFileReader.ts' />
///<reference path='flashlog.ts' />
///<reference path='remoting.ts' />
///<reference path='external.ts' />
///<reference path='legacy/ISecurityDomain.ts' />
///<reference path='legacy/Errors.ts' />
///<reference path='legacy/LegacyEntity.ts' />
///<reference path='legacy/ByteArray.ts' />
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Theme;
        (function (Theme) {
            var UI = /** @class */ (function () {
                function UI() {
                }
                UI.toRGBA = function (r, g, b, a) {
                    if (a === void 0) { a = 1; }
                    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
                };
                return UI;
            }());
            Theme.UI = UI;
            var UIThemeDark = /** @class */ (function () {
                function UIThemeDark() {
                }
                // Chrome Colors
                UIThemeDark.prototype.tabToolbar = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(37, 44, 51, a);
                };
                UIThemeDark.prototype.toolbars = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(52, 60, 69, a);
                };
                UIThemeDark.prototype.selectionBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(29, 79, 115, a);
                };
                UIThemeDark.prototype.selectionText = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(245, 247, 250, a);
                };
                UIThemeDark.prototype.splitters = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(0, 0, 0, a);
                };
                // Content Colors
                UIThemeDark.prototype.bodyBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(17, 19, 21, a);
                };
                UIThemeDark.prototype.sidebarBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(24, 29, 32, a);
                };
                UIThemeDark.prototype.attentionBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(161, 134, 80, a);
                };
                // Text Colors
                UIThemeDark.prototype.bodyText = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeDark.prototype.foregroundTextGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(182, 186, 191, a);
                };
                UIThemeDark.prototype.contentTextHighContrast = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(169, 186, 203, a);
                };
                UIThemeDark.prototype.contentTextGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeDark.prototype.contentTextDarkGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(95, 115, 135, a);
                };
                // Highlight Colors
                UIThemeDark.prototype.blueHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(70, 175, 227, a);
                };
                UIThemeDark.prototype.purpleHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(107, 122, 187, a);
                };
                UIThemeDark.prototype.pinkHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(223, 128, 255, a);
                };
                UIThemeDark.prototype.redHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(235, 83, 104, a);
                };
                UIThemeDark.prototype.orangeHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(217, 102, 41, a);
                };
                UIThemeDark.prototype.lightOrangeHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(217, 155, 40, a);
                };
                UIThemeDark.prototype.greenHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(112, 191, 83, a);
                };
                UIThemeDark.prototype.blueGreyHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(94, 136, 176, a);
                };
                return UIThemeDark;
            }());
            Theme.UIThemeDark = UIThemeDark;
            var UIThemeLight = /** @class */ (function () {
                function UIThemeLight() {
                }
                // Chrome Colors
                UIThemeLight.prototype.tabToolbar = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(235, 236, 237, a);
                };
                UIThemeLight.prototype.toolbars = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(240, 241, 242, a);
                };
                UIThemeLight.prototype.selectionBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(76, 158, 217, a);
                };
                UIThemeLight.prototype.selectionText = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(245, 247, 250, a);
                };
                UIThemeLight.prototype.splitters = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(170, 170, 170, a);
                };
                // Content Colors
                UIThemeLight.prototype.bodyBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(252, 252, 252, a);
                };
                UIThemeLight.prototype.sidebarBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(247, 247, 247, a);
                };
                UIThemeLight.prototype.attentionBackground = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(161, 134, 80, a);
                };
                // Text Colors
                UIThemeLight.prototype.bodyText = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(24, 25, 26, a);
                };
                UIThemeLight.prototype.foregroundTextGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(88, 89, 89, a);
                };
                UIThemeLight.prototype.contentTextHighContrast = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(41, 46, 51, a);
                };
                UIThemeLight.prototype.contentTextGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(143, 161, 178, a);
                };
                UIThemeLight.prototype.contentTextDarkGrey = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(102, 115, 128, a);
                };
                // Highlight Colors
                UIThemeLight.prototype.blueHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(0, 136, 204, a);
                };
                UIThemeLight.prototype.purpleHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(91, 95, 255, a);
                };
                UIThemeLight.prototype.pinkHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(184, 46, 229, a);
                };
                UIThemeLight.prototype.redHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(237, 38, 85, a);
                };
                UIThemeLight.prototype.orangeHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(241, 60, 0, a);
                };
                UIThemeLight.prototype.lightOrangeHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(217, 126, 0, a);
                };
                UIThemeLight.prototype.greenHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(44, 187, 15, a);
                };
                UIThemeLight.prototype.blueGreyHighlight = function (a) {
                    if (a === void 0) { a = 1; }
                    return UI.toRGBA(95, 136, 176, a);
                };
                return UIThemeLight;
            }());
            Theme.UIThemeLight = UIThemeLight;
        })(Theme = Tools.Theme || (Tools.Theme = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var Profile = /** @class */ (function () {
                function Profile(buffers, startTime) {
                    this._buffers = buffers || [];
                    this._snapshots = [];
                    this._startTime = startTime;
                    this._windowStart = startTime;
                    this._maxDepth = 0;
                }
                Profile.prototype.addBuffer = function (buffer) {
                    this._buffers.push(buffer);
                };
                Profile.prototype.getSnapshotAt = function (index) {
                    return this._snapshots[index];
                };
                Object.defineProperty(Profile.prototype, "hasSnapshots", {
                    get: function () {
                        return (this.snapshotCount > 0);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "snapshotCount", {
                    get: function () {
                        return this._snapshots.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "startTime", {
                    get: function () {
                        return this._startTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "endTime", {
                    get: function () {
                        return this._endTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "totalTime", {
                    get: function () {
                        return this.endTime - this.startTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "windowStart", {
                    get: function () {
                        return this._windowStart;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "windowEnd", {
                    get: function () {
                        return this._windowEnd;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "windowLength", {
                    get: function () {
                        return this.windowEnd - this.windowStart;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Profile.prototype, "maxDepth", {
                    get: function () {
                        return this._maxDepth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Profile.prototype.forEachSnapshot = function (visitor) {
                    for (var i = 0, n = this.snapshotCount; i < n; i++) {
                        visitor(this._snapshots[i], i);
                    }
                };
                Profile.prototype.createSnapshots = function () {
                    var endTime = Number.MIN_VALUE;
                    var maxDepth = 0;
                    this._snapshots = [];
                    while (this._buffers.length > 0) {
                        var buffer = this._buffers.shift();
                        var snapshot = buffer.createSnapshot();
                        if (snapshot) {
                            if (endTime < snapshot.endTime) {
                                endTime = snapshot.endTime;
                            }
                            if (maxDepth < snapshot.maxDepth) {
                                maxDepth = snapshot.maxDepth;
                            }
                            this._snapshots.push(snapshot);
                        }
                    }
                    this._endTime = endTime;
                    this._windowEnd = endTime;
                    this._maxDepth = maxDepth;
                };
                Profile.prototype.setWindow = function (start, end) {
                    if (start > end) {
                        var tmp = start;
                        start = end;
                        end = tmp;
                    }
                    var length = Math.min(end - start, this.totalTime);
                    if (start < this._startTime) {
                        start = this._startTime;
                        end = this._startTime + length;
                    }
                    else if (end > this._endTime) {
                        start = this._endTime - length;
                        end = this._endTime;
                    }
                    this._windowStart = start;
                    this._windowEnd = end;
                };
                Profile.prototype.moveWindowTo = function (time) {
                    this.setWindow(time - this.windowLength / 2, time + this.windowLength / 2);
                };
                return Profile;
            }());
            Profiler.Profile = Profile;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var TimelineFrameStatistics = /** @class */ (function () {
                function TimelineFrameStatistics(kind) {
                    this.kind = kind;
                    this.count = 0;
                    this.selfTime = 0;
                    this.totalTime = 0;
                }
                return TimelineFrameStatistics;
            }());
            Profiler.TimelineFrameStatistics = TimelineFrameStatistics;
            /**
             * Represents a single timeline frame range and makes it easier to work with the compacted
             * timeline buffer data.
             */
            var TimelineFrame = /** @class */ (function () {
                function TimelineFrame(parent, kind, startData, endData, startTime, endTime) {
                    this.parent = parent;
                    this.kind = kind;
                    this.startData = startData;
                    this.endData = endData;
                    this.startTime = startTime;
                    this.endTime = endTime;
                    this.maxDepth = 0;
                }
                Object.defineProperty(TimelineFrame.prototype, "totalTime", {
                    get: function () {
                        return this.endTime - this.startTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TimelineFrame.prototype, "selfTime", {
                    get: function () {
                        var selfTime = this.totalTime;
                        if (this.children) {
                            for (var i = 0, n = this.children.length; i < n; i++) {
                                var child = this.children[i];
                                selfTime -= (child.endTime - child.startTime);
                            }
                        }
                        return selfTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets the child index of the first child to overlap the specified time.
                 */
                TimelineFrame.prototype.getChildIndex = function (time) {
                    var children = this.children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.endTime > time) {
                            return i;
                        }
                    }
                    return 0;
                };
                /**
                 * Gets the high and low index of the children that intersect the specified time range.
                 */
                TimelineFrame.prototype.getChildRange = function (startTime, endTime) {
                    if (this.children && startTime <= this.endTime && endTime >= this.startTime && endTime >= startTime) {
                        var startIdx = this._getNearestChild(startTime);
                        var endIdx = this._getNearestChildReverse(endTime);
                        if (startIdx <= endIdx) {
                            var startTime_1 = this.children[startIdx].startTime;
                            var endTime_1 = this.children[endIdx].endTime;
                            return {
                                startIndex: startIdx,
                                endIndex: endIdx,
                                startTime: startTime_1,
                                endTime: endTime_1,
                                totalTime: endTime_1 - startTime_1
                            };
                        }
                    }
                    return null;
                };
                TimelineFrame.prototype._getNearestChild = function (time) {
                    var children = this.children;
                    if (children && children.length) {
                        if (time <= children[0].endTime) {
                            return 0;
                        }
                        var imid = void 0;
                        var imin = 0;
                        var imax = children.length - 1;
                        while (imax > imin) {
                            imid = ((imin + imax) / 2) | 0;
                            var child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return imid;
                            }
                            else if (time > child.endTime) {
                                imin = imid + 1;
                            }
                            else {
                                imax = imid;
                            }
                        }
                        return Math.ceil((imin + imax) / 2);
                    }
                    else {
                        return 0;
                    }
                };
                TimelineFrame.prototype._getNearestChildReverse = function (time) {
                    var children = this.children;
                    if (children && children.length) {
                        var imax = children.length - 1;
                        if (time >= children[imax].startTime) {
                            return imax;
                        }
                        var imid = void 0;
                        var imin = 0;
                        while (imax > imin) {
                            imid = Math.ceil((imin + imax) / 2);
                            var child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return imid;
                            }
                            else if (time > child.endTime) {
                                imin = imid;
                            }
                            else {
                                imax = imid - 1;
                            }
                        }
                        return ((imin + imax) / 2) | 0;
                    }
                    else {
                        return 0;
                    }
                };
                /**
                 * Finds the deepest child that intersects with the specified time.
                 */
                TimelineFrame.prototype.query = function (time) {
                    if (time < this.startTime || time > this.endTime) {
                        return null;
                    }
                    var children = this.children;
                    if (children && children.length > 0) {
                        var child = void 0;
                        var imin = 0;
                        var imax = children.length - 1;
                        while (imax > imin) {
                            var imid = ((imin + imax) / 2) | 0;
                            child = children[imid];
                            if (time >= child.startTime && time <= child.endTime) {
                                return child.query(time);
                            }
                            else if (time > child.endTime) {
                                imin = imid + 1;
                            }
                            else {
                                imax = imid;
                            }
                        }
                        child = children[imax];
                        if (time >= child.startTime && time <= child.endTime) {
                            return child.query(time);
                        }
                    }
                    return this;
                };
                /**
                 * When querying a series of samples, if the deepest child for the previous time is known,
                 * it is faster to go up the tree from there, until a frame is found that contains the next time,
                 * and then go back down.
                 *
                 * More often than not we don't have to start at the very top.
                 */
                TimelineFrame.prototype.queryNext = function (time) {
                    var frame = this;
                    while (time > frame.endTime) {
                        if (frame.parent) {
                            frame = frame.parent;
                        }
                        else {
                            return frame.query(time);
                        }
                    }
                    return frame.query(time);
                };
                /**
                 * Gets this frame's distance to the root.
                 */
                TimelineFrame.prototype.getDepth = function () {
                    var depth = 0;
                    var self = this;
                    while (self) {
                        depth++;
                        self = self.parent;
                    }
                    return depth;
                };
                TimelineFrame.prototype.calculateStatistics = function () {
                    var statistics = this.statistics = [];
                    function visit(frame) {
                        if (frame.kind) {
                            var s = statistics[frame.kind.id] || (statistics[frame.kind.id] = new TimelineFrameStatistics(frame.kind));
                            s.count++;
                            s.selfTime += frame.selfTime;
                            s.totalTime += frame.totalTime;
                        }
                        if (frame.children) {
                            frame.children.forEach(visit);
                        }
                    }
                    visit(this);
                };
                TimelineFrame.prototype.trace = function (writer) {
                    var s = (this.kind ? this.kind.name + ": " : "Profile: ") +
                        (this.endTime - this.startTime).toFixed(2);
                    if (this.children && this.children.length) {
                        writer.enter(s);
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].trace(writer);
                        }
                        writer.outdent();
                    }
                    else {
                        writer.writeLn(s);
                    }
                };
                return TimelineFrame;
            }());
            Profiler.TimelineFrame = TimelineFrame;
            var TimelineBufferSnapshot = /** @class */ (function (_super) {
                __extends(TimelineBufferSnapshot, _super);
                function TimelineBufferSnapshot(name) {
                    var _this = _super.call(this, null, null, null, null, NaN, NaN) || this;
                    _this.name = name;
                    return _this;
                }
                return TimelineBufferSnapshot;
            }(TimelineFrame));
            Profiler.TimelineBufferSnapshot = TimelineBufferSnapshot;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            /**
             * Records enter / leave events in two circular buffers.
             * The goal here is to be able to handle large amounts of data.
             */
            var TimelineBuffer = /** @class */ (function () {
                function TimelineBuffer(name, startTime) {
                    if (name === void 0) { name = ""; }
                    this.name = name || "";
                    this._startTime = Shumway.isNullOrUndefined(startTime) ? jsGlobal.START_TIME : startTime;
                }
                TimelineBuffer.prototype.getKind = function (kind) {
                    return this._kinds[kind];
                };
                Object.defineProperty(TimelineBuffer.prototype, "kinds", {
                    get: function () {
                        return this._kinds.concat();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TimelineBuffer.prototype, "depth", {
                    get: function () {
                        return this._depth;
                    },
                    enumerable: true,
                    configurable: true
                });
                TimelineBuffer.prototype._initialize = function () {
                    this._depth = 0;
                    this._stack = [];
                    this._data = [];
                    this._kinds = [];
                    this._kindNameMap = Object.create(null);
                    this._marks = new Shumway.CircularBuffer(Int32Array, 20);
                    this._times = new Shumway.CircularBuffer(Float64Array, 20);
                };
                TimelineBuffer.prototype._getKindId = function (name) {
                    var kindId = TimelineBuffer.MAX_KINDID;
                    if (this._kindNameMap[name] === undefined) {
                        kindId = this._kinds.length;
                        if (kindId < TimelineBuffer.MAX_KINDID) {
                            var kind = {
                                id: kindId,
                                name: name,
                                visible: true
                            };
                            this._kinds.push(kind);
                            this._kindNameMap[name] = kind;
                        }
                        else {
                            kindId = TimelineBuffer.MAX_KINDID;
                        }
                    }
                    else {
                        kindId = this._kindNameMap[name].id;
                    }
                    return kindId;
                };
                TimelineBuffer.prototype._getMark = function (type, kindId, data) {
                    var dataId = TimelineBuffer.MAX_DATAID;
                    if (!Shumway.isNullOrUndefined(data) && kindId !== TimelineBuffer.MAX_KINDID) {
                        dataId = this._data.length;
                        if (dataId < TimelineBuffer.MAX_DATAID) {
                            this._data.push(data);
                        }
                        else {
                            dataId = TimelineBuffer.MAX_DATAID;
                        }
                    }
                    return type | (dataId << 16) | kindId;
                };
                TimelineBuffer.prototype.enter = function (name, data, time) {
                    time = (Shumway.isNullOrUndefined(time) ? performance.now() : time) - this._startTime;
                    if (!this._marks) {
                        this._initialize();
                    }
                    this._depth++;
                    var kindId = this._getKindId(name);
                    this._marks.write(this._getMark(TimelineBuffer.ENTER, kindId, data));
                    this._times.write(time);
                    this._stack.push(kindId);
                };
                TimelineBuffer.prototype.leave = function (name, data, time) {
                    time = (Shumway.isNullOrUndefined(time) ? performance.now() : time) - this._startTime;
                    var kindId = this._stack.pop();
                    if (name) {
                        kindId = this._getKindId(name);
                    }
                    this._marks.write(this._getMark(TimelineBuffer.LEAVE, kindId, data));
                    this._times.write(time);
                    this._depth--;
                };
                TimelineBuffer.prototype.count = function (name, value, data) {
                    // Not Implemented
                };
                /**
                 * Constructs an easier to work with TimelineFrame data structure.
                 */
                TimelineBuffer.prototype.createSnapshot = function (count) {
                    if (count === void 0) { count = Number.MAX_VALUE; }
                    if (!this._marks) {
                        return null;
                    }
                    var times = this._times;
                    var kinds = this._kinds;
                    var datastore = this._data;
                    var snapshot = new Profiler.TimelineBufferSnapshot(this.name);
                    var stack = [snapshot];
                    var topLevelFrameCount = 0;
                    if (!this._marks) {
                        this._initialize();
                    }
                    this._marks.forEachInReverse(function (mark, i) {
                        var dataId = (mark >>> 16) & TimelineBuffer.MAX_DATAID;
                        var data = datastore[dataId];
                        var kindId = mark & TimelineBuffer.MAX_KINDID;
                        var kind = kinds[kindId];
                        if (Shumway.isNullOrUndefined(kind) || kind.visible) {
                            var action = mark & 0x80000000;
                            var time = times.get(i);
                            var stackLength = stack.length;
                            if (action === TimelineBuffer.LEAVE) {
                                if (stackLength === 1) {
                                    topLevelFrameCount++;
                                    if (topLevelFrameCount > count) {
                                        return true;
                                    }
                                }
                                stack.push(new Profiler.TimelineFrame(stack[stackLength - 1], kind, null, data, NaN, time));
                            }
                            else if (action === TimelineBuffer.ENTER) {
                                var node = stack.pop();
                                var top_1 = stack[stack.length - 1];
                                if (top_1) {
                                    if (!top_1.children) {
                                        top_1.children = [node];
                                    }
                                    else {
                                        top_1.children.unshift(node);
                                    }
                                    var currentDepth = stack.length;
                                    node.depth = currentDepth;
                                    node.startData = data;
                                    node.startTime = time;
                                    while (node) {
                                        if (node.maxDepth < currentDepth) {
                                            node.maxDepth = currentDepth;
                                            node = node.parent;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                        return false;
                    });
                    if (snapshot.children && snapshot.children.length) {
                        snapshot.startTime = snapshot.children[0].startTime;
                        snapshot.endTime = snapshot.children[snapshot.children.length - 1].endTime;
                    }
                    return snapshot;
                };
                TimelineBuffer.prototype.reset = function (startTime) {
                    this._startTime = Shumway.isNullOrUndefined(startTime) ? performance.now() : startTime;
                    if (!this._marks) {
                        this._initialize();
                        return;
                    }
                    this._depth = 0;
                    this._data = [];
                    this._marks.reset();
                    this._times.reset();
                };
                TimelineBuffer.FromFirefoxProfile = function (profile, name) {
                    var samples = profile.profile.threads[0].samples;
                    var buffer = new TimelineBuffer(name, samples[0].time);
                    var currentStack = [];
                    var sample;
                    var time;
                    for (var i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        time = sample.time;
                        var stack = sample.frames;
                        var j = 0;
                        var minStackLen = Math.min(stack.length, currentStack.length);
                        while (j < minStackLen && stack[j].location === currentStack[j].location) {
                            j++;
                        }
                        var leaveCount = currentStack.length - j;
                        for (var k = 0; k < leaveCount; k++) {
                            sample = currentStack.pop();
                            buffer.leave(sample.location, null, time);
                        }
                        while (j < stack.length) {
                            sample = stack[j++];
                            buffer.enter(sample.location, null, time);
                        }
                        currentStack = stack;
                    }
                    while (sample = currentStack.pop()) {
                        buffer.leave(sample.location, null, time);
                    }
                    return buffer;
                };
                TimelineBuffer.FromChromeProfile = function (profile, name) {
                    var timestamps = profile.timestamps;
                    var samples = profile.samples;
                    var buffer = new TimelineBuffer(name, timestamps[0] / 1000);
                    var currentStack = [];
                    var idMap = {};
                    var sample;
                    var time;
                    TimelineBuffer._resolveIds(profile.head, idMap);
                    for (var i = 0; i < timestamps.length; i++) {
                        time = timestamps[i] / 1000;
                        var stack = [];
                        sample = idMap[samples[i]];
                        while (sample) {
                            stack.unshift(sample);
                            sample = sample.parent;
                        }
                        var j = 0;
                        var minStackLen = Math.min(stack.length, currentStack.length);
                        while (j < minStackLen && stack[j] === currentStack[j]) {
                            j++;
                        }
                        var leaveCount = currentStack.length - j;
                        for (var k = 0; k < leaveCount; k++) {
                            sample = currentStack.pop();
                            buffer.leave(sample.functionName, null, time);
                        }
                        while (j < stack.length) {
                            sample = stack[j++];
                            buffer.enter(sample.functionName, null, time);
                        }
                        currentStack = stack;
                    }
                    while (sample = currentStack.pop()) {
                        buffer.leave(sample.functionName, null, time);
                    }
                    return buffer;
                };
                TimelineBuffer._resolveIds = function (parent, idMap) {
                    idMap[parent.id] = parent;
                    if (parent.children) {
                        for (var i = 0; i < parent.children.length; i++) {
                            parent.children[i].parent = parent;
                            TimelineBuffer._resolveIds(parent.children[i], idMap);
                        }
                    }
                };
                TimelineBuffer.ENTER = 0 << 31;
                TimelineBuffer.LEAVE = 1 << 31;
                TimelineBuffer.MAX_KINDID = 0xffff;
                TimelineBuffer.MAX_DATAID = 0x7fff;
                return TimelineBuffer;
            }());
            Profiler.TimelineBuffer = TimelineBuffer;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var UIThemeType;
            (function (UIThemeType) {
                UIThemeType[UIThemeType["DARK"] = 0] = "DARK";
                UIThemeType[UIThemeType["LIGHT"] = 1] = "LIGHT";
            })(UIThemeType = Profiler.UIThemeType || (Profiler.UIThemeType = {}));
            var Controller = /** @class */ (function () {
                function Controller(container, themeType) {
                    if (themeType === void 0) { themeType = 0 /* DARK */; }
                    this._container = container;
                    this._headers = [];
                    this._charts = [];
                    this._profiles = [];
                    this._activeProfile = null;
                    this.themeType = themeType;
                    this._tooltip = this._createTooltip();
                }
                Controller.prototype.createProfile = function (buffers, startTime) {
                    var profile = new Profiler.Profile(buffers, startTime);
                    profile.createSnapshots();
                    this._profiles.push(profile);
                    this.activateProfile(profile);
                    return profile;
                };
                Controller.prototype.activateProfile = function (profile) {
                    this.deactivateProfile();
                    this._activeProfile = profile;
                    this._createViews();
                    this._initializeViews();
                };
                Controller.prototype.activateProfileAt = function (index) {
                    this.activateProfile(this.getProfileAt(index));
                };
                Controller.prototype.deactivateProfile = function () {
                    if (this._activeProfile) {
                        this._destroyViews();
                        this._activeProfile = null;
                    }
                };
                Controller.prototype.resize = function () {
                    this._onResize();
                };
                Controller.prototype.getProfileAt = function (index) {
                    return this._profiles[index];
                };
                Object.defineProperty(Controller.prototype, "activeProfile", {
                    get: function () {
                        return this._activeProfile;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Controller.prototype, "profileCount", {
                    get: function () {
                        return this._profiles.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Controller.prototype, "container", {
                    get: function () {
                        return this._container;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Controller.prototype, "themeType", {
                    get: function () {
                        return this._themeType;
                    },
                    set: function (value) {
                        switch (value) {
                            case 0 /* DARK */:
                                this._theme = new Tools.Theme.UIThemeDark();
                                break;
                            case 1 /* LIGHT */:
                                this._theme = new Tools.Theme.UIThemeLight();
                                break;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Controller.prototype, "theme", {
                    get: function () {
                        return this._theme;
                    },
                    enumerable: true,
                    configurable: true
                });
                Controller.prototype.getSnapshotAt = function (index) {
                    return this._activeProfile.getSnapshotAt(index);
                };
                Controller.prototype._createViews = function () {
                    if (this._activeProfile) {
                        var self_1 = this;
                        this._overviewHeader = new Profiler.FlameChartHeader(this, 0 /* OVERVIEW */);
                        this._overview = new Profiler.FlameChartOverview(this, 0 /* OVERLAY */);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self_1._headers.push(new Profiler.FlameChartHeader(self_1, 1 /* CHART */));
                            self_1._charts.push(new Profiler.FlameChart(self_1, snapshot));
                        });
                        window.addEventListener("resize", this._onResize.bind(this));
                    }
                };
                Controller.prototype._destroyViews = function () {
                    if (this._activeProfile) {
                        this._overviewHeader.destroy();
                        this._overview.destroy();
                        while (this._headers.length) {
                            this._headers.pop().destroy();
                        }
                        while (this._charts.length) {
                            this._charts.pop().destroy();
                        }
                        window.removeEventListener("resize", this._onResize.bind(this));
                    }
                };
                Controller.prototype._initializeViews = function () {
                    if (this._activeProfile) {
                        var self_2 = this;
                        var startTime_2 = this._activeProfile.startTime;
                        var endTime_2 = this._activeProfile.endTime;
                        this._overviewHeader.initialize(startTime_2, endTime_2);
                        this._overview.initialize(startTime_2, endTime_2);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self_2._headers[index].initialize(startTime_2, endTime_2);
                            self_2._charts[index].initialize(startTime_2, endTime_2);
                        });
                    }
                };
                Controller.prototype._onResize = function () {
                    if (this._activeProfile) {
                        var self_3 = this;
                        var width_1 = this._container.offsetWidth;
                        this._overviewHeader.setSize(width_1);
                        this._overview.setSize(width_1);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self_3._headers[index].setSize(width_1);
                            self_3._charts[index].setSize(width_1);
                        });
                    }
                };
                Controller.prototype._updateViews = function () {
                    if (this._activeProfile) {
                        var self_4 = this;
                        var start_1 = this._activeProfile.windowStart;
                        var end_1 = this._activeProfile.windowEnd;
                        this._overviewHeader.setWindow(start_1, end_1);
                        this._overview.setWindow(start_1, end_1);
                        this._activeProfile.forEachSnapshot(function (snapshot, index) {
                            self_4._headers[index].setWindow(start_1, end_1);
                            self_4._charts[index].setWindow(start_1, end_1);
                        });
                    }
                };
                Controller.prototype._drawViews = function () {
                    /*
                    let self = this;
                    this._overviewHeader.draw();
                    this._overview.setWindow(start, end);
                    this._profile.forEachBuffer(function(buffer: TimelineBufferSnapshot, index: number) {
                      self._headers[index].setWindow(start, end);
                      self._charts[index].setWindow(start, end);
                    });
                    */
                };
                Controller.prototype._createTooltip = function () {
                    var el = document.createElement("div");
                    el.classList.add("profiler-tooltip");
                    el.style.display = "none";
                    this._container.insertBefore(el, this._container.firstChild);
                    return el;
                };
                /**
                 * View callbacks
                 */
                Controller.prototype.setWindow = function (start, end) {
                    this._activeProfile.setWindow(start, end);
                    this._updateViews();
                };
                Controller.prototype.moveWindowTo = function (time) {
                    this._activeProfile.moveWindowTo(time);
                    this._updateViews();
                };
                Controller.prototype.showTooltip = function (chart, frame, x, y) {
                    this.removeTooltipContent();
                    this._tooltip.appendChild(this.createTooltipContent(chart, frame));
                    this._tooltip.style.display = "block";
                    var elContent = this._tooltip.firstChild;
                    var tooltipWidth = elContent.clientWidth;
                    var tooltipHeight = elContent.clientHeight;
                    var totalWidth = chart.canvas.clientWidth;
                    x += (x + tooltipWidth >= totalWidth - 50) ? -(tooltipWidth + 20) : 25;
                    y += chart.canvas.offsetTop - tooltipHeight / 2;
                    this._tooltip.style.left = x + "px";
                    this._tooltip.style.top = y + "px";
                };
                Controller.prototype.hideTooltip = function () {
                    this._tooltip.style.display = "none";
                };
                Controller.prototype.createTooltipContent = function (chart, frame) {
                    var totalTime = Math.round(frame.totalTime * 100000) / 100000;
                    var selfTime = Math.round(frame.selfTime * 100000) / 100000;
                    var selfPercent = Math.round(frame.selfTime * 100 * 100 / frame.totalTime) / 100;
                    var elContent = document.createElement("div");
                    var elName = document.createElement("h1");
                    elName.textContent = frame.kind.name;
                    elContent.appendChild(elName);
                    var elTotalTime = document.createElement("p");
                    elTotalTime.textContent = "Total: " + totalTime + " ms";
                    elContent.appendChild(elTotalTime);
                    var elSelfTime = document.createElement("p");
                    elSelfTime.textContent = "Self: " + selfTime + " ms (" + selfPercent + "%)";
                    elContent.appendChild(elSelfTime);
                    var statistics = chart.getStatistics(frame.kind);
                    if (statistics) {
                        var elAllCount = document.createElement("p");
                        elAllCount.textContent = "Count: " + statistics.count;
                        elContent.appendChild(elAllCount);
                        var allTotalTime = Math.round(statistics.totalTime * 100000) / 100000;
                        var elAllTotalTime = document.createElement("p");
                        elAllTotalTime.textContent = "All Total: " + allTotalTime + " ms";
                        elContent.appendChild(elAllTotalTime);
                        var allSelfTime = Math.round(statistics.selfTime * 100000) / 100000;
                        var elAllSelfTime = document.createElement("p");
                        elAllSelfTime.textContent = "All Self: " + allSelfTime + " ms";
                        elContent.appendChild(elAllSelfTime);
                    }
                    this.appendDataElements(elContent, frame.startData);
                    this.appendDataElements(elContent, frame.endData);
                    return elContent;
                };
                Controller.prototype.appendDataElements = function (el, data) {
                    if (!Shumway.isNullOrUndefined(data)) {
                        el.appendChild(document.createElement("hr"));
                        var elData = void 0;
                        if (Shumway.isObject(data)) {
                            for (var key in data) {
                                elData = document.createElement("p");
                                elData.textContent = key + ": " + data[key];
                                el.appendChild(elData);
                            }
                        }
                        else {
                            elData = document.createElement("p");
                            elData.textContent = data.toString();
                            el.appendChild(elData);
                        }
                    }
                };
                Controller.prototype.removeTooltipContent = function () {
                    var el = this._tooltip;
                    while (el.firstChild) {
                        el.removeChild(el.firstChild);
                    }
                };
                return Controller;
            }());
            Profiler.Controller = Controller;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;
            var MouseCursor = /** @class */ (function () {
                function MouseCursor(value) {
                    this.value = value;
                }
                MouseCursor.prototype.toString = function () {
                    return this.value;
                };
                MouseCursor.AUTO = new MouseCursor("auto");
                MouseCursor.DEFAULT = new MouseCursor("default");
                MouseCursor.NONE = new MouseCursor("none");
                MouseCursor.HELP = new MouseCursor("help");
                MouseCursor.POINTER = new MouseCursor("pointer");
                MouseCursor.PROGRESS = new MouseCursor("progress");
                MouseCursor.WAIT = new MouseCursor("wait");
                MouseCursor.CELL = new MouseCursor("cell");
                MouseCursor.CROSSHAIR = new MouseCursor("crosshair");
                MouseCursor.TEXT = new MouseCursor("text");
                MouseCursor.ALIAS = new MouseCursor("alias");
                MouseCursor.COPY = new MouseCursor("copy");
                MouseCursor.MOVE = new MouseCursor("move");
                MouseCursor.NO_DROP = new MouseCursor("no-drop");
                MouseCursor.NOT_ALLOWED = new MouseCursor("not-allowed");
                MouseCursor.ALL_SCROLL = new MouseCursor("all-scroll");
                MouseCursor.COL_RESIZE = new MouseCursor("col-resize");
                MouseCursor.ROW_RESIZE = new MouseCursor("row-resize");
                MouseCursor.N_RESIZE = new MouseCursor("n-resize");
                MouseCursor.E_RESIZE = new MouseCursor("e-resize");
                MouseCursor.S_RESIZE = new MouseCursor("s-resize");
                MouseCursor.W_RESIZE = new MouseCursor("w-resize");
                MouseCursor.NE_RESIZE = new MouseCursor("ne-resize");
                MouseCursor.NW_RESIZE = new MouseCursor("nw-resize");
                MouseCursor.SE_RESIZE = new MouseCursor("se-resize");
                MouseCursor.SW_RESIZE = new MouseCursor("sw-resize");
                MouseCursor.EW_RESIZE = new MouseCursor("ew-resize");
                MouseCursor.NS_RESIZE = new MouseCursor("ns-resize");
                MouseCursor.NESW_RESIZE = new MouseCursor("nesw-resize");
                MouseCursor.NWSE_RESIZE = new MouseCursor("nwse-resize");
                MouseCursor.ZOOM_IN = new MouseCursor("zoom-in");
                MouseCursor.ZOOM_OUT = new MouseCursor("zoom-out");
                MouseCursor.GRAB = new MouseCursor("grab");
                MouseCursor.GRABBING = new MouseCursor("grabbing");
                return MouseCursor;
            }());
            Profiler.MouseCursor = MouseCursor;
            var MouseController = /** @class */ (function () {
                function MouseController(target, eventTarget) {
                    this._target = target;
                    this._eventTarget = eventTarget;
                    this._wheelDisabled = false;
                    this._boundOnMouseDown = this._onMouseDown.bind(this);
                    this._boundOnMouseUp = this._onMouseUp.bind(this);
                    this._boundOnMouseOver = this._onMouseOver.bind(this);
                    this._boundOnMouseOut = this._onMouseOut.bind(this);
                    this._boundOnMouseMove = this._onMouseMove.bind(this);
                    this._boundOnMouseWheel = this._onMouseWheel.bind(this);
                    this._boundOnDrag = this._onDrag.bind(this);
                    eventTarget.addEventListener("mousedown", this._boundOnMouseDown, false);
                    eventTarget.addEventListener("mouseover", this._boundOnMouseOver, false);
                    eventTarget.addEventListener("mouseout", this._boundOnMouseOut, false);
                    eventTarget.addEventListener(("onwheel" in document ? "wheel" : "mousewheel"), this._boundOnMouseWheel, false);
                }
                MouseController.prototype.destroy = function () {
                    var eventTarget = this._eventTarget;
                    eventTarget.removeEventListener("mousedown", this._boundOnMouseDown);
                    eventTarget.removeEventListener("mouseover", this._boundOnMouseOver);
                    eventTarget.removeEventListener("mouseout", this._boundOnMouseOut);
                    eventTarget.removeEventListener(("onwheel" in document ? "wheel" : "mousewheel"), this._boundOnMouseWheel);
                    window.removeEventListener("mousemove", this._boundOnDrag);
                    window.removeEventListener("mouseup", this._boundOnMouseUp);
                    this._killHoverCheck();
                    this._eventTarget = null;
                    this._target = null;
                };
                MouseController.prototype.updateCursor = function (cursor) {
                    if (!MouseController._cursorOwner || MouseController._cursorOwner === this._target) {
                        var el_1 = this._eventTarget.parentElement;
                        if (MouseController._cursor !== cursor) {
                            MouseController._cursor = cursor;
                            var self_5 = this;
                            ["", "-moz-", "-webkit-"].forEach(function (prefix) {
                                el_1.style.cursor = prefix + cursor;
                            });
                        }
                        if (MouseController._cursor === MouseCursor.DEFAULT) {
                            MouseController._cursorOwner = null;
                        }
                        else {
                            MouseController._cursorOwner = this._target;
                        }
                    }
                };
                MouseController.prototype._onMouseDown = function (event) {
                    this._killHoverCheck();
                    if (event.button === 0) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._dragInfo = {
                            start: pos,
                            current: pos,
                            delta: { x: 0, y: 0 },
                            hasMoved: false,
                            originalTarget: event.target
                        };
                        window.addEventListener("mousemove", this._boundOnDrag, false);
                        window.addEventListener("mouseup", this._boundOnMouseUp, false);
                        this._target.onMouseDown(pos.x, pos.y);
                    }
                };
                MouseController.prototype._onDrag = function (event) {
                    var dragInfo = this._dragInfo;
                    var current = this._getTargetMousePos(event, dragInfo.originalTarget);
                    var delta = {
                        x: current.x - dragInfo.start.x,
                        y: current.y - dragInfo.start.y
                    };
                    dragInfo.current = current;
                    dragInfo.delta = delta;
                    dragInfo.hasMoved = true;
                    this._target.onDrag(dragInfo.start.x, dragInfo.start.y, current.x, current.y, delta.x, delta.y);
                };
                MouseController.prototype._onMouseUp = function (event) {
                    window.removeEventListener("mousemove", this._boundOnDrag);
                    window.removeEventListener("mouseup", this._boundOnMouseUp);
                    var self = this;
                    var dragInfo = this._dragInfo;
                    if (dragInfo.hasMoved) {
                        this._target.onDragEnd(dragInfo.start.x, dragInfo.start.y, dragInfo.current.x, dragInfo.current.y, dragInfo.delta.x, dragInfo.delta.y);
                    }
                    else {
                        this._target.onClick(dragInfo.current.x, dragInfo.current.y);
                    }
                    this._dragInfo = null;
                    this._wheelDisabled = true;
                    setTimeout(function () {
                        self._wheelDisabled = false;
                    }, 500);
                };
                MouseController.prototype._onMouseOver = function (event) {
                    event.target.addEventListener("mousemove", this._boundOnMouseMove, false);
                    if (!this._dragInfo) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._target.onMouseOver(pos.x, pos.y);
                        this._startHoverCheck(event);
                    }
                };
                MouseController.prototype._onMouseOut = function (event) {
                    event.target.removeEventListener("mousemove", this._boundOnMouseMove, false);
                    if (!this._dragInfo) {
                        this._target.onMouseOut();
                    }
                    this._killHoverCheck();
                };
                MouseController.prototype._onMouseMove = function (event) {
                    if (!this._dragInfo) {
                        var pos = this._getTargetMousePos(event, (event.target));
                        this._target.onMouseMove(pos.x, pos.y);
                        this._killHoverCheck();
                        this._startHoverCheck(event);
                    }
                };
                MouseController.prototype._onMouseWheel = function (event) {
                    if (!event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {
                        event.preventDefault();
                        if (!this._dragInfo && !this._wheelDisabled) {
                            var pos = this._getTargetMousePos(event, (event.target));
                            var delta = clamp((typeof event.deltaY !== "undefined") ? event.deltaY / 16 : -event.wheelDelta / 40, -1, 1);
                            var zoom = Math.pow(1.2, delta) - 1;
                            this._target.onMouseWheel(pos.x, pos.y, zoom);
                        }
                    }
                };
                MouseController.prototype._startHoverCheck = function (event) {
                    this._hoverInfo = {
                        isHovering: false,
                        timeoutHandle: setTimeout(this._onMouseMoveIdleHandler.bind(this), MouseController.HOVER_TIMEOUT),
                        pos: this._getTargetMousePos(event, (event.target))
                    };
                };
                MouseController.prototype._killHoverCheck = function () {
                    if (this._hoverInfo) {
                        clearTimeout(this._hoverInfo.timeoutHandle);
                        if (this._hoverInfo.isHovering) {
                            this._target.onHoverEnd();
                        }
                        this._hoverInfo = null;
                    }
                };
                MouseController.prototype._onMouseMoveIdleHandler = function () {
                    var hoverInfo = this._hoverInfo;
                    hoverInfo.isHovering = true;
                    this._target.onHoverStart(hoverInfo.pos.x, hoverInfo.pos.y);
                };
                MouseController.prototype._getTargetMousePos = function (event, target) {
                    var rect = target.getBoundingClientRect();
                    return {
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    };
                };
                MouseController.HOVER_TIMEOUT = 500;
                MouseController._cursor = MouseCursor.DEFAULT;
                return MouseController;
            }());
            Profiler.MouseController = MouseController;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var FlameChartDragTarget;
            (function (FlameChartDragTarget) {
                FlameChartDragTarget[FlameChartDragTarget["NONE"] = 0] = "NONE";
                FlameChartDragTarget[FlameChartDragTarget["WINDOW"] = 1] = "WINDOW";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_LEFT"] = 2] = "HANDLE_LEFT";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_RIGHT"] = 3] = "HANDLE_RIGHT";
                FlameChartDragTarget[FlameChartDragTarget["HANDLE_BOTH"] = 4] = "HANDLE_BOTH";
            })(FlameChartDragTarget = Profiler.FlameChartDragTarget || (Profiler.FlameChartDragTarget = {}));
            var FlameChartBase = /** @class */ (function () {
                function FlameChartBase(controller) {
                    var preArgs = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        preArgs[_i - 1] = arguments[_i];
                    }
                    this.preConstructor.apply(this, preArgs);
                    this._controller = controller;
                    this._initialized = false;
                    this._canvas = document.createElement("canvas");
                    this._context = this._canvas.getContext("2d");
                    this._mouseController = new Profiler.MouseController(this, this._canvas);
                    var container = controller.container;
                    container.appendChild(this._canvas);
                    var rect = container.getBoundingClientRect();
                    this.setSize(rect.width);
                }
                FlameChartBase.prototype.preConstructor = function () {
                };
                Object.defineProperty(FlameChartBase.prototype, "canvas", {
                    get: function () {
                        return this._canvas;
                    },
                    enumerable: true,
                    configurable: true
                });
                FlameChartBase.prototype.setSize = function (width, height) {
                    if (height === void 0) { height = 20; }
                    this._width = width;
                    this._height = height;
                    this._resetCanvas();
                    this.draw();
                };
                FlameChartBase.prototype.initialize = function (rangeStart, rangeEnd) {
                    this._initialized = true;
                    this.setRange(rangeStart, rangeEnd, false);
                    this.setWindow(rangeStart, rangeEnd, false);
                    this.draw();
                };
                FlameChartBase.prototype.setWindow = function (start, end, draw) {
                    if (draw === void 0) { draw = true; }
                    this._windowStart = start;
                    this._windowEnd = end;
                    !draw || this.draw();
                };
                FlameChartBase.prototype.setRange = function (start, end, draw) {
                    if (draw === void 0) { draw = true; }
                    this._rangeStart = start;
                    this._rangeEnd = end;
                    !draw || this.draw();
                };
                FlameChartBase.prototype.destroy = function () {
                    this._mouseController.destroy();
                    this._mouseController = null;
                    this._controller.container.removeChild(this._canvas);
                    this._controller = null;
                };
                FlameChartBase.prototype._resetCanvas = function () {
                    var ratio = window.devicePixelRatio;
                    var canvas = this._canvas;
                    canvas.width = this._width * ratio;
                    canvas.height = this._height * ratio;
                    canvas.style.width = this._width + "px";
                    canvas.style.height = this._height + "px";
                };
                FlameChartBase.prototype.draw = function () {
                };
                FlameChartBase.prototype._almostEq = function (a, b, precision) {
                    if (precision === void 0) { precision = 10; }
                    var pow10 = Math.pow(10, precision);
                    return Math.abs(a - b) < (1 / pow10);
                };
                FlameChartBase.prototype._windowEqRange = function () {
                    return (this._almostEq(this._windowStart, this._rangeStart) && this._almostEq(this._windowEnd, this._rangeEnd));
                };
                FlameChartBase.prototype._decimalPlaces = function (value) {
                    return ((+value).toFixed(10)).replace(/^-?\d*\.?|0+$/g, '').length;
                };
                FlameChartBase.prototype._toPixelsRelative = function (time) {
                    return 0;
                };
                FlameChartBase.prototype._toPixels = function (time) {
                    return 0;
                };
                FlameChartBase.prototype._toTimeRelative = function (px) {
                    return 0;
                };
                FlameChartBase.prototype._toTime = function (px) {
                    return 0;
                };
                FlameChartBase.prototype.onMouseWheel = function (x, y, delta) {
                    var time = this._toTime(x);
                    var windowStart = this._windowStart;
                    var windowEnd = this._windowEnd;
                    var windowLen = windowEnd - windowStart;
                    /*
                     * Find maximum allowed delta
                     * (windowEnd + (windowEnd - time) * delta) - (windowStart + (windowStart - time) * delta) = LEN
                     * (windowEnd - windowStart) + ((windowEnd - time) * delta) - ((windowStart - time) * delta) = LEN
                     * (windowEnd - windowStart) + ((windowEnd - time) - (windowStart - time)) * delta = LEN
                     * (windowEnd - windowStart) + (windowEnd - windowStart) * delta = LEN
                     * (windowEnd - windowStart) * delta = LEN - (windowEnd - windowStart)
                     * delta = (LEN - (windowEnd - windowStart)) / (windowEnd - windowStart)
                     */
                    var maxDelta = Math.max((FlameChartBase.MIN_WINDOW_LEN - windowLen) / windowLen, delta);
                    var start = windowStart + (windowStart - time) * maxDelta;
                    var end = windowEnd + (windowEnd - time) * maxDelta;
                    this._controller.setWindow(start, end);
                    this.onHoverEnd();
                };
                FlameChartBase.prototype.onMouseDown = function (x, y) {
                };
                FlameChartBase.prototype.onMouseMove = function (x, y) {
                };
                FlameChartBase.prototype.onMouseOver = function (x, y) {
                };
                FlameChartBase.prototype.onMouseOut = function () {
                };
                FlameChartBase.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                };
                FlameChartBase.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                };
                FlameChartBase.prototype.onClick = function (x, y) {
                };
                FlameChartBase.prototype.onHoverStart = function (x, y) {
                };
                FlameChartBase.prototype.onHoverEnd = function () {
                };
                FlameChartBase.DRAGHANDLE_WIDTH = 4;
                FlameChartBase.MIN_WINDOW_LEN = 0.1;
                return FlameChartBase;
            }());
            Profiler.FlameChartBase = FlameChartBase;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var trimMiddle = Shumway.StringUtilities.trimMiddle;
            var FlameChart = /** @class */ (function (_super) {
                __extends(FlameChart, _super);
                function FlameChart(controller, snapshot) {
                    var _this = _super.call(this, controller) || this;
                    _this._textWidth = {};
                    /**
                     * Don't paint frames whose width is smaller than this value. This helps a lot when drawing
                     * large ranges. This can be < 1 since anti-aliasing can look quite nice.
                     */
                    _this._minFrameWidthInPixels = 1;
                    _this._snapshot = snapshot;
                    _this._kindStyle = Object.create(null);
                    return _this;
                }
                FlameChart.prototype.setSize = function (width, height) {
                    _super.prototype.setSize.call(this, width, height || this._initialized ? this._maxDepth * 12.5 : 100);
                };
                FlameChart.prototype.initialize = function (rangeStart, rangeEnd) {
                    this._initialized = true;
                    this._maxDepth = this._snapshot.maxDepth;
                    this.setRange(rangeStart, rangeEnd, false);
                    this.setWindow(rangeStart, rangeEnd, false);
                    this.setSize(this._width, this._maxDepth * 12.5);
                };
                FlameChart.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    this._snapshot = null;
                };
                FlameChart.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;
                    Shumway.ColorStyle.reset();
                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.bodyBackground(1);
                    context.fillRect(0, 0, this._width, this._height);
                    if (this._initialized) {
                        this._drawChildren(this._snapshot);
                    }
                    context.restore();
                };
                FlameChart.prototype._drawChildren = function (parent, depth) {
                    if (depth === void 0) { depth = 0; }
                    var range = parent.getChildRange(this._windowStart, this._windowEnd);
                    if (range) {
                        for (var i = range.startIndex; i <= range.endIndex; i++) {
                            var child = parent.children[i];
                            if (this._drawFrame(child, depth)) {
                                this._drawChildren(child, depth + 1);
                            }
                        }
                    }
                };
                FlameChart.prototype._drawFrame = function (frame, depth) {
                    var context = this._context;
                    var frameHPadding = 0.5;
                    var left = this._toPixels(frame.startTime);
                    var right = this._toPixels(frame.endTime);
                    var width = right - left;
                    if (width <= this._minFrameWidthInPixels) {
                        context.fillStyle = this._controller.theme.tabToolbar(1);
                        context.fillRect(left, depth * (12 + frameHPadding), this._minFrameWidthInPixels, 12 + (frame.maxDepth - frame.depth) * 12.5);
                        return false;
                    }
                    if (left < 0) {
                        right = width + left;
                        left = 0;
                    }
                    var adjustedWidth = right - left;
                    var style = this._kindStyle[frame.kind.id];
                    if (!style) {
                        var background = Shumway.ColorStyle.randomStyle();
                        style = this._kindStyle[frame.kind.id] = {
                            bgColor: background,
                            textColor: Shumway.ColorStyle.contrastStyle(background)
                        };
                    }
                    context.save();
                    //if (this._hoveredFrame && this._hoveredFrame.kind !== frame.kind) {
                    //  context.globalAlpha = 0.4;
                    //}
                    context.fillStyle = style.bgColor;
                    context.fillRect(left, depth * (12 + frameHPadding), adjustedWidth, 12);
                    if (width > 12) {
                        var label = frame.kind.name;
                        if (label && label.length) {
                            var labelHPadding = 2;
                            label = this._prepareText(context, label, adjustedWidth - labelHPadding * 2);
                            if (label.length) {
                                context.fillStyle = style.textColor;
                                context.textBaseline = "bottom";
                                context.fillText(label, left + labelHPadding, (depth + 1) * (12 + frameHPadding) - 1);
                            }
                        }
                    }
                    context.restore();
                    return true;
                };
                FlameChart.prototype._prepareText = function (context, title, maxSize) {
                    var titleWidth = this._measureWidth(context, title);
                    if (maxSize > titleWidth) {
                        return title;
                    }
                    var l = 3;
                    var r = title.length;
                    while (l < r) {
                        var m = (l + r) >> 1;
                        if (this._measureWidth(context, trimMiddle(title, m)) < maxSize) {
                            l = m + 1;
                        }
                        else {
                            r = m;
                        }
                    }
                    title = trimMiddle(title, r - 1);
                    titleWidth = this._measureWidth(context, title);
                    if (titleWidth <= maxSize) {
                        return title;
                    }
                    return "";
                };
                FlameChart.prototype._measureWidth = function (context, text) {
                    var width = this._textWidth[text];
                    if (!width) {
                        width = context.measureText(text).width;
                        this._textWidth[text] = width;
                    }
                    return width;
                };
                FlameChart.prototype._toPixelsRelative = function (time) {
                    return time * this._width / (this._windowEnd - this._windowStart);
                };
                FlameChart.prototype._toPixels = function (time) {
                    return this._toPixelsRelative(time - this._windowStart);
                };
                FlameChart.prototype._toTimeRelative = function (px) {
                    return px * (this._windowEnd - this._windowStart) / this._width;
                };
                FlameChart.prototype._toTime = function (px) {
                    return this._toTimeRelative(px) + this._windowStart;
                };
                FlameChart.prototype._getFrameAtPosition = function (x, y) {
                    var time = this._toTime(x);
                    var depth = 1 + (y / 12.5) | 0;
                    var frame = this._snapshot.query(time);
                    if (frame && frame.depth >= depth) {
                        while (frame && frame.depth > depth) {
                            frame = frame.parent;
                        }
                        return frame;
                    }
                    return null;
                };
                FlameChart.prototype.onMouseDown = function (x, y) {
                    if (!this._windowEqRange()) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.ALL_SCROLL);
                        this._dragInfo = {
                            windowStartInitial: this._windowStart,
                            windowEndInitial: this._windowEnd,
                            target: 1 /* WINDOW */
                        };
                    }
                };
                FlameChart.prototype.onMouseMove = function (x, y) {
                };
                FlameChart.prototype.onMouseOver = function (x, y) {
                };
                FlameChart.prototype.onMouseOut = function () {
                };
                FlameChart.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    var dragInfo = this._dragInfo;
                    if (dragInfo) {
                        var delta = this._toTimeRelative(-deltaX);
                        var windowStart = dragInfo.windowStartInitial + delta;
                        var windowEnd = dragInfo.windowEndInitial + delta;
                        this._controller.setWindow(windowStart, windowEnd);
                    }
                };
                FlameChart.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    this._dragInfo = null;
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };
                FlameChart.prototype.onClick = function (x, y) {
                    this._dragInfo = null;
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };
                FlameChart.prototype.onHoverStart = function (x, y) {
                    var frame = this._getFrameAtPosition(x, y);
                    if (frame) {
                        this._hoveredFrame = frame;
                        this._controller.showTooltip(this, frame, x, y);
                        //this._draw();
                    }
                };
                FlameChart.prototype.onHoverEnd = function () {
                    if (this._hoveredFrame) {
                        this._hoveredFrame = null;
                        this._controller.hideTooltip();
                        //this._draw();
                    }
                };
                FlameChart.prototype.getStatistics = function (kind) {
                    var snapshot = this._snapshot;
                    if (!snapshot.statistics) {
                        snapshot.calculateStatistics();
                    }
                    return snapshot.statistics[kind.id];
                };
                return FlameChart;
            }(Profiler.FlameChartBase));
            Profiler.FlameChart = FlameChart;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;
            var FlameChartOverviewMode;
            (function (FlameChartOverviewMode) {
                FlameChartOverviewMode[FlameChartOverviewMode["OVERLAY"] = 0] = "OVERLAY";
                FlameChartOverviewMode[FlameChartOverviewMode["STACK"] = 1] = "STACK";
                FlameChartOverviewMode[FlameChartOverviewMode["UNION"] = 2] = "UNION";
            })(FlameChartOverviewMode = Profiler.FlameChartOverviewMode || (Profiler.FlameChartOverviewMode = {}));
            var FlameChartOverview = /** @class */ (function (_super) {
                __extends(FlameChartOverview, _super);
                function FlameChartOverview(controller, mode) {
                    return _super.call(this, controller, mode) || this;
                }
                FlameChartOverview.prototype.preConstructor = function (mode) {
                    if (mode === void 0) { mode = 1 /* STACK */; }
                    this._mode = mode;
                    this._overviewCanvasDirty = true;
                    this._overviewCanvas = document.createElement("canvas");
                    this._overviewContext = this._overviewCanvas.getContext("2d");
                };
                FlameChartOverview.prototype.setSize = function (width, height) {
                    _super.prototype.setSize.call(this, width, height || 64);
                };
                Object.defineProperty(FlameChartOverview.prototype, "mode", {
                    set: function (value) {
                        this._mode = value;
                        this.draw();
                    },
                    enumerable: true,
                    configurable: true
                });
                FlameChartOverview.prototype._resetCanvas = function () {
                    _super.prototype._resetCanvas.call(this);
                    this._overviewCanvas.width = this._canvas.width;
                    this._overviewCanvas.height = this._canvas.height;
                    this._overviewCanvasDirty = true;
                };
                FlameChartOverview.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;
                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.bodyBackground(1); //"rgba(17, 19, 21, 1)";
                    context.fillRect(0, 0, width, height);
                    context.restore();
                    if (this._initialized) {
                        if (this._overviewCanvasDirty) {
                            this._drawChart();
                            this._overviewCanvasDirty = false;
                        }
                        context.drawImage(this._overviewCanvas, 0, 0);
                        this._drawSelection();
                    }
                };
                FlameChartOverview.prototype._drawSelection = function () {
                    var context = this._context;
                    var height = this._height;
                    var ratio = window.devicePixelRatio;
                    var left = this._selection ? this._selection.left : this._toPixels(this._windowStart);
                    var right = this._selection ? this._selection.right : this._toPixels(this._windowEnd);
                    var theme = this._controller.theme;
                    context.save();
                    context.scale(ratio, ratio);
                    // Draw fills
                    if (this._selection) {
                        context.fillStyle = theme.selectionText(0.15); //"rgba(245, 247, 250, 0.15)";
                        context.fillRect(left, 1, right - left, height - 1);
                        context.fillStyle = "rgba(133, 0, 0, 1)";
                        context.fillRect(left + 0.5, 0, right - left - 1, 4);
                        context.fillRect(left + 0.5, height - 4, right - left - 1, 4);
                    }
                    else {
                        context.fillStyle = theme.bodyBackground(0.4); //"rgba(17, 19, 21, 0.4)";
                        context.fillRect(0, 1, left, height - 1);
                        context.fillRect(right, 1, this._width, height - 1);
                    }
                    // Draw border lines
                    context.beginPath();
                    context.moveTo(left, 0);
                    context.lineTo(left, height);
                    context.moveTo(right, 0);
                    context.lineTo(right, height);
                    context.lineWidth = 0.5;
                    context.strokeStyle = theme.foregroundTextGrey(1); //"rgba(245, 247, 250, 1)";
                    context.stroke();
                    // Draw info labels
                    var start = this._selection ? this._toTime(this._selection.left) : this._windowStart;
                    var end = this._selection ? this._toTime(this._selection.right) : this._windowEnd;
                    var time = Math.abs(end - start);
                    context.fillStyle = theme.selectionText(0.5); //"rgba(255, 255, 255, 0.5)";
                    context.font = '8px sans-serif';
                    context.textBaseline = "alphabetic";
                    context.textAlign = "end";
                    // Selection Range in MS
                    context.fillText(time.toFixed(2), Math.min(left, right) - 4, 10);
                    // Selection Range in Frames
                    context.fillText((time / 60).toFixed(2), Math.min(left, right) - 4, 20);
                    context.restore();
                };
                FlameChartOverview.prototype._drawChart = function () {
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;
                    var profile = this._controller.activeProfile;
                    var samplesPerPixel = 4;
                    var samplesCount = width * samplesPerPixel;
                    var sampleTimeInterval = profile.totalTime / samplesCount;
                    var contextOverview = this._overviewContext;
                    var overviewChartColor = this._controller.theme.blueHighlight(1);
                    contextOverview.save();
                    contextOverview.translate(0, ratio * height);
                    var yScale = -ratio * height / (profile.maxDepth - 1);
                    contextOverview.scale(ratio / samplesPerPixel, yScale);
                    contextOverview.clearRect(0, 0, samplesCount, profile.maxDepth - 1);
                    if (this._mode == 1 /* STACK */) {
                        contextOverview.scale(1, 1 / profile.snapshotCount);
                    }
                    for (var i = 0, n = profile.snapshotCount; i < n; i++) {
                        var snapshot = profile.getSnapshotAt(i);
                        if (snapshot) {
                            var deepestFrame = null;
                            var depth = 0;
                            contextOverview.beginPath();
                            contextOverview.moveTo(0, 0);
                            var x = void 0;
                            for (x = 0; x < samplesCount; x++) {
                                var time = profile.startTime + x * sampleTimeInterval;
                                if (!deepestFrame) {
                                    deepestFrame = snapshot.query(time);
                                }
                                else {
                                    deepestFrame = deepestFrame.queryNext(time);
                                }
                                depth = deepestFrame ? deepestFrame.getDepth() - 1 : 0;
                                contextOverview.lineTo(x, depth);
                            }
                            contextOverview.lineTo(x, 0);
                            contextOverview.fillStyle = overviewChartColor;
                            contextOverview.fill();
                            if (this._mode == 1 /* STACK */) {
                                contextOverview.translate(0, -height * ratio / yScale);
                            }
                        }
                    }
                    contextOverview.restore();
                };
                FlameChartOverview.prototype._toPixelsRelative = function (time) {
                    return time * this._width / (this._rangeEnd - this._rangeStart);
                };
                FlameChartOverview.prototype._toPixels = function (time) {
                    return this._toPixelsRelative(time - this._rangeStart);
                };
                FlameChartOverview.prototype._toTimeRelative = function (px) {
                    return px * (this._rangeEnd - this._rangeStart) / this._width;
                };
                FlameChartOverview.prototype._toTime = function (px) {
                    return this._toTimeRelative(px) + this._rangeStart;
                };
                FlameChartOverview.prototype._getDragTargetUnderCursor = function (x, y) {
                    if (y >= 0 && y < this._height) {
                        var left = this._toPixels(this._windowStart);
                        var right = this._toPixels(this._windowEnd);
                        var radius = 2 + (Profiler.FlameChartBase.DRAGHANDLE_WIDTH) / 2;
                        var leftHandle = (x >= left - radius && x <= left + radius);
                        var rightHandle = (x >= right - radius && x <= right + radius);
                        if (leftHandle && rightHandle) {
                            return 4 /* HANDLE_BOTH */;
                        }
                        else if (leftHandle) {
                            return 2 /* HANDLE_LEFT */;
                        }
                        else if (rightHandle) {
                            return 3 /* HANDLE_RIGHT */;
                        }
                        else if (!this._windowEqRange() && x > left + radius && x < right - radius) {
                            return 1 /* WINDOW */;
                        }
                    }
                    return 0 /* NONE */;
                };
                FlameChartOverview.prototype.onMouseDown = function (x, y) {
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget === 0 /* NONE */) {
                        this._selection = { left: x, right: x };
                        this.draw();
                    }
                    else {
                        if (dragTarget === 1 /* WINDOW */) {
                            this._mouseController.updateCursor(Profiler.MouseCursor.GRABBING);
                        }
                        this._dragInfo = {
                            windowStartInitial: this._windowStart,
                            windowEndInitial: this._windowEnd,
                            target: dragTarget
                        };
                    }
                };
                FlameChartOverview.prototype.onMouseMove = function (x, y) {
                    var cursor = Profiler.MouseCursor.DEFAULT;
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget !== 0 /* NONE */ && !this._selection) {
                        cursor = (dragTarget === 1 /* WINDOW */) ? Profiler.MouseCursor.GRAB : Profiler.MouseCursor.EW_RESIZE;
                    }
                    this._mouseController.updateCursor(cursor);
                };
                FlameChartOverview.prototype.onMouseOver = function (x, y) {
                    this.onMouseMove(x, y);
                };
                FlameChartOverview.prototype.onMouseOut = function () {
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };
                FlameChartOverview.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    if (this._selection) {
                        this._selection = { left: startX, right: clamp(currentX, 0, this._width - 1) };
                        this.draw();
                    }
                    else {
                        var dragInfo = this._dragInfo;
                        if (dragInfo.target === 4 /* HANDLE_BOTH */) {
                            if (deltaX !== 0) {
                                dragInfo.target = (deltaX < 0) ? 2 /* HANDLE_LEFT */ : 3 /* HANDLE_RIGHT */;
                            }
                            else {
                                return;
                            }
                        }
                        var windowStart = this._windowStart;
                        var windowEnd = this._windowEnd;
                        var delta = this._toTimeRelative(deltaX);
                        switch (dragInfo.target) {
                            case 1 /* WINDOW */:
                                windowStart = dragInfo.windowStartInitial + delta;
                                windowEnd = dragInfo.windowEndInitial + delta;
                                break;
                            case 2 /* HANDLE_LEFT */:
                                windowStart = clamp(dragInfo.windowStartInitial + delta, this._rangeStart, windowEnd - Profiler.FlameChartBase.MIN_WINDOW_LEN);
                                break;
                            case 3 /* HANDLE_RIGHT */:
                                windowEnd = clamp(dragInfo.windowEndInitial + delta, windowStart + Profiler.FlameChartBase.MIN_WINDOW_LEN, this._rangeEnd);
                                break;
                            default:
                                return;
                        }
                        this._controller.setWindow(windowStart, windowEnd);
                    }
                };
                FlameChartOverview.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    if (this._selection) {
                        this._selection = null;
                        this._controller.setWindow(this._toTime(startX), this._toTime(currentX));
                    }
                    this._dragInfo = null;
                    this.onMouseMove(currentX, currentY);
                };
                FlameChartOverview.prototype.onClick = function (x, y) {
                    this._dragInfo = null;
                    this._selection = null;
                    if (!this._windowEqRange()) {
                        var dragTarget = this._getDragTargetUnderCursor(x, y);
                        if (dragTarget === 0 /* NONE */) {
                            this._controller.moveWindowTo(this._toTime(x));
                        }
                        this.onMouseMove(x, y);
                    }
                    this.draw();
                };
                FlameChartOverview.prototype.onHoverStart = function (x, y) {
                };
                FlameChartOverview.prototype.onHoverEnd = function () {
                };
                return FlameChartOverview;
            }(Profiler.FlameChartBase));
            Profiler.FlameChartOverview = FlameChartOverview;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var clamp = Shumway.NumberUtilities.clamp;
            var FlameChartHeaderType;
            (function (FlameChartHeaderType) {
                FlameChartHeaderType[FlameChartHeaderType["OVERVIEW"] = 0] = "OVERVIEW";
                FlameChartHeaderType[FlameChartHeaderType["CHART"] = 1] = "CHART";
            })(FlameChartHeaderType = Profiler.FlameChartHeaderType || (Profiler.FlameChartHeaderType = {}));
            var FlameChartHeader = /** @class */ (function (_super) {
                __extends(FlameChartHeader, _super);
                function FlameChartHeader(controller, type) {
                    return _super.call(this, controller, type) || this;
                }
                FlameChartHeader.prototype.preConstructor = function (type) {
                    if (type === void 0) { type = null; }
                    this._type = type;
                };
                FlameChartHeader.prototype.draw = function () {
                    var context = this._context;
                    var ratio = window.devicePixelRatio;
                    var width = this._width;
                    var height = this._height;
                    context.save();
                    context.scale(ratio, ratio);
                    context.fillStyle = this._controller.theme.tabToolbar(1); //"#252c33";
                    context.fillRect(0, 0, width, height);
                    if (this._initialized) {
                        if (this._type == 0 /* OVERVIEW */) {
                            var left = this._toPixels(this._windowStart);
                            var right = this._toPixels(this._windowEnd);
                            context.fillStyle = this._controller.theme.bodyBackground(1); //"#14171a";
                            context.fillRect(left, 0, right - left, height);
                            this._drawLabels(this._rangeStart, this._rangeEnd);
                            this._drawDragHandle(left);
                            this._drawDragHandle(right);
                        }
                        else {
                            this._drawLabels(this._windowStart, this._windowEnd);
                        }
                    }
                    context.restore();
                };
                FlameChartHeader.prototype._drawLabels = function (rangeStart, rangeEnd) {
                    var context = this._context;
                    var tickInterval = this._calculateTickInterval(rangeStart, rangeEnd);
                    var tick = Math.ceil(rangeStart / tickInterval) * tickInterval;
                    var showSeconds = (tickInterval >= 500);
                    var divisor = showSeconds ? 1000 : 1;
                    var precision = this._decimalPlaces(tickInterval / divisor);
                    var unit = showSeconds ? "s" : "ms";
                    var x = this._toPixels(tick);
                    var y = this._height / 2;
                    var theme = this._controller.theme;
                    context.lineWidth = 1;
                    context.strokeStyle = theme.contentTextDarkGrey(0.5); //"rgba(95, 115, 135, 0.5)";
                    context.fillStyle = theme.contentTextDarkGrey(1); //"rgba(95, 115, 135, 1)";
                    context.textAlign = "right";
                    context.textBaseline = "middle";
                    context.font = '11px sans-serif';
                    var maxWidth = this._width + FlameChartHeader.TICK_MAX_WIDTH;
                    while (x < maxWidth) {
                        var tickStr = (tick / divisor).toFixed(precision) + " " + unit;
                        context.fillText(tickStr, x - 7, y + 1);
                        context.beginPath();
                        context.moveTo(x, 0);
                        context.lineTo(x, this._height + 1);
                        context.closePath();
                        context.stroke();
                        tick += tickInterval;
                        x = this._toPixels(tick);
                    }
                };
                FlameChartHeader.prototype._calculateTickInterval = function (rangeStart, rangeEnd) {
                    // http://stackoverflow.com/a/361687
                    var tickCount = this._width / FlameChartHeader.TICK_MAX_WIDTH;
                    var range = rangeEnd - rangeStart;
                    var minimum = range / tickCount;
                    var magnitude = Math.pow(10, Math.floor(Math.log(minimum) / Math.LN10));
                    var residual = minimum / magnitude;
                    if (residual > 5) {
                        return 10 * magnitude;
                    }
                    else if (residual > 2) {
                        return 5 * magnitude;
                    }
                    else if (residual > 1) {
                        return 2 * magnitude;
                    }
                    return magnitude;
                };
                FlameChartHeader.prototype._drawDragHandle = function (pos) {
                    var context = this._context;
                    context.lineWidth = 2;
                    context.strokeStyle = this._controller.theme.bodyBackground(1); //"#14171a";
                    context.fillStyle = this._controller.theme.foregroundTextGrey(0.7); //"rgba(182, 186, 191, 0.7)";
                    this._drawRoundedRect(context, pos - Profiler.FlameChartBase.DRAGHANDLE_WIDTH / 2, 1, Profiler.FlameChartBase.DRAGHANDLE_WIDTH, this._height - 2, 2, true);
                };
                FlameChartHeader.prototype._drawRoundedRect = function (context, x, y, width, height, radius, stroke, fill) {
                    if (stroke === void 0) { stroke = true; }
                    if (fill === void 0) { fill = true; }
                    context.beginPath();
                    context.moveTo(x + radius, y);
                    context.lineTo(x + width - radius, y);
                    context.quadraticCurveTo(x + width, y, x + width, y + radius);
                    context.lineTo(x + width, y + height - radius);
                    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    context.lineTo(x + radius, y + height);
                    context.quadraticCurveTo(x, y + height, x, y + height - radius);
                    context.lineTo(x, y + radius);
                    context.quadraticCurveTo(x, y, x + radius, y);
                    context.closePath();
                    if (stroke) {
                        context.stroke();
                    }
                    if (fill) {
                        context.fill();
                    }
                };
                FlameChartHeader.prototype._toPixelsRelative = function (time) {
                    var range = (this._type === 0 /* OVERVIEW */)
                        ? this._rangeEnd - this._rangeStart
                        : this._windowEnd - this._windowStart;
                    return time * this._width / range;
                };
                FlameChartHeader.prototype._toPixels = function (time) {
                    var start = (this._type === 0 /* OVERVIEW */) ? this._rangeStart : this._windowStart;
                    return this._toPixelsRelative(time - start);
                };
                FlameChartHeader.prototype._toTimeRelative = function (px) {
                    var range = (this._type === 0 /* OVERVIEW */)
                        ? this._rangeEnd - this._rangeStart
                        : this._windowEnd - this._windowStart;
                    return px * range / this._width;
                };
                FlameChartHeader.prototype._toTime = function (px) {
                    var start = (this._type === 0 /* OVERVIEW */) ? this._rangeStart : this._windowStart;
                    return this._toTimeRelative(px) + start;
                };
                FlameChartHeader.prototype._getDragTargetUnderCursor = function (x, y) {
                    if (y >= 0 && y < this._height) {
                        if (this._type === 0 /* OVERVIEW */) {
                            var left = this._toPixels(this._windowStart);
                            var right = this._toPixels(this._windowEnd);
                            var radius = 2 + (Profiler.FlameChartBase.DRAGHANDLE_WIDTH) / 2;
                            var leftHandle = (x >= left - radius && x <= left + radius);
                            var rightHandle = (x >= right - radius && x <= right + radius);
                            if (leftHandle && rightHandle) {
                                return 4 /* HANDLE_BOTH */;
                            }
                            else if (leftHandle) {
                                return 2 /* HANDLE_LEFT */;
                            }
                            else if (rightHandle) {
                                return 3 /* HANDLE_RIGHT */;
                            }
                            else if (!this._windowEqRange()) {
                                return 1 /* WINDOW */;
                            }
                        }
                        else if (!this._windowEqRange()) {
                            return 1 /* WINDOW */;
                        }
                    }
                    return 0 /* NONE */;
                };
                FlameChartHeader.prototype.onMouseDown = function (x, y) {
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget === 1 /* WINDOW */) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.GRABBING);
                    }
                    this._dragInfo = {
                        windowStartInitial: this._windowStart,
                        windowEndInitial: this._windowEnd,
                        target: dragTarget
                    };
                };
                FlameChartHeader.prototype.onMouseMove = function (x, y) {
                    var cursor = Profiler.MouseCursor.DEFAULT;
                    var dragTarget = this._getDragTargetUnderCursor(x, y);
                    if (dragTarget !== 0 /* NONE */) {
                        if (dragTarget !== 1 /* WINDOW */) {
                            cursor = Profiler.MouseCursor.EW_RESIZE;
                        }
                        else if (dragTarget === 1 /* WINDOW */ && !this._windowEqRange()) {
                            cursor = Profiler.MouseCursor.GRAB;
                        }
                    }
                    this._mouseController.updateCursor(cursor);
                };
                FlameChartHeader.prototype.onMouseOver = function (x, y) {
                    this.onMouseMove(x, y);
                };
                FlameChartHeader.prototype.onMouseOut = function () {
                    this._mouseController.updateCursor(Profiler.MouseCursor.DEFAULT);
                };
                FlameChartHeader.prototype.onDrag = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    var dragInfo = this._dragInfo;
                    if (dragInfo.target === 4 /* HANDLE_BOTH */) {
                        if (deltaX !== 0) {
                            dragInfo.target = (deltaX < 0) ? 2 /* HANDLE_LEFT */ : 3 /* HANDLE_RIGHT */;
                        }
                        else {
                            return;
                        }
                    }
                    var windowStart = this._windowStart;
                    var windowEnd = this._windowEnd;
                    var delta = this._toTimeRelative(deltaX);
                    switch (dragInfo.target) {
                        case 1 /* WINDOW */:
                            var mult = (this._type === 0 /* OVERVIEW */) ? 1 : -1;
                            windowStart = dragInfo.windowStartInitial + mult * delta;
                            windowEnd = dragInfo.windowEndInitial + mult * delta;
                            break;
                        case 2 /* HANDLE_LEFT */:
                            windowStart = clamp(dragInfo.windowStartInitial + delta, this._rangeStart, windowEnd - Profiler.FlameChartBase.MIN_WINDOW_LEN);
                            break;
                        case 3 /* HANDLE_RIGHT */:
                            windowEnd = clamp(dragInfo.windowEndInitial + delta, windowStart + Profiler.FlameChartBase.MIN_WINDOW_LEN, this._rangeEnd);
                            break;
                        default:
                            return;
                    }
                    this._controller.setWindow(windowStart, windowEnd);
                };
                FlameChartHeader.prototype.onDragEnd = function (startX, startY, currentX, currentY, deltaX, deltaY) {
                    this._dragInfo = null;
                    this.onMouseMove(currentX, currentY);
                };
                FlameChartHeader.prototype.onClick = function (x, y) {
                    if (this._dragInfo.target === 1 /* WINDOW */) {
                        this._mouseController.updateCursor(Profiler.MouseCursor.GRAB);
                    }
                };
                FlameChartHeader.prototype.onHoverStart = function (x, y) {
                };
                FlameChartHeader.prototype.onHoverEnd = function () {
                };
                FlameChartHeader.TICK_MAX_WIDTH = 75;
                return FlameChartHeader;
            }(Profiler.FlameChartBase));
            Profiler.FlameChartHeader = FlameChartHeader;
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var TraceLogger;
            (function (TraceLogger_1) {
                var TraceLoggerProgressInfo = /** @class */ (function () {
                    function TraceLoggerProgressInfo(pageLoaded, threadsTotal, threadsLoaded, threadFilesTotal, threadFilesLoaded) {
                        this.pageLoaded = pageLoaded;
                        this.threadsTotal = threadsTotal;
                        this.threadsLoaded = threadsLoaded;
                        this.threadFilesTotal = threadFilesTotal;
                        this.threadFilesLoaded = threadFilesLoaded;
                    }
                    TraceLoggerProgressInfo.prototype.toString = function () {
                        return "[" + ["pageLoaded", "threadsTotal", "threadsLoaded", "threadFilesTotal", "threadFilesLoaded"].map(function (value, i, arr) {
                            return value + ":" + this[value];
                        }, this).join(", ") + "]";
                    };
                    return TraceLoggerProgressInfo;
                }());
                TraceLogger_1.TraceLoggerProgressInfo = TraceLoggerProgressInfo;
                var TraceLogger = /** @class */ (function () {
                    function TraceLogger(baseUrl) {
                        this._baseUrl = baseUrl;
                        this._threads = [];
                        this._progressInfo = null;
                    }
                    TraceLogger.prototype.loadPage = function (url, callback, progress) {
                        this._threads = [];
                        this._pageLoadCallback = callback;
                        this._pageLoadProgressCallback = progress;
                        this._progressInfo = new TraceLoggerProgressInfo(false, 0, 0, 0, 0);
                        this._loadData([url], this._onLoadPage.bind(this));
                    };
                    Object.defineProperty(TraceLogger.prototype, "buffers", {
                        get: function () {
                            var buffers = [];
                            for (var i = 0, n = this._threads.length; i < n; i++) {
                                buffers.push(this._threads[i].buffer);
                            }
                            return buffers;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TraceLogger.prototype._onProgress = function () {
                        if (this._pageLoadProgressCallback) {
                            this._pageLoadProgressCallback.call(this, this._progressInfo);
                        }
                    };
                    TraceLogger.prototype._onLoadPage = function (result) {
                        if (result && result.length == 1) {
                            var self_6 = this;
                            var count_1 = 0;
                            var threads = result[0];
                            var threadCount_1 = threads.length;
                            this._threads = Array(threadCount_1);
                            this._progressInfo.pageLoaded = true;
                            this._progressInfo.threadsTotal = threadCount_1;
                            for (var i = 0; i < threads.length; i++) {
                                var thread = threads[i];
                                var urls = [thread.dict, thread.tree];
                                if (thread.corrections) {
                                    urls.push(thread.corrections);
                                }
                                this._progressInfo.threadFilesTotal += urls.length;
                                this._loadData(urls, (function (index) {
                                    return function (result) {
                                        if (result) {
                                            var thread_1 = new TraceLogger_1.Thread(result);
                                            thread_1.buffer.name = "Thread " + index;
                                            self_6._threads[index] = thread_1;
                                        }
                                        count_1++;
                                        self_6._progressInfo.threadsLoaded++;
                                        self_6._onProgress();
                                        if (count_1 === threadCount_1) {
                                            self_6._pageLoadCallback.call(self_6, null, self_6._threads);
                                        }
                                    };
                                })(i), function (count) {
                                    self_6._progressInfo.threadFilesLoaded++;
                                    self_6._onProgress();
                                });
                            }
                            this._onProgress();
                        }
                        else {
                            this._pageLoadCallback.call(this, "Error loading page.", null);
                        }
                    };
                    TraceLogger.prototype._loadData = function (urls, callback, progress) {
                        var count = 0;
                        var errors = 0;
                        var expected = urls.length;
                        var received = [];
                        received.length = expected;
                        for (var i = 0; i < expected; i++) {
                            var url = this._baseUrl + urls[i];
                            var isTL = /\.tl$/i.test(url);
                            var xhr = new XMLHttpRequest();
                            var responseType = isTL ? "arraybuffer" : "json";
                            xhr.open('GET', url, true);
                            xhr.responseType = responseType;
                            xhr.onload = (function (index, type) {
                                return function (event) {
                                    if (type === "json") {
                                        var json = this.response;
                                        if (typeof json === "string") {
                                            try {
                                                json = JSON.parse(json);
                                                received[index] = json;
                                            }
                                            catch (e) {
                                                errors++;
                                            }
                                        }
                                        else {
                                            received[index] = json;
                                        }
                                    }
                                    else {
                                        received[index] = this.response;
                                    }
                                    ++count;
                                    if (progress) {
                                        progress(count);
                                    }
                                    if (count === expected) {
                                        callback(received);
                                    }
                                };
                            })(i, responseType);
                            xhr.send();
                        }
                    };
                    TraceLogger.colors = [
                        "#0044ff", "#8c4b00", "#cc5c33", "#ff80c4", "#ffbfd9", "#ff8800", "#8c5e00", "#adcc33", "#b380ff", "#bfd9ff",
                        "#ffaa00", "#8c0038", "#bf8f30", "#f780ff", "#cc99c9", "#aaff00", "#000073", "#452699", "#cc8166", "#cca799",
                        "#000066", "#992626", "#cc6666", "#ccc299", "#ff6600", "#526600", "#992663", "#cc6681", "#99ccc2", "#ff0066",
                        "#520066", "#269973", "#61994d", "#739699", "#ffcc00", "#006629", "#269199", "#94994d", "#738299", "#ff0000",
                        "#590000", "#234d8c", "#8c6246", "#7d7399", "#ee00ff", "#00474d", "#8c2385", "#8c7546", "#7c8c69", "#eeff00",
                        "#4d003d", "#662e1a", "#62468c", "#8c6969", "#6600ff", "#4c2900", "#1a6657", "#8c464f", "#8c6981", "#44ff00",
                        "#401100", "#1a2466", "#663355", "#567365", "#d90074", "#403300", "#101d40", "#59562d", "#66614d", "#cc0000",
                        "#002b40", "#234010", "#4c2626", "#4d5e66", "#00a3cc", "#400011", "#231040", "#4c3626", "#464359", "#0000bf",
                        "#331b00", "#80e6ff", "#311a33", "#4d3939", "#a69b00", "#003329", "#80ffb2", "#331a20", "#40303d", "#00a658",
                        "#40ffd9", "#ffc480", "#ffe1bf", "#332b26", "#8c2500", "#9933cc", "#80fff6", "#ffbfbf", "#303326", "#005e8c",
                        "#33cc47", "#b2ff80", "#c8bfff", "#263332", "#00708c", "#cc33ad", "#ffe680", "#f2ffbf", "#262a33", "#388c00",
                        "#335ccc", "#8091ff", "#bfffd9"
                    ];
                    return TraceLogger;
                }());
                TraceLogger_1.TraceLogger = TraceLogger;
            })(TraceLogger = Profiler.TraceLogger || (Profiler.TraceLogger = {}));
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Profiler;
        (function (Profiler) {
            var TraceLogger;
            (function (TraceLogger) {
                var Offsets;
                (function (Offsets) {
                    Offsets[Offsets["START_HI"] = 0] = "START_HI";
                    Offsets[Offsets["START_LO"] = 4] = "START_LO";
                    Offsets[Offsets["STOP_HI"] = 8] = "STOP_HI";
                    Offsets[Offsets["STOP_LO"] = 12] = "STOP_LO";
                    Offsets[Offsets["TEXTID"] = 16] = "TEXTID";
                    Offsets[Offsets["NEXTID"] = 20] = "NEXTID";
                })(Offsets || (Offsets = {}));
                var Thread = /** @class */ (function () {
                    function Thread(data) {
                        if (data.length >= 2) {
                            this._text = data[0];
                            this._data = new DataView(data[1]);
                            this._buffer = new Profiler.TimelineBuffer();
                            this._walkTree(0);
                        }
                    }
                    Object.defineProperty(Thread.prototype, "buffer", {
                        get: function () {
                            return this._buffer;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Thread.prototype._walkTree = function (id) {
                        var data = this._data;
                        var buffer = this._buffer;
                        do {
                            var index = id * Thread.ITEM_SIZE;
                            var start = data.getUint32(index + Offsets.START_HI, false) * 4294967295 + data.getUint32(index + Offsets.START_LO, false);
                            var stop_1 = data.getUint32(index + Offsets.STOP_HI, false) * 4294967295 + data.getUint32(index + Offsets.STOP_LO, false);
                            var textId = data.getUint32(index + Offsets.TEXTID, false);
                            var nextId = data.getUint32(index + Offsets.NEXTID, false);
                            var hasChildren = ((textId & 1) === 1);
                            textId >>>= 1;
                            var text = this._text[textId];
                            buffer.enter(text, null, start / 1000000);
                            if (hasChildren) {
                                this._walkTree(id + 1);
                            }
                            buffer.leave(text, null, stop_1 / 1000000);
                            id = nextId;
                        } while (id !== 0);
                    };
                    Thread.ITEM_SIZE = 8 + 8 + 4 + 4;
                    return Thread;
                }());
                TraceLogger.Thread = Thread;
            })(TraceLogger = Profiler.TraceLogger || (Profiler.TraceLogger = {}));
        })(Profiler = Tools.Profiler || (Tools.Profiler = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='profile.ts' />
/// <reference path='timelineFrame.ts' />
/// <reference path='timelineBuffer.ts' />
/// <reference path='controller.ts' />
/// <reference path='mouseController.ts' />
/// <reference path='flameChartBase.ts' />
/// <reference path='flameChart.ts' />
/// <reference path='flameChartOverview.ts' />
/// <reference path='flameChartHeader.ts' />
/// <reference path='tracelogger/traceLogger.ts' />
/// <reference path='tracelogger/thread.ts' />
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Terminal;
        (function (Terminal_1) {
            var clamp = Shumway.NumberUtilities.clamp;
            var Buffer = /** @class */ (function () {
                function Buffer() {
                    this.length = 0;
                    this.lines = [];
                    this.format = [];
                    this.time = [];
                    this.repeat = [];
                    this.length = 0;
                }
                Buffer.prototype.append = function (line, color) {
                    var lines = this.lines;
                    if (lines.length > 0 && lines[lines.length - 1] === line) {
                        this.repeat[lines.length - 1]++;
                        return;
                    }
                    this.lines.push(line);
                    this.repeat.push(1);
                    this.format.push(color ? { backgroundFillStyle: color } : undefined);
                    this.time.push(performance.now());
                    this.length++;
                };
                Buffer.prototype.get = function (i) {
                    return this.lines[i];
                };
                Buffer.prototype.getFormat = function (i) {
                    return this.format[i];
                };
                Buffer.prototype.getTime = function (i) {
                    return this.time[i];
                };
                Buffer.prototype.getRepeat = function (i) {
                    return this.repeat[i];
                };
                return Buffer;
            }());
            Terminal_1.Buffer = Buffer;
            /**
             * If you're going to write a lot of data to the browser console you're gonna have a bad time. This may make your
             * life a little more pleasant.
             */
            var Terminal = /** @class */ (function () {
                function Terminal(canvas) {
                    this.lineColor = "#2A2A2A";
                    this.alternateLineColor = "#262626";
                    this.textColor = "#FFFFFF";
                    this.selectionColor = "#96C9F3";
                    this.selectionTextColor = "#000000";
                    this.ratio = 1;
                    this.showLineNumbers = true;
                    this.showLineTime = false;
                    this.showLineCounter = false;
                    this.canvas = canvas;
                    this.canvas.focus();
                    this.context = canvas.getContext('2d', { original: true });
                    this.context.fillStyle = "#FFFFFF";
                    this.fontSize = 10;
                    this.lineIndex = 0;
                    this.pageIndex = 0;
                    this.columnIndex = 0;
                    this.selection = null;
                    this.lineHeight = 15;
                    this.hasFocus = false;
                    window.addEventListener('resize', this._resizeHandler.bind(this), false);
                    this._resizeHandler();
                    this.textMarginLeft = 4;
                    this.textMarginBottom = 4;
                    this.refreshFrequency = 0;
                    this.buffer = new Buffer();
                    canvas.addEventListener('keydown', onKeyDown.bind(this), false);
                    canvas.addEventListener('focus', onFocusIn.bind(this), false);
                    canvas.addEventListener('blur', onFocusOut.bind(this), false);
                    var PAGE_UP = 33;
                    var PAGE_DOWN = 34;
                    var HOME = 36;
                    var END = 35;
                    var UP = 38;
                    var DOWN = 40;
                    var LEFT = 37;
                    var RIGHT = 39;
                    var KEY_A = 65;
                    var KEY_C = 67;
                    var KEY_F = 70;
                    var ESCAPE = 27;
                    var KEY_N = 78;
                    var KEY_T = 84;
                    var KEY_H = 72;
                    var KEY_S = 83;
                    function onFocusIn(event) {
                        this.hasFocus = true;
                    }
                    function onFocusOut(event) {
                        this.hasFocus = false;
                    }
                    function onKeyDown(event) {
                        var delta = 0;
                        switch (event.keyCode) {
                            case KEY_H:
                                this.printHelp();
                                break;
                            case KEY_N:
                                this.showLineNumbers = !this.showLineNumbers;
                                break;
                            case KEY_T:
                                this.showLineTime = !this.showLineTime;
                                break;
                            case UP:
                                delta = -1;
                                break;
                            case DOWN:
                                delta = +1;
                                break;
                            case PAGE_UP:
                                delta = -this.pageLineCount;
                                break;
                            case PAGE_DOWN:
                                delta = this.pageLineCount;
                                break;
                            case HOME:
                                delta = -this.lineIndex;
                                break;
                            case END:
                                delta = this.buffer.length - this.lineIndex;
                                break;
                            case LEFT:
                                this.columnIndex -= event.metaKey ? 10 : 1;
                                if (this.columnIndex < 0) {
                                    this.columnIndex = 0;
                                }
                                event.preventDefault();
                                break;
                            case RIGHT:
                                this.columnIndex += event.metaKey ? 10 : 1;
                                event.preventDefault();
                                break;
                            case KEY_A:
                                if (event.metaKey || event.ctrlKey) {
                                    this.selection = { start: 0, end: this.buffer.length - 1 };
                                    event.preventDefault();
                                }
                                break;
                            case KEY_C:
                            case KEY_S:
                                if (event.metaKey || event.ctrlKey) {
                                    var str = "";
                                    if (this.selection) {
                                        for (var i = this.selection.start; i <= this.selection.end; i++) {
                                            str += this.buffer.get(i) + "\n";
                                        }
                                    }
                                    else {
                                        str = this.buffer.get(this.lineIndex);
                                    }
                                    if (event.keyCode === KEY_C) {
                                        alert(str);
                                    }
                                    else {
                                        window.open(URL.createObjectURL(new Blob([str], { type: 'text/plain' })), '_blank');
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                        if (event.metaKey) {
                            delta *= this.pageLineCount;
                        }
                        if (delta) {
                            this.scroll(delta);
                            event.preventDefault();
                        }
                        if (delta && event.shiftKey) {
                            if (!this.selection) {
                                if (delta > 0) {
                                    this.selection = { start: this.lineIndex - delta, end: this.lineIndex };
                                }
                                else if (delta < 0) {
                                    this.selection = { start: this.lineIndex, end: this.lineIndex - delta };
                                }
                            }
                            else {
                                if (this.lineIndex > this.selection.start) {
                                    this.selection.end = this.lineIndex;
                                }
                                else {
                                    this.selection.start = this.lineIndex;
                                }
                            }
                        }
                        else if (delta) {
                            this.selection = null;
                        }
                        this.paint();
                    }
                }
                Terminal.prototype.printHelp = function () {
                    var _this = this;
                    var lines = [
                        'h - help',
                        'n - turn on/off line numbers',
                        't - turn on/off line time',
                        'arrow_keys - navigation',
                        'cmd/ctrl+a - select all',
                        'cmd/ctrl+c - copy/alert selection',
                        'cmd/ctrl+s - open selection in new tab',
                        'shift+arrow_keys - selection'
                    ];
                    lines.forEach(function (l) { return _this.buffer.append(l, '#002000'); });
                };
                Terminal.prototype.resize = function () {
                    this._resizeHandler();
                };
                Terminal.prototype._resizeHandler = function () {
                    var parent = this.canvas.parentElement;
                    var cw = parent.clientWidth;
                    var ch = parent.clientHeight && (parent.clientHeight - 1);
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStoreRatio = 1;
                    if (devicePixelRatio !== backingStoreRatio) {
                        this.ratio = devicePixelRatio / backingStoreRatio;
                        this.canvas.width = cw * this.ratio;
                        this.canvas.height = ch * this.ratio;
                        this.canvas.style.width = cw + 'px';
                        this.canvas.style.height = ch + 'px';
                    }
                    else {
                        this.ratio = 1;
                        this.canvas.width = cw;
                        this.canvas.height = ch;
                    }
                    this.pageLineCount = Math.floor(this.canvas.height / this.lineHeight);
                };
                Terminal.prototype.gotoLine = function (index) {
                    this.lineIndex = clamp(index, 0, this.buffer.length - 1);
                };
                Terminal.prototype.scrollIntoView = function () {
                    if (this.lineIndex < this.pageIndex) {
                        this.pageIndex = this.lineIndex;
                    }
                    else if (this.lineIndex >= this.pageIndex + this.pageLineCount) {
                        this.pageIndex = this.lineIndex - this.pageLineCount + 1;
                    }
                };
                Terminal.prototype.scroll = function (delta) {
                    this.gotoLine(this.lineIndex + delta);
                    this.scrollIntoView();
                };
                Terminal.prototype.paint = function () {
                    var lineCount = this.pageLineCount;
                    if (this.pageIndex + lineCount > this.buffer.length) {
                        lineCount = this.buffer.length - this.pageIndex;
                    }
                    var charSize = 5;
                    var lineNumberMargin = this.textMarginLeft;
                    var lineTimeMargin = lineNumberMargin + (this.showLineNumbers ? (String(this.buffer.length).length + 2) * charSize : 0);
                    var lineRepeatMargin = lineTimeMargin + (this.showLineTime ? charSize * 8 : 2 * charSize);
                    var lineMargin = lineRepeatMargin + charSize * 5;
                    this.context.font = this.fontSize + 'px Consolas, "Liberation Mono", Courier, monospace';
                    this.context.setTransform(this.ratio, 0, 0, this.ratio, 0, 0);
                    var w = this.canvas.width;
                    var h = this.lineHeight;
                    for (var i = 0; i < lineCount; i++) {
                        var y = i * this.lineHeight;
                        var lineIndex = this.pageIndex + i;
                        var line = this.buffer.get(lineIndex);
                        var lineFormat = this.buffer.getFormat(lineIndex);
                        var lineRepeat = this.buffer.getRepeat(lineIndex);
                        // let lineTimeDelta = lineIndex > 1 ? this.buffer.getTime(lineIndex) - this.buffer.getTime(lineIndex - 1) : 0;
                        var lineTimeDelta = lineIndex > 1 ? this.buffer.getTime(lineIndex) - this.buffer.getTime(0) : 0;
                        this.context.fillStyle = lineIndex % 2 ? this.lineColor : this.alternateLineColor;
                        if (lineFormat && lineFormat.backgroundFillStyle) {
                            this.context.fillStyle = lineFormat.backgroundFillStyle;
                        }
                        this.context.fillRect(0, y, w, h);
                        this.context.fillStyle = this.selectionTextColor;
                        this.context.fillStyle = this.textColor;
                        if (this.selection && lineIndex >= this.selection.start && lineIndex <= this.selection.end) {
                            this.context.fillStyle = this.selectionColor;
                            this.context.fillRect(0, y, w, h);
                            this.context.fillStyle = this.selectionTextColor;
                        }
                        if (this.hasFocus && lineIndex === this.lineIndex) {
                            this.context.fillStyle = this.selectionColor;
                            this.context.fillRect(0, y, w, h);
                            this.context.fillStyle = this.selectionTextColor;
                        }
                        if (this.columnIndex > 0) {
                            line = line.substring(this.columnIndex);
                        }
                        var marginTop = (i + 1) * this.lineHeight - this.textMarginBottom;
                        if (this.showLineNumbers) {
                            this.context.fillText(String(lineIndex), lineNumberMargin, marginTop);
                        }
                        if (this.showLineTime) {
                            this.context.fillText(lineTimeDelta.toFixed(1).padLeft(' ', 6), lineTimeMargin, marginTop);
                        }
                        if (lineRepeat > 1) {
                            this.context.fillText(String(lineRepeat).padLeft(' ', 3), lineRepeatMargin, marginTop);
                        }
                        this.context.fillText(line, lineMargin, marginTop);
                    }
                };
                Terminal.prototype.refreshEvery = function (ms) {
                    var that = this;
                    this.refreshFrequency = ms;
                    function refresh() {
                        that.paint();
                        if (that.refreshFrequency) {
                            setTimeout(refresh, that.refreshFrequency);
                        }
                    }
                    if (that.refreshFrequency) {
                        setTimeout(refresh, that.refreshFrequency);
                    }
                };
                Terminal.prototype.isScrolledToBottom = function () {
                    return this.lineIndex === this.buffer.length - 1;
                };
                return Terminal;
            }());
            Terminal_1.Terminal = Terminal;
        })(Terminal = Tools.Terminal || (Tools.Terminal = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='terminal.ts' />
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Tools;
    (function (Tools) {
        var Mini;
        (function (Mini) {
            var FPS = /** @class */ (function () {
                function FPS(container) {
                    this._index = 0;
                    this._lastTime = 0;
                    this._lastWeightedTime = 0;
                    this._gradient = [
                        "#FF0000",
                        "#FF1100",
                        "#FF2300",
                        "#FF3400",
                        "#FF4600",
                        "#FF5700",
                        "#FF6900",
                        "#FF7B00",
                        "#FF8C00",
                        "#FF9E00",
                        "#FFAF00",
                        "#FFC100",
                        "#FFD300",
                        "#FFE400",
                        "#FFF600",
                        "#F7FF00",
                        "#E5FF00",
                        "#D4FF00",
                        "#C2FF00",
                        "#B0FF00",
                        "#9FFF00",
                        "#8DFF00",
                        "#7CFF00",
                        "#6AFF00",
                        "#58FF00",
                        "#47FF00",
                        "#35FF00",
                        "#24FF00",
                        "#12FF00",
                        "#00FF00" // Green
                    ];
                    this._container = container;
                    this._canvas = document.createElement("canvas");
                    this._container.appendChild(this._canvas);
                    this._context = this._canvas.getContext("2d");
                    this._listenForContainerSizeChanges();
                }
                FPS.prototype._listenForContainerSizeChanges = function () {
                    var pollInterval = 10;
                    var w = this._containerWidth;
                    var h = this._containerHeight;
                    this._onContainerSizeChanged();
                    var self = this;
                    setInterval(function () {
                        if (w !== self._containerWidth || h !== self._containerHeight) {
                            self._onContainerSizeChanged();
                            w = self._containerWidth;
                            h = self._containerHeight;
                        }
                    }, pollInterval);
                };
                FPS.prototype._onContainerSizeChanged = function () {
                    var cw = this._containerWidth;
                    var ch = this._containerHeight;
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStoreRatio = 1;
                    if (devicePixelRatio !== backingStoreRatio) {
                        this._ratio = devicePixelRatio / backingStoreRatio;
                        this._canvas.width = cw * this._ratio;
                        this._canvas.height = ch * this._ratio;
                        this._canvas.style.width = cw + 'px';
                        this._canvas.style.height = ch + 'px';
                    }
                    else {
                        this._ratio = 1;
                        this._canvas.width = cw;
                        this._canvas.height = ch;
                    }
                };
                Object.defineProperty(FPS.prototype, "_containerWidth", {
                    get: function () {
                        return this._container.clientWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FPS.prototype, "_containerHeight", {
                    get: function () {
                        return this._container.clientHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                FPS.prototype.tickAndRender = function (idle, renderTime) {
                    if (idle === void 0) { idle = false; }
                    if (renderTime === void 0) { renderTime = 0; }
                    if (this._lastTime === 0) {
                        this._lastTime = performance.now();
                        return;
                    }
                    var elapsedTime = performance.now() - this._lastTime;
                    var weightRatio = 0; // Use ratio here if you want smoothing.
                    var weightedTime = elapsedTime * (1 - weightRatio) + this._lastWeightedTime * weightRatio;
                    var context = this._context;
                    var w = 2 * this._ratio;
                    var wPadding = 1;
                    var fontSize = 8;
                    var tickOffset = this._ratio * 30;
                    var webkitPerformance = performance;
                    if (webkitPerformance.memory) {
                        tickOffset += this._ratio * 30;
                    }
                    var count = ((this._canvas.width - tickOffset) / (w + wPadding)) | 0;
                    var index = this._index++;
                    if (this._index > count) {
                        this._index = 0;
                    }
                    var canvasHeight = this._canvas.height;
                    context.globalAlpha = 1;
                    context.fillStyle = "black";
                    context.fillRect(tickOffset + index * (w + wPadding), 0, w * 4, this._canvas.height);
                    var r = Math.min((1000 / 60) / weightedTime, 1);
                    context.fillStyle = "#00FF00"; // this._gradient[r * (this._gradient.length - 1) | 0];
                    context.globalAlpha = idle ? 0.5 : 1;
                    var v = canvasHeight / 2 * r | 0;
                    context.fillRect(tickOffset + index * (w + wPadding), canvasHeight - v, w, v);
                    if (renderTime) {
                        r = Math.min((1000 / 240) / renderTime, 1);
                        context.fillStyle = "#FF6347"; // "#58FF00"; // "#00FF00"; // this._gradient[r * (this._gradient.length - 1) | 0];
                        var v_1 = canvasHeight / 2 * r | 0;
                        context.fillRect(tickOffset + index * (w + wPadding), (canvasHeight / 2) - v_1, w, v_1);
                    }
                    if (index % 16 === 0) {
                        context.globalAlpha = 1;
                        context.fillStyle = "black";
                        context.fillRect(0, 0, tickOffset, this._canvas.height);
                        context.fillStyle = "white";
                        context.font = (this._ratio * fontSize) + "px Arial";
                        context.textBaseline = "middle";
                        var s = (1000 / weightedTime).toFixed(0);
                        if (renderTime) {
                            s += " " + renderTime.toFixed(0);
                        }
                        if (webkitPerformance.memory) {
                            s += " " + (webkitPerformance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                        }
                        context.fillText(s, 2 * this._ratio, this._containerHeight / 2 * this._ratio);
                    }
                    this._lastTime = performance.now();
                    this._lastWeightedTime = weightedTime;
                };
                return FPS;
            }());
            Mini.FPS = FPS;
        })(Mini = Tools.Mini || (Tools.Mini = {}));
    })(Tools = Shumway.Tools || (Shumway.Tools = {}));
})(Shumway || (Shumway = {}));
/// <reference path='../references.ts' />
/// <reference path='fps.ts' />
/// <reference path='theme/ui.ts' />
/// <reference path='profiler/references.ts' />
/// <reference path='terminal/references.ts' />
/// <reference path='mini/references.ts' />
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var LowLevel;
            (function (LowLevel) {
                function parseBbox(stream) {
                    stream.align();
                    var bits = stream.readUb(5);
                    var xMin = stream.readSb(bits);
                    var xMax = stream.readSb(bits);
                    var yMin = stream.readSb(bits);
                    var yMax = stream.readSb(bits);
                    stream.align();
                    return { xMin: xMin, xMax: xMax, yMin: yMin, yMax: yMax };
                }
                function parseRgb(stream) {
                    return ((stream.readUi8() << 24) | (stream.readUi8() << 16) |
                        (stream.readUi8() << 8) | 0xff) >>> 0;
                }
                LowLevel.parseRgb = parseRgb;
                function parseRgba(stream) {
                    return (stream.readUi8() << 24) | (stream.readUi8() << 16) |
                        (stream.readUi8() << 8) | stream.readUi8();
                }
                function parseArgb(stream) {
                    return stream.readUi8() | (stream.readUi8() << 24) |
                        (stream.readUi8() << 16) | (stream.readUi8() << 8);
                }
                function parseMatrix(stream) {
                    var matrix = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
                    stream.align();
                    var hasScale = stream.readUb(1);
                    if (hasScale) {
                        var bits_1 = stream.readUb(5);
                        matrix.a = stream.readFb(bits_1);
                        matrix.d = stream.readFb(bits_1);
                    }
                    var hasRotate = stream.readUb(1);
                    if (hasRotate) {
                        var bits_2 = stream.readUb(5);
                        matrix.b = stream.readFb(bits_2);
                        matrix.c = stream.readFb(bits_2);
                    }
                    var bits = stream.readUb(5);
                    matrix.tx = stream.readSb(bits);
                    matrix.ty = stream.readSb(bits);
                    stream.align();
                    return matrix;
                }
                function parseColorTransform(stream, hasAlpha) {
                    var cxform = {
                        redMultiplier: 0xff,
                        greenMultiplier: 0xff,
                        blueMultiplier: 0xff,
                        alphaMultiplier: 0xff,
                        redOffset: 0,
                        greenOffset: 0,
                        blueOffset: 0,
                        alphaOffset: 0,
                    };
                    stream.align();
                    var hasOffsets = stream.readUb(1);
                    var hasMultipliers = stream.readUb(1);
                    var bits = stream.readUb(4);
                    if (hasMultipliers) {
                        cxform.redMultiplier = stream.readSb(bits);
                        cxform.greenMultiplier = stream.readSb(bits);
                        cxform.blueMultiplier = stream.readSb(bits);
                        if (hasAlpha) {
                            cxform.alphaMultiplier = stream.readSb(bits);
                        }
                    }
                    if (hasOffsets) {
                        cxform.redOffset = stream.readSb(bits);
                        cxform.greenOffset = stream.readSb(bits);
                        cxform.blueOffset = stream.readSb(bits);
                        if (hasAlpha) {
                            cxform.alphaOffset = stream.readSb(bits);
                        }
                    }
                    stream.align();
                    return cxform;
                }
                function parsePlaceObjectTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.actionBlocksPrecedence = stream.pos;
                    if (tagCode === 4 /* CODE_PLACE_OBJECT */) {
                        tag.symbolId = stream.readUi16();
                        tag.depth = stream.readUi16();
                        tag.flags |= 4 /* HasMatrix */;
                        tag.matrix = parseMatrix(stream);
                        if (stream.pos < tagEnd) {
                            tag.flags |= 8 /* HasColorTransform */;
                            tag.cxform = parseColorTransform(stream, false);
                        }
                        return tag;
                    }
                    var flags = tag.flags = tagCode > 26 /* CODE_PLACE_OBJECT2 */ ?
                        stream.readUi16() :
                        stream.readUi8();
                    tag.depth = stream.readUi16();
                    if (flags & 2048 /* HasClassName */) {
                        tag.className = stream.readString(-1);
                    }
                    if (flags & 2 /* HasCharacter */) {
                        tag.symbolId = stream.readUi16();
                    }
                    if (flags & 4 /* HasMatrix */) {
                        tag.matrix = parseMatrix(stream);
                    }
                    if (flags & 8 /* HasColorTransform */) {
                        tag.cxform = parseColorTransform(stream, true);
                    }
                    if (flags & 16 /* HasRatio */) {
                        tag.ratio = stream.readUi16();
                    }
                    if (flags & 32 /* HasName */) {
                        tag.name = stream.readString(-1);
                    }
                    if (flags & 64 /* HasClipDepth */) {
                        tag.clipDepth = stream.readUi16();
                    }
                    if (flags & 256 /* HasFilterList */) {
                        var count = stream.readUi8();
                        var filters = tag.filters = [];
                        while (count--) {
                            filters.push(parseFilter(stream));
                        }
                    }
                    if (flags & 512 /* HasBlendMode */) {
                        tag.blendMode = stream.readUi8();
                    }
                    if (flags & 1024 /* HasCacheAsBitmap */) {
                        tag.bmpCache = stream.readUi8();
                    }
                    if (flags & 8192 /* HasVisible */) {
                        tag.visibility = stream.readBool();
                    }
                    if (flags & 16384 /* OpaqueBackground */) {
                        tag.backgroundColor = parseArgb(stream);
                    }
                    if (flags & 128 /* HasClipActions */) {
                        var reserved = stream.readUi16();
                        var allFlags = swfVersion >= 6 ? stream.readUi32() : stream.readUi16();
                        var allEvents = tag.events = [];
                        var events = void 0;
                        while (events = parseEvents(stream, swfVersion)) {
                            if (stream.pos > tagEnd) {
                                Shumway.Debug.warning('PlaceObject handler attempted to read clip events beyond tag end');
                                stream.pos = tagEnd;
                                break;
                            }
                            allEvents.push(events);
                        }
                        ;
                    }
                    return tag;
                }
                function parseEvents(stream, swfVersion) {
                    var flags = swfVersion >= 6 ? stream.readUi32() : stream.readUi16();
                    if (!flags) {
                        // `true` means this is the EndOfEvents marker.
                        return null;
                    }
                    var events = {};
                    // The Construct event is only allowed in 7+. It can't be set in < 6, so mask it out for 6.
                    if (swfVersion === 6) {
                        flags = flags & ~262144 /* Construct */;
                    }
                    events.flags = flags;
                    var length = stream.readUi32();
                    if (flags & 131072 /* KeyPress */) {
                        events.keyCode = stream.readUi8();
                        length--;
                    }
                    var end = stream.pos + length;
                    events.actionsBlock = stream.bytes.subarray(stream.pos, end);
                    stream.pos = end;
                    return events;
                }
                function parseFilter(stream) {
                    var filter = {};
                    var type = filter.type = stream.readUi8();
                    var matrix;
                    var i;
                    switch (type) {
                        case 0:
                        case 2:
                        case 3:
                        case 4:
                        case 7:
                            var glow = filter;
                            var count = void 0;
                            if (type === 4 || type === 7) {
                                count = stream.readUi8();
                            }
                            else {
                                count = type === 3 ? 2 : 1;
                            }
                            var colors = glow.colors = [];
                            i = count;
                            while (i--) {
                                colors.push(parseRgba(stream));
                            }
                            if (type === 4 || type === 7) {
                                var ratios = glow.ratios = [];
                                i = count;
                                while (i--) {
                                    ratios.push(stream.readUi8());
                                }
                            }
                            glow.blurX = stream.readFixed();
                            glow.blurY = stream.readFixed();
                            if (type !== 2) {
                                glow.angle = stream.readFixed();
                                glow.distance = stream.readFixed();
                            }
                            glow.strength = stream.readFixed8();
                            glow.inner = !!stream.readUb(1);
                            glow.knockout = !!stream.readUb(1);
                            glow.compositeSource = !!stream.readUb(1);
                            if (type === 3 || type === 4 || type === 7) {
                                glow.onTop = !!stream.readUb(1);
                                glow.quality = stream.readUb(4);
                            }
                            else {
                                glow.quality = stream.readUb(5);
                            }
                            return glow;
                        case 1:
                            var blur_1 = filter;
                            blur_1.blurX = stream.readFixed();
                            blur_1.blurY = stream.readFixed();
                            blur_1.quality = stream.readUb(5);
                            stream.readUb(3);
                            return blur_1;
                        case 5:
                            var conv = filter;
                            var matrixX = conv.matrixX = stream.readUi8();
                            var matrixY = conv.matrixY = stream.readUi8();
                            conv.divisor = stream.readFloat();
                            conv.bias = stream.readFloat();
                            matrix = conv.matrix = [];
                            i = matrixX * matrixY;
                            while (i--) {
                                matrix.push(stream.readFloat());
                            }
                            conv.color = parseRgba(stream);
                            var reserved = stream.readUb(6);
                            conv.clamp = !!stream.readUb(1);
                            conv.preserveAlpha = !!stream.readUb(1);
                            return conv;
                        case 6:
                            var cm = filter;
                            matrix = cm.matrix = [];
                            i = 20;
                            while (i--) {
                                matrix.push(stream.readFloat());
                            }
                            return cm;
                        default:
                    }
                    return filter;
                }
                function parseRemoveObjectTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    if (tagCode === 5 /* CODE_REMOVE_OBJECT */) {
                        tag.depth = stream.readUi16();
                        tag.symbolId = stream.readUi16();
                    }
                    else {
                        tag.depth = stream.readUi16();
                    }
                    return tag;
                }
                function parseDefineImageTag(stream, swfVersion, tagCode, tagEnd, jpegTables) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var imgData;
                    if (tagCode > 21 /* CODE_DEFINE_BITS_JPEG2 */) {
                        var alphaDataOffset = stream.readUi32();
                        if (tagCode === 90 /* CODE_DEFINE_BITS_JPEG4 */) {
                            tag.deblock = stream.readFixed8();
                        }
                        alphaDataOffset += stream.pos;
                        imgData = tag.imgData = stream.bytes.subarray(stream.pos, alphaDataOffset);
                        tag.alphaData = stream.bytes.subarray(alphaDataOffset, tagEnd);
                        stream.pos = tagEnd;
                    }
                    else {
                        imgData = tag.imgData = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    }
                    switch (imgData[0] << 8 | imgData[1]) {
                        case 65496:
                        case 65497:
                            tag.mimeType = "image/jpeg";
                            break;
                        case 35152:
                            tag.mimeType = "image/png";
                            break;
                        case 18249:
                            tag.mimeType = "image/gif";
                            break;
                        default:
                            tag.mimeType = "application/octet-stream";
                    }
                    if (tagCode === 6 /* CODE_DEFINE_BITS */) {
                        tag.jpegTables = { data: jpegTables };
                    }
                    return tag;
                }
                LowLevel.parseDefineImageTag = parseDefineImageTag;
                function parseDefineButtonTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var characters = tag.characters = [];
                    var character;
                    if (tagCode == 7 /* CODE_DEFINE_BUTTON */) {
                        while (character = parseButtonCharacter(stream, swfVersion, tagCode)) {
                            characters.push(character);
                        }
                        tag.actionsData = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    }
                    else {
                        var trackFlags = stream.readUi8();
                        tag.trackAsMenu = !!(trackFlags >> 7 & 1);
                        var actionOffset = stream.readUi16();
                        while (character = parseButtonCharacter(stream, swfVersion, tagCode)) {
                            characters.push(character);
                        }
                        ;
                        if (!!actionOffset) {
                            var buttonActions = tag.buttonActions = [];
                            while (stream.pos < tagEnd) {
                                var action = parseButtonCondAction(stream, tagEnd);
                                // Ignore actions that exceed the tag length.
                                if (stream.pos > tagEnd) {
                                    break;
                                }
                                buttonActions.push(action);
                            }
                            stream.pos = tagEnd;
                        }
                    }
                    return tag;
                }
                function parseButtonCharacter(stream, swfVersion, tagCode) {
                    var flags = stream.readUi8();
                    if (!flags) {
                        return null;
                    }
                    var character = {};
                    if (swfVersion < 8) {
                        // Clear HasBlendMode and HasFilterList flags.
                        flags &= ~(512 /* HasBlendMode */ | 256 /* HasFilterList */);
                    }
                    character.flags = flags;
                    character.symbolId = stream.readUi16();
                    character.depth = stream.readUi16();
                    character.matrix = parseMatrix(stream);
                    if (tagCode === 34 /* CODE_DEFINE_BUTTON2 */) {
                        character.cxform = parseColorTransform(stream, true);
                    }
                    if (character.flags & 16 /* HasFilterList */) {
                        var count = stream.readUi8();
                        var filters = character.filters = [];
                        var i = count;
                        while (i--) {
                            filters.push(parseFilter(stream));
                        }
                    }
                    if (character.flags & 32 /* HasBlendMode */) {
                        character.blendMode = stream.readUi8();
                    }
                    return character;
                }
                function parseButtonCondAction(stream, tagEnd) {
                    var start = stream.pos;
                    var tagSize = stream.readUi16();
                    // If no tagSize is given, read to the tag's end.
                    var end = tagSize ? start + tagSize : tagEnd;
                    var conditions = stream.readUi16();
                    stream.pos = end;
                    return {
                        // The 7 upper bits hold a key code the button should respond to.
                        keyCode: (conditions & 0xfe00) >> 9,
                        // The lower 9 bits hold state transition flags. See the enum in AVM1Button for details.
                        stateTransitionFlags: conditions & 0x1ff,
                        // If no tagSize is given, pass `0` to readBinary.
                        actionsData: stream.bytes.subarray(start + 4, end)
                    };
                }
                function parseDefineBinaryDataTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    stream.pos += 4; // Reserved
                    tag.data = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                function parseDefineFontTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var firstOffset = stream.readUi16();
                    var glyphCount = firstOffset / 2;
                    var restOffsets = [];
                    var i = glyphCount - 1;
                    while (i--) {
                        restOffsets.push(stream.readUi16());
                    }
                    tag.offsets = [firstOffset].concat(restOffsets);
                    var glyphs = tag.glyphs = [];
                    i = glyphCount;
                    while (i--) {
                        glyphs.push(parseGlyph(stream, swfVersion, tagCode));
                    }
                    return tag;
                }
                LowLevel.parseDefineFontTag = parseDefineFontTag;
                function parseGlyph(stream, swfVersion, tagCode) {
                    stream.align();
                    var fillBits = stream.readUb(4);
                    var lineBits = stream.readUb(4);
                    return parseShapeRecords(stream, swfVersion, tagCode, false, fillBits, lineBits, false);
                }
                function parseDefineTextTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.bbox = parseBbox(stream);
                    tag.matrix = parseMatrix(stream);
                    var glyphBits = stream.readUi8();
                    var advanceBits = stream.readUi8();
                    var records = tag.records = [];
                    var record;
                    while (record = parseTextRecord(stream, swfVersion, tagCode, glyphBits, advanceBits)) {
                        records.push(record);
                    }
                    return tag;
                }
                function parseTextRecord(stream, swfVersion, tagCode, glyphBits, advanceBits) {
                    stream.align();
                    var flags = stream.readUb(8);
                    if (!flags) {
                        return null;
                    }
                    var record = {};
                    record.flags = flags;
                    if (flags & 8 /* HasFont */) {
                        record.fontId = stream.readUi16();
                    }
                    if (flags & 4 /* HasColor */) {
                        record.color = tagCode === 33 /* CODE_DEFINE_TEXT2 */ ?
                            parseRgba(stream) :
                            parseRgb(stream);
                    }
                    if (flags & 1 /* HasMoveX */) {
                        record.moveX = stream.readSi16();
                    }
                    if (flags & 2 /* HasMoveY */) {
                        record.moveY = stream.readSi16();
                    }
                    if (flags & 8 /* HasFont */) {
                        record.fontHeight = stream.readUi16();
                    }
                    var glyphCount = stream.readUi8();
                    if (swfVersion <= 6) {
                        glyphCount = glyphCount; // & 0x7f ???;
                    }
                    var entries = record.entries = [];
                    var i = glyphCount;
                    while (i--) {
                        entries.push({
                            glyphIndex: stream.readUb(glyphBits),
                            advance: stream.readSb(advanceBits)
                        });
                    }
                    return record;
                }
                function parseDefineSoundTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var soundFlags = stream.readUi8();
                    tag.soundFormat = soundFlags >> 4 & 15;
                    tag.soundRate = soundFlags >> 2 & 3;
                    tag.soundSize = soundFlags >> 1 & 1;
                    tag.soundType = soundFlags & 1;
                    tag.samplesCount = stream.readUi32();
                    tag.soundData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                function parseStartSoundTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    if (tagCode == 15 /* CODE_START_SOUND */) {
                        tag.soundId = stream.readUi16();
                    }
                    if (tagCode == 89 /* CODE_START_SOUND2 */) {
                        tag.soundClassName = stream.readString(-1);
                    }
                    tag.soundInfo = parseSoundInfo(stream);
                    return tag;
                }
                function parseSoundInfo(stream) {
                    var info = {};
                    var flags = info.flags = stream.readUi8();
                    if (flags & 1 /* HasInPoint */) {
                        info.inPoint = stream.readUi32();
                    }
                    if (flags & 2 /* HasOutPoint */) {
                        info.outPoint = stream.readUi32();
                    }
                    if (flags & 4 /* HasLoops */) {
                        info.loopCount = stream.readUi16();
                    }
                    if (flags & 8 /* HasEnvelope */) {
                        var envelopeCount = stream.readUi8();
                        var envelopes = info.envelopes = [];
                        var i = envelopeCount;
                        while (i--) {
                            envelopes.push({
                                pos44: stream.readUi32(),
                                volumeLeft: stream.readUi16(),
                                volumeRight: stream.readUi16()
                            });
                        }
                    }
                    return info;
                }
                function parseSoundStreamHeadTag(stream, tagEnd) {
                    var tag = {};
                    var playbackFlags = stream.readUi8();
                    tag.playbackRate = playbackFlags >> 2 & 3;
                    tag.playbackSize = playbackFlags >> 1 & 1;
                    tag.playbackType = playbackFlags & 1;
                    var streamFlags = stream.readUi8();
                    var streamCompression = tag.streamCompression = streamFlags >> 4 & 15;
                    tag.streamRate = streamFlags >> 2 & 3;
                    tag.streamSize = streamFlags >> 1 & 1;
                    tag.streamType = streamFlags & 1;
                    tag.samplesCount = stream.readUi16();
                    if (streamCompression == 2 && tagEnd - stream.pos >= 2) {
                        tag.latencySeek = stream.readSi16();
                    }
                    return tag;
                }
                LowLevel.parseSoundStreamHeadTag = parseSoundStreamHeadTag;
                function parseDefineBitmapTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var format = tag.format = stream.readUi8();
                    tag.width = stream.readUi16();
                    tag.height = stream.readUi16();
                    tag.hasAlpha = tagCode === 36 /* CODE_DEFINE_BITS_LOSSLESS2 */;
                    if (format === 3) {
                        tag.colorTableSize = stream.readUi8();
                    }
                    tag.bmpData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                LowLevel.parseDefineBitmapTag = parseDefineBitmapTag;
                function parseDefineEditTextTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.bbox = parseBbox(stream);
                    var flags = tag.flags = stream.readUi16();
                    if (flags & 1 /* HasFont */) {
                        tag.fontId = stream.readUi16();
                    }
                    if (flags & 32768 /* HasFontClass */) {
                        tag.fontClass = stream.readString(-1);
                    }
                    if (flags & 1 /* HasFont */) {
                        tag.fontHeight = stream.readUi16();
                    }
                    if (flags & 4 /* HasColor */) {
                        tag.color = parseRgba(stream);
                    }
                    if (flags & 2 /* HasMaxLength */) {
                        tag.maxLength = stream.readUi16();
                    }
                    if (flags & 8192 /* HasLayout */) {
                        tag.align = stream.readUi8();
                        tag.leftMargin = stream.readUi16();
                        tag.rightMargin = stream.readUi16();
                        tag.indent = stream.readSi16();
                        tag.leading = stream.readSi16();
                    }
                    tag.variableName = stream.readString(-1);
                    if (flags & 128 /* HasText */) {
                        tag.initialText = stream.readString(-1);
                    }
                    return tag;
                }
                function parseDefineFont2Tag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var flags = tag.flags = stream.readUi8();
                    var wide = !!(flags & 4 /* WideOrHasFontData */);
                    if (swfVersion > 5) {
                        tag.language = stream.readUi8();
                    }
                    else {
                        // Clear ShiftJis flag.
                        flags = tag.flags = flags & ~64 /* ShiftJis */;
                        // Skip reserved byte.
                        stream.pos += 1;
                        tag.language = 0;
                    }
                    var nameLength = stream.readUi8();
                    tag.name = stream.readString(nameLength);
                    if (tagCode === 75 /* CODE_DEFINE_FONT3 */) {
                        tag.resolution = 20;
                    }
                    var glyphCount = stream.readUi16();
                    // The SWF format docs doesn't say that, but the DefineFont{2,3} tag ends here for device fonts.
                    if (glyphCount === 0) {
                        return tag;
                    }
                    var startpos = stream.pos;
                    var offsets = tag.offsets = [];
                    var i = glyphCount;
                    if ((flags & 8 /* WideOffset */) !== 0) {
                        while (i--) {
                            offsets.push(stream.readUi32());
                        }
                        tag.mapOffset = stream.readUi32();
                    }
                    else {
                        while (i--) {
                            offsets.push(stream.readUi16());
                        }
                        tag.mapOffset = stream.readUi16();
                    }
                    var glyphs = tag.glyphs = [];
                    i = glyphCount;
                    while (i--) {
                        var dist = tag.offsets[glyphCount - i] + startpos - stream.pos;
                        // when just one byte difference between two offsets, just read that and insert an empty glyph.
                        if (dist === 1) {
                            stream.pos += 1;
                            glyphs.push([]);
                            continue;
                        }
                        glyphs.push(parseGlyph(stream, swfVersion, tagCode));
                    }
                    var codes = tag.codes = [];
                    i = glyphCount;
                    while (i--) {
                        codes.push(wide ? stream.readUi16() : stream.readUi8());
                    }
                    if ((flags & 128 /* HasLayout */) !== 0) {
                        tag.ascent = stream.readUi16();
                        tag.descent = stream.readUi16();
                        tag.leading = stream.readSi16();
                        var advance = tag.advance = [];
                        i = glyphCount;
                        while (i--) {
                            advance.push(stream.readSi16());
                        }
                        var bbox = tag.bbox = [];
                        i = glyphCount;
                        while (i--) {
                            bbox.push(parseBbox(stream));
                        }
                        var kerningCount = stream.readUi16();
                        var kernings = tag.kerning = [];
                        i = kerningCount;
                        // DefineFont2 tags tend to have a wrong kerning count so we have to make sure here that there is enough unread
                        // data remaining before parsing the next kerning record. If not, we have to bail out earlier in the following
                        // loop to avoid reading out of bound.
                        while (i-- && tagEnd - stream.pos >= (wide ? 4 : 2) + 2) {
                            kernings.push(parseKerning(stream, wide));
                        }
                    }
                    return tag;
                }
                LowLevel.parseDefineFont2Tag = parseDefineFont2Tag;
                function parseKerning(stream, wide) {
                    var kerning = {};
                    if (wide) {
                        kerning.code1 = stream.readUi16();
                        kerning.code2 = stream.readUi16();
                    }
                    else {
                        kerning.code1 = stream.readUi8();
                        kerning.code2 = stream.readUi8();
                    }
                    kerning.adjustment = stream.readUi16();
                    return kerning;
                }
                function parseDefineFont4Tag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var flags = tag.flags = stream.readUi8();
                    tag.name = stream.readString(-1);
                    if (flags & 4 /* WideOrHasFontData */) {
                        tag.data = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    }
                    return tag;
                }
                LowLevel.parseDefineFont4Tag = parseDefineFont4Tag;
                function parseDefineScalingGridTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.symbolId = stream.readUi16();
                    tag.splitter = parseBbox(stream);
                    return tag;
                }
                function parseDefineSceneTag(stream, tagCode) {
                    var tag = { code: tagCode };
                    var sceneCount = stream.readEncodedU32();
                    var scenes = tag.scenes = [];
                    var i = sceneCount;
                    while (i--) {
                        scenes.push({
                            offset: stream.readEncodedU32(),
                            name: stream.readString(-1)
                        });
                    }
                    var labelCount = stream.readEncodedU32();
                    var labels = tag.labels = [];
                    i = labelCount;
                    while (i--) {
                        labels.push({
                            frame: stream.readEncodedU32(),
                            name: stream.readString(-1)
                        });
                    }
                    return tag;
                }
                LowLevel.parseDefineSceneTag = parseDefineSceneTag;
                function parseDefineShapeTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.lineBounds = parseBbox(stream);
                    var flags = 0;
                    var isMorph = tagCode === 46 /* CODE_DEFINE_MORPH_SHAPE */ ||
                        tagCode === 84 /* CODE_DEFINE_MORPH_SHAPE2 */;
                    if (isMorph) {
                        flags |= 8 /* IsMorph */;
                        tag.lineBoundsMorph = parseBbox(stream);
                    }
                    var canHaveStrokes = tagCode === 83 /* CODE_DEFINE_SHAPE4 */ ||
                        tagCode === 84 /* CODE_DEFINE_MORPH_SHAPE2 */;
                    if (canHaveStrokes) {
                        var fillBounds = tag.fillBounds = parseBbox(stream);
                        if (isMorph) {
                            tag.fillBoundsMorph = parseBbox(stream);
                        }
                        flags |= stream.readUi8() & 0x07;
                    }
                    tag.flags = flags;
                    if (isMorph) {
                        stream.pos += 4;
                    }
                    tag.fillStyles = parseFillStyles(stream, swfVersion, tagCode, isMorph);
                    tag.lineStyles = parseLineStyles(stream, swfVersion, tagCode, isMorph, canHaveStrokes);
                    stream.align();
                    var fillBits = stream.readUb(4);
                    var lineBits = stream.readUb(4);
                    tag.records = parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, canHaveStrokes);
                    if (isMorph) {
                        stream.align();
                        fillBits = stream.readUb(4);
                        lineBits = stream.readUb(4);
                        tag.recordsMorph = parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, canHaveStrokes);
                    }
                    return tag;
                }
                function parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes) {
                    var records = [];
                    var bits;
                    do {
                        var record = {};
                        var type = record.type = stream.readUb(1);
                        var flags = stream.readUb(5);
                        if (!(type || flags)) {
                            break;
                        }
                        if (type) {
                            var bits_3 = (flags & 0x0f) + 2;
                            flags = (flags & 0xf0) << 1;
                            if (flags & 32 /* IsStraight */) {
                                var isGeneral = record.isGeneral = stream.readUb(1);
                                if (isGeneral) {
                                    flags |= 64 /* IsGeneral */;
                                    record.deltaX = stream.readSb(bits_3);
                                    record.deltaY = stream.readSb(bits_3);
                                }
                                else {
                                    var isVertical = record.isVertical = stream.readUb(1);
                                    if (isVertical) {
                                        flags |= 128 /* IsVertical */;
                                        record.deltaY = stream.readSb(bits_3);
                                    }
                                    else {
                                        record.deltaX = stream.readSb(bits_3);
                                    }
                                }
                            }
                            else {
                                record.controlDeltaX = stream.readSb(bits_3);
                                record.controlDeltaY = stream.readSb(bits_3);
                                record.anchorDeltaX = stream.readSb(bits_3);
                                record.anchorDeltaY = stream.readSb(bits_3);
                            }
                        }
                        else {
                            if (tagCode <= 2 /* CODE_DEFINE_SHAPE */) {
                                // Clear HasNewStyles flag.
                                flags &= ~16 /* HasNewStyles */;
                            }
                            if (flags & 1 /* Move */) {
                                bits = stream.readUb(5);
                                record.moveX = stream.readSb(bits);
                                record.moveY = stream.readSb(bits);
                            }
                            if (flags & 2 /* HasFillStyle0 */) {
                                record.fillStyle0 = stream.readUb(fillBits);
                            }
                            if (flags & 4 /* HasFillStyle1 */) {
                                record.fillStyle1 = stream.readUb(fillBits);
                            }
                            if (flags & 8 /* HasLineStyle */) {
                                record.lineStyle = stream.readUb(lineBits);
                            }
                            if (flags & 16 /* HasNewStyles */) {
                                record.fillStyles = parseFillStyles(stream, swfVersion, tagCode, isMorph);
                                record.lineStyles = parseLineStyles(stream, swfVersion, tagCode, isMorph, hasStrokes);
                                stream.align();
                                fillBits = stream.readUb(4);
                                lineBits = stream.readUb(4);
                            }
                        }
                        record.flags = flags;
                        records.push(record);
                    } while (true);
                    return records;
                }
                function parseFillStyles(stream, swfVersion, tagCode, isMorph) {
                    var count = stream.readUi8();
                    if (tagCode > 2 /* CODE_DEFINE_SHAPE */ && count === 255) {
                        count = stream.readUi16();
                    }
                    var styles = [];
                    var i = count;
                    while (i--) {
                        styles.push(parseFillStyle(stream, swfVersion, tagCode, isMorph));
                    }
                    return styles;
                }
                function parseFillStyle(stream, swfVersion, tagCode, isMorph) {
                    var style = {};
                    var type = style.type = stream.readUi8();
                    switch (type) {
                        case 0:
                            var solid = style;
                            solid.color = tagCode > 22 /* CODE_DEFINE_SHAPE2 */ || isMorph ?
                                parseRgba(stream) :
                                parseRgb(stream);
                            if (isMorph) {
                                solid.colorMorph = parseRgba(stream);
                            }
                            return solid;
                        case 16:
                        case 18:
                        case 19:
                            var gradient = style;
                            gradient.matrix = parseMatrix(stream);
                            if (isMorph) {
                                gradient.matrixMorph = parseMatrix(stream);
                            }
                            if (tagCode === 83 /* CODE_DEFINE_SHAPE4 */) {
                                gradient.spreadMode = stream.readUb(2);
                                gradient.interpolationMode = stream.readUb(2);
                            }
                            else {
                                stream.readUb(4);
                            }
                            var count = stream.readUb(4);
                            var records = gradient.records = [];
                            var j = count;
                            while (j--) {
                                records.push(parseGradientRecord(stream, tagCode, isMorph));
                            }
                            if (type === 19) {
                                gradient.focalPoint = stream.readSi16();
                                if (isMorph) {
                                    gradient.focalPointMorph = stream.readSi16();
                                }
                            }
                            return gradient;
                        case 64:
                        case 65:
                        case 66:
                        case 67:
                            var pattern = style;
                            pattern.bitmapId = stream.readUi16();
                            pattern.condition = type === 64 || type === 67;
                            pattern.matrix = parseMatrix(stream);
                            if (isMorph) {
                                pattern.matrixMorph = parseMatrix(stream);
                            }
                            return pattern;
                    }
                    return style;
                }
                function parseGradientRecord(stream, tagCode, isMorph) {
                    var record = {};
                    record.ratio = stream.readUi8();
                    if (tagCode > 22 /* CODE_DEFINE_SHAPE2 */) {
                        record.color = parseRgba(stream);
                    }
                    else {
                        record.color = parseRgb(stream);
                    }
                    if (isMorph) {
                        record.ratioMorph = stream.readUi8();
                        record.colorMorph = parseRgba(stream);
                    }
                    return record;
                }
                function parseLineStyles(stream, swfVersion, tagCode, isMorph, hasStrokes) {
                    var count = stream.readUi8();
                    if (tagCode > 2 /* CODE_DEFINE_SHAPE */ && count === 255) {
                        count = stream.readUi16();
                    }
                    var styles = [];
                    var i = count;
                    while (i--) {
                        var style = {};
                        style.width = stream.readUi16();
                        if (isMorph) {
                            style.widthMorph = stream.readUi16();
                        }
                        if (hasStrokes) {
                            stream.align();
                            style.startCapsStyle = stream.readUb(2);
                            var jointStyle = style.jointStyle = stream.readUb(2);
                            var hasFill = style.hasFill = stream.readUb(1);
                            style.noHscale = !!stream.readUb(1);
                            style.noVscale = !!stream.readUb(1);
                            style.pixelHinting = !!stream.readUb(1);
                            stream.readUb(5);
                            style.noClose = !!stream.readUb(1);
                            style.endCapsStyle = stream.readUb(2);
                            if (jointStyle === 2) {
                                style.miterLimitFactor = stream.readFixed8();
                            }
                            if (hasFill) {
                                style.fillStyle = parseFillStyle(stream, swfVersion, tagCode, isMorph);
                            }
                            else {
                                style.color = parseRgba(stream);
                                if (isMorph) {
                                    style.colorMorph = parseRgba(stream);
                                }
                            }
                        }
                        else {
                            if (tagCode > 22 /* CODE_DEFINE_SHAPE2 */) {
                                style.color = parseRgba(stream);
                            }
                            else {
                                style.color = parseRgb(stream);
                            }
                            if (isMorph) {
                                style.colorMorph = parseRgba(stream);
                            }
                        }
                        styles.push(style);
                    }
                    return styles;
                }
                function parseDefineVideoStreamTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.numFrames = stream.readUi16();
                    tag.width = stream.readUi16();
                    tag.height = stream.readUi16();
                    stream.readUb(4);
                    tag.deblocking = stream.readUb(3);
                    tag.smoothing = !!stream.readUb(1);
                    tag.codecId = stream.readUi8();
                    return tag;
                }
                function parseVideoFrameTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.streamId = stream.readUi16();
                    tag.frameNum = stream.readUi16();
                    tag.videoData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                LowLevel.tagHandlers = {
                    /* End */ 0: undefined,
                    /* ShowFrame */ 1: undefined,
                    /* DefineShape */ 2: parseDefineShapeTag,
                    /* PlaceObject */ 4: parsePlaceObjectTag,
                    /* RemoveObject */ 5: parseRemoveObjectTag,
                    /* DefineBits */ 6: parseDefineImageTag,
                    /* DefineButton */ 7: parseDefineButtonTag,
                    /* JPEGTables */ 8: undefined,
                    /* SetBackgroundColor */ 9: undefined,
                    /* DefineFont */ 10: parseDefineFontTag,
                    /* DefineText */ 11: parseDefineTextTag,
                    /* DoAction */ 12: undefined,
                    /* DefineFontInfo */ 13: undefined,
                    /* DefineSound */ 14: parseDefineSoundTag,
                    /* StartSound */ 15: parseStartSoundTag,
                    /* DefineButtonSound */ 17: undefined,
                    /* SoundStreamHead */ 18: undefined,
                    /* SoundStreamBlock */ 19: undefined,
                    /* DefineBitsLossless */ 20: parseDefineBitmapTag,
                    /* DefineBitsJPEG2 */ 21: parseDefineImageTag,
                    /* DefineShape2 */ 22: parseDefineShapeTag,
                    /* DefineButtonCxform */ 23: undefined,
                    /* Protect */ 24: undefined,
                    /* PlaceObject2 */ 26: parsePlaceObjectTag,
                    /* RemoveObject2 */ 28: parseRemoveObjectTag,
                    /* DefineShape3 */ 32: parseDefineShapeTag,
                    /* DefineText2 */ 33: parseDefineTextTag,
                    /* DefineButton2 */ 34: parseDefineButtonTag,
                    /* DefineBitsJPEG3 */ 35: parseDefineImageTag,
                    /* DefineBitsLossless2 */ 36: parseDefineBitmapTag,
                    /* DefineEditText */ 37: parseDefineEditTextTag,
                    /* DefineSprite */ 39: undefined,
                    /* FrameLabel */ 43: undefined,
                    /* SoundStreamHead2 */ 45: undefined,
                    /* DefineMorphShape */ 46: parseDefineShapeTag,
                    /* DefineFont2 */ 48: parseDefineFont2Tag,
                    /* ExportAssets */ 56: undefined,
                    /* ImportAssets */ 57: undefined,
                    /* EnableDebugger */ 58: undefined,
                    /* DoInitAction */ 59: undefined,
                    /* DefineVideoStream */ 60: parseDefineVideoStreamTag,
                    /* VideoFrame */ 61: parseVideoFrameTag,
                    /* DefineFontInfo2 */ 62: undefined,
                    /* EnableDebugger2 */ 64: undefined,
                    /* ScriptLimits */ 65: undefined,
                    /* SetTabIndex */ 66: undefined,
                    /* FileAttributes */ 69: undefined,
                    /* PlaceObject3 */ 70: parsePlaceObjectTag,
                    /* ImportAssets2 */ 71: undefined,
                    /* DoABC (undoc) */ 72: undefined,
                    /* DefineFontAlignZones */ 73: undefined,
                    /* CSMTextSettings */ 74: undefined,
                    /* DefineFont3 */ 75: parseDefineFont2Tag,
                    /* SymbolClass */ 76: undefined,
                    /* Metadata */ 77: undefined,
                    /* DefineScalingGrid */ 78: parseDefineScalingGridTag,
                    /* DoABC */ 82: undefined,
                    /* DefineShape4 */ 83: parseDefineShapeTag,
                    /* DefineMorphShape2 */ 84: parseDefineShapeTag,
                    /* DefineSceneAndFrameLabelData */ 86: parseDefineSceneTag,
                    /* DefineBinaryData */ 87: parseDefineBinaryDataTag,
                    /* DefineFontName */ 88: undefined,
                    /* StartSound2 */ 89: parseStartSoundTag,
                    /* DefineBitsJPEG4 */ 90: parseDefineImageTag,
                    /* DefineFont4 */ 91: parseDefineFont4Tag
                };
                function parseHeader(stream) {
                    var bits = stream.readUb(5);
                    var xMin = stream.readSb(bits);
                    var xMax = stream.readSb(bits);
                    var yMin = stream.readSb(bits);
                    var yMax = stream.readSb(bits);
                    stream.align();
                    var frameRateFraction = stream.readUi8();
                    var frameRate = stream.readUi8() + frameRateFraction / 256;
                    var frameCount = stream.readUi16();
                    return {
                        frameRate: frameRate,
                        frameCount: frameCount,
                        bounds: new Shumway.Bounds(xMin, yMin, xMax, yMax)
                    };
                }
                LowLevel.parseHeader = parseHeader;
            })(LowLevel = Parser.LowLevel || (Parser.LowLevel = {}));
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var roundToMultipleOfFour = Shumway.IntegerUtilities.roundToMultipleOfFour;
            var Inflate = Shumway.ArrayUtilities.Inflate;
            var BitmapFormat;
            (function (BitmapFormat) {
                /**
                 * 8-bit color mapped image.
                 */
                BitmapFormat[BitmapFormat["FORMAT_COLORMAPPED"] = 3] = "FORMAT_COLORMAPPED";
                /**
                 * 15-bit RGB image.
                 */
                BitmapFormat[BitmapFormat["FORMAT_15BPP"] = 4] = "FORMAT_15BPP";
                /**
                 * 24-bit RGB image, however stored as 4 byte value 0x00RRGGBB.
                 */
                BitmapFormat[BitmapFormat["FORMAT_24BPP"] = 5] = "FORMAT_24BPP";
            })(BitmapFormat = Parser.BitmapFormat || (Parser.BitmapFormat = {}));
            /** @const */ var FACTOR_5BBP = 255 / 31;
            /*
             * Returns a Uint8Array of ARGB values. The source image is color mapped meaning
             * that the buffer is first prefixed with a color table:
             *
             * +--------------|--------------------------------------------------+
             * | Color Table  |  Image Data (byte indices into the color table)  |
             * +--------------|--------------------------------------------------+
             *
             * Color Table entries are either in RGB or RGBA format.
             *
             * There are two variations of these file formats, with or without alpha.
             *
             * Row pixels always start at 32 bit alinged offsets, the color table as
             * well as the end of each row may be padded so that the next row of pixels
             * is aligned.
             */
            function parseColorMapped(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;
                var padding = roundToMultipleOfFour(width) - width;
                var colorTableLength = tag.colorTableSize + 1;
                var colorTableEntrySize = hasAlpha ? 4 : 3;
                var colorTableSize = roundToMultipleOfFour(colorTableLength * colorTableEntrySize);
                var dataSize = colorTableSize + ((width + padding) * height);
                var bytes = Inflate.inflate(tag.bmpData, dataSize, true);
                var view = new Uint32Array(width * height);
                // TODO: Figure out why this fails.
                // Make sure we've deflated enough bytes.
                // stream.ensure(dataSize);
                var p = colorTableSize, i = 0, offset = 0;
                if (hasAlpha) {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] << 2;
                            var a = bytes[offset + 3]; // A
                            var r = bytes[offset + 0]; // R
                            var g = bytes[offset + 1]; // G
                            var b = bytes[offset + 2]; // B
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                }
                else {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] * colorTableEntrySize;
                            var a = 0xff; // A
                            var r = bytes[offset + 0]; // R
                            var g = bytes[offset + 1]; // G
                            var b = bytes[offset + 2]; // B
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                }
                release || assert(p === dataSize, "We should be at the end of the data buffer now.");
                release || assert(i === width * height, "Should have filled the entire image.");
                return new Uint8Array(view.buffer);
            }
            /**
             * Returns a Uint8Array of ARGB values. The data is already stored in premultiplied ARGB
             * so there's not much to do unless there's no alpha in which case we expand it here.
             */
            function parse24BPP(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;
                // Even without alpha, 24BPP is stored as 4 bytes, probably for alignment reasons.
                var dataSize = height * width * 4;
                var bytes = Inflate.inflate(tag.bmpData, dataSize, true);
                if (hasAlpha) {
                    return bytes;
                }
                var view = new Uint32Array(width * height);
                var length = width * height, p = 0;
                // TODO: Looks like we can probably get away with just setting alpha to 0xff instead of
                // reading the entire buffer.
                for (var i = 0; i < length; i++) {
                    p++; // Reserved, always zero.
                    var r = bytes[p++];
                    var g = bytes[p++];
                    var b = bytes[p++];
                    view[i] = b << 24 | g << 16 | r << 8 | 0xff;
                }
                release || assert(p === dataSize, "We should be at the end of the data buffer now.");
                return new Uint8Array(view.buffer);
            }
            function parse15BPP(tag) {
                release || notImplemented("parse15BPP");
                /*
                  case FORMAT_15BPP:
                    let colorType = 0x02;
                    let bytesPerLine = ((width * 2) + 3) & ~3;
                    let stream = createInflatedStream(bmpData, bytesPerLine * height);
        
                    for (let y = 0, i = 0; y < height; ++y) {
                      stream.ensure(bytesPerLine);
                      for (let x = 0; x < width; ++x, i += 4) {
                        let word = stream.readUi16();
                        // Extracting RGB color components and changing values range
                        // from 0..31 to 0..255.
                        data[i] = 0 | (FACTOR_5BBP * ((word >> 10) & 0x1f));
                        data[i + 1] = 0 | (FACTOR_5BBP * ((word >> 5) & 0x1f));
                        data[i + 2] = 0 | (FACTOR_5BBP * (word & 0x1f));
                        data[i + 3] = 255;
                      }
                      stream += bytesPerLine;
                    }
                    break;
                  */
                return null;
            }
            function defineBitmap(tag) {
                SWF.enterTimeline("defineBitmap");
                var data;
                var type = Shumway.ImageType.None;
                switch (tag.format) {
                    case 3 /* FORMAT_COLORMAPPED */:
                        data = parseColorMapped(tag);
                        type = Shumway.ImageType.PremultipliedAlphaARGB;
                        break;
                    case 5 /* FORMAT_24BPP */:
                        data = parse24BPP(tag);
                        type = Shumway.ImageType.PremultipliedAlphaARGB;
                        break;
                    case 4 /* FORMAT_15BPP */:
                        data = parse15BPP(tag);
                        type = Shumway.ImageType.PremultipliedAlphaARGB;
                        break;
                    default:
                        release || assertUnreachable('invalid bitmap format');
                }
                SWF.leaveTimeline();
                return {
                    definition: {
                        type: 'image',
                        id: tag.id,
                        width: tag.width,
                        height: tag.height,
                        mimeType: 'application/octet-stream',
                        data: data,
                        dataType: type,
                        image: null
                    },
                    type: 'image'
                };
            }
            Parser.defineBitmap = defineBitmap;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            function defineButton(tag, dictionary) {
                var characters = tag.characters;
                var states = {
                    up: [],
                    over: [],
                    down: [],
                    hitTest: []
                };
                var i = 0, character;
                while ((character = characters[i++])) {
                    var characterItem = dictionary[character.symbolId];
                    // The Flash Player ignores references to undefined symbols here. So should we.
                    // TODO: What should happen if the symbol gets defined later in the file?
                    if (characterItem) {
                        var cmd = {
                            symbolId: characterItem.id,
                            code: 4 /* CODE_PLACE_OBJECT */,
                            depth: character.depth,
                            flags: character.matrix ? 4 /* HasMatrix */ : 0,
                            matrix: character.matrix
                        };
                        if (character.flags & 1 /* StateUp */)
                            states.up.push(cmd);
                        if (character.flags & 2 /* StateOver */)
                            states.over.push(cmd);
                        if (character.flags & 4 /* StateDown */)
                            states.down.push(cmd);
                        if (character.flags & 8 /* StateHitTest */)
                            states.hitTest.push(cmd);
                    }
                    else {
                        release || Shumway.Debug.warning('undefined character in button ' + tag.id);
                    }
                }
                var button = {
                    type: 'button',
                    id: tag.id,
                    buttonActions: tag.buttonActions,
                    states: states
                };
                return button;
            }
            Parser.defineButton = defineButton;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var pow = Math.pow;
            var min = Math.min;
            var max = Math.max;
            var logE = Math.log;
            var fromCharCode = String.fromCharCode;
            var nextFontId = 1;
            function maxPower2(num) {
                var maxPower = 0;
                var val = num;
                while (val >= 2) {
                    val /= 2;
                    ++maxPower;
                }
                return pow(2, maxPower);
            }
            function toString16(val) {
                return fromCharCode((val >> 8) & 0xff, val & 0xff);
            }
            function toString32(val) {
                return toString16(val >> 16) + toString16(val);
            }
            /**
             * Heuristic to detect if DefineFont2 was scaled as Font3: scanning all
             * x and y coordinates of the glyphs and if their bounding box dimensions
             * greater than 5000 (that's more than enough for normal TrueType font),
             * then the font coordinates were scaled by 20.
             */
            function isScaledFont2(glyphs) {
                var xMin = 0, yMin = 0, xMax = 0, yMax = 0;
                var record;
                for (var i = 0; i < glyphs.length; i++) {
                    var records = glyphs[i];
                    if (!records) {
                        continue;
                    }
                    var x = 0;
                    var y = 0;
                    for (var j = 0; j < records.length; j++) {
                        record = records[j];
                        if (record.type) {
                            if ((record.flags & 32 /* IsStraight */) !== 0) {
                                x += (record.deltaX || 0);
                                y += -(record.deltaY || 0);
                            }
                            else {
                                x += record.controlDeltaX;
                                y += -record.controlDeltaY;
                                x += record.anchorDeltaX;
                                y += -record.anchorDeltaY;
                            }
                        }
                        else {
                            if ((record.flags & 1 /* Move */) !== 0) {
                                x = record.moveX;
                                y = -record.moveY;
                            }
                        }
                        if (xMin > x) {
                            xMin = x;
                        }
                        if (yMin > y) {
                            yMin = y;
                        }
                        if (xMax < x) {
                            xMax = x;
                        }
                        if (yMax < y) {
                            yMax = y;
                        }
                    }
                }
                var maxDimension = Math.max(xMax - xMin, yMax - yMin);
                return maxDimension > 5000;
            }
            function defineFont(tag) {
                var uniqueName = 'swf-font-' + tag.id;
                var fontName = tag.name || uniqueName;
                var font = {
                    type: 'font',
                    id: tag.id,
                    name: fontName,
                    bold: !!(tag.flags & 1 /* Bold */),
                    italic: !!(tag.flags & 2 /* Italic */),
                    codes: null,
                    metrics: null,
                    data: tag.data,
                    originalSize: false
                };
                var glyphs = tag.glyphs;
                var glyphCount = glyphs ? glyphs.length : 0;
                if (!glyphCount) {
                    return font;
                }
                var tables = {};
                var codes = [];
                var glyphIndex = {};
                var ranges = [];
                var originalCode;
                var generateAdvancement = !('advance' in tag);
                var correction = 0;
                var isFont2 = tag.code === 48 /* CODE_DEFINE_FONT2 */;
                var isFont3 = tag.code === 75 /* CODE_DEFINE_FONT3 */;
                if (generateAdvancement) {
                    tag.advance = [];
                }
                var maxCode = Math.max.apply(null, tag.codes) || 35;
                var indices;
                var code;
                if (tag.codes) {
                    for (var i_2 = 0; i_2 < tag.codes.length; i_2++) {
                        var code_1 = tag.codes[i_2];
                        if (code_1 < 32 || code_1 in glyphIndex) {
                            maxCode++;
                            if (maxCode == 8232) {
                                maxCode = 8240;
                            }
                            code_1 = maxCode;
                        }
                        codes.push(code_1);
                        glyphIndex[code_1] = i_2;
                    }
                    originalCode = codes.concat();
                    codes.sort(function (a, b) {
                        return a - b;
                    });
                    var i_3 = 0;
                    while ((code = codes[i_3++]) !== undefined) {
                        var start = code;
                        var end = start;
                        indices = [i_3 - 1];
                        while (((code = codes[i_3]) !== undefined) && end + 1 === code) {
                            ++end;
                            indices.push(i_3);
                            ++i_3;
                        }
                        ranges.push([start, end, indices]);
                    }
                }
                else {
                    indices = [];
                    var UAC_OFFSET = 0xe000;
                    for (var i_4 = 0; i_4 < glyphCount; i_4++) {
                        code = UAC_OFFSET + i_4;
                        codes.push(code);
                        glyphIndex[code] = i_4;
                        indices.push(i_4);
                    }
                    ranges.push([UAC_OFFSET, UAC_OFFSET + glyphCount - 1, indices]);
                    originalCode = codes.concat();
                }
                var resolution = tag.resolution || 1;
                if (isFont2 && isScaledFont2(glyphs)) {
                    // some DefineFont2 without layout using DefineFont3 resolution, why?
                    resolution = 20;
                    font.originalSize = true;
                }
                var ascent = Math.ceil(tag.ascent / resolution) || 1024;
                var descent = -Math.ceil(tag.descent / resolution) || 0;
                var leading = (tag.leading / resolution) || 0;
                tables['OS/2'] = '';
                var startCount = '';
                var endCount = '';
                var idDelta = '';
                var idRangeOffset = '';
                var i = 0;
                var range;
                while ((range = ranges[i++])) {
                    var start = range[0];
                    var end = range[1];
                    code = range[2][0];
                    startCount += toString16(start);
                    endCount += toString16(end);
                    idDelta += toString16(((code - start) + 1) & 0xffff);
                    idRangeOffset += toString16(0);
                }
                endCount += '\xff\xff';
                startCount += '\xff\xff';
                idDelta += '\x00\x01';
                idRangeOffset += '\x00\x00';
                var segCount = ranges.length + 1;
                var searchRange = maxPower2(segCount) * 2;
                var rangeShift = (2 * segCount) - searchRange;
                var format314 = '\x00\x00' + // language
                    toString16(segCount * 2) + // segCountX2
                    toString16(searchRange) +
                    toString16(logE(segCount) / logE(2)) + // entrySelector
                    toString16(rangeShift) +
                    endCount +
                    '\x00\x00' + // reservedPad
                    startCount +
                    idDelta +
                    idRangeOffset;
                tables['cmap'] =
                    '\x00\x00' + // version
                        '\x00\x01' + // numTables
                        '\x00\x03' + // platformID
                        '\x00\x01' + // encodingID
                        '\x00\x00\x00\x0c' + // offset
                        '\x00\x04' + // format
                        toString16(format314.length + 4) + // length
                        format314;
                var glyf = '\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x31\x00';
                var loca = '\x00\x00';
                var offset = 16;
                var maxPoints = 0;
                var xMins = [];
                var xMaxs = [];
                var yMins = [];
                var yMaxs = [];
                var maxContours = 0;
                i = 0;
                var j;
                var rawData = {};
                var record;
                var segments;
                var myFlags = '';
                var myEndpts = '';
                var endPoint = 0;
                while ((code = codes[i++]) !== undefined) {
                    var records = glyphs[glyphIndex[code]];
                    var x = 0;
                    var y = 0;
                    myFlags = '';
                    myEndpts = '';
                    endPoint = 0;
                    segments = [];
                    var segmentIndex = -1;
                    for (j = 0; j < records.length; j++) {
                        record = records[j];
                        if (record.type) {
                            if (segmentIndex < 0) {
                                segmentIndex = 0;
                                segments[segmentIndex] = { data: [], commands: [], xMin: 0, xMax: 0, yMin: 0, yMax: 0 };
                            }
                            if (record.flags & 32 /* IsStraight */) {
                                segments[segmentIndex].commands.push(2);
                                var dx = (record.deltaX || 0) / resolution;
                                var dy = -(record.deltaY || 0) / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            }
                            else {
                                segments[segmentIndex].commands.push(3);
                                var cx = record.controlDeltaX / resolution;
                                var cy = -record.controlDeltaY / resolution;
                                x += cx;
                                y += cy;
                                segments[segmentIndex].data.push(x, y);
                                var dx = record.anchorDeltaX / resolution;
                                var dy = -record.anchorDeltaY / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            }
                        }
                        else {
                            if ((record.flags & 1 /* Move */) !== 0) {
                                segmentIndex++;
                                segments[segmentIndex] = { data: [], commands: [], xMin: 0, xMax: 0, yMin: 0, yMax: 0 };
                                segments[segmentIndex].commands.push(1);
                                var moveX = record.moveX / resolution;
                                var moveY = -record.moveY / resolution;
                                var dx = moveX - x;
                                var dy = moveY - y;
                                x = moveX;
                                y = moveY;
                                segments[segmentIndex].data.push(x, y);
                            }
                        }
                        if (segmentIndex > -1) {
                            if (segments[segmentIndex].xMin > x) {
                                segments[segmentIndex].xMin = x;
                            }
                            if (segments[segmentIndex].yMin > y) {
                                segments[segmentIndex].yMin = y;
                            }
                            if (segments[segmentIndex].xMax < x) {
                                segments[segmentIndex].xMax = x;
                            }
                            if (segments[segmentIndex].yMax < y) {
                                segments[segmentIndex].yMax = y;
                            }
                        }
                    }
                    if (!isFont3) {
                        segments.sort(function (a, b) {
                            return (b.xMax - b.xMin) * (b.yMax - b.yMin) - (a.xMax - a.xMin) * (a.yMax - a.yMin);
                        });
                    }
                    rawData[code] = segments;
                }
                i = 0;
                while ((code = codes[i++]) !== undefined) {
                    var records = glyphs[glyphIndex[code]];
                    segments = rawData[code];
                    var numberOfContours = 1;
                    endPoint = 0;
                    var endPtsOfContours = '';
                    var flags = '';
                    var xCoordinates = '';
                    var yCoordinates = '';
                    var x = 0;
                    var y = 0;
                    var xMin = 0;
                    var xMax = -1024;
                    var yMin = 0;
                    var yMax = -1024;
                    var myFlags_1 = '';
                    myEndpts = '';
                    var segmentIndex = -1;
                    var data = [];
                    var commands = [];
                    for (j = 0; j < segments.length; j++) {
                        data = data.concat(segments[j].data);
                        commands = commands.concat(segments[j].commands);
                    }
                    x = 0;
                    y = 0;
                    var nx = 0;
                    var ny = 0;
                    var myXCoordinates = '';
                    var myYCoordinates = '';
                    var dataIndex = 0;
                    endPoint = 0;
                    numberOfContours = 1;
                    myEndpts = '';
                    for (j = 0; j < commands.length; j++) {
                        var command = commands[j];
                        var cx = void 0, cy = void 0;
                        if (command === 1) {
                            if (endPoint) {
                                ++numberOfContours;
                                myEndpts += toString16(endPoint - 1);
                            }
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags_1 += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        }
                        else if (command === 2) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags_1 += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        }
                        else if (command === 3) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            cx = nx - x;
                            cy = ny - y;
                            myFlags_1 += '\x00';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                            endPoint++;
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            cx = nx - x;
                            cy = ny - y;
                            myFlags_1 += '\x01';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                        }
                        endPoint++;
                        if (endPoint > maxPoints) {
                            maxPoints = endPoint;
                        }
                        if (xMin > x) {
                            xMin = x;
                        }
                        if (yMin > y) {
                            yMin = y;
                        }
                        if (xMax < x) {
                            xMax = x;
                        }
                        if (yMax < y) {
                            yMax = y;
                        }
                    }
                    myEndpts += toString16((endPoint || 1) - 1);
                    endPtsOfContours = myEndpts;
                    xCoordinates = myXCoordinates;
                    yCoordinates = myYCoordinates;
                    flags = myFlags_1;
                    if (!j) {
                        xMin = xMax = yMin = yMax = 0;
                        flags += '\x31';
                    }
                    var entry = toString16(numberOfContours) +
                        toString16(xMin) +
                        toString16(yMin) +
                        toString16(xMax) +
                        toString16(yMax) +
                        endPtsOfContours +
                        '\x00\x00' + // instructionLength
                        flags +
                        xCoordinates +
                        yCoordinates;
                    if (entry.length & 1) {
                        entry += '\x00';
                    }
                    glyf += entry;
                    loca += toString16(offset / 2);
                    offset += entry.length;
                    xMins.push(xMin);
                    xMaxs.push(xMax);
                    yMins.push(yMin);
                    yMaxs.push(yMax);
                    if (numberOfContours > maxContours) {
                        maxContours = numberOfContours;
                    }
                    if (endPoint > maxPoints) {
                        maxPoints = endPoint;
                    }
                    if (generateAdvancement) {
                        tag.advance.push((xMax - xMin) * resolution * 1.3);
                    }
                }
                loca += toString16(offset / 2);
                tables['glyf'] = glyf;
                if (!isFont3) {
                    var minYmin = Math.min.apply(null, yMins);
                    if (minYmin < 0) {
                        descent = descent || minYmin;
                    }
                }
                tables['OS/2'] =
                    '\x00\x01' + // version
                        '\x00\x00' + // xAvgCharWidth
                        toString16(font.bold ? 700 : 400) + // usWeightClass
                        '\x00\x05' + // usWidthClass
                        '\x00\x00' + // fstype
                        '\x00\x00' + // ySubscriptXSize
                        '\x00\x00' + // ySubscriptYSize
                        '\x00\x00' + // ySubscriptXOffset
                        '\x00\x00' + // ySubscriptYOffset
                        '\x00\x00' + // ySuperScriptXSize
                        '\x00\x00' + // ySuperScriptYSize
                        '\x00\x00' + // ySuperScriptXOffset
                        '\x00\x00' + // ySuperScriptYOffset
                        '\x00\x00' + // yStrikeoutSize
                        '\x00\x00' + // yStrikeoutPosition
                        '\x00\x00' + // sFamilyClass
                        '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' + // panose
                        '\x00\x00\x00\x00' + // ulUnicodeRange1
                        '\x00\x00\x00\x00' + // ulUnicodeRange2
                        '\x00\x00\x00\x00' + // ulUnicodeRange3
                        '\x00\x00\x00\x00' + // ulUnicodeRange4
                        'ALF ' + // achVendID
                        toString16((font.italic ? 0x01 : 0) | (font.bold ? 0x20 : 0)) + // fsSelection
                        toString16(codes[0]) + // usFirstCharIndex
                        toString16(codes[codes.length - 1]) + // usLastCharIndex
                        toString16(ascent) + // sTypoAscender
                        toString16(descent) + // sTypoDescender
                        toString16(leading) + // sTypoLineGap
                        toString16(ascent) + // usWinAscent
                        toString16(-descent) + // usWinDescent
                        '\x00\x00\x00\x00' + // ulCodePageRange1
                        '\x00\x00\x00\x00' // ulCodePageRange2
                ;
                tables['head'] =
                    '\x00\x01\x00\x00' + // version
                        '\x00\x01\x00\x00' + // fontRevision
                        '\x00\x00\x00\x00' + // checkSumAdjustement
                        '\x5f\x0f\x3c\xf5' + // magicNumber
                        '\x00\x0b' + // flags
                        '\x04\x00' + // unitsPerEm
                        '\x00\x00\x00\x00' + toString32(Date.now()) + // created
                        '\x00\x00\x00\x00' + toString32(Date.now()) + // modified
                        toString16(min.apply(null, xMins)) + // xMin
                        toString16(min.apply(null, yMins)) + // yMin
                        toString16(max.apply(null, xMaxs)) + // xMax
                        toString16(max.apply(null, yMaxs)) + // yMax
                        toString16((font.italic ? 2 : 0) | (font.bold ? 1 : 0)) + // macStyle
                        '\x00\x08' + // lowestRecPPEM
                        '\x00\x02' + // fontDirectionHint
                        '\x00\x00' + // indexToLocFormat
                        '\x00\x00' // glyphDataFormat
                ;
                var advance = tag.advance;
                tables['hhea'] =
                    '\x00\x01\x00\x00' + // version
                        toString16(ascent) + // ascender
                        toString16(descent) + // descender
                        toString16(leading) + // lineGap
                        toString16(advance ? max.apply(null, advance) : 1024) + // advanceWidthMax
                        '\x00\x00' + // minLeftSidebearing
                        '\x00\x00' + // minRightSidebearing
                        '\x03\xb8' + // xMaxExtent
                        '\x00\x01' + // caretSlopeRise
                        '\x00\x00' + // caretSlopeRun
                        '\x00\x00' + // caretOffset
                        '\x00\x00' + // reserved
                        '\x00\x00' + // reserved
                        '\x00\x00' + // reserved
                        '\x00\x00' + // reserved
                        '\x00\x00' + // metricDataFormat
                        toString16(glyphCount + 1) // numberOfHMetrics
                ;
                var hmtx = '\x00\x00\x00\x00';
                for (var i_5 = 0; i_5 < glyphCount; ++i_5) {
                    hmtx += toString16(advance ? (advance[i_5] / resolution) : 1024) + '\x00\x00';
                }
                tables['hmtx'] = hmtx;
                if (tag.kerning && tag.kerning.length) {
                    var kerning = tag.kerning;
                    var nPairs = kerning.length;
                    var searchRange_1 = maxPower2(nPairs) * 2;
                    var kern = '\x00\x00' + // version
                        '\x00\x01' + // nTables
                        '\x00\x00' + // subtable version
                        toString16(14 + (nPairs * 6)) + // length
                        '\x00\x01' + // coverage
                        toString16(nPairs) +
                        toString16(searchRange_1) +
                        toString16(logE(nPairs) / logE(2)) + // entrySelector
                        toString16((2 * nPairs) - searchRange_1) // rangeShift
                    ;
                    var i_6 = 0;
                    while ((record = kerning[i_6++])) {
                        kern +=
                            toString16(glyphIndex[record.code1]) + // left
                                toString16(glyphIndex[record.code2]) + // right
                                toString16(record.adjustment) // value
                        ;
                    }
                    tables['kern'] = kern;
                }
                tables['loca'] = loca;
                tables['maxp'] =
                    '\x00\x01\x00\x00' + // version
                        toString16(glyphCount + 1) + // numGlyphs
                        toString16(maxPoints) +
                        toString16(maxContours) +
                        '\x00\x00' + // maxCompositePoints
                        '\x00\x00' + // maxCompositeContours
                        '\x00\x01' + // maxZones
                        '\x00\x00' + // maxTwilightPoints
                        '\x00\x00' + // maxStorage
                        '\x00\x00' + // maxFunctionDefs
                        '\x00\x00' + // maxInstructionDefs
                        '\x00\x00' + // maxStackElements
                        '\x00\x00' + // maxSizeOfInstructions
                        '\x00\x00' + // maxComponentElements
                        '\x00\x00' // maxComponentDepth
                ;
                var psName = fontName.replace(/ /g, '');
                var strings = [
                    tag.copyright || 'Original licence',
                    fontName,
                    'Unknown',
                    uniqueName,
                    fontName,
                    '1.0',
                    psName,
                    'Unknown',
                    'Unknown',
                    'Unknown' // 9. Designer
                ];
                var count = strings.length;
                var name = '\x00\x00' + // format
                    toString16(count) + // count
                    toString16((count * 12) + 6); // stringOffset
                offset = 0;
                i = 0;
                var str;
                while ((str = strings[i++])) {
                    name +=
                        '\x00\x01' + // platformID
                            '\x00\x00' + // encodingID
                            '\x00\x00' + // languageID
                            toString16(i - 1) + // nameID
                            toString16(str.length) +
                            toString16(offset);
                    offset += str.length;
                }
                tables['name'] = name + strings.join('');
                tables['post'] =
                    '\x00\x03\x00\x00' + // version
                        '\x00\x00\x00\x00' + // italicAngle
                        '\x00\x00' + // underlinePosition
                        '\x00\x00' + // underlineThickness
                        '\x00\x00\x00\x00' + // isFixedPitch
                        '\x00\x00\x00\x00' + // minMemType42
                        '\x00\x00\x00\x00' + // maxMemType42
                        '\x00\x00\x00\x00' + // minMemType1
                        '\x00\x00\x00\x00' // maxMemType1
                ;
                var names = Object.keys(tables);
                var numTables = names.length;
                var header = '\x00\x01\x00\x00' + // version
                    toString16(numTables) +
                    '\x00\x80' + // searchRange
                    '\x00\x03' + // entrySelector
                    '\x00\x20' // rangeShift
                ;
                var dataString = '';
                offset = (numTables * 16) + header.length;
                i = 0;
                while ((name = names[i++])) {
                    var table = tables[name];
                    var length_2 = table.length;
                    header +=
                        name +
                            '\x00\x00\x00\x00' + // checkSum
                            toString32(offset) +
                            toString32(length_2);
                    while (length_2 & 3) {
                        table += '\x00';
                        ++length_2;
                    }
                    dataString += table;
                    while (offset & 3) {
                        ++offset;
                    }
                    offset += length_2;
                }
                var otf = header + dataString;
                var unitPerEm = 1024;
                var metrics = {
                    ascent: ascent / unitPerEm,
                    descent: -descent / unitPerEm,
                    leading: leading / unitPerEm
                };
                // TODO: use a buffer to generate font data
                var dataBuffer = new Uint8Array(otf.length);
                for (var i_7 = 0; i_7 < otf.length; i_7++) {
                    dataBuffer[i_7] = otf.charCodeAt(i_7) & 0xff;
                }
                font.codes = originalCode;
                font.metrics = metrics;
                font.data = dataBuffer;
                return font;
            }
            Parser.defineFont = defineFont;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var Inflate = Shumway.ArrayUtilities.Inflate;
            /**
             * Reads the next two bytes at the specified position.
             */
            function readUint16(bytes, position) {
                return (bytes[position] << 8) | bytes[position + 1];
            }
            /**
             * Reads the next four bytes at the specified position.
             */
            function readInt32(bytes, position) {
                return (bytes[position] << 24) | (bytes[position + 1] << 16) |
                    (bytes[position + 2] << 8) | bytes[position + 3];
            }
            /**
             * Parses JPEG chunks and reads image width and height information. JPEG data
             * in SWFs is encoded in chunks and not directly decodable by the JPEG parser.
             */
            function parseJpegChunks(bytes, chunks) {
                var i = 0;
                var n = bytes.length;
                // Finding first marker, and skipping the data before this marker.
                // (FF 00 - code is escaped FF; FF FF ... (FF xx) - fill bytes before marker).
                while (i < n && (bytes[i] !== 0xff ||
                    (i + 1 < n && (bytes[i + 1] === 0x00 || bytes[i + 1] === 0xff)))) {
                    ++i;
                }
                if (i >= n) {
                    return; // no valid data was found
                }
                do {
                    release || Shumway.Debug.assert(bytes[i] === 0xff);
                    var begin = i++;
                    var code = bytes[i++];
                    // Some tags have length field -- using it
                    if ((code >= 0xc0 && code <= 0xc7) || (code >= 0xc9 && code <= 0xcf) ||
                        (code >= 0xda && code <= 0xef) || code === 0xfe) {
                        var length_3 = readUint16(bytes, i);
                        i += length_3;
                    }
                    // Finding next marker.
                    while (i < n && (bytes[i] !== 0xff ||
                        (i + 1 < n && (bytes[i + 1] === 0x00 || bytes[i + 1] === 0xff)))) {
                        ++i;
                    }
                    if (code === 0xd8 || code === 0xd9) {
                        // Removing SOI and EOI to avoid wrong EOI-SOI pairs in the middle.
                        continue;
                    }
                    chunks.push(bytes.subarray(begin, i));
                } while (i < n);
            }
            Parser.parseJpegChunks = parseJpegChunks;
            /**
             * Extracts PNG width and height information.
             */
            function parsePngHeaders(image, bytes) {
                var ihdrOffset = 12;
                if (bytes[ihdrOffset] !== 0x49 || bytes[ihdrOffset + 1] !== 0x48 ||
                    bytes[ihdrOffset + 2] !== 0x44 || bytes[ihdrOffset + 3] !== 0x52) {
                    return;
                }
                image.width = readInt32(bytes, ihdrOffset + 4);
                image.height = readInt32(bytes, ihdrOffset + 8);
                var type = bytes[ihdrOffset + 14];
                image.hasAlpha = type === 4 || type === 6;
            }
            Parser.parsePngHeaders = parsePngHeaders;
            /**
             * Joins all the chunks in a larger byte array.
             */
            function joinChunks(chunks) {
                var length = 0;
                for (var i = 0; i < chunks.length; i++) {
                    length += chunks[i].length;
                }
                var bytes = new Uint8Array(length);
                var offset = 0;
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    bytes.set(chunk, offset);
                    offset += chunk.length;
                }
                return bytes;
            }
            function injectJPEGTables(chunks, state) {
                if (!state.parsedChunks) {
                    var parsedChunks = [];
                    parseJpegChunks(state.data, parsedChunks);
                    state.parsedChunks = parsedChunks;
                }
                // Finding first SOF and inserting tables there
                var i = 0;
                while (i < chunks.length &&
                    !(chunks[i][1] >= 0xc0 && chunks[i][1] <= 0xc0)) {
                    i++;
                }
                Array.prototype.splice.apply(chunks, Array.prototype.concat.call([i, 0], state.parsedChunks));
            }
            var JPEG_SOI = new Uint8Array([0xff, 0xd8]);
            var JPEG_EOI = new Uint8Array([0xff, 0xd9]);
            function defineImage(tag) {
                SWF.enterTimeline("defineImage");
                var image = {
                    type: 'image',
                    id: tag.id,
                    mimeType: tag.mimeType
                };
                var imgData = tag.imgData;
                if (tag.mimeType === 'image/jpeg') {
                    // Parsing/repairing the SWF JPEG data.
                    var chunks = [];
                    chunks.push(JPEG_SOI);
                    parseJpegChunks(imgData, chunks);
                    if (tag.jpegTables) {
                        injectJPEGTables(chunks, tag.jpegTables);
                    }
                    chunks.push(JPEG_EOI);
                    // Finding SOF to extract image size.
                    chunks.forEach(function (chunk) {
                        var code = chunk[1];
                        if (code >= 0xc0 && code <= 0xc3) {
                            image.height = readUint16(chunk, 5);
                            image.width = readUint16(chunk, 7);
                        }
                    });
                    image.data = joinChunks(chunks);
                    image.dataType = Shumway.ImageType.JPEG;
                    var alphaData = tag.alphaData;
                    if (alphaData) {
                        var length_4 = image.width * image.height;
                        try {
                            image.alphaData = Inflate.inflate(alphaData, length_4, true);
                        }
                        catch (e) {
                            // Alpha layer is invalid, so hiding everything.
                            image.alphaData = new Uint8Array(length_4);
                        }
                    }
                }
                else {
                    parsePngHeaders(image, imgData);
                    image.data = imgData;
                    image.dataType = Shumway.ImageType.PNG;
                }
                SWF.leaveTimeline();
                return image;
            }
            Parser.defineImage = defineImage;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            function defineLabel(tag) {
                var label = {
                    type: 'label',
                    id: tag.id,
                    fillBounds: tag.bbox,
                    matrix: tag.matrix,
                    tag: {
                        hasText: true,
                        initialText: '',
                        html: true,
                        readonly: true
                    },
                    records: tag.records,
                    coords: null,
                    static: true,
                    require: null
                };
                return label;
            }
            Parser.defineLabel = defineLabel;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var ShapeData = Shumway.ShapeData;
            var clamp = Shumway.NumberUtilities.clamp;
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var push = Array.prototype.push;
            var FillType;
            (function (FillType) {
                FillType[FillType["Solid"] = 0] = "Solid";
                FillType[FillType["LinearGradient"] = 16] = "LinearGradient";
                FillType[FillType["RadialGradient"] = 18] = "RadialGradient";
                FillType[FillType["FocalRadialGradient"] = 19] = "FocalRadialGradient";
                FillType[FillType["RepeatingBitmap"] = 64] = "RepeatingBitmap";
                FillType[FillType["ClippedBitmap"] = 65] = "ClippedBitmap";
                FillType[FillType["NonsmoothedRepeatingBitmap"] = 66] = "NonsmoothedRepeatingBitmap";
                FillType[FillType["NonsmoothedClippedBitmap"] = 67] = "NonsmoothedClippedBitmap";
            })(FillType || (FillType = {}));
            /*
             * Applies the current segment to the paths of all styles specified in the last
             * style-change record.
             *
             * For fill0, we have to apply commands and their data in reverse order, to turn
             * left fills into right ones.
             *
             * If we have more than one style, we only recorded commands for the first one
             * and have to duplicate them for the other styles. The order is: fill1, line,
             * fill0. (That means we only ever recorded into fill0 if that's the only style.)
             */
            function applySegmentToStyles(segment, styles, linePaths, fillPaths) {
                if (!segment) {
                    return;
                }
                var path;
                if (styles.fill0) {
                    path = fillPaths[styles.fill0 - 1];
                    // If fill0 is the only style, we have pushed the segment to its stack. In
                    // that case, just mark it as reversed and move on.
                    if (!(styles.fill1 || styles.line)) {
                        segment.isReversed = true;
                        return;
                    }
                    else {
                        path.addSegment(segment.toReversed());
                    }
                }
                if (styles.line && styles.fill1) {
                    path = linePaths[styles.line - 1];
                    path.addSegment(segment.clone());
                }
            }
            /*
             * Converts records from the space-optimized format they're stored in to a
             * format that's more amenable to fast rendering.
             *
             * See http://blogs.msdn.com/b/mswanson/archive/2006/02/27/539749.aspx and
             * http://wahlers.com.br/claus/blog/hacking-swf-1-shapes-in-flash/ for details.
             */
            function convertRecordsToShapeData(records, fillPaths, linePaths, dependencies, recordsMorph) {
                var isMorph = recordsMorph !== null;
                var styles = { fill0: 0, fill1: 0, line: 0 };
                var segment = null;
                // Fill- and line styles can be added by style change records in the middle of
                // a shape records list. This also causes the previous paths to be treated as
                // a group, so the lines don't get moved on top of any following fills.
                // To support this, we just append all current fill and line paths to a list
                // when new styles are introduced.
                var allPaths;
                // If no style is set for a segment of a path, a 1px transparent line is used.
                var defaultPath;
                var numRecords = records.length;
                var x = 0;
                var y = 0;
                var morphX = 0;
                var morphY = 0;
                var path;
                for (var i = 0, j = 0; i < numRecords; i++) {
                    var record = records[i];
                    var morphRecord = void 0;
                    if (isMorph) {
                        morphRecord = recordsMorph[j++];
                    }
                    // type 0 is a StyleChange record
                    if (record.type === 0) {
                        //TODO: make the `has*` fields bitflags
                        if (segment) {
                            applySegmentToStyles(segment, styles, linePaths, fillPaths);
                        }
                        if (record.flags & 16 /* HasNewStyles */) {
                            if (!allPaths) {
                                allPaths = [];
                            }
                            push.apply(allPaths, fillPaths);
                            fillPaths = createPathsList(record.fillStyles, false, isMorph, dependencies);
                            push.apply(allPaths, linePaths);
                            linePaths = createPathsList(record.lineStyles, true, isMorph, dependencies);
                            if (defaultPath) {
                                allPaths.push(defaultPath);
                                defaultPath = null;
                            }
                            styles = { fill0: 0, fill1: 0, line: 0 };
                        }
                        if ((record.flags & 2 /* HasFillStyle0 */) !== 0) {
                            styles.fill0 = record.fillStyle0;
                        }
                        if ((record.flags & 4 /* HasFillStyle1 */) !== 0) {
                            styles.fill1 = record.fillStyle1;
                        }
                        if ((record.flags & 8 /* HasLineStyle */) !== 0) {
                            styles.line = record.lineStyle;
                        }
                        if (styles.fill1) {
                            path = fillPaths[styles.fill1 - 1];
                        }
                        else if (styles.line) {
                            path = linePaths[styles.line - 1];
                        }
                        else if (styles.fill0) {
                            path = fillPaths[styles.fill0 - 1];
                        }
                        if (record.flags & 1 /* Move */) {
                            x = record.moveX | 0;
                            y = record.moveY | 0;
                            // When morphed, StyleChangeRecords/MoveTo might not have a
                            // corresponding record in the start or end shape --
                            // processing morphRecord below before converting type 1 records.
                        }
                        // Very first record can be just fill/line-style definition record.
                        if (path) {
                            segment = PathSegment.FromDefaults(isMorph);
                            path.addSegment(segment);
                            // Move or not, we want this path segment to start where the last one
                            // left off. Even if the last one belonged to a different style.
                            // "Huh," you say? Yup.
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            }
                            else {
                                if (morphRecord.type === 0) {
                                    morphX = morphRecord.moveX | 0;
                                    morphY = morphRecord.moveY | 0;
                                }
                                else {
                                    morphX = x;
                                    morphY = y;
                                    // Not all moveTos are reflected in morph data.
                                    // In that case, decrease morph data index.
                                    j--;
                                }
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                    }
                    else {
                        release || assert(record.type === 1);
                        if (!segment) {
                            if (!defaultPath) {
                                var style = { color: { red: 0, green: 0, blue: 0, alpha: 0 }, width: 20 };
                                defaultPath = new SegmentedPath(null, processStyle(style, true, isMorph, dependencies));
                            }
                            segment = PathSegment.FromDefaults(isMorph);
                            defaultPath.addSegment(segment);
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            }
                            else {
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                        if (isMorph) {
                            // An invalid SWF might contain a move in the EndEdges list where the
                            // StartEdges list contains an edge. The Flash Player seems to skip it,
                            // so we do, too.
                            while (morphRecord && morphRecord.type === 0) {
                                morphRecord = recordsMorph[j++];
                            }
                            // The EndEdges list might be shorter than the StartEdges list. Reuse
                            // start edges as end edges in that case.
                            if (!morphRecord) {
                                morphRecord = record;
                            }
                        }
                        if (record.flags & 32 /* IsStraight */ &&
                            (!isMorph || (morphRecord.flags & 32 /* IsStraight */) !== 0)) {
                            x += record.deltaX | 0;
                            y += record.deltaY | 0;
                            if (!isMorph) {
                                segment.lineTo(x, y);
                            }
                            else {
                                morphX += morphRecord.deltaX | 0;
                                morphY += morphRecord.deltaY | 0;
                                segment.morphLineTo(x, y, morphX, morphY);
                            }
                        }
                        else {
                            var cx = void 0, cy = void 0;
                            var deltaX = void 0, deltaY = void 0;
                            if ((record.flags & 32 /* IsStraight */) === 0) {
                                cx = x + record.controlDeltaX | 0;
                                cy = y + record.controlDeltaY | 0;
                                x = cx + record.anchorDeltaX | 0;
                                y = cy + record.anchorDeltaY | 0;
                            }
                            else {
                                deltaX = record.deltaX | 0;
                                deltaY = record.deltaY | 0;
                                cx = x + (deltaX >> 1);
                                cy = y + (deltaY >> 1);
                                x += deltaX;
                                y += deltaY;
                            }
                            if (!isMorph) {
                                segment.curveTo(cx, cy, x, y);
                            }
                            else {
                                var morphCX = void 0, morphCY = void 0;
                                if ((morphRecord.flags & 32 /* IsStraight */) === 0) {
                                    morphCX = morphX + morphRecord.controlDeltaX | 0;
                                    morphCY = morphY + morphRecord.controlDeltaY | 0;
                                    morphX = morphCX + morphRecord.anchorDeltaX | 0;
                                    morphY = morphCY + morphRecord.anchorDeltaY | 0;
                                }
                                else {
                                    deltaX = morphRecord.deltaX | 0;
                                    deltaY = morphRecord.deltaY | 0;
                                    morphCX = morphX + (deltaX >> 1);
                                    morphCY = morphY + (deltaY >> 1);
                                    morphX += deltaX;
                                    morphY += deltaY;
                                }
                                segment.morphCurveTo(cx, cy, x, y, morphCX, morphCY, morphX, morphY);
                            }
                        }
                    }
                }
                applySegmentToStyles(segment, styles, linePaths, fillPaths);
                // All current paths get appended to the allPaths list at the end. First fill,
                // then line paths.
                if (allPaths) {
                    push.apply(allPaths, fillPaths);
                }
                else {
                    allPaths = fillPaths;
                }
                push.apply(allPaths, linePaths);
                if (defaultPath) {
                    allPaths.push(defaultPath);
                }
                var shape = new ShapeData();
                if (isMorph) {
                    shape.morphCoordinates = new Int32Array(shape.coordinates.length);
                    shape.morphStyles = new DataBuffer(16);
                }
                for (var i = 0; i < allPaths.length; i++) {
                    allPaths[i].serialize(shape);
                }
                return shape;
            }
            var IDENTITY_MATRIX = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
            function processStyle(style, isLineStyle, isMorph, dependencies) {
                var shapeStyle = style;
                if (isMorph) {
                    shapeStyle.morph = processMorphStyle(style, isLineStyle, dependencies);
                }
                if (isLineStyle) {
                    shapeStyle.miterLimit = (style.miterLimitFactor || 1.5) * 2;
                    if (!style.color && style.hasFill) {
                        var fillStyle = processStyle(style.fillStyle, false, false, dependencies);
                        shapeStyle.type = fillStyle.type;
                        shapeStyle.transform = fillStyle.transform;
                        shapeStyle.colors = fillStyle.colors;
                        shapeStyle.ratios = fillStyle.ratios;
                        shapeStyle.focalPoint = fillStyle.focalPoint;
                        shapeStyle.bitmapId = fillStyle.bitmapId;
                        shapeStyle.bitmapIndex = fillStyle.bitmapIndex;
                        shapeStyle.repeat = fillStyle.repeat;
                        style.fillStyle = null;
                        return shapeStyle;
                    }
                    else {
                        shapeStyle.type = FillType.Solid;
                        return shapeStyle;
                    }
                }
                if (style.type === undefined || style.type === FillType.Solid) {
                    return shapeStyle;
                }
                var scale;
                switch (style.type) {
                    case FillType.LinearGradient:
                    case FillType.RadialGradient:
                    case FillType.FocalRadialGradient:
                        var records = style.records;
                        var colors = shapeStyle.colors = [];
                        var ratios = shapeStyle.ratios = [];
                        for (var i = 0; i < records.length; i++) {
                            var record = records[i];
                            colors.push(record.color);
                            ratios.push(record.ratio);
                        }
                        scale = 819.2;
                        break;
                    case FillType.RepeatingBitmap:
                    case FillType.ClippedBitmap:
                    case FillType.NonsmoothedRepeatingBitmap:
                    case FillType.NonsmoothedClippedBitmap:
                        shapeStyle.smooth = style.type !== FillType.NonsmoothedRepeatingBitmap &&
                            style.type !== FillType.NonsmoothedClippedBitmap;
                        shapeStyle.repeat = style.type !== FillType.ClippedBitmap &&
                            style.type !== FillType.NonsmoothedClippedBitmap;
                        var index = dependencies.indexOf(style.bitmapId);
                        if (index === -1) {
                            index = dependencies.length;
                            dependencies.push(style.bitmapId);
                        }
                        shapeStyle.bitmapIndex = index;
                        scale = 0.05;
                        break;
                    default:
                        Shumway.Debug.warning('shape parser encountered invalid fill style ' + style.type);
                }
                if (!style.matrix) {
                    shapeStyle.transform = IDENTITY_MATRIX;
                    return shapeStyle;
                }
                var matrix = style.matrix;
                shapeStyle.transform = {
                    a: (matrix.a * scale),
                    b: (matrix.b * scale),
                    c: (matrix.c * scale),
                    d: (matrix.d * scale),
                    tx: matrix.tx / 20,
                    ty: matrix.ty / 20
                };
                // null data that's unused from here on out
                style.matrix = null;
                return shapeStyle;
            }
            function processMorphStyle(style, isLineStyle, dependencies) {
                var morphStyle = Object.create(style);
                if (isLineStyle) {
                    morphStyle.width = style.widthMorph;
                    if (!style.color && style.hasFill) {
                        var fillStyle = processMorphStyle(style.fillStyle, false, dependencies);
                        morphStyle.transform = fillStyle.transform;
                        morphStyle.colors = fillStyle.colors;
                        morphStyle.ratios = fillStyle.ratios;
                        return morphStyle;
                    }
                    else {
                        morphStyle.color = style.colorMorph;
                        return morphStyle;
                    }
                }
                if (style.type === undefined) {
                    return morphStyle;
                }
                if (style.type === FillType.Solid) {
                    morphStyle.color = style.colorMorph;
                    return morphStyle;
                }
                var scale;
                switch (style.type) {
                    case FillType.LinearGradient:
                    case FillType.RadialGradient:
                    case FillType.FocalRadialGradient:
                        var records = style.records;
                        var colors = morphStyle.colors = [];
                        var ratios = morphStyle.ratios = [];
                        for (var i = 0; i < records.length; i++) {
                            var record = records[i];
                            colors.push(record.colorMorph);
                            ratios.push(record.ratioMorph);
                        }
                        scale = 819.2;
                        break;
                    case FillType.RepeatingBitmap:
                    case FillType.ClippedBitmap:
                    case FillType.NonsmoothedRepeatingBitmap:
                    case FillType.NonsmoothedClippedBitmap:
                        scale = 0.05;
                        break;
                    default:
                        release || assertUnreachable('shape parser encountered invalid fill style');
                }
                if (!style.matrix) {
                    morphStyle.transform = IDENTITY_MATRIX;
                    return morphStyle;
                }
                var matrix = style.matrixMorph;
                morphStyle.transform = {
                    a: (matrix.a * scale),
                    b: (matrix.b * scale),
                    c: (matrix.c * scale),
                    d: (matrix.d * scale),
                    tx: matrix.tx / 20,
                    ty: matrix.ty / 20
                };
                return morphStyle;
            }
            /*
             * Paths are stored in 2-dimensional arrays. Each of the inner arrays contains
             * all the paths for a certain fill or line style.
             */
            function createPathsList(styles, isLineStyle, isMorph, dependencies) {
                var paths = [];
                for (var i = 0; i < styles.length; i++) {
                    var style = processStyle(styles[i], isLineStyle, isMorph, dependencies);
                    if (!isLineStyle) {
                        paths[i] = new SegmentedPath(style, null);
                    }
                    else {
                        paths[i] = new SegmentedPath(null, style);
                    }
                }
                return paths;
            }
            function defineShape(tag) {
                var dependencies = [];
                var fillPaths = createPathsList(tag.fillStyles, false, !!tag.recordsMorph, dependencies);
                var linePaths = createPathsList(tag.lineStyles, true, !!tag.recordsMorph, dependencies);
                var shape = convertRecordsToShapeData(tag.records, fillPaths, linePaths, dependencies, tag.recordsMorph || null);
                return {
                    type: tag.flags & 8 /* IsMorph */ ? 'morphshape' : 'shape',
                    id: tag.id,
                    fillBounds: tag.fillBounds,
                    lineBounds: tag.lineBounds,
                    morphFillBounds: tag.fillBoundsMorph || null,
                    morphLineBounds: tag.lineBoundsMorph || null,
                    shape: shape.toPlainObject(),
                    transferables: shape.buffers,
                    require: dependencies.length ? dependencies : null
                };
            }
            Parser.defineShape = defineShape;
            var PathSegment = /** @class */ (function () {
                function PathSegment(commands, data, morphData, prev, next, isReversed) {
                    this.commands = commands;
                    this.data = data;
                    this.morphData = morphData;
                    this.prev = prev;
                    this.next = next;
                    this.isReversed = isReversed;
                    this.id = PathSegment._counter++;
                }
                PathSegment.FromDefaults = function (isMorph) {
                    var commands = new DataBuffer();
                    var data = new DataBuffer();
                    commands.endian = data.endian = 'auto';
                    var morphData = null;
                    if (isMorph) {
                        morphData = new DataBuffer();
                        morphData.endian = 'auto';
                    }
                    return new PathSegment(commands, data, morphData, null, null, false);
                };
                PathSegment.prototype.moveTo = function (x, y) {
                    this.commands.writeUnsignedByte(9 /* MoveTo */);
                    this.data.write2Ints(x, y);
                };
                PathSegment.prototype.morphMoveTo = function (x, y, mx, my) {
                    this.moveTo(x, y);
                    this.morphData.write2Ints(mx, my);
                };
                PathSegment.prototype.lineTo = function (x, y) {
                    this.commands.writeUnsignedByte(10 /* LineTo */);
                    this.data.write2Ints(x, y);
                };
                PathSegment.prototype.morphLineTo = function (x, y, mx, my) {
                    this.lineTo(x, y);
                    this.morphData.write2Ints(mx, my);
                };
                PathSegment.prototype.curveTo = function (cpx, cpy, x, y) {
                    this.commands.writeUnsignedByte(11 /* CurveTo */);
                    this.data.write4Ints(cpx, cpy, x, y);
                };
                PathSegment.prototype.morphCurveTo = function (cpx, cpy, x, y, mcpx, mcpy, mx, my) {
                    this.curveTo(cpx, cpy, x, y);
                    this.morphData.write4Ints(mcpx, mcpy, mx, my);
                };
                /**
                 * Returns a shallow copy of the segment with the "isReversed" flag set.
                 * Reversed segments play themselves back in reverse when they're merged into the final
                 * non-segmented path.
                 * Note: Don't modify the original, or the reversed copy, after this operation!
                 */
                PathSegment.prototype.toReversed = function () {
                    release || assert(!this.isReversed);
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, true);
                };
                PathSegment.prototype.clone = function () {
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, this.isReversed);
                };
                PathSegment.prototype.storeStartAndEnd = function () {
                    var data = this.data.ints;
                    var endPoint1 = data[0] + ',' + data[1];
                    var endPoint2Offset = (this.data.length >> 2) - 2;
                    var endPoint2 = data[endPoint2Offset] + ',' + data[endPoint2Offset + 1];
                    if (!this.isReversed) {
                        this.startPoint = endPoint1;
                        this.endPoint = endPoint2;
                    }
                    else {
                        this.startPoint = endPoint2;
                        this.endPoint = endPoint1;
                    }
                };
                PathSegment.prototype.connectsTo = function (other) {
                    release || assert(other !== this);
                    release || assert(this.endPoint);
                    release || assert(other.startPoint);
                    return this.endPoint === other.startPoint;
                };
                PathSegment.prototype.startConnectsTo = function (other) {
                    release || assert(other !== this);
                    return this.startPoint === other.startPoint;
                };
                PathSegment.prototype.flipDirection = function () {
                    var tempPoint = "";
                    tempPoint = this.startPoint;
                    this.startPoint = this.endPoint;
                    this.endPoint = tempPoint;
                    this.isReversed = !this.isReversed;
                };
                PathSegment.prototype.serialize = function (shape, lastPosition) {
                    if (this.isReversed) {
                        this._serializeReversed(shape, lastPosition);
                        return;
                    }
                    var commands = this.commands.bytes;
                    // Note: this *must* use `this.data.length`, because buffers will have padding.
                    var dataLength = this.data.length >> 2;
                    var morphData = this.morphData ? this.morphData.ints : null;
                    var data = this.data.ints;
                    release || assert(commands[0] === 9 /* MoveTo */);
                    // If the segment's first moveTo goes to the current coordinates, we have to skip it.
                    var offset = 0;
                    if (data[0] === lastPosition.x && data[1] === lastPosition.y) {
                        offset++;
                    }
                    var commandsCount = this.commands.length;
                    var dataPosition = offset * 2;
                    for (var i = offset; i < commandsCount; i++) {
                        dataPosition = this._writeCommand(commands[i], dataPosition, data, morphData, shape);
                    }
                    release || assert(dataPosition === dataLength);
                    lastPosition.x = data[dataLength - 2];
                    lastPosition.y = data[dataLength - 1];
                };
                PathSegment.prototype._serializeReversed = function (shape, lastPosition) {
                    // For reversing the fill0 segments, we rely on the fact that each segment
                    // starts with a moveTo. We first write a new moveTo with the final drawing command's
                    // target coordinates (if we don't skip it, see below). For each of the following
                    // commands, we take the coordinates of the command originally *preceding*
                    // it as the new target coordinates. The final coordinates we target will be
                    // the ones from the original first moveTo.
                    // Note: these *must* use `this.{data,commands}.length`, because buffers will have padding.
                    var commandsCount = this.commands.length;
                    var dataPosition = (this.data.length >> 2) - 2;
                    var commands = this.commands.bytes;
                    release || assert(commands[0] === 9 /* MoveTo */);
                    var data = this.data.ints;
                    var morphData = this.morphData ? this.morphData.ints : null;
                    // Only write the first moveTo if it doesn't go to the current coordinates.
                    if (data[dataPosition] !== lastPosition.x || data[dataPosition + 1] !== lastPosition.y) {
                        this._writeCommand(9 /* MoveTo */, dataPosition, data, morphData, shape);
                    }
                    if (commandsCount === 1) {
                        lastPosition.x = data[0];
                        lastPosition.y = data[1];
                        return;
                    }
                    for (var i = commandsCount; i-- > 1;) {
                        dataPosition -= 2;
                        var command = commands[i];
                        shape.writeCommandAndCoordinates(command, data[dataPosition], data[dataPosition + 1]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                        }
                        if (command === 11 /* CurveTo */) {
                            dataPosition -= 2;
                            shape.writeCoordinates(data[dataPosition], data[dataPosition + 1]);
                            if (morphData) {
                                shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                            }
                        }
                        else {
                        }
                    }
                    release || assert(dataPosition === 0);
                    lastPosition.x = data[0];
                    lastPosition.y = data[1];
                };
                PathSegment.prototype._writeCommand = function (command, position, data, morphData, shape) {
                    shape.writeCommandAndCoordinates(command, data[position++], data[position++]);
                    if (morphData) {
                        shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                    }
                    if (command === 11 /* CurveTo */) {
                        shape.writeCoordinates(data[position++], data[position++]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                        }
                    }
                    return position;
                };
                PathSegment._counter = 0;
                return PathSegment;
            }());
            var SegmentedPath = /** @class */ (function () {
                function SegmentedPath(fillStyle, lineStyle) {
                    this.fillStyle = fillStyle;
                    this.lineStyle = lineStyle;
                    this._head = null;
                }
                SegmentedPath.prototype.addSegment = function (segment) {
                    release || assert(segment);
                    release || assert(segment.next === null);
                    release || assert(segment.prev === null);
                    var currentHead = this._head;
                    if (currentHead) {
                        release || assert(segment !== currentHead);
                        currentHead.next = segment;
                        segment.prev = currentHead;
                    }
                    this._head = segment;
                };
                // Does *not* reset the segment's prev and next pointers!
                SegmentedPath.prototype.removeSegment = function (segment) {
                    if (segment.prev) {
                        segment.prev.next = segment.next;
                    }
                    if (segment.next) {
                        segment.next.prev = segment.prev;
                    }
                };
                SegmentedPath.prototype.insertSegment = function (segment, next) {
                    var prev = next.prev;
                    segment.prev = prev;
                    segment.next = next;
                    if (prev) {
                        prev.next = segment;
                    }
                    next.prev = segment;
                };
                SegmentedPath.prototype.head = function () {
                    return this._head;
                };
                SegmentedPath.prototype.serialize = function (shape) {
                    var segment = this.head();
                    if (!segment) {
                        // Path is empty.
                        return null;
                    }
                    while (segment) {
                        segment.storeStartAndEnd();
                        segment = segment.prev;
                    }
                    var start = this.head();
                    var end = start;
                    var finalRoot = null;
                    var finalHead = null;
                    // Path segments for one style can appear in arbitrary order in the tag's list
                    // of edge records.
                    // Before we linearize them, we have to identify all pairs of segments where
                    // one ends at a coordinate the other starts at.
                    // The following loop does that, by creating ever-growing runs of matching
                    // segments. If no more segments are found that match the current run (either
                    // at the beginning, or at the end), the current run is complete, and a new
                    // one is started. Rinse, repeat, until no solitary segments remain.
                    var current = start.prev;
                    while (start) {
                        while (current) {
                            if (current.startConnectsTo(start)) {
                                current.flipDirection();
                            }
                            if (current.connectsTo(start)) {
                                if (current.next !== start) {
                                    this.removeSegment(current);
                                    this.insertSegment(current, start);
                                }
                                start = current;
                                current = start.prev;
                                continue;
                            }
                            if (current.startConnectsTo(end)) {
                                current.flipDirection();
                            }
                            if (end.connectsTo(current)) {
                                this.removeSegment(current);
                                end.next = current;
                                current = current.prev;
                                end.next.prev = end;
                                end.next.next = null;
                                end = end.next;
                                continue;
                            }
                            current = current.prev;
                        }
                        // This run of segments is finished. Store and forget it (for this loop).
                        current = start.prev;
                        if (!finalRoot) {
                            finalRoot = start;
                            finalHead = end;
                        }
                        else {
                            finalHead.next = start;
                            start.prev = finalHead;
                            finalHead = end;
                            finalHead.next = null;
                        }
                        if (!current) {
                            break;
                        }
                        start = end = current;
                        current = start.prev;
                    }
                    if (this.fillStyle) {
                        var style = this.fillStyle;
                        var morph = style.morph;
                        switch (style.type) {
                            case FillType.Solid:
                                shape.beginFill(style.color);
                                if (morph) {
                                    shape.writeMorphFill(morph.color);
                                }
                                break;
                            case FillType.LinearGradient:
                            case FillType.RadialGradient:
                            case FillType.FocalRadialGradient:
                                writeGradient(2 /* BeginGradientFill */, style, shape);
                                if (morph) {
                                    writeMorphGradient(morph, shape);
                                }
                                break;
                            case FillType.ClippedBitmap:
                            case FillType.RepeatingBitmap:
                            case FillType.NonsmoothedClippedBitmap:
                            case FillType.NonsmoothedRepeatingBitmap:
                                writeBitmap(3 /* BeginBitmapFill */, style, shape);
                                if (morph) {
                                    writeMorphBitmap(morph, shape);
                                }
                                break;
                            default:
                                release || assertUnreachable('Invalid fill style type: ' + style.type);
                        }
                    }
                    else {
                        var style = this.lineStyle;
                        var morph = style.morph;
                        release || assert(style);
                        switch (style.type) {
                            case FillType.Solid:
                                writeLineStyle(style, shape);
                                if (morph) {
                                    writeMorphLineStyle(morph, shape);
                                }
                                break;
                            case FillType.LinearGradient:
                            case FillType.RadialGradient:
                            case FillType.FocalRadialGradient:
                                writeLineStyle(style, shape);
                                writeGradient(6 /* LineStyleGradient */, style, shape);
                                if (morph) {
                                    writeMorphLineStyle(morph, shape);
                                    writeMorphGradient(morph, shape);
                                }
                                break;
                            case FillType.ClippedBitmap:
                            case FillType.RepeatingBitmap:
                            case FillType.NonsmoothedClippedBitmap:
                            case FillType.NonsmoothedRepeatingBitmap:
                                writeLineStyle(style, shape);
                                writeBitmap(7 /* LineStyleBitmap */, style, shape);
                                if (morph) {
                                    writeMorphLineStyle(morph, shape);
                                    writeMorphBitmap(morph, shape);
                                }
                                break;
                            default:
                        }
                    }
                    var lastPosition = { x: 0, y: 0 };
                    current = finalRoot;
                    while (current) {
                        current.serialize(shape, lastPosition);
                        current = current.next;
                    }
                    if (this.fillStyle) {
                        shape.endFill();
                    }
                    else {
                        shape.endLine();
                    }
                    return shape;
                };
                return SegmentedPath;
            }());
            function writeLineStyle(style, shape) {
                // No scaling == 0, normal == 1, vertical only == 2, horizontal only == 3.
                var scaleMode = style.noHscale ?
                    (style.noVscale ? 0 : 2) :
                    style.noVscale ? 3 : 1;
                // TODO: Figure out how to handle startCapsStyle
                var thickness = clamp(style.width, 0, 0xff * 20) | 0;
                shape.lineStyle(thickness, style.color, style.pixelHinting, scaleMode, style.endCapsStyle, style.jointStyle, style.miterLimit);
            }
            function writeMorphLineStyle(style, shape) {
                // TODO: Figure out how to handle startCapsStyle
                var thickness = clamp(style.width, 0, 0xff * 20) | 0;
                shape.writeMorphLineStyle(thickness, style.color);
            }
            function writeGradient(command, style, shape) {
                var gradientType = style.type === FillType.LinearGradient ?
                    16 /* Linear */ :
                    18 /* Radial */;
                shape.beginGradient(command, style.colors, style.ratios, gradientType, style.transform, style.spreadMethod, style.interpolationMode, style.focalPoint / 2 | 0);
            }
            function writeMorphGradient(style, shape) {
                shape.writeMorphGradient(style.colors, style.ratios, style.transform);
            }
            function writeBitmap(command, style, shape) {
                shape.beginBitmap(command, style.bitmapIndex, style.transform, style.repeat, style.smooth);
            }
            function writeMorphBitmap(style, shape) {
                shape.writeMorphBitmap(style.transform);
            }
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var SOUND_SIZE_8_BIT = 0;
            var SOUND_SIZE_16_BIT = 1;
            var SOUND_TYPE_MONO = 0;
            var SOUND_TYPE_STEREO = 1;
            var SOUND_FORMAT_PCM_BE = 0;
            var SOUND_FORMAT_ADPCM = 1;
            var SOUND_FORMAT_MP3 = 2;
            var SOUND_FORMAT_PCM_LE = 3;
            var SOUND_FORMAT_NELLYMOSER_16 = 4;
            var SOUND_FORMAT_NELLYMOSER_8 = 5;
            var SOUND_FORMAT_NELLYMOSER = 6;
            var SOUND_FORMAT_SPEEX = 11;
            var SOUND_RATES = [5512, 11250, 22500, 44100];
            var WaveHeader = new Uint8Array([0x52, 0x49, 0x46, 0x46, 0x00, 0x00, 0x00, 0x00,
                0x57, 0x41, 0x56, 0x45, 0x66, 0x6D, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00,
                0x01, 0x00, 0x02, 0x00, 0x44, 0xAC, 0x00, 0x00, 0x10, 0xB1, 0x02, 0x00,
                0x04, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00]);
            function packageWave(data, sampleRate, channels, size, swapBytes) {
                var sizeInBytes = size >> 3;
                var sizePerSecond = channels * sampleRate * sizeInBytes;
                var sizePerSample = channels * sizeInBytes;
                var dataLength = data.length + (data.length & 1);
                var buffer = new ArrayBuffer(WaveHeader.length + dataLength);
                var bytes = new Uint8Array(buffer);
                bytes.set(WaveHeader);
                if (swapBytes) {
                    for (var i = 0, j = WaveHeader.length; i < data.length; i += 2, j += 2) {
                        bytes[j] = data[i + 1];
                        bytes[j + 1] = data[i];
                    }
                }
                else {
                    bytes.set(data, WaveHeader.length);
                }
                var view = new DataView(buffer);
                view.setUint32(4, dataLength + 36, true);
                view.setUint16(22, channels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sizePerSecond, true);
                view.setUint16(32, sizePerSample, true);
                view.setUint16(34, size, true);
                view.setUint32(40, dataLength, true);
                return {
                    data: bytes,
                    mimeType: 'audio/wav'
                };
            }
            function defineSound(tag) {
                var channels = tag.soundType == SOUND_TYPE_STEREO ? 2 : 1;
                var samplesCount = tag.samplesCount;
                var sampleRate = SOUND_RATES[tag.soundRate];
                var data = tag.soundData;
                var pcm, packaged;
                switch (tag.soundFormat) {
                    case SOUND_FORMAT_PCM_BE:
                        pcm = new Float32Array(samplesCount * channels);
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                                pcm[i] = ((data[j] << 24) | (data[j + 1] << 16)) / 2147483648;
                            packaged = packageWave(data, sampleRate, channels, 16, true);
                        }
                        else {
                            for (var i = 0; i < pcm.length; i++)
                                pcm[i] = (data[i] - 128) / 128;
                            packaged = packageWave(data, sampleRate, channels, 8, false);
                        }
                        break;
                    case SOUND_FORMAT_PCM_LE:
                        pcm = new Float32Array(samplesCount * channels);
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                                pcm[i] = ((data[j + 1] << 24) | (data[j] << 16)) / 2147483648;
                            packaged = packageWave(data, sampleRate, channels, 16, false);
                        }
                        else {
                            for (var i = 0; i < pcm.length; i++)
                                pcm[i] = (data[i] - 128) / 128;
                            packaged = packageWave(data, sampleRate, channels, 8, false);
                        }
                        break;
                    case SOUND_FORMAT_MP3:
                        packaged = {
                            data: new Uint8Array(data.subarray(2)),
                            mimeType: 'audio/mpeg'
                        };
                        break;
                    case SOUND_FORMAT_ADPCM:
                        var pcm16 = new Int16Array(samplesCount * channels);
                        decodeACPCMSoundData(data, pcm16, channels);
                        pcm = new Float32Array(samplesCount * channels);
                        for (var i = 0; i < pcm.length; i++)
                            pcm[i] = pcm16[i] / 32768;
                        packaged = packageWave(new Uint8Array(pcm16.buffer), sampleRate, channels, 16, !(new Uint8Array(new Uint16Array([1]).buffer))[0]);
                        break;
                    default:
                        Shumway.Debug.warning('Unsupported audio format: ' + tag.soundFormat);
                }
                var sound = {
                    type: 'sound',
                    id: tag.id,
                    sampleRate: sampleRate,
                    channels: channels,
                    pcm: pcm,
                    packaged: null
                };
                if (packaged) {
                    sound.packaged = packaged;
                }
                return sound;
            }
            Parser.defineSound = defineSound;
            var ACPCMIndexTables = [
                [-1, 2],
                [-1, -1, 2, 4],
                [-1, -1, -1, -1, 2, 4, 6, 8],
                [-1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 4, 6, 8, 10, 13, 16]
            ];
            var ACPCMStepSizeTable = [
                7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
                50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230,
                253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,
                1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327,
                3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487,
                12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
            ];
            function decodeACPCMSoundData(data, pcm16, channels) {
                function readBits(n) {
                    while (dataBufferLength < n) {
                        dataBuffer = (dataBuffer << 8) | data[dataPosition++];
                        dataBufferLength += 8;
                    }
                    dataBufferLength -= n;
                    return (dataBuffer >>> dataBufferLength) & ((1 << n) - 1);
                }
                var dataPosition = 0;
                var dataBuffer = 0;
                var dataBufferLength = 0;
                var pcmPosition = 0;
                var codeSize = readBits(2);
                var indexTable = ACPCMIndexTables[codeSize];
                while (pcmPosition < pcm16.length) {
                    var x = pcm16[pcmPosition++] = (readBits(16) << 16) >> 16, x2 = void 0;
                    var stepIndex = readBits(6), stepIndex2 = void 0;
                    if (channels > 1) {
                        x2 = pcm16[pcmPosition++] = (readBits(16) << 16) >> 16;
                        stepIndex2 = readBits(6);
                    }
                    var signMask = 1 << (codeSize + 1);
                    for (var i = 0; i < 4095; i++) {
                        var nibble = readBits(codeSize + 2);
                        var step = ACPCMStepSizeTable[stepIndex];
                        var sum = 0;
                        for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                            if (nibble & currentBit)
                                sum += step;
                        }
                        x += (nibble & signMask ? -1 : 1) * (sum + step);
                        pcm16[pcmPosition++] = (x = (x < -32768 ? -32768 : x > 32767 ? 32767 : x));
                        stepIndex += indexTable[nibble & ~signMask];
                        stepIndex = stepIndex < 0 ? 0 : stepIndex > 88 ? 88 : stepIndex;
                        if (channels > 1) {
                            nibble = readBits(codeSize + 2);
                            step = ACPCMStepSizeTable[stepIndex2];
                            sum = 0;
                            for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                                if (nibble & currentBit)
                                    sum += step;
                            }
                            x2 += (nibble & signMask ? -1 : 1) * (sum + step);
                            pcm16[pcmPosition++] = (x2 = (x2 < -32768 ? -32768 : x2 > 32767 ? 32767 : x2));
                            stepIndex2 += indexTable[nibble & ~signMask];
                            stepIndex2 = stepIndex2 < 0 ? 0 : stepIndex2 > 88 ? 88 : stepIndex2;
                        }
                    }
                }
            }
            var nextSoundStreamId = 0;
            var SoundStream = /** @class */ (function () {
                function SoundStream(samplesCount, sampleRate, channels) {
                    this.streamId = (nextSoundStreamId++);
                    this.samplesCount = samplesCount;
                    this.sampleRate = sampleRate;
                    this.channels = channels;
                    this.format = null;
                    this.currentSample = 0;
                }
                SoundStream.FromTag = function (tag) {
                    var channels = tag.streamType == SOUND_TYPE_STEREO ? 2 : 1;
                    var samplesCount = tag.samplesCount;
                    var sampleRate = SOUND_RATES[tag.streamRate];
                    var stream = new SoundStream(samplesCount, sampleRate, channels);
                    switch (tag.streamCompression) {
                        case SOUND_FORMAT_PCM_BE:
                        case SOUND_FORMAT_PCM_LE:
                            stream.format = 'wave';
                            if (tag.soundSize == SOUND_SIZE_16_BIT) {
                                stream.decode = tag.streamCompression === SOUND_FORMAT_PCM_BE ?
                                    SwfSoundStream_decode_PCM_be :
                                    SwfSoundStream_decode_PCM_le;
                            }
                            else {
                                stream.decode = SwfSoundStream_decode_PCM;
                            }
                            break;
                        case SOUND_FORMAT_MP3:
                            stream.format = 'mp3';
                            stream.decode = SwfSoundStream_decode_MP3;
                            break;
                        default:
                            Shumway.Debug.warning('Unsupported audio stream format: ' + tag.streamCompression);
                            return null;
                    }
                    return stream;
                };
                return SoundStream;
            }());
            Parser.SoundStream = SoundStream;
            function SwfSoundStream_decode_PCM(data) {
                var pcm = new Float32Array(data.length);
                for (var i = 0; i < pcm.length; i++)
                    pcm[i] = (data[i] - 128) / 128;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_PCM_be(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = ((data[j] << 24) | (data[j + 1] << 16)) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_PCM_le(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = ((data[j + 1] << 24) | (data[j] << 16)) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_MP3(data) {
                var samplesCount = (data[1] << 8) | data[0];
                var seek = (data[3] << 8) | data[2];
                this.currentSample += samplesCount;
                return {
                    streamId: this.streamId,
                    samplesCount: samplesCount,
                    data: new Uint8Array(data.subarray(4)),
                    seek: seek
                };
            }
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            function defineText(tag) {
                var bold = false;
                var italic = false;
                return {
                    type: 'text',
                    id: tag.id,
                    fillBounds: tag.bbox,
                    variableName: tag.variableName,
                    tag: tag,
                    bold: bold,
                    italic: italic
                };
            }
            Parser.defineText = defineText;
        })(Parser = SWF.Parser || (SWF.Parser = {}));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='../references.ts' />
///<reference path='module.ts' />
///<reference path='bitmap.ts' />
///<reference path='button.ts' />
///<reference path='font.ts' />
///<reference path='image.ts' />
///<reference path='label.ts' />
///<reference path='shape.ts' />
///<reference path='sound.ts' />
///<reference path='text.ts' />
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        SWF.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer("Parser") : null;
        function enterTimeline(name, data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.enter(name, data);
        }
        SWF.enterTimeline = enterTimeline;
        function leaveTimeline(data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.leave(null, data);
        }
        SWF.leaveTimeline = leaveTimeline;
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        SWF.parserOptions = shumwayOptions.register(new OptionSet("Parser Options"));
        SWF.traceLevel = SWF.parserOptions.register(new Option("parsertracelevel", "Parser Trace Level", "number", 0, "Parser Trace Level"));
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        SWF.StreamNoDataError = {};
        var masks = new Uint32Array(33);
        for (var i = 1, mask = 0; i <= 32; ++i) {
            masks[i] = mask = (mask << 1) | 1;
        }
        var Stream = /** @class */ (function () {
            function Stream(buffer, offset, length, maxLength) {
                if (offset === undefined)
                    offset = 0;
                if (buffer.buffer instanceof ArrayBuffer) {
                    offset += buffer.byteOffset;
                    buffer = buffer.buffer;
                }
                if (length === undefined)
                    length = buffer.byteLength - offset;
                if (maxLength === undefined)
                    maxLength = length;
                this.bytes = new Uint8Array(buffer, offset, maxLength);
                this.view = new DataView(buffer, offset, maxLength);
                this.pos = 0;
                this.end = length;
                this.bitBuffer = 0;
                this.bitLength = 0;
            }
            Stream.prototype.align = function () {
                this.bitBuffer = this.bitLength = 0;
            };
            Stream.prototype.ensure = function (size) {
                if (this.pos + size > this.end) {
                    throw SWF.StreamNoDataError;
                }
            };
            Stream.prototype.remaining = function () {
                return this.end - this.pos;
            };
            Stream.prototype.substream = function (begin, end) {
                var stream = new Stream(this.bytes);
                stream.pos = begin;
                stream.end = end;
                return stream;
            };
            Stream.prototype.push = function (data) {
                var bytes = this.bytes;
                var newBytesLength = this.end + data.length;
                if (newBytesLength > bytes.length) {
                    throw 'stream buffer overfow';
                }
                bytes.set(data, this.end);
                this.end = newBytesLength;
            };
            Stream.prototype.readSi8 = function () {
                return this.view.getInt8(this.pos++);
            };
            Stream.prototype.readSi16 = function () {
                var r = this.view.getInt16(this.pos, true);
                this.pos += 2;
                return r;
            };
            Stream.prototype.readSi32 = function () {
                var r = this.view.getInt32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readUi8 = function () {
                return this.bytes[this.pos++];
            };
            Stream.prototype.readUi16 = function () {
                var r = this.view.getUint16(this.pos, true);
                this.pos += 2;
                return r;
            };
            Stream.prototype.readUi32 = function () {
                var r = this.view.getUint32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readFixed = function () {
                var r = this.view.getInt32(this.pos, true) / 65536;
                this.pos += 4;
                return r;
            };
            Stream.prototype.readFixed8 = function () {
                var r = this.view.getInt16(this.pos, true) / 256;
                this.pos += 2;
                return r;
            };
            Stream.prototype.readFloat16 = function () {
                var ui16 = this.view.getUint16(this.pos, false);
                this.pos += 2;
                var sign = ui16 >> 15 ? -1 : 1;
                var exponent = (ui16 & 0x7c00) >> 10;
                var fraction = ui16 & 0x03ff;
                if (!exponent)
                    return sign * Math.pow(2, -14) * (fraction / 1024);
                if (exponent === 0x1f)
                    return fraction ? NaN : sign * Infinity;
                return sign * Math.pow(2, exponent - 15) * (1 + (fraction / 1024));
            };
            Stream.prototype.readFloat = function () {
                var r = this.view.getFloat32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readDouble = function () {
                var r = this.view.getFloat64(this.pos, true);
                this.pos += 8;
                return r;
            };
            Stream.prototype.readEncodedU32 = function () {
                var bytes = this.bytes;
                var val = bytes[this.pos++];
                if (!(val & 0x080))
                    return val;
                val = (val & 0x7f) | bytes[this.pos++] << 7;
                if (!(val & 0x4000))
                    return val;
                val = (val & 0x3fff) | bytes[this.pos++] << 14;
                if (!(val & 0x200000))
                    return val;
                val = (val & 0x1FFFFF) | bytes[this.pos++] << 21;
                if (!(val & 0x10000000))
                    return val;
                return (val & 0xFFFFFFF) | (bytes[this.pos++] << 28);
            };
            Stream.prototype.readBool = function () {
                return !!this.bytes[this.pos++];
            };
            Stream.prototype.readSb = function (size) {
                return (this.readUb(size) << (32 - size)) >> (32 - size);
            };
            Stream.prototype.readUb = function (size) {
                var buffer = this.bitBuffer;
                var bitlen = this.bitLength;
                var val = 0;
                while (size > bitlen) {
                    if (bitlen > 24) {
                        // Avoid overflow. Save current buffer in val and add remaining bits later.
                        size -= bitlen;
                        val = buffer << size;
                        bitlen = 0;
                    }
                    buffer = (buffer << 8) | this.bytes[this.pos++];
                    bitlen += 8;
                }
                bitlen -= size;
                val |= (buffer >>> bitlen) & masks[size];
                this.bitBuffer = buffer;
                this.bitLength = bitlen;
                return val;
            };
            Stream.prototype.readFb = function (size) {
                return this.readSb(size) / 65536;
            };
            Stream.prototype.readString = function (length) {
                var bytes = this.bytes;
                var codes;
                var pos = this.pos;
                if (length > -1) {
                    codes = bytes.subarray(pos, pos += length);
                }
                else {
                    length = 0;
                    for (var i = pos; bytes[i]; i++) {
                        length++;
                    }
                    codes = bytes.subarray(pos, pos += length);
                    pos++;
                }
                this.pos = pos;
                var str = Shumway.StringUtilities.utf8encode(codes);
                if (str.indexOf('\0') >= 0) {
                    str = str.split('\0').join('');
                }
                return str;
            };
            return Stream;
        }());
        SWF.Stream = Stream;
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        SWF.MP3WORKER_PATH = '../../lib/mp3/mp3worker.js';
        var mp3Worker = null;
        function ensureMP3Worker() {
            if (!mp3Worker) {
                mp3Worker = new Worker(SWF.MP3WORKER_PATH);
                mp3Worker.addEventListener('message', function (e) {
                    if (e.data.action === 'console') {
                        console[e.data.method].call(console, e.data.message);
                    }
                });
            }
            return mp3Worker;
        }
        var nextSessionId = 0;
        var MP3DecoderSession = /** @class */ (function () {
            function MP3DecoderSession() {
                this._sessionId = (nextSessionId++);
                this._onworkermessageBound = this.onworkermessage.bind(this);
                this._worker = ensureMP3Worker();
                this._worker.addEventListener('message', this._onworkermessageBound, false);
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'create'
                });
            }
            MP3DecoderSession.prototype.onworkermessage = function (e) {
                if (e.data.sessionId !== this._sessionId)
                    return;
                var action = e.data.action;
                switch (action) {
                    case 'closed':
                        if (this.onclosed) {
                            this.onclosed();
                        }
                        this._worker.removeEventListener('message', this._onworkermessageBound, false);
                        this._worker = null;
                        break;
                    case 'frame':
                        this.onframedata(e.data.frameData, e.data.channels, e.data.sampleRate, e.data.bitRate);
                        break;
                    case 'id3':
                        if (this.onid3tag) {
                            this.onid3tag(e.data.id3Data);
                        }
                        break;
                    case 'error':
                        if (this.onerror) {
                            this.onerror(e.data.message);
                        }
                        break;
                }
            };
            MP3DecoderSession.prototype.pushAsync = function (data) {
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'decode',
                    data: data
                });
            };
            MP3DecoderSession.prototype.close = function () {
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'close'
                });
            };
            MP3DecoderSession.processAll = function (data) {
                var currentBufferSize = 8000;
                var currentBuffer = new Float32Array(currentBufferSize);
                var bufferPosition = 0;
                var id3Tags = [];
                var sessionAborted = false;
                var promiseWrapper = new Shumway.PromiseWrapper();
                var session = new MP3DecoderSession();
                session.onframedata = function (frameData, channels, sampleRate, bitRate) {
                    var needed = frameData.length + bufferPosition;
                    if (needed > currentBufferSize) {
                        do {
                            currentBufferSize *= 2;
                        } while (needed > currentBufferSize);
                        var newBuffer = new Float32Array(currentBufferSize);
                        newBuffer.set(currentBuffer);
                        currentBuffer = newBuffer;
                    }
                    currentBuffer.set(frameData, bufferPosition);
                    bufferPosition += frameData.length;
                };
                session.onid3tag = function (tagData) {
                    id3Tags.push(tagData);
                };
                session.onclosed = function () {
                    if (sessionAborted)
                        return;
                    promiseWrapper.resolve({ data: currentBuffer.subarray(0, bufferPosition), id3Tags: id3Tags });
                };
                session.onerror = function (error) {
                    if (sessionAborted)
                        return;
                    sessionAborted = true;
                    promiseWrapper.reject(error);
                };
                session.pushAsync(data);
                session.close();
                return promiseWrapper.promise;
            };
            return MP3DecoderSession;
        }());
        SWF.MP3DecoderSession = MP3DecoderSession;
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var assert = Shumway.Debug.assert;
        var Parser = Shumway.SWF.Parser;
        var Stream = SWF.Stream;
        var Inflate = Shumway.ArrayUtilities.Inflate;
        var LzmaDecoder = Shumway.ArrayUtilities.LzmaDecoder;
        var DefinitionTags = Parser.DefinitionTags;
        var ImageDefinitionTags = Parser.ImageDefinitionTags;
        var FontDefinitionTags = Parser.FontDefinitionTags;
        var ControlTags = Parser.ControlTags;
        var getSwfTagCodeName = Parser.getSwfTagCodeName;
        var CompressionMethod;
        (function (CompressionMethod) {
            CompressionMethod[CompressionMethod["None"] = 0] = "None";
            CompressionMethod[CompressionMethod["Deflate"] = 1] = "Deflate";
            CompressionMethod[CompressionMethod["LZMA"] = 2] = "LZMA";
        })(CompressionMethod = SWF.CompressionMethod || (SWF.CompressionMethod = {}));
        var SWFFile = /** @class */ (function () {
            function SWFFile(initialBytes, length, env) {
                // TODO: cleanly abort loading/parsing instead of just asserting here.
                release || assert(initialBytes[0] === 67 || initialBytes[0] === 70 || initialBytes[0] === 90, "Unsupported compression format: " + initialBytes[0]);
                release || assert(initialBytes[1] === 87);
                release || assert(initialBytes[2] === 83);
                release || assert(initialBytes.length >= 30, "At least the header must be complete here.");
                if (!release && SWF.traceLevel.value > 0) {
                    console.log('Create SWFFile');
                }
                this.env = env;
                this.compression = 0 /* None */;
                this.swfVersion = 0;
                this.useAVM1 = true;
                this.backgroundColor = 0xffffffff;
                this.bounds = null;
                this.frameRate = 0;
                this.frameCount = 0;
                this.attributes = null;
                this.sceneAndFrameLabelData = null;
                this.bytesLoaded = 0;
                this.bytesTotal = length;
                this.pendingUpdateDelays = 0;
                this.framesLoaded = 0;
                this.frames = [];
                this.abcBlocks = [];
                this.dictionary = [];
                this.fonts = [];
                this.symbolClassesMap = [];
                this.symbolClassesList = [];
                this.eagerlyParsedSymbolsMap = [];
                this.eagerlyParsedSymbolsList = [];
                this._jpegTables = null;
                this._currentFrameLabel = null;
                this._currentSoundStreamHead = null;
                this._currentSoundStreamBlock = null;
                this._currentControlTags = null;
                this._currentActionBlocks = null;
                this._currentInitActionBlocks = null;
                this._currentExports = null;
                this._endTagEncountered = false;
                this.readHeaderAndInitialize(initialBytes);
            }
            SWFFile.prototype.appendLoadedData = function (bytes) {
                // TODO: only report decoded or sync-decodable bytes as loaded.
                this.bytesLoaded += bytes.length;
                release || assert(this.bytesLoaded <= this.bytesTotal);
                // Tags after the end tag are simply ignored, so we don't even have to scan them.
                if (this._endTagEncountered) {
                    return;
                }
                if (this.compression !== 0 /* None */) {
                    this._decompressor.push(bytes);
                }
                else {
                    this.processDecompressedData(bytes);
                }
                this.scanLoadedData();
            };
            SWFFile.prototype.finishLoading = function () {
                if (this.compression !== 0 /* None */) {
                    this._decompressor.close();
                    this._decompressor = null;
                    this.scanLoadedData();
                }
            };
            SWFFile.prototype.getSymbol = function (id) {
                if (this.eagerlyParsedSymbolsMap[id]) {
                    return this.eagerlyParsedSymbolsMap[id];
                }
                var unparsed = this.dictionary[id];
                if (!unparsed) {
                    return null;
                }
                var symbol;
                if (unparsed.tagCode === 39 /* CODE_DEFINE_SPRITE */) {
                    // TODO: replace this whole silly `type` business with tagCode checking.
                    symbol = this.parseSpriteTimeline(unparsed);
                }
                else {
                    symbol = this.getParsedTag(unparsed);
                }
                symbol.className = this.symbolClassesMap[id] || null;
                symbol.env = this.env;
                return symbol;
            };
            SWFFile.prototype.getParsedTag = function (unparsed) {
                SWF.enterTimeline('Parse tag ' + getSwfTagCodeName(unparsed.tagCode));
                this._dataStream.align();
                this._dataStream.pos = unparsed.byteOffset;
                var handler = Parser.LowLevel.tagHandlers[unparsed.tagCode];
                release || Shumway.Debug.assert(handler, 'handler shall exists here');
                var tagEnd = Math.min(unparsed.byteOffset + unparsed.byteLength, this._dataStream.end);
                var tag = handler(this._dataStream, this.swfVersion, unparsed.tagCode, tagEnd, this._jpegTables);
                var finalPos = this._dataStream.pos;
                if (finalPos !== tagEnd) {
                    this.emitTagSlopWarning(unparsed, tagEnd);
                }
                var symbol = defineSymbol(tag, this.dictionary);
                SWF.leaveTimeline();
                return symbol;
            };
            SWFFile.prototype.readHeaderAndInitialize = function (initialBytes) {
                SWF.enterTimeline('Initialize SWFFile');
                var isDeflateCompressed = initialBytes[0] === 67;
                var isLzmaCompressed = initialBytes[0] === 90;
                if (isDeflateCompressed) {
                    this.compression = 1 /* Deflate */;
                }
                else if (isLzmaCompressed) {
                    this.compression = 2 /* LZMA */;
                }
                this.swfVersion = initialBytes[3];
                this._loadStarted = Date.now();
                this._uncompressedLength = readSWFLength(initialBytes);
                this.bytesLoaded = initialBytes.length;
                // In some malformed SWFs, the parsed length in the header doesn't exactly match the actual size of the file. For
                // uncompressed files it seems to be safer to make the buffer large enough from the beginning to fit the entire
                // file than having to resize it later or risking an exception when reading out of bounds.
                this.data = new Uint8Array(this.compression === 0 /* None */ ?
                    this.bytesTotal : this._uncompressedLength);
                this._dataStream = new Stream(this.data.buffer);
                this._dataStream.pos = 8;
                this._dataView = this._dataStream.view;
                if (isDeflateCompressed) {
                    this.data.set(initialBytes.subarray(0, 8));
                    // @ivanpopelyshev Data will be uncompressed, so lets change the flag in case someone wants to get the bytes
                    this.data[0] = 70;
                    this._uncompressedLoadedLength = 8;
                    this._decompressor = Inflate.create(true);
                    // Parts of the header are compressed. Get those out of the way before starting tag parsing.
                    this._decompressor.onData = this.processFirstBatchOfDecompressedData.bind(this);
                    this._decompressor.onError = function (error) {
                        // TODO: Let the loader handle this error.
                        throw new Error(error);
                    };
                    this._decompressor.push(initialBytes.subarray(8));
                }
                else if (isLzmaCompressed) {
                    this.data.set(initialBytes.subarray(0, 8));
                    this.data[0] = 70;
                    this._uncompressedLoadedLength = 8;
                    this._decompressor = new LzmaDecoder(true);
                    this._decompressor.onData = this.processFirstBatchOfDecompressedData.bind(this);
                    this._decompressor.onError = function (error) {
                        // TODO: Let the loader handle this error.
                        Shumway.Debug.warning('Invalid LZMA stream: ' + error);
                    };
                    this._decompressor.push(initialBytes);
                }
                else {
                    this.data.set(initialBytes);
                    this._uncompressedLoadedLength = initialBytes.length;
                    this._decompressor = null;
                    this.parseHeaderContents();
                }
                SWF.leaveTimeline();
                this._lastScanPosition = this._dataStream.pos;
                this.scanLoadedData();
            };
            SWFFile.prototype.parseHeaderContents = function () {
                var obj = Parser.LowLevel.parseHeader(this._dataStream);
                this.bounds = obj.bounds;
                this.frameRate = obj.frameRate;
                this.frameCount = obj.frameCount;
            };
            SWFFile.prototype.processFirstBatchOfDecompressedData = function (data) {
                this.processDecompressedData(data);
                this.parseHeaderContents();
                this._decompressor.onData = this.processDecompressedData.bind(this);
            };
            SWFFile.prototype.processDecompressedData = function (data) {
                // Make sure we don't cause an exception here when trying to set out-of-bound data by clamping the number of bytes
                // to write to the remaining space in our buffer. If this is the case, we probably got a wrong file length from
                // the SWF header. The Flash Player ignores data that goes over that given length, so should we.
                var length = Math.min(data.length, this._uncompressedLength - this._uncompressedLoadedLength);
                Shumway.ArrayUtilities.memCopy(this.data, data, this._uncompressedLoadedLength, 0, length);
                this._uncompressedLoadedLength += length;
            };
            SWFFile.prototype.scanLoadedData = function () {
                SWF.enterTimeline('Scan loaded SWF file tags');
                this._dataStream.pos = this._lastScanPosition;
                this.scanTagsToOffset(this._uncompressedLoadedLength, true);
                this._lastScanPosition = this._dataStream.pos;
                SWF.leaveTimeline();
            };
            SWFFile.prototype.scanTagsToOffset = function (endOffset, rootTimelineMode) {
                // `parsePos` is always at the start of a tag at this point, because it only gets updated
                // when a tag has been fully parsed.
                var tempTag = new UnparsedTag(0, 0, 0);
                var pos;
                while ((pos = this._dataStream.pos) < endOffset - 1) {
                    if (!this.parseNextTagHeader(tempTag)) {
                        break;
                    }
                    if (tempTag.tagCode === 0 /* CODE_END */) {
                        if (rootTimelineMode) {
                            this._endTagEncountered = true;
                        }
                        return;
                    }
                    var tagEnd = tempTag.byteOffset + tempTag.byteLength;
                    if (tagEnd > endOffset) {
                        this._dataStream.pos = pos;
                        return;
                    }
                    this.scanTag(tempTag, rootTimelineMode);
                    if (this._dataStream.pos !== tagEnd) {
                        this.emitTagSlopWarning(tempTag, tagEnd);
                    }
                }
            };
            /**
             * Parses tag header information at the current seek offset and stores it in the given object.
             *
             * Public so it can be used by tools to parse through entire SWFs.
             */
            SWFFile.prototype.parseNextTagHeader = function (target) {
                var position = this._dataStream.pos;
                var tagCodeAndLength = this._dataView.getUint16(position, true);
                position += 2;
                target.tagCode = tagCodeAndLength >> 6;
                var tagLength = tagCodeAndLength & 0x3f;
                var extendedLength = tagLength === 0x3f;
                if (extendedLength) {
                    if (position + 4 > this._uncompressedLoadedLength) {
                        return false;
                    }
                    tagLength = this._dataView.getUint32(position, true);
                    position += 4;
                }
                this._dataStream.pos = position;
                target.byteOffset = position;
                target.byteLength = tagLength;
                return true;
            };
            SWFFile.prototype.scanTag = function (tag, rootTimelineMode) {
                var stream = this._dataStream;
                var byteOffset = stream.pos;
                release || assert(byteOffset === tag.byteOffset);
                var tagCode = tag.tagCode;
                var tagLength = tag.byteLength;
                if (!release && SWF.traceLevel.value > 1) {
                    console.info("Scanning tag " + getSwfTagCodeName(tagCode) + " (start: " + byteOffset +
                        ", end: " + (byteOffset + tagLength) + ")");
                }
                if (tagCode === 39 /* CODE_DEFINE_SPRITE */) {
                    // According to Chapter 13 of the SWF format spec, no nested definition tags are
                    // allowed within DefineSprite. However, they're added to the symbol dictionary
                    // anyway, and some tools produce them. Notably swfmill.
                    // We essentially treat them as though they came before the current sprite. That
                    // should be ok because it doesn't make sense for them to rely on their parent being
                    // fully defined - so they don't have to come after it -, and any control tags within
                    // the parent will just pick them up the moment they're defined, just as always.
                    this.addLazySymbol(tagCode, byteOffset, tagLength);
                    var spriteTagEnd = byteOffset + tagLength;
                    stream.pos += 4; // Jump over symbol ID and frameCount.
                    this.scanTagsToOffset(spriteTagEnd, false);
                    if (this._dataStream.pos !== spriteTagEnd) {
                        this.emitTagSlopWarning(tag, spriteTagEnd);
                    }
                    return;
                }
                if (ImageDefinitionTags[tagCode]) {
                    // Images are decoded asynchronously, so we have to deal with them ahead of time to
                    // ensure they're ready when used.
                    var unparsed = this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.decodeEmbeddedImage(unparsed);
                    return;
                }
                if (FontDefinitionTags[tagCode]) {
                    var unparsed = this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.registerEmbeddedFont(unparsed);
                    return;
                }
                if (DefinitionTags[tagCode]) {
                    this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.jumpToNextTag(tagLength);
                    return;
                }
                if (!rootTimelineMode &&
                    !(tagCode === 76 /* CODE_SYMBOL_CLASS */ || tagCode === 56 /* CODE_EXPORT_ASSETS */)) {
                    this.jumpToNextTag(tagLength);
                    return;
                }
                if (ControlTags[tagCode]) {
                    this.addControlTag(tagCode, byteOffset, tagLength);
                    return;
                }
                var tagEnd;
                switch (tagCode) {
                    case 69 /* CODE_FILE_ATTRIBUTES */:
                        this.setFileAttributes(tagLength);
                        break;
                    case 86 /* CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA */:
                        this.setSceneAndFrameLabelData(tagLength);
                        break;
                    case 9 /* CODE_SET_BACKGROUND_COLOR */:
                        this.backgroundColor = Parser.LowLevel.parseRgb(this._dataStream);
                        break;
                    case 8 /* CODE_JPEG_TABLES */:
                        // Only use the first JpegTables tag, ignore any following.
                        // TODO test it, swfdec is using the last one
                        if (!this._jpegTables) {
                            this._jpegTables = tagLength === 0 ?
                                new Uint8Array(0) :
                                this.data.subarray(stream.pos, stream.pos + tagLength - 2);
                        }
                        this.jumpToNextTag(tagLength);
                        break;
                    case 82 /* CODE_DO_ABC */:
                    case 72 /* CODE_DO_ABC_DEFINE */:
                        if (!this.useAVM1) {
                            var tagEnd_1 = byteOffset + tagLength;
                            var abcBlock = new ABCBlock();
                            if (tagCode === 82 /* CODE_DO_ABC */) {
                                abcBlock.flags = stream.readUi32();
                                abcBlock.name = stream.readString(-1);
                            }
                            else {
                                abcBlock.flags = 0;
                                abcBlock.name = "";
                            }
                            abcBlock.data = this.data.subarray(stream.pos, tagEnd_1);
                            this.abcBlocks.push(abcBlock);
                            stream.pos = tagEnd_1;
                        }
                        else {
                            this.jumpToNextTag(tagLength);
                        }
                        break;
                    case 76 /* CODE_SYMBOL_CLASS */:
                        var tagEnd_2 = byteOffset + tagLength;
                        var symbolCount = stream.readUi16();
                        // TODO: check if symbols can be reassociated after instances have been created.
                        while (symbolCount--) {
                            var symbolId = stream.readUi16();
                            var symbolClassName = stream.readString(-1);
                            if (!release && SWF.traceLevel.value > 0) {
                                console.log('Registering symbol class ' + symbolClassName + ' to symbol ' + symbolId);
                            }
                            this.symbolClassesMap[symbolId] = symbolClassName;
                            this.symbolClassesList.push({ id: symbolId, className: symbolClassName });
                        }
                        // Make sure we move to end of tag even if the content is invalid.
                        stream.pos = tagEnd_2;
                        break;
                    case 59 /* CODE_DO_INIT_ACTION */:
                        if (this.useAVM1) {
                            var initActionBlocks = this._currentInitActionBlocks ||
                                (this._currentInitActionBlocks = []);
                            var spriteId = this._dataView.getUint16(stream.pos, true);
                            var actionsData = this.data.subarray(byteOffset + 2, byteOffset + tagLength);
                            initActionBlocks.push({ spriteId: spriteId, actionsData: actionsData });
                        }
                        this.jumpToNextTag(tagLength);
                        break;
                    case 12 /* CODE_DO_ACTION */:
                        if (this.useAVM1) {
                            var actionBlocks = this._currentActionBlocks || (this._currentActionBlocks = []);
                            var actionsData = this.data.subarray(stream.pos, stream.pos + tagLength);
                            actionBlocks.push({ actionsData: actionsData, precedence: stream.pos });
                        }
                        this.jumpToNextTag(tagLength);
                        break;
                    case 18 /* CODE_SOUND_STREAM_HEAD */:
                    case 45 /* CODE_SOUND_STREAM_HEAD2 */:
                        var soundStreamTag = Parser.LowLevel.parseSoundStreamHeadTag(this._dataStream, byteOffset + tagLength);
                        this._currentSoundStreamHead = Parser.SoundStream.FromTag(soundStreamTag);
                        break;
                    case 19 /* CODE_SOUND_STREAM_BLOCK */:
                        this._currentSoundStreamBlock = this.data.subarray(stream.pos, stream.pos += tagLength);
                        break;
                    case 43 /* CODE_FRAME_LABEL */:
                        tagEnd_2 = stream.pos + tagLength;
                        this._currentFrameLabel = stream.readString(-1);
                        // TODO: support SWF6+ anchors.
                        stream.pos = tagEnd_2;
                        break;
                    case 1 /* CODE_SHOW_FRAME */:
                        this.finishFrame();
                        break;
                    case 0 /* CODE_END */:
                        return;
                    case 56 /* CODE_EXPORT_ASSETS */:
                        tagEnd_2 = stream.pos + tagLength;
                        var exportsCount = stream.readUi16();
                        var exports = this._currentExports || (this._currentExports = []);
                        while (exportsCount--) {
                            var symbolId = stream.readUi16();
                            var className = stream.readString(-1);
                            if (stream.pos > tagEnd_2) {
                                stream.pos = tagEnd_2;
                                break;
                            }
                            exports.push(new SymbolExport(symbolId, className));
                        }
                        stream.pos = tagEnd_2;
                        break;
                    case 23 /* CODE_DEFINE_BUTTON_CXFORM */:
                    case 17 /* CODE_DEFINE_BUTTON_SOUND */:
                    case 13 /* CODE_DEFINE_FONT_INFO */:
                    case 62 /* CODE_DEFINE_FONT_INFO2 */:
                    case 78 /* CODE_DEFINE_SCALING_GRID */:
                    case 57 /* CODE_IMPORT_ASSETS */:
                    case 71 /* CODE_IMPORT_ASSETS2 */:
                        Shumway.Debug.warning('Unsupported tag encountered ' + tagCode + ': ' + getSwfTagCodeName(tagCode));
                        this.jumpToNextTag(tagLength);
                        break;
                    // These tags should be supported at some point, but for now, we ignore them.
                    case 74 /* CODE_CSM_TEXT_SETTINGS */:
                    case 73 /* CODE_DEFINE_FONT_ALIGN_ZONES */:
                    case 65 /* CODE_SCRIPT_LIMITS */:
                    case 66 /* CODE_SET_TAB_INDEX */:
                    // These tags are used by the player, but not relevant to us.
                    case 58 /* CODE_ENABLE_DEBUGGER */:
                    case 64 /* CODE_ENABLE_DEBUGGER2 */:
                    case 63 /* CODE_DEBUG_ID */:
                    case 88 /* CODE_DEFINE_FONT_NAME */:
                    case 40 /* CODE_NAME_CHARACTER */:
                    case 41 /* CODE_PRODUCT_INFO */:
                    case 77 /* CODE_METADATA */:
                    case 24 /* CODE_PROTECT */:
                    case 25 /* CODE_PATHS_ARE_POSTSCRIPT */:
                    case 93 /* CODE_TELEMETRY */:
                    // These are obsolete Generator-related tags.
                    case 55 /* CODE_GEN_TAG_OBJECTS */:
                    case 49 /* CODE_GEN_COMMAND */:
                        this.jumpToNextTag(tagLength);
                        break;
                    // These tags aren't used in the player.
                    case 51 /* CODE_CHARACTER_SET */:
                    case 44 /* CODE_DEFINE_BEHAVIOUR */:
                    case 50 /* CODE_DEFINE_COMMAND_OBJECT */:
                    case 53 /* CODE_DEFINE_FUNCTION */:
                    case 42 /* CODE_DEFINE_TEXT_FORMAT */:
                    case 38 /* CODE_DEFINE_VIDEO */:
                    case 52 /* CODE_EXTERNAL_FONT */:
                    case 3 /* CODE_FREE_CHARACTER */:
                    case 31 /* CODE_FREE_ALL */:
                    case 47 /* CODE_GENERATE_FRAME */:
                    case 16 /* CODE_STOP_SOUND */:
                    case 29 /* CODE_SYNC_FRAME */:
                        console.info("Ignored tag (these shouldn't occur) " + tagCode + ': ' + getSwfTagCodeName(tagCode));
                        this.jumpToNextTag(tagLength);
                        break;
                    default:
                        if (tagCode > 100) {
                            Shumway.Debug.warning("Encountered undefined tag " + tagCode + ", probably used for AVM1 " +
                                "obfuscation. See http://ijs.mtasa.com/files/swfdecrypt.cpp.");
                        }
                        else {
                            Shumway.Debug.warning('Tag not handled by the parser: ' + tagCode + ': ' + getSwfTagCodeName(tagCode));
                        }
                        this.jumpToNextTag(tagLength);
                }
            };
            SWFFile.prototype.parseSpriteTimeline = function (spriteTag) {
                SWF.enterTimeline("parseSpriteTimeline");
                var data = this.data;
                var stream = this._dataStream;
                var dataView = this._dataView;
                var timeline = {
                    id: spriteTag.id,
                    type: 'sprite',
                    frames: []
                };
                var spriteTagEnd = spriteTag.byteOffset + spriteTag.byteLength;
                var frames = timeline.frames;
                var label = null;
                var controlTags = [];
                var soundStreamHead = null;
                var soundStreamBlock = null;
                var actionBlocks = null;
                var initActionBlocks = null;
                // Skip ID.
                stream.pos = spriteTag.byteOffset + 2;
                // TODO: check if numFrames or the real number of ShowFrame tags wins. (Probably the former.)
                timeline.frameCount = dataView.getUint16(stream.pos, true);
                stream.pos += 2;
                var spriteContentTag = new UnparsedTag(0, 0, 0);
                while (stream.pos < spriteTagEnd) {
                    this.parseNextTagHeader(spriteContentTag);
                    var tagLength = spriteContentTag.byteLength;
                    var tagCode = spriteContentTag.tagCode;
                    if (stream.pos + tagLength > spriteTagEnd) {
                        Shumway.Debug.warning("DefineSprite child tags exceed DefineSprite tag length and are dropped");
                        break;
                    }
                    if (Parser.ControlTags[tagCode]) {
                        controlTags.push(new UnparsedTag(tagCode, stream.pos, tagLength));
                        stream.pos += tagLength;
                        continue;
                    }
                    switch (tagCode) {
                        case 12 /* CODE_DO_ACTION */:
                            if (this.useAVM1) {
                                if (!actionBlocks) {
                                    actionBlocks = [];
                                }
                                var actionsData = data.subarray(stream.pos, stream.pos + tagLength);
                                actionBlocks.push({ actionsData: actionsData, precedence: stream.pos });
                            }
                            break;
                        case 59 /* CODE_DO_INIT_ACTION */:
                            if (this.useAVM1) {
                                if (!initActionBlocks) {
                                    initActionBlocks = [];
                                }
                                var spriteId = dataView.getUint16(stream.pos, true);
                                stream.pos += 2;
                                var actionsData = data.subarray(stream.pos, stream.pos + tagLength);
                                initActionBlocks.push({ spriteId: spriteId, actionsData: actionsData });
                            }
                            break;
                        case 43 /* CODE_FRAME_LABEL */:
                            var tagEnd = stream.pos + tagLength;
                            label = stream.readString(-1);
                            // TODO: support SWF6+ anchors.
                            stream.pos = tagEnd;
                            tagLength = 0;
                            break;
                        case 1 /* CODE_SHOW_FRAME */:
                            frames.push(new SWFFrame(controlTags, label, soundStreamHead, soundStreamBlock, actionBlocks, initActionBlocks, null));
                            label = null;
                            controlTags = [];
                            soundStreamHead = null;
                            soundStreamBlock = null;
                            actionBlocks = null;
                            initActionBlocks = null;
                            break;
                        case 0 /* CODE_END */:
                            stream.pos = spriteTagEnd;
                            tagLength = 0;
                            break;
                        default:
                    }
                    stream.pos += tagLength;
                    release || assert(stream.pos <= spriteTagEnd);
                }
                SWF.leaveTimeline();
                return timeline;
            };
            SWFFile.prototype.jumpToNextTag = function (currentTagLength) {
                this._dataStream.pos += currentTagLength;
            };
            SWFFile.prototype.emitTagSlopWarning = function (tag, tagEnd) {
                var consumedBytes = this._dataStream.pos - tag.byteOffset;
                Shumway.Debug.warning('Scanning ' + getSwfTagCodeName(tag.tagCode) + ' at offset ' + tag.byteOffset +
                    ' consumed ' + consumedBytes + ' of ' + tag.byteLength + ' bytes. (' +
                    (tag.byteLength - consumedBytes) + ' left)');
                this._dataStream.pos = tagEnd;
            };
            SWFFile.prototype.finishFrame = function () {
                if (this.pendingUpdateDelays === 0) {
                    this.framesLoaded++;
                }
                this.frames.push(new SWFFrame(this._currentControlTags, this._currentFrameLabel, this._currentSoundStreamHead, this._currentSoundStreamBlock, this._currentActionBlocks, this._currentInitActionBlocks, this._currentExports));
                this._currentFrameLabel = null;
                this._currentControlTags = null;
                this._currentSoundStreamHead = null;
                this._currentSoundStreamBlock = null;
                this._currentActionBlocks = null;
                this._currentInitActionBlocks = null;
                this._currentExports = null;
            };
            SWFFile.prototype.setFileAttributes = function (tagLength) {
                // TODO: check what happens to attributes tags that aren't the first tag.
                if (this.attributes) {
                    this.jumpToNextTag(tagLength);
                }
                var bits = this.data[this._dataStream.pos];
                this._dataStream.pos += 4;
                this.attributes = {
                    network: bits & 0x1,
                    relativeUrls: bits & 0x2,
                    noCrossDomainCaching: bits & 0x4,
                    doAbc: bits & 0x8,
                    hasMetadata: bits & 0x10,
                    useGpu: bits & 0x20,
                    useDirectBlit: bits & 0x40
                };
                this.useAVM1 = !this.attributes.doAbc;
            };
            SWFFile.prototype.setSceneAndFrameLabelData = function (tagLength) {
                if (this.sceneAndFrameLabelData) {
                    this.jumpToNextTag(tagLength);
                    return;
                }
                this.sceneAndFrameLabelData = Parser.LowLevel.parseDefineSceneTag(this._dataStream, 86 /* CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA */);
            };
            SWFFile.prototype.addControlTag = function (tagCode, byteOffset, tagLength) {
                var controlTags = this._currentControlTags || (this._currentControlTags = []);
                controlTags.push(new UnparsedTag(tagCode, byteOffset, tagLength));
                this.jumpToNextTag(tagLength);
            };
            SWFFile.prototype.addLazySymbol = function (tagCode, byteOffset, tagLength) {
                var id = this._dataView.getUint16(this._dataStream.pos, true);
                var symbol = new DictionaryEntry(id, tagCode, byteOffset, tagLength);
                this.dictionary[id] = symbol;
                if (!release && SWF.traceLevel.value > 0) {
                    console.info("Registering symbol " + id + " of type " + getSwfTagCodeName(tagCode));
                }
                return symbol;
            };
            SWFFile.prototype.decodeEmbeddedFont = function (unparsed) {
                var definition = this.getParsedTag(unparsed);
                var symbol = new EagerlyParsedDictionaryEntry(definition.id, unparsed, 'font', definition, this.env);
                if (!release && SWF.traceLevel.value > 0) {
                    var style_1 = flagsToFontStyle(definition.bold, definition.italic);
                    console.info("Decoding embedded font " + definition.id + " with name '" + definition.name +
                        "' and style " + style_1, definition);
                }
                this.eagerlyParsedSymbolsMap[symbol.id] = symbol;
                this.eagerlyParsedSymbolsList.push(symbol);
                var style = flagsToFontStyle(definition.bold, definition.italic);
                this.fonts.push({ name: definition.name, id: definition.id, style: style });
            };
            SWFFile.prototype.registerEmbeddedFont = function (unparsed) {
                if (!inFirefox) {
                    this.decodeEmbeddedFont(unparsed);
                    return;
                }
                var stream = this._dataStream;
                var id = this._dataView.getUint16(stream.pos, true);
                var style;
                var name;
                // DefineFont only specifies a symbol ID, no font name or style.
                if (unparsed.tagCode === 10 /* CODE_DEFINE_FONT */) {
                    // Assigning some unique name to simplify font registration and look ups.
                    name = '__autofont__' + unparsed.byteOffset;
                    style = 'regular';
                }
                else {
                    var flags = this.data[stream.pos + 2];
                    style = flagsToFontStyle(!!(flags & 0x1), !!(flags & 0x2));
                    var nameLength = this.data[stream.pos + 4];
                    // Skip language code.
                    stream.pos += 5;
                    name = stream.readString(nameLength);
                }
                this.fonts.push({ name: name, id: id, style: style });
                if (!release && SWF.traceLevel.value > 0) {
                    console.info("Registering embedded font " + id + " with name '" + name + "' and style " +
                        style);
                }
                stream.pos = unparsed.byteOffset + unparsed.byteLength;
            };
            SWFFile.prototype.decodeEmbeddedImage = function (unparsed) {
                var definition = this.getParsedTag(unparsed);
                var symbol = new EagerlyParsedDictionaryEntry(definition.id, unparsed, 'image', definition, this.env);
                if (!release && SWF.traceLevel.value > 0) {
                    console.info("Decoding embedded image " + definition.id + " of type " +
                        getSwfTagCodeName(unparsed.tagCode) + " (start: " + unparsed.byteOffset +
                        ", end: " + (unparsed.byteOffset + unparsed.byteLength) + ")");
                }
                this.eagerlyParsedSymbolsMap[symbol.id] = symbol;
                this.eagerlyParsedSymbolsList.push(symbol);
            };
            return SWFFile;
        }());
        SWF.SWFFile = SWFFile;
        function flagsToFontStyle(bold, italic) {
            if (bold && italic) {
                return 'boldItalic';
            }
            if (bold) {
                return 'bold';
            }
            if (italic) {
                return 'italic';
            }
            return 'regular';
        }
        var SWFFrame = /** @class */ (function () {
            function SWFFrame(controlTags, labelName, soundStreamHead, soundStreamBlock, actionBlocks, initActionBlocks, exports) {
                release || controlTags && Object.freeze(controlTags);
                this.controlTags = controlTags;
                this.labelName = labelName;
                release || actionBlocks && Object.freeze(actionBlocks);
                this.soundStreamHead = soundStreamHead;
                this.soundStreamBlock = soundStreamBlock;
                this.actionBlocks = actionBlocks;
                release || initActionBlocks && Object.freeze(initActionBlocks);
                this.initActionBlocks = initActionBlocks;
                release || exports && Object.freeze(exports);
                this.exports = exports;
            }
            return SWFFrame;
        }());
        SWF.SWFFrame = SWFFrame;
        var ABCBlock = /** @class */ (function () {
            function ABCBlock() {
            }
            return ABCBlock;
        }());
        SWF.ABCBlock = ABCBlock;
        var ActionBlock = /** @class */ (function () {
            function ActionBlock() {
            }
            return ActionBlock;
        }());
        SWF.ActionBlock = ActionBlock;
        var InitActionBlock = /** @class */ (function () {
            function InitActionBlock() {
            }
            return InitActionBlock;
        }());
        SWF.InitActionBlock = InitActionBlock;
        var SymbolExport = /** @class */ (function () {
            function SymbolExport(symbolId, className) {
                this.symbolId = symbolId;
                this.className = className;
            }
            return SymbolExport;
        }());
        SWF.SymbolExport = SymbolExport;
        var UnparsedTag = /** @class */ (function () {
            function UnparsedTag(tagCode, byteOffset, byteLength) {
                this.tagCode = tagCode;
                this.byteOffset = byteOffset;
                this.byteLength = byteLength;
            }
            return UnparsedTag;
        }());
        SWF.UnparsedTag = UnparsedTag;
        var DictionaryEntry = /** @class */ (function (_super) {
            __extends(DictionaryEntry, _super);
            function DictionaryEntry(id, tagCode, byteOffset, byteLength) {
                var _this = _super.call(this, tagCode, byteOffset, byteLength) || this;
                _this.id = id;
                return _this;
            }
            return DictionaryEntry;
        }(UnparsedTag));
        SWF.DictionaryEntry = DictionaryEntry;
        var EagerlyParsedDictionaryEntry = /** @class */ (function (_super) {
            __extends(EagerlyParsedDictionaryEntry, _super);
            function EagerlyParsedDictionaryEntry(id, unparsed, type, definition, env) {
                var _this = _super.call(this, id, unparsed.tagCode, unparsed.byteOffset, unparsed.byteLength) || this;
                _this.type = type;
                _this.definition = definition;
                _this.env = env;
                _this.ready = false;
                return _this;
            }
            return EagerlyParsedDictionaryEntry;
        }(DictionaryEntry));
        SWF.EagerlyParsedDictionaryEntry = EagerlyParsedDictionaryEntry;
        function readSWFLength(bytes) {
            // We read the length manually because creating a DataView just for that is silly.
            return (bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24) >>> 0;
        }
        function defineSymbol(swfTag, symbols) {
            switch (swfTag.code) {
                case 6 /* CODE_DEFINE_BITS */:
                case 21 /* CODE_DEFINE_BITS_JPEG2 */:
                case 35 /* CODE_DEFINE_BITS_JPEG3 */:
                case 90 /* CODE_DEFINE_BITS_JPEG4 */:
                    return Shumway.SWF.Parser.defineImage(swfTag);
                case 20 /* CODE_DEFINE_BITS_LOSSLESS */:
                case 36 /* CODE_DEFINE_BITS_LOSSLESS2 */:
                    return Shumway.SWF.Parser.defineBitmap(swfTag);
                case 7 /* CODE_DEFINE_BUTTON */:
                case 34 /* CODE_DEFINE_BUTTON2 */:
                    return Shumway.SWF.Parser.defineButton(swfTag, symbols);
                case 37 /* CODE_DEFINE_EDIT_TEXT */:
                    return Shumway.SWF.Parser.defineText(swfTag);
                case 10 /* CODE_DEFINE_FONT */:
                case 48 /* CODE_DEFINE_FONT2 */:
                case 75 /* CODE_DEFINE_FONT3 */:
                case 91 /* CODE_DEFINE_FONT4 */:
                    return Shumway.SWF.Parser.defineFont(swfTag);
                case 46 /* CODE_DEFINE_MORPH_SHAPE */:
                case 84 /* CODE_DEFINE_MORPH_SHAPE2 */:
                case 2 /* CODE_DEFINE_SHAPE */:
                case 22 /* CODE_DEFINE_SHAPE2 */:
                case 32 /* CODE_DEFINE_SHAPE3 */:
                case 83 /* CODE_DEFINE_SHAPE4 */:
                    return Shumway.SWF.Parser.defineShape(swfTag);
                case 14 /* CODE_DEFINE_SOUND */:
                    return Shumway.SWF.Parser.defineSound(swfTag);
                case 60 /* CODE_DEFINE_VIDEO_STREAM */:
                    return {
                        type: 'video',
                        id: swfTag.id,
                        width: swfTag.width,
                        height: swfTag.height,
                        deblocking: swfTag.deblocking,
                        smoothing: swfTag.smoothing,
                        codec: swfTag.codecId
                    };
                case 39 /* CODE_DEFINE_SPRITE */:
                    // Sprites are fully defined at this point.
                    return swfTag;
                case 87 /* CODE_DEFINE_BINARY_DATA */:
                    return {
                        type: 'binary',
                        id: swfTag.id,
                        data: swfTag.data
                    };
                case 11 /* CODE_DEFINE_TEXT */:
                case 33 /* CODE_DEFINE_TEXT2 */:
                    return Shumway.SWF.Parser.defineLabel(swfTag);
                default:
                    return swfTag;
            }
        }
    })(SWF = Shumway.SWF || (Shumway.SWF = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var ImageTypeMagicHeaderBytes;
    (function (ImageTypeMagicHeaderBytes) {
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes["JPG"] = 16767231] = "JPG";
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes["PNG"] = 8998990] = "PNG";
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes["GIF"] = 4671814] = "GIF";
    })(ImageTypeMagicHeaderBytes || (ImageTypeMagicHeaderBytes = {}));
    var mimetypesForHeaders = {};
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.JPG] = 'image/jpeg';
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.PNG] = 'image/png';
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.GIF] = 'image/gif';
    var ImageFile = /** @class */ (function () {
        function ImageFile(header, fileLength, env) {
            this.type = 4;
            this.env = env;
            this.bytesLoaded = header.length;
            if (header.length === fileLength) {
                this.data = header;
            }
            else {
                this.data = new Uint8Array(fileLength);
                this.data.set(header);
            }
            this.setMimetype();
        }
        Object.defineProperty(ImageFile.prototype, "bytesTotal", {
            get: function () {
                return this.data.length;
            },
            enumerable: true,
            configurable: true
        });
        ImageFile.prototype.appendLoadedData = function (data) {
            this.data.set(data, this.bytesLoaded);
            this.bytesLoaded += data.length;
        };
        ImageFile.prototype.setMimetype = function () {
            var magic = (this.data[0] << 16) | (this.data[1] << 8) | this.data[2];
            this.mimeType = mimetypesForHeaders[magic];
        };
        return ImageFile;
    }());
    Shumway.ImageFile = ImageFile;
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates as much of the external file loading process as possible. This means all of it
 * except for (stand-alone or embedded) images and fonts embedded in SWFs. As these have to be
 * decoded before being usable by content, we stall reporting loading progress until the decoding
 * has finished. The following is a description of the ridiculously complicated contortions we
 * have to go through for this to work:

 ### Life-cycle of embedded images and fonts from being encountered in the SWF to being ready for
 use:
 1.
 1. An image tag is encountered, `SWFFile#decodeEmbeddedImage` is called.
 2. A font tag is encountered, `SWFFile#registerEmbeddedFont` is called. For Firefox, things end
 here for now: fonts can be decoded synchronously, so we don't need to do it eagerly.
 2. Embedded asset's contents are extracted from SWF and stored in an
 `EagerlyParsedDictionaryEntry`.
 3. Once scanning of the currently loaded SWF bytes is complete, `Loader#onNewEagerlyParsedSymbols`
 is called with a list of all newly encountered fonts and images.
 Note: `Loader` does *not* receive updates about any other newly loaded data; not even how many
 bytes were loaded.
 4. `Loader#onNewEagerlyParsedSymbols` iterates over list of fonts and images and retrieves their
 symbols.
 5. `LoaderInfo#getSymbolById` creates a `{Font,Bitmap}Symbol` instance, which gets a `syncID` and
 a `resolveAssetPromise` and a `ready` flag set to `false`.
 6. `LoaderInfo#getSymbolById` invokes `Timeline.IAssetResolver#registerFont` or
 `Timeline.IAssetResolver#registerImage`. The singleton implementation of `IAssetResolver` is
 the active instance of `Player`.
 7. `Player#registerFont` or `Player#registerImage` send sync message to GFX side requesting
 decoding of asset.
 8. `GFXChannelDeserializerContext#register{Font,Image}` is called, which triggers the actual
 decoding and, in the image case, registration of the asset.
 9.
 1. A `CSSFont` is created and a 400ms timeout triggered.
 2.
 1. A `HTMLImageElement` is created and a load triggered from the blob containing the image
 bytes.
 2. A `RenderableBitmap` is created with the `HTMLImageElement` as its `renderSource` and
 `-1,-1` dimensions.
 10. `Loader#onNewEagerlyParsedSymbols` creates a `Promise.all` promise for all assets'
 `resolveAssetPromise`s and returns that to the `FileLoader`.
 11. For all assets:
 1. Loading finishes for images / timeout happens for fonts, resolving their
 `resolveAssetPromise`.
 2. Symbols get marked as `ready`, fonts get their metrics filled in.
 12. The combined promise is resolved, causing `FileLoader` to deliver the queued load update,
 informing content about newly loaded bytes, assets, scripts, etc.

 Note: loading and scanning of the SWF has continued in the meantime, so there can be multiple
 updates queued for the same promise.


 ### Usage of an image in GFX-land:
 Images are guaranteed to be ready for rendering when content is told about them, so there can
 never be a need to asynchronously decode them. If an image is never used for anything but
 rendering, it's never expanded into a Canvas. If, see below, content accesses the image's bytes,
 it's expanded and the original `HTMLImageElement` discarded.

 ### Usage of an image in Player-land:
 If content accesses an image's pixels for the first time, e.g. using `BitmapData#getPixel`, the
 `BitmapData` instance requests the pixel data from GFX-land. That causes the above-mentioned
 expansion into a Canvas and discarding of the `HTMLImageElement`, followed by a `getImageData`
 call.
 */
var Shumway;
(function (Shumway) {
    var assert = Shumway.Debug.assert;
    var SWFFile = Shumway.SWF.SWFFile;
    // Minimal amount of data to load before starting to parse. Chosen fairly arbitrarily.
    var MIN_LOADED_BYTES = 8192;
    var LoadProgressUpdate = /** @class */ (function () {
        function LoadProgressUpdate(bytesLoaded, framesLoaded) {
            this.bytesLoaded = bytesLoaded;
            this.framesLoaded = framesLoaded;
        }
        return LoadProgressUpdate;
    }());
    Shumway.LoadProgressUpdate = LoadProgressUpdate;
    var FileLoader = /** @class */ (function () {
        function FileLoader(listener, env) {
            release || assert(listener);
            this._file = null;
            this._url = '';
            this._listener = listener;
            this._env = env;
            this._loadingServiceSession = null;
            this._delayedUpdatesPromise = null;
            this._bytesLoaded = 0;
        }
        // TODO: strongly type
        FileLoader.prototype.loadFile = function (request) {
            this._url = request.url;
            Shumway.SWF.enterTimeline('Load file', request.url);
            this._bytesLoaded = 0;
            var session = this._loadingServiceSession = Shumway.FileLoadingService.instance.createSession();
            session.onopen = this.processLoadOpen.bind(this);
            session.onprogress = this.processNewData.bind(this);
            session.onerror = this.processError.bind(this);
            session.onclose = this.processLoadClose.bind(this);
            session.open(request);
        };
        FileLoader.prototype.abortLoad = function () {
            if (this._loadingServiceSession) {
                this._loadingServiceSession.close();
                Shumway.SWF.leaveTimeline();
            }
            this._file = null;
        };
        FileLoader.prototype.loadBytes = function (bytes) {
            Shumway.SWF.enterTimeline('Load bytes');
            this.processLoadOpen();
            this.processNewData(bytes, { bytesLoaded: bytes.length, bytesTotal: bytes.length });
            this.processLoadClose();
            // SWF.leaveTimeline happens in processLoadClose.
        };
        FileLoader.prototype.processLoadOpen = function () {
            release || assert(!this._file);
        };
        FileLoader.prototype.processNewData = function (data, progressInfo) {
            this._bytesLoaded += data.length;
            var isLoadingInProgress = progressInfo.bytesLoaded < progressInfo.bytesTotal;
            if (this._bytesLoaded < MIN_LOADED_BYTES && isLoadingInProgress) {
                if (!this._queuedInitialData) {
                    this._queuedInitialData = new Uint8Array(Math.min(MIN_LOADED_BYTES, progressInfo.bytesTotal));
                }
                this._queuedInitialData.set(data, this._bytesLoaded - data.length);
                return;
            }
            else if (this._queuedInitialData) {
                var allData = new Uint8Array(this._bytesLoaded);
                allData.set(this._queuedInitialData);
                allData.set(data, this._bytesLoaded - data.length);
                data = allData;
                this._queuedInitialData = null;
            }
            var file = this._file;
            var eagerlyParsedSymbolsCount = 0;
            var previousFramesLoaded = 0;
            if (!file) {
                file = this._file = createFileInstanceForHeader(data, progressInfo.bytesTotal, this._env);
                if (file) {
                    this._listener.onLoadOpen(file);
                }
            }
            else {
                if (file instanceof SWFFile) {
                    eagerlyParsedSymbolsCount = file.eagerlyParsedSymbolsList.length;
                    previousFramesLoaded = file.framesLoaded;
                }
                file.appendLoadedData(data);
            }
            if (file instanceof SWFFile) {
                this.processSWFFileUpdate(file, eagerlyParsedSymbolsCount, previousFramesLoaded);
            }
            else {
                release || assert(file instanceof Shumway.ImageFile);
                this._listener.onLoadProgress(new LoadProgressUpdate(progressInfo.bytesLoaded, -1));
                if (progressInfo.bytesLoaded === progressInfo.bytesTotal) {
                    this._listener.onImageBytesLoaded();
                }
            }
        };
        FileLoader.prototype.processError = function (error) {
            Shumway.Debug.warning('Loading error encountered:', error);
        };
        FileLoader.prototype.processLoadClose = function () {
            var file = this._file;
            if (!file) {
                this._listener.onLoadOpen(null);
                return;
            }
            if (file instanceof SWFFile) {
                var eagerlyParsedSymbolsCount = file.eagerlyParsedSymbolsList.length;
                var previousFramesLoaded = file.framesLoaded;
                file.finishLoading();
                this.processSWFFileUpdate(file, eagerlyParsedSymbolsCount, previousFramesLoaded);
            }
            if (file.bytesLoaded !== file.bytesTotal) {
                Shumway.Debug.warning("Shouldn't have reached this: aborting a load should prevent this from " +
                    "being called.");
                Shumway.Debug.warning(new Error().stack);
            }
            else {
                Shumway.SWF.leaveTimeline();
            }
        };
        FileLoader.prototype.processSWFFileUpdate = function (file, previousEagerlyParsedSymbolsCount, previousFramesLoaded) {
            var promise;
            var eagerlyParsedSymbolsDelta = file.eagerlyParsedSymbolsList.length -
                previousEagerlyParsedSymbolsCount;
            if (!eagerlyParsedSymbolsDelta) {
                var update_1 = this._lastDelayedUpdate;
                if (!update_1) {
                    release || assert(file.framesLoaded === file.frames.length);
                    this._listener.onLoadProgress(new LoadProgressUpdate(file.bytesLoaded, file.framesLoaded));
                }
                else {
                    release || assert(update_1.framesLoaded <= file.frames.length);
                    update_1.bytesLoaded = file.bytesLoaded;
                    update_1.framesLoaded = file.frames.length;
                }
                return;
            }
            promise = this._listener.onNewEagerlyParsedSymbols(file.eagerlyParsedSymbolsList, eagerlyParsedSymbolsDelta);
            if (this._delayedUpdatesPromise) {
                promise = Promise.all([this._delayedUpdatesPromise, promise]);
            }
            this._delayedUpdatesPromise = promise;
            var update = new LoadProgressUpdate(file.bytesLoaded, file.frames.length);
            this._lastDelayedUpdate = update;
            file.pendingUpdateDelays++;
            var self = this;
            // Make sure the framesLoaded value from after this update isn't yet visible. Otherwise,
            // we might signal a higher value than allowed if this update is delayed sufficiently long
            // for another update to arrive in the meantime. That update sets the framesLoaded value too
            // high. Then, this update gets resolved, but signals a value for framesLoaded that's too
            // high.
            file.framesLoaded = previousFramesLoaded;
            promise.then(function () {
                if (!release && Shumway.SWF.traceLevel.value > 0) {
                    console.log("Reducing pending update delays from " + file.pendingUpdateDelays + " to " +
                        (file.pendingUpdateDelays - 1));
                }
                file.pendingUpdateDelays--;
                release || assert(file.pendingUpdateDelays >= 0);
                file.framesLoaded = update.framesLoaded;
                self._listener.onLoadProgress(update);
                if (self._delayedUpdatesPromise === promise) {
                    self._delayedUpdatesPromise = null;
                    self._lastDelayedUpdate = null;
                }
            });
        };
        return FileLoader;
    }());
    Shumway.FileLoader = FileLoader;
    function createFileInstanceForHeader(header, fileLength, env) {
        var magic = (header[0] << 16) | (header[1] << 8) | header[2];
        if ((magic & 0xffff) === FileTypeMagicHeaderBytes.SWF) {
            return new SWFFile(header, fileLength, env);
        }
        if (magic === FileTypeMagicHeaderBytes.JPG || magic === FileTypeMagicHeaderBytes.PNG ||
            magic === FileTypeMagicHeaderBytes.GIF) {
            return new Shumway.ImageFile(header, fileLength, env);
        }
        // TODO: throw instead of returning null? Perhaps?
        return null;
    }
    var FileTypeMagicHeaderBytes;
    (function (FileTypeMagicHeaderBytes) {
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes["SWF"] = 22355] = "SWF";
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes["JPG"] = 16767231] = "JPG";
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes["PNG"] = 8998990] = "PNG";
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes["GIF"] = 4671814] = "GIF";
    })(FileTypeMagicHeaderBytes || (FileTypeMagicHeaderBytes = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='parser/references.ts' />
///<reference path='module.ts'/>
///<reference path='settings.ts'/>
///<reference path='stream.ts' />
///<reference path='mp3decodersession.ts' />
///<reference path='SWFFile.ts' />
///<reference path='ImageFile.ts' />
///<reference path='FileLoader.ts' />
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var Browser;
    (function (Browser) {
        var ShumwayComRtmpSocket = /** @class */ (function () {
            function ShumwayComRtmpSocket(host, port, params) {
                this._socket = ShumwayCom.createRtmpSocket({ host: host, port: port, ssl: params.useSecureTransport });
            }
            Object.defineProperty(ShumwayComRtmpSocket, "isAvailable", {
                get: function () {
                    return !!(typeof ShumwayCom !== 'undefined' && ShumwayCom.createRtmpSocket);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, "onopen", {
                get: function () {
                    return this._onopen;
                },
                set: function (callback) {
                    this._socket.setOpenCallback(this._onopen = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, "ondata", {
                get: function () {
                    return this._ondata;
                },
                set: function (callback) {
                    this._socket.setDataCallback(this._ondata = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, "ondrain", {
                get: function () {
                    return this._ondrain;
                },
                set: function (callback) {
                    this._socket.setDrainCallback(this._ondrain = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, "onerror", {
                get: function () {
                    return this._onerror;
                },
                set: function (callback) {
                    this._socket.setErrorCallback(this._onerror = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, "onclose", {
                get: function () {
                    return this._onclose;
                },
                set: function (callback) {
                    this._socket.setCloseCallback(this._onclose = callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComRtmpSocket.prototype.send = function (buffer, offset, count) {
                return this._socket.send(buffer, offset, count);
            };
            ShumwayComRtmpSocket.prototype.close = function () {
                this._socket.close();
            };
            return ShumwayComRtmpSocket;
        }());
        Browser.ShumwayComRtmpSocket = ShumwayComRtmpSocket;
        var ShumwayComRtmpXHR = /** @class */ (function () {
            function ShumwayComRtmpXHR() {
                this._xhr = ShumwayCom.createRtmpXHR();
            }
            Object.defineProperty(ShumwayComRtmpXHR, "isAvailable", {
                get: function () {
                    return !!(typeof ShumwayCom !== 'undefined' && ShumwayCom.createRtmpXHR);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, "status", {
                get: function () {
                    return this._xhr.status;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, "response", {
                get: function () {
                    return this._xhr.response;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, "responseType", {
                get: function () {
                    return this._xhr.responseType;
                },
                set: function (type) {
                    this._xhr.responseType = type;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, "onload", {
                get: function () {
                    return this._onload;
                },
                set: function (callback) {
                    this._xhr.setLoadCallback(this._onload = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, "onerror", {
                get: function () {
                    return this._onload;
                },
                set: function (callback) {
                    this._xhr.setErrorCallback(this._onerror = callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComRtmpXHR.prototype.open = function (method, path, async) {
                if (async === void 0) { async = true; }
                this._xhr.open(method, path, async);
            };
            ShumwayComRtmpXHR.prototype.setRequestHeader = function (header, value) {
                this._xhr.setRequestHeader(header, value);
            };
            ShumwayComRtmpXHR.prototype.send = function (data) {
                this._xhr.send(data);
            };
            return ShumwayComRtmpXHR;
        }());
        Browser.ShumwayComRtmpXHR = ShumwayComRtmpXHR;
    })(Browser = RtmpJs.Browser || (RtmpJs.Browser = {}));
})(RtmpJs || (RtmpJs = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var MAX_CHUNKED_CHANNEL_BUFFER = 0x80000;
    var RANDOM_DATA_SIZE = 1536;
    var PROTOCOL_VERSION = 3;
    var SET_CHUNK_SIZE_CONTROL_MESSAGE_ID = 1;
    var ABORT_MESSAGE_CONTROL_MESSAGE_ID = 2;
    var ACK_MESSAGE_ID = 3;
    var USER_CONTROL_MESSAGE_ID = 4;
    var ACK_WINDOW_SIZE_MESSAGE_ID = 5;
    var SET_PEER_BANDWIDTH_MESSAGE_ID = 6;
    var CONTROL_CHUNK_STREAM_ID = 2;
    var MIN_CHUNK_STREAM_ID = 3;
    var MAX_CHUNK_STREAM_ID = 65599;
    var MAX_CHUNK_HEADER_SIZE = 18;
    var ChunkedStream = /** @class */ (function () {
        function ChunkedStream(id) {
            this.onmessage = null;
            this.id = id;
            this.buffer = null;
            this.bufferLength = 0;
            this.lastStreamId = -1;
            this.lastTimestamp = 0;
            this.lastLength = 0;
            this.lastTypeId = 0;
            this.lastMessageComplete = false;
            this.waitingForBytes = 0;
            this.sentStreamId = -1;
            this.sentTimestamp = 0;
            this.sentLength = 0;
            this.sentTypeId = 0;
        }
        ChunkedStream.prototype.setBuffer = function (enabled) {
            if (enabled && !this.buffer) {
                this.buffer = new Uint8Array(128);
                this.bufferLength = 0;
            }
            if (!enabled && this.buffer) {
                this.buffer = null;
                this.bufferLength = 0;
            }
        };
        ChunkedStream.prototype.abort = function () {
            if (this.buffer) {
                this.bufferLength = 0;
            }
            else if (!this.lastMessageComplete) {
                this.lastMessageComplete = true;
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: null,
                    firstChunk: false,
                    lastChunk: true
                });
            }
        };
        ChunkedStream.prototype._push = function (data, firstChunk, lastChunk) {
            if (!this.onmessage) {
                return;
            }
            if ((firstChunk && lastChunk) || !this.buffer) {
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: data,
                    firstChunk: firstChunk,
                    lastChunk: lastChunk
                });
                return;
            }
            if (firstChunk) {
                this.bufferLength = 0;
                if (this.lastLength > this.buffer.length) {
                    this.buffer = new Uint8Array(this.lastLength);
                }
            }
            this.buffer.set(data, this.bufferLength);
            this.bufferLength += data.length;
            if (lastChunk) {
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: this.buffer.subarray(0, this.bufferLength),
                    firstChunk: true,
                    lastChunk: true
                });
            }
        };
        return ChunkedStream;
    }());
    RtmpJs.ChunkedStream = ChunkedStream;
    var ChunkedChannel = /** @class */ (function () {
        function ChunkedChannel() {
            this.onusercontrolmessage = null;
            this.onack = null;
            this.ondata = function (data) {
            };
            this.onclose = function () {
            };
            this.oncreated = null;
            this.state = 'uninitialized';
            this.buffer = new Uint8Array(4092);
            this.bufferLength = 0;
            this.chunkSize = 128;
            this.chunkStreams = [];
            this.peerChunkSize = 128;
            this.peerAckWindowSize = 0;
            this.bandwidthLimitType = 0;
            this.windowAckSize = 0;
            this.bytesReceived = 0;
            this.lastAckSent = 0;
        }
        ChunkedChannel.prototype.push = function (data) {
            var newDataLength = data.length + this.bufferLength;
            if (newDataLength > this.buffer.length) {
                var newBufferLength = this.buffer.length * 2;
                while (newDataLength > newBufferLength) {
                    newBufferLength *= 2;
                }
                if (newBufferLength > MAX_CHUNKED_CHANNEL_BUFFER) {
                    this._fail('Buffer overflow');
                }
                var newBuffer = new Uint8Array(newBufferLength);
                newBuffer.set(this.buffer);
                this.buffer = newBuffer;
            }
            for (var i = 0, j = this.bufferLength; i < data.length; i++, j++) {
                this.buffer[j] = data[i];
            }
            this.bufferLength = newDataLength;
            this.bytesReceived += data.length;
            if (this.peerAckWindowSize &&
                (this.bytesReceived - this.lastAckSent) >= this.peerAckWindowSize) {
                this._sendAck();
            }
            while (this.bufferLength > 0) {
                // release || console.log('current bufferLength: ' + this.bufferLength + ' state:' + this.state);
                var shiftBy = 0;
                switch (this.state) {
                    case 'uninitialized':
                        if (this.bufferLength < 1) {
                            return;
                        }
                        this.serverVersion = this.buffer[0];
                        shiftBy = 1;
                        if (this.serverVersion !== PROTOCOL_VERSION) {
                            this._fail('Unsupported protocol version: ' + this.serverVersion);
                        }
                        this.state = 'version_received';
                        break;
                    case 'version_received':
                        if (this.bufferLength < RANDOM_DATA_SIZE) {
                            return;
                        }
                        shiftBy = RANDOM_DATA_SIZE;
                        var timestamp = (Date.now() - this.epochStart) | 0;
                        this.buffer[4] = (timestamp >>> 24) & 0xFF;
                        this.buffer[5] = (timestamp >>> 16) & 0xFF;
                        this.buffer[6] = (timestamp >>> 8) & 0xFF;
                        this.buffer[7] = timestamp & 0xFF;
                        this.ondata(this.buffer.subarray(0, RANDOM_DATA_SIZE));
                        this.state = 'ack_sent';
                        break;
                    case 'ack_sent':
                        if (this.bufferLength < RANDOM_DATA_SIZE) {
                            return;
                        }
                        shiftBy = RANDOM_DATA_SIZE;
                        for (var i = 8; i < RANDOM_DATA_SIZE; i++) {
                            if (this.buffer[i] !== this.randomData[i]) {
                                this._fail('Random data do not match @' + i);
                            }
                        }
                        this.state = 'handshake_done';
                        this.lastAckSent = this.bytesReceived;
                        this._initialize();
                        break;
                    case 'handshake_done':
                        shiftBy = this._parseChunkedData();
                        if (!shiftBy) {
                            return;
                        }
                        break;
                    default:
                        return;
                }
                this.buffer.set(this.buffer.subarray(shiftBy, this.bufferLength), 0);
                this.bufferLength -= shiftBy;
            }
        };
        ChunkedChannel.prototype._initialize = function () {
            var controlStream = this._getChunkStream(CONTROL_CHUNK_STREAM_ID);
            controlStream.setBuffer(true);
            controlStream.onmessage = function (e) {
                if (e.streamId !== 0) {
                    return;
                }
                release || console.log('Control message: ' + e.typeId);
                var ackWindowSize;
                switch (e.typeId) {
                    case SET_CHUNK_SIZE_CONTROL_MESSAGE_ID:
                        var newChunkSize = (e.data[0] << 24) | (e.data[1] << 16) |
                            (e.data[2] << 8) | e.data[3];
                        if (newChunkSize >= 1 && newChunkSize <= 0x7FFFFFFF) {
                            this.peerChunkSize = newChunkSize;
                        }
                        break;
                    case ABORT_MESSAGE_CONTROL_MESSAGE_ID:
                        var chunkStreamId = (e.data[0] << 24) | (e.data[1] << 16) |
                            (e.data[2] << 8) | e.data[3];
                        if (MIN_CHUNK_STREAM_ID <= chunkStreamId &&
                            chunkStreamId <= MAX_CHUNK_STREAM_ID) {
                            var chunkStream = this._getChunkStream(chunkStreamId);
                            chunkStream.abort();
                        }
                        break;
                    case ACK_MESSAGE_ID:
                        if (this.onack) {
                            this.onack();
                        }
                        break;
                    case USER_CONTROL_MESSAGE_ID:
                        if (this.onusercontrolmessage) {
                            this.onusercontrolmessage({
                                type: (e.data[0] << 8) | e.data[1],
                                data: e.data.subarray(2)
                            });
                        }
                        break;
                    case ACK_WINDOW_SIZE_MESSAGE_ID:
                        ackWindowSize = (e.data[0] << 24) | (e.data[1] << 16) |
                            (e.data[2] << 8) | e.data[3];
                        if (ackWindowSize < 0) {
                            break;
                        }
                        this.peerAckWindowSize = ackWindowSize;
                        break;
                    case SET_PEER_BANDWIDTH_MESSAGE_ID:
                        ackWindowSize = (e.data[0] << 24) | (e.data[1] << 16) |
                            (e.data[2] << 8) | e.data[3];
                        var limitType = e.data[4];
                        if (ackWindowSize < 0 || limitType > 2) {
                            break;
                        }
                        if (limitType === 1 ||
                            (limitType === 2 && this.bandwidthLimitType === 1)) {
                            ackWindowSize = Math.min(this.windowAckSize, ackWindowSize);
                        }
                        if (ackWindowSize !== this.ackWindowSize) {
                            this.ackWindowSize = ackWindowSize;
                            var ackData = new Uint8Array([(ackWindowSize >>> 24) & 0xFF,
                                (ackWindowSize >>> 16) & 0xFF,
                                (ackWindowSize >>> 8) & 0xFF,
                                ackWindowSize & 0xFF]);
                            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                                typeId: ACK_WINDOW_SIZE_MESSAGE_ID,
                                streamId: 0,
                                data: ackData
                            });
                            if (limitType !== 2) {
                                this.bandwidthLimitType = limitType;
                            }
                        }
                        break;
                }
            }.bind(this);
            if (this.oncreated) {
                this.oncreated();
            }
        };
        ChunkedChannel.prototype.setChunkSize = function (chunkSize) {
            if (chunkSize < 1 || chunkSize > 0x7FFFFFFF) {
                throw new Error('Invalid chunk size');
            }
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                streamId: 0,
                typeId: SET_CHUNK_SIZE_CONTROL_MESSAGE_ID,
                data: new Uint8Array([(chunkSize >>> 24) & 0xFF,
                    (chunkSize >>> 16) & 0xFF,
                    (chunkSize >>> 8) & 0xFF,
                    chunkSize & 0xFF])
            });
            this.chunkSize = chunkSize;
        };
        ChunkedChannel.prototype.send = function (chunkStreamId, message) {
            if (chunkStreamId < MIN_CHUNK_STREAM_ID ||
                chunkStreamId > MAX_CHUNK_STREAM_ID) {
                throw new Error('Invalid chunkStreamId');
            }
            return this._sendMessage(chunkStreamId, message);
        };
        ChunkedChannel.prototype.sendUserControlMessage = function (type, data) {
            var eventData = new Uint8Array(2 + data.length);
            eventData[0] = (type >> 8) & 0xFF;
            eventData[1] = type & 0xFF;
            eventData.set(data, 2);
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                typeId: USER_CONTROL_MESSAGE_ID,
                streamId: 0,
                data: eventData
            });
        };
        ChunkedChannel.prototype._sendAck = function () {
            var ackData = new Uint8Array([(this.bytesReceived >>> 24) & 0xFF,
                (this.bytesReceived >>> 16) & 0xFF,
                (this.bytesReceived >>> 8) & 0xFF,
                this.bytesReceived & 0xFF]);
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                typeId: ACK_MESSAGE_ID,
                streamId: 0,
                data: ackData
            });
        };
        ChunkedChannel.prototype._sendMessage = function (chunkStreamId, message) {
            var data = message.data;
            var messageLength = data.length;
            var chunkStream = this._getChunkStream(chunkStreamId);
            var timestamp = ('timestamp' in message ? message.timestamp : (Date.now() - this.epochStart)) | 0;
            var timestampDelta = (timestamp - chunkStream.sentTimestamp) | 0;
            var buffer = new Uint8Array(this.chunkSize + MAX_CHUNK_HEADER_SIZE);
            var chunkStreamIdSize;
            if (chunkStreamId < 64) {
                chunkStreamIdSize = 1;
                buffer[0] = chunkStreamId;
            }
            else if (chunkStreamId < 320) {
                chunkStreamIdSize = 2;
                buffer[0] = 0;
                buffer[1] = chunkStreamId - 64;
            }
            else {
                chunkStreamIdSize = 3;
                buffer[0] = 1;
                buffer[1] = ((chunkStreamId - 64) >> 8) & 0xFF;
                buffer[2] = (chunkStreamId - 64) & 0xFF;
            }
            var position = chunkStreamIdSize;
            var extendTimestamp = 0;
            if (message.streamId !== chunkStream.sentStreamId || timestampDelta < 0) {
                // chunk type 0
                if ((timestamp & 0xFF000000) !== 0) {
                    extendTimestamp = timestamp;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 0xFF;
                }
                else {
                    buffer[position] = (timestamp >> 16) & 0xFF;
                    buffer[position + 1] = (timestamp >> 8) & 0xFF;
                    buffer[position + 2] = timestamp & 0xFF;
                }
                position += 3;
                buffer[position++] = (messageLength >> 16) & 0xFF;
                buffer[position++] = (messageLength >> 8) & 0xFF;
                buffer[position++] = messageLength & 0xFF;
                buffer[position++] = message.typeId;
                buffer[position++] = message.streamId & 0xFF; // little-endian
                buffer[position++] = (message.streamId >> 8) & 0xFF;
                buffer[position++] = (message.streamId >> 16) & 0xFF;
                buffer[position++] = (message.streamId >> 24) & 0xFF;
            }
            else if (messageLength !== chunkStream.sentLength ||
                message.typeId !== chunkStream.sentTypeId) {
                // chunk type 1
                buffer[0] |= 0x40;
                if ((timestampDelta & 0xFF000000) !== 0) {
                    extendTimestamp = timestampDelta;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 0xFF;
                }
                else {
                    buffer[position] = (timestampDelta >> 16) & 0xFF;
                    buffer[position + 1] = (timestampDelta >> 8) & 0xFF;
                    buffer[position + 2] = timestampDelta & 0xFF;
                }
                position += 3;
                buffer[position++] = (messageLength >> 16) & 0xFF;
                buffer[position++] = (messageLength >> 8) & 0xFF;
                buffer[position++] = messageLength & 0xFF;
                buffer[position++] = message.typeId;
            }
            else if (timestampDelta !== 0) {
                // chunk type 2
                buffer[0] |= 0x80;
                if ((timestampDelta & 0xFF000000) !== 0) {
                    extendTimestamp = timestampDelta;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 0xFF;
                }
                else {
                    buffer[position] = (timestampDelta >> 16) & 0xFF;
                    buffer[position + 1] = (timestampDelta >> 8) & 0xFF;
                    buffer[position + 2] = timestampDelta & 0xFF;
                }
                position += 3;
            }
            else {
                // chunk type 3
                buffer[0] |= 0xC0;
            }
            if (extendTimestamp) {
                buffer[position++] = (extendTimestamp >>> 24) & 0xFF;
                buffer[position++] = (extendTimestamp >>> 16) & 0xFF;
                buffer[position++] = (extendTimestamp >>> 8) & 0xFF;
                buffer[position++] = extendTimestamp & 0xFF;
            }
            chunkStream.sentTimestamp = timestamp;
            chunkStream.sentStreamId = message.streamId;
            chunkStream.sentTypeId = message.typeId;
            chunkStream.sentLength = messageLength;
            var sent = 0;
            while (sent < messageLength) {
                var currentChunkLength = Math.min(messageLength - sent, this.chunkSize);
                buffer.set(data.subarray(sent, sent + currentChunkLength), position);
                sent += currentChunkLength;
                this.ondata(buffer.subarray(0, position + currentChunkLength));
                // reset position and chunk type
                buffer[0] |= 0xC0;
                position = chunkStreamIdSize;
            }
            return timestamp;
        };
        ChunkedChannel.prototype._getChunkStream = function (id) {
            var chunkStream = this.chunkStreams[id];
            if (!chunkStream) {
                this.chunkStreams[id] = chunkStream = new ChunkedStream(id);
                chunkStream.setBuffer(true);
                chunkStream.onmessage = function (message) {
                    if (this.onmessage) {
                        this.onmessage(message);
                    }
                }.bind(this);
            }
            return chunkStream;
        };
        ChunkedChannel.prototype._parseChunkedData = function () {
            if (this.bufferLength < 1) {
                return 0;
            }
            var chunkType = (this.buffer[0] >> 6) & 3;
            var chunkHeaderPosition = 1;
            var chunkStreamId = this.buffer[0] & 0x3F;
            if (chunkStreamId === 0) {
                if (this.bufferLength < 2) {
                    return 0;
                }
                chunkStreamId = this.buffer[1] + 64;
                chunkHeaderPosition = 2;
            }
            else if (chunkStreamId === 1) {
                if (this.bufferLength < 2) {
                    return 0;
                }
                chunkStreamId = (this.buffer[1] << 8) + this.buffer[2] + 64;
                chunkHeaderPosition = 3;
            }
            var chunkHeaderSize = chunkType === 0 ? 11 : chunkType === 1 ? 7 :
                chunkType === 2 ? 3 : 0;
            if (this.bufferLength < chunkHeaderPosition + chunkHeaderSize) {
                return 0;
            }
            var extendTimestampSize = chunkType !== 3 &&
                this.buffer[chunkHeaderPosition] === 0xFF &&
                this.buffer[chunkHeaderPosition + 1] === 0xFF &&
                this.buffer[chunkHeaderPosition + 2] === 0xFF ? 4 : 0;
            var totalChunkHeaderSize = chunkHeaderPosition + chunkHeaderSize +
                extendTimestampSize;
            if (this.bufferLength < totalChunkHeaderSize) {
                return 0;
            }
            var chunkStream = this._getChunkStream(chunkStreamId);
            var chunkTimestamp;
            if (chunkType === 3) {
                chunkTimestamp = chunkStream.lastTimestamp;
            }
            else {
                chunkTimestamp = (this.buffer[chunkHeaderPosition] << 16) |
                    (this.buffer[chunkHeaderPosition + 1] << 8) |
                    this.buffer[chunkHeaderPosition + 2];
            }
            if (extendTimestampSize) {
                var chunkTimestampPosition = chunkHeaderPosition + chunkHeaderSize;
                chunkTimestamp = (this.buffer[chunkTimestampPosition] << 24) |
                    (this.buffer[chunkTimestampPosition + 1] << 16) |
                    (this.buffer[chunkTimestampPosition + 2] << 8) |
                    this.buffer[chunkTimestampPosition + 3];
            }
            if (chunkType === 1 || chunkType === 2) {
                chunkTimestamp = (chunkStream.lastTimestamp + chunkTimestamp) | 0;
            }
            var messageLength = chunkStream.lastLength;
            var messageTypeId = chunkStream.lastTypeId;
            var messageStreamId = chunkStream.lastStreamId;
            if (chunkType === 0 || chunkType === 1) {
                messageLength = (this.buffer[chunkHeaderPosition + 3] << 16) |
                    (this.buffer[chunkHeaderPosition + 4] << 8) |
                    this.buffer[chunkHeaderPosition + 5];
                messageTypeId = this.buffer[chunkHeaderPosition + 6];
            }
            if (chunkType === 0) {
                // little-endian
                messageStreamId = (this.buffer[chunkHeaderPosition + 10] << 24) |
                    (this.buffer[chunkHeaderPosition + 9] << 16) |
                    (this.buffer[chunkHeaderPosition + 8] << 8) |
                    this.buffer[chunkHeaderPosition + 7];
            }
            var read, tailLength, firstChunk;
            if (chunkType === 3 && chunkStream.waitingForBytes) {
                firstChunk = false;
                read = Math.min(chunkStream.waitingForBytes, this.peerChunkSize);
                tailLength = chunkStream.waitingForBytes - read;
            }
            else {
                firstChunk = true;
                read = Math.min(messageLength, this.peerChunkSize);
                tailLength = messageLength - read;
            }
            if (this.bufferLength < totalChunkHeaderSize + read) {
                return 0;
            }
            release || (!firstChunk && tailLength) || // limiting trace to first/last chunks
                console.log('Chunk received: cs:' + chunkStreamId + '; ' +
                    'f/l:' + firstChunk + '/' + (!tailLength) + ';  len:' + messageLength);
            chunkStream.lastTimestamp = chunkTimestamp;
            chunkStream.lastLength = messageLength;
            chunkStream.lastTypeId = messageTypeId;
            chunkStream.lastStreamId = messageStreamId;
            chunkStream.lastMessageComplete = !tailLength;
            chunkStream.waitingForBytes = tailLength;
            chunkStream._push(this.buffer.subarray(totalChunkHeaderSize, totalChunkHeaderSize + read), firstChunk, !tailLength);
            return totalChunkHeaderSize + read;
        };
        ChunkedChannel.prototype.start = function () {
            this.epochStart = Date.now();
            this.ondata(new Uint8Array([PROTOCOL_VERSION])); // c0
            this.randomData = new Uint8Array(RANDOM_DATA_SIZE);
            this.randomData[0] = 0;
            this.randomData[1] = 0;
            this.randomData[2] = 0;
            this.randomData[3] = 0;
            for (var i = 8; i < RANDOM_DATA_SIZE; i++) {
                this.randomData[i] = (Math.random() * 256) | 0;
            }
            this.ondata(this.randomData); // c1
            console.log('## connected');
        };
        ChunkedChannel.prototype.stop = function (error) {
            if (error) {
                console.error('socket error!!!');
            }
            console.log('## closed');
        };
        ChunkedChannel.prototype._fail = function (message) {
            console.error('failed: ' + message);
            this.state = 'failed';
            this.onclose();
            throw new Error(message);
        };
        return ChunkedChannel;
    }());
    RtmpJs.ChunkedChannel = ChunkedChannel;
})(RtmpJs || (RtmpJs = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var flash = Shumway.flash;
    var TRANSPORT_ENCODING = 0;
    var MAIN_CHUNKED_STREAM_ID = 3;
    var CONNECT_TRANSACTION_ID = 1;
    var DEFAULT_STREAM_ID = 0;
    var COMMAND_MESSAGE_AMF0_ID = 20;
    var COMMAND_MESSAGE_AMF3_ID = 17;
    var SET_BUFFER_CONTROL_MESSAGE_ID = 3;
    var PING_REQUEST_CONTROL_MESSAGE_ID = 6;
    var PING_RESPONSE_CONTROL_MESSAGE_ID = 7;
    var BaseTransport = /** @class */ (function () {
        function BaseTransport() {
            this._streams = [];
        }
        BaseTransport.prototype.connect = function (properties, args) {
            throw new Error('Abstract BaseTransport.connect method');
        };
        BaseTransport.prototype._initChannel = function (properties, args) {
            var channel = new RtmpJs.ChunkedChannel();
            var transport = this;
            channel.oncreated = function () {
                var ba = new flash.utils.ByteArray();
                ba.objectEncoding = TRANSPORT_ENCODING;
                ba.writeObject('connect');
                ba.writeObject(CONNECT_TRANSACTION_ID);
                ba.writeObject(properties);
                ba.writeObject(args || null);
                release || console.log('.. Connect sent');
                channel.send(MAIN_CHUNKED_STREAM_ID, {
                    streamId: DEFAULT_STREAM_ID,
                    typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                    data: new Uint8Array(ba._buffer, 0, ba.length)
                });
            };
            channel.onmessage = function (message) {
                release || console.log('.. Data received: typeId:' + message.typeId +
                    ', streamId:' + message.streamId +
                    ', cs: ' + message.chunkedStreamId);
                if (message.streamId !== 0) {
                    transport._streams[message.streamId]._push(message);
                    return;
                }
                if (message.typeId === COMMAND_MESSAGE_AMF0_ID ||
                    message.typeId === COMMAND_MESSAGE_AMF3_ID) {
                    var ba = new flash.utils.ByteArray();
                    ba.writeRawBytes(message.data);
                    ba.position = 0;
                    ba.objectEncoding = message.typeId === COMMAND_MESSAGE_AMF0_ID ? 0 : 3;
                    var commandName = ba.readObject();
                    if (commandName === undefined) {
                        ba.objectEncoding = 0;
                        commandName = ba.readObject();
                    }
                    var transactionId = ba.readObject();
                    if (commandName === '_result' || commandName === '_error') {
                        var isError = commandName === '_error';
                        if (transactionId === CONNECT_TRANSACTION_ID) {
                            var properties_1 = ba.readObject();
                            var information = ba.readObject();
                            if (transport.onconnected) {
                                transport.onconnected({
                                    properties: properties_1,
                                    information: information,
                                    isError: isError
                                });
                            }
                        }
                        else {
                            var commandObject = ba.readObject();
                            var streamId = ba.readObject();
                            if (transport.onstreamcreated) {
                                var stream = new NetStream(transport, streamId);
                                transport._streams[streamId] = stream;
                                transport.onstreamcreated({
                                    transactionId: transactionId,
                                    commandObject: commandObject,
                                    streamId: streamId,
                                    stream: stream,
                                    isError: isError
                                });
                            }
                        }
                    }
                    else if (commandName === 'onBWCheck' || commandName === 'onBWDone') {
                        // TODO skipping those for now
                        transport.sendCommandOrResponse('_error', transactionId, null, { code: 'NetConnection.Call.Failed', level: 'error' });
                    }
                    else {
                        var commandObject = ba.readObject();
                        var response = ba.position < ba.length ? ba.readObject() : undefined;
                        if (transport.onresponse) {
                            transport.onresponse({
                                commandName: commandName,
                                transactionId: transactionId,
                                commandObject: commandObject,
                                response: response
                            });
                        }
                    }
                    return;
                }
                // TODO misc messages
            };
            channel.onusercontrolmessage = function (e) {
                release || console.log('.. Event ' + e.type + ' +' + e.data.length + ' bytes');
                if (e.type === PING_REQUEST_CONTROL_MESSAGE_ID) {
                    channel.sendUserControlMessage(PING_RESPONSE_CONTROL_MESSAGE_ID, e.data);
                }
                if (transport.onevent) {
                    transport.onevent({ type: e.type, data: e.data });
                }
            };
            return (this.channel = channel);
        };
        BaseTransport.prototype.call = function (procedureName, transactionId, commandObject, args) {
            var channel = this.channel;
            var ba = new flash.utils.ByteArray();
            ba.objectEncoding = TRANSPORT_ENCODING;
            ba.writeObject(procedureName);
            ba.writeObject(transactionId);
            ba.writeObject(commandObject);
            ba.writeObject(args);
            channel.send(MAIN_CHUNKED_STREAM_ID, {
                streamId: DEFAULT_STREAM_ID,
                typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                data: new Uint8Array(ba._buffer, 0, ba.length)
            });
        };
        BaseTransport.prototype.createStream = function (transactionId, commandObject) {
            this.sendCommandOrResponse('createStream', transactionId, commandObject);
        };
        BaseTransport.prototype.sendCommandOrResponse = function (commandName, transactionId, commandObject, response) {
            var channel = this.channel;
            var ba = new flash.utils.ByteArray();
            ba.writeByte(0); // ???
            ba.objectEncoding = 0; // TRANSPORT_ENCODING;
            ba.writeObject(commandName);
            ba.writeObject(transactionId);
            ba.writeObject(commandObject || null);
            if (arguments.length > 3) {
                ba.writeObject(response);
            }
            channel.send(MAIN_CHUNKED_STREAM_ID, {
                streamId: DEFAULT_STREAM_ID,
                typeId: COMMAND_MESSAGE_AMF3_ID,
                data: new Uint8Array(ba._buffer, 0, ba.length)
            });
            /*     // really weird that this does not work
             let ba = new flash.utils.ByteArray();
             ba.objectEncoding = TRANSPORT_ENCODING;
             ba.writeObject('createStream');
             ba.writeObject(transactionId);
             ba.writeObject(commandObject || null);
             channel.send(MAIN_CHUNKED_STREAM_ID, {
             streamId: DEFAULT_STREAM_ID,
             typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
             data: new Uint8Array((<any> ba)._buffer, 0, (<any> ba).length)
             });
             */
        };
        BaseTransport.prototype._setBuffer = function (streamId, ms) {
            this.channel.sendUserControlMessage(SET_BUFFER_CONTROL_MESSAGE_ID, new Uint8Array([
                (streamId >> 24) & 0xFF,
                (streamId >> 16) & 0xFF,
                (streamId >> 8) & 0xFF,
                streamId & 0xFF,
                (ms >> 24) & 0xFF,
                (ms >> 16) & 0xFF,
                (ms >> 8) & 0xFF,
                ms & 0xFF
            ]));
        };
        BaseTransport.prototype._sendCommand = function (streamId, data) {
            this.channel.send(8, {
                streamId: streamId,
                typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                data: data
            });
        };
        return BaseTransport;
    }());
    RtmpJs.BaseTransport = BaseTransport;
    var DEFAULT_BUFFER_LENGTH = 100; // ms
    var NetStream = /** @class */ (function () {
        function NetStream(transport, streamId) {
            this.transport = transport;
            this.streamId = streamId;
        }
        NetStream.prototype.play = function (name, start, duration, reset) {
            var ba = new flash.utils.ByteArray();
            ba.objectEncoding = TRANSPORT_ENCODING;
            ba.writeObject('play');
            ba.writeObject(0);
            ba.writeObject(null);
            ba.writeObject(name);
            if (arguments.length > 1) {
                ba.writeObject(start);
            }
            if (arguments.length > 2) {
                ba.writeObject(duration);
            }
            if (arguments.length > 3) {
                ba.writeObject(reset);
            }
            this.transport._sendCommand(this.streamId, new Uint8Array(ba._buffer, 0, ba.length));
            // set the buffer, otherwise it will stop in ~15 sec
            this.transport._setBuffer(this.streamId, DEFAULT_BUFFER_LENGTH);
        };
        NetStream.prototype._push = function (message) {
            switch (message.typeId) {
                case 8:
                case 9:
                    if (this.ondata) {
                        this.ondata(message);
                    }
                    break;
                case 18:
                case 20:
                    var args = [];
                    var ba = new flash.utils.ByteArray();
                    ba.writeRawBytes(message.data);
                    ba.position = 0;
                    ba.objectEncoding = 0;
                    while (ba.position < ba.length) {
                        args.push(ba.readObject());
                    }
                    if (message.typeId === 18 && this.onscriptdata) {
                        this.onscriptdata.apply(this, args);
                    }
                    if (message.typeId === 20 && this.oncallback) {
                        this.oncallback.apply(this, args);
                    }
                    break;
            }
        };
        return NetStream;
    }());
    function parseConnectionString(s) {
        // The s has to have the following format:
        //   protocol:[//host][:port]/appname[/instanceName]
        var protocolSeparatorIndex = s.indexOf(':');
        if (protocolSeparatorIndex < 0) {
            return null; // no protocol
        }
        if (s[protocolSeparatorIndex + 1] !== '/') {
            return null; // shall have '/' after protocol
        }
        var protocol = s.substring(0, protocolSeparatorIndex).toLocaleLowerCase();
        if (protocol !== 'rtmp' && protocol !== 'rtmpt' && protocol !== 'rtmps' &&
            protocol !== 'rtmpe' && protocol !== 'rtmpte' && protocol !== 'rtmfp') {
            return null;
        }
        var host, port;
        var appnameSeparator = protocolSeparatorIndex + 1;
        if (s[protocolSeparatorIndex + 2] === '/') {
            // has host
            appnameSeparator = s.indexOf('/', protocolSeparatorIndex + 3);
            if (appnameSeparator < 0) {
                return undefined; // has host but no appname
            }
            var portSeparator = s.indexOf(':', protocolSeparatorIndex + 1);
            if (portSeparator >= 0 && portSeparator < appnameSeparator) {
                host = s.substring(protocolSeparatorIndex + 3, portSeparator);
                port = +s.substring(portSeparator + 1, appnameSeparator);
            }
            else {
                host = s.substring(protocolSeparatorIndex + 3, appnameSeparator);
            }
        }
        var app = s.substring(appnameSeparator + 1);
        return {
            protocol: protocol,
            host: host,
            port: port,
            app: app
        };
    }
    RtmpJs.parseConnectionString = parseConnectionString;
})(RtmpJs || (RtmpJs = {}));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var Browser;
    (function (Browser) {
        var DEFAULT_RTMP_PORT = 1935;
        var COMBINE_RTMPT_DATA = true;
        var RtmpTransport = /** @class */ (function (_super) {
            __extends(RtmpTransport, _super);
            function RtmpTransport(connectionSettings) {
                var _this = _super.call(this) || this;
                if (typeof connectionSettings === 'string') {
                    connectionSettings = { host: connectionSettings };
                }
                _this.host = connectionSettings.host || 'localhost';
                _this.port = connectionSettings.port || DEFAULT_RTMP_PORT;
                _this.ssl = !!connectionSettings.ssl || false;
                return _this;
            }
            RtmpTransport.prototype.connect = function (properties, args) {
                var TCPSocket = typeof navigator !== 'undefined' &&
                    navigator.mozTCPSocket;
                if (!TCPSocket) {
                    throw new Error('Your browser does not support socket communication.\n' +
                        'Currenly only Firefox with enabled mozTCPSocket is allowed (see README.md).');
                }
                var channel = this._initChannel(properties, args);
                var writeQueue = [], socketError = false;
                var socket = typeof Browser.ShumwayComRtmpSocket !== 'undefined' && Browser.ShumwayComRtmpSocket.isAvailable ?
                    new Browser.ShumwayComRtmpSocket(this.host, this.port, {
                        useSecureTransport: this.ssl,
                        binaryType: 'arraybuffer'
                    }) :
                    TCPSocket.open(this.host, this.port, { useSecureTransport: this.ssl, binaryType: 'arraybuffer' });
                var sendData = function (data) {
                    return socket.send(data.buffer, data.byteOffset, data.byteLength);
                };
                socket.onopen = function (e) {
                    channel.ondata = function (data) {
                        var buf = new Uint8Array(data);
                        writeQueue.push(buf);
                        if (writeQueue.length > 1) {
                            return;
                        }
                        release || console.log('Bytes written: ' + buf.length);
                        if (sendData(buf)) {
                            writeQueue.shift();
                        }
                    };
                    channel.onclose = function () {
                        socket.close();
                    };
                    channel.start();
                };
                socket.ondrain = function (e) {
                    writeQueue.shift();
                    release || console.log('Write completed');
                    while (writeQueue.length > 0) {
                        release || console.log('Bytes written: ' + writeQueue[0].length);
                        if (!sendData(writeQueue[0])) {
                            break;
                        }
                        writeQueue.shift();
                    }
                };
                socket.onclose = function (e) {
                    channel.stop(socketError);
                };
                socket.onerror = function (e) {
                    socketError = true;
                    console.error('socket error: ' + e.data);
                };
                socket.ondata = function (e) {
                    release || console.log('Bytes read: ' + e.data.byteLength);
                    channel.push(new Uint8Array(e.data));
                };
            };
            return RtmpTransport;
        }(RtmpJs.BaseTransport));
        Browser.RtmpTransport = RtmpTransport;
        /*
         * RtmptTransport uses systemXHR to send HTTP requests.
         * See https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#XMLHttpRequest%28%29 and
         * https://github.com/mozilla-b2g/gaia/blob/master/apps/email/README.md#running-in-firefox
         *
         * Spec at http://red5.electroteque.org/dev/doc/html/rtmpt.html
         */
        var RtmptTransport = /** @class */ (function (_super) {
            __extends(RtmptTransport, _super);
            function RtmptTransport(connectionSettings) {
                var _this = _super.call(this) || this;
                var host = connectionSettings.host || 'localhost';
                var url = (connectionSettings.ssl ? 'https' : 'http') + '://' + host;
                if (connectionSettings.port) {
                    url += ':' + connectionSettings.port;
                }
                _this.baseUrl = url;
                _this.stopped = false;
                _this.sessionId = null;
                _this.requestId = 0;
                _this.data = [];
                return _this;
            }
            RtmptTransport.prototype.connect = function (properties, args) {
                var channel = this._initChannel(properties, args);
                channel.ondata = function (data) {
                    release || console.log('Bytes written: ' + data.length);
                    this.data.push(new Uint8Array(data));
                }.bind(this);
                channel.onclose = function () {
                    this.stopped = true;
                }.bind(this);
                post(this.baseUrl + '/fcs/ident2', null, function (data, status) {
                    if (status !== 404) {
                        throw new Error('Unexpected response: ' + status);
                    }
                    post(this.baseUrl + '/open/1', null, function (data, status) {
                        this.sessionId = String.fromCharCode.apply(null, data).slice(0, -1); // - '\n'
                        console.log('session id: ' + this.sessionId);
                        this.tick();
                        channel.start();
                    }.bind(this));
                }.bind(this));
            };
            RtmptTransport.prototype.tick = function () {
                var continueSend = function (data, status) {
                    if (status !== 200) {
                        throw new Error('Invalid HTTP status');
                    }
                    var idle = data[0];
                    if (data.length > 1) {
                        this.channel.push(data.subarray(1));
                    }
                    setTimeout(this.tick.bind(this), idle * 16);
                }.bind(this);
                if (this.stopped) {
                    post(this.baseUrl + '/close/2', null, function () {
                        // do nothing
                    });
                    return;
                }
                if (this.data.length > 0) {
                    var data_1;
                    if (COMBINE_RTMPT_DATA) {
                        var length_5 = 0;
                        this.data.forEach(function (i) {
                            length_5 += i.length;
                        });
                        var pos_1 = 0;
                        data_1 = new Uint8Array(length_5);
                        this.data.forEach(function (i) {
                            data_1.set(i, pos_1);
                            pos_1 += i.length;
                        });
                        this.data.length = 0;
                    }
                    else {
                        data_1 = this.data.shift();
                    }
                    post(this.baseUrl + '/send/' + this.sessionId + '/' + (this.requestId++), data_1, continueSend);
                }
                else {
                    post(this.baseUrl + '/idle/' + this.sessionId + '/' + (this.requestId++), null, continueSend);
                }
            };
            return RtmptTransport;
        }(RtmpJs.BaseTransport));
        Browser.RtmptTransport = RtmptTransport;
        var emptyPostData = new Uint8Array([0]);
        function post(path, data, onload) {
            data || (data = emptyPostData);
            var xhr = typeof Browser.ShumwayComRtmpXHR !== 'undefined' && Browser.ShumwayComRtmpXHR.isAvailable ?
                new Browser.ShumwayComRtmpXHR() : new XMLHttpRequest({ mozSystem: true });
            xhr.open('POST', path, true);
            xhr.responseType = 'arraybuffer';
            xhr.setRequestHeader('Content-Type', 'application/x-fcs');
            xhr.onload = function (e) {
                onload(new Uint8Array(xhr.response), xhr.status);
            };
            xhr.onerror = function (e) {
                console.log('error');
                throw new Error('HTTP error');
            };
            xhr.send(data);
        }
    })(Browser = RtmpJs.Browser || (RtmpJs.Browser = {}));
})(RtmpJs || (RtmpJs = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var MP4;
    (function (MP4) {
        var Iso;
        (function (Iso) {
            var utf8decode = Shumway.StringUtilities.utf8decode;
            var START_DATE = -2082844800000;
            /* midnight after Jan. 1, 1904 */
            var DEFAULT_MOVIE_MATRIX = [1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0];
            var DEFAULT_OP_COLOR = [0, 0, 0];
            function concatArrays(arg0) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return Array.prototype.concat.apply(arg0, args);
            }
            function writeInt32(data, offset, value) {
                data[offset] = (value >> 24) & 255;
                data[offset + 1] = (value >> 16) & 255;
                data[offset + 2] = (value >> 8) & 255;
                data[offset + 3] = value & 255;
            }
            function decodeInt32(s) {
                return (s.charCodeAt(0) << 24) | (s.charCodeAt(1) << 16) |
                    (s.charCodeAt(2) << 8) | s.charCodeAt(3);
            }
            function encodeDate(d) {
                return ((d - START_DATE) / 1000) | 0;
            }
            function encodeFloat_16_16(f) {
                return (f * 0x10000) | 0;
            }
            function encodeFloat_2_30(f) {
                return (f * 0x40000000) | 0;
            }
            function encodeFloat_8_8(f) {
                return (f * 0x100) | 0;
            }
            function encodeLang(s) {
                return ((s.charCodeAt(0) & 0x1F) << 10) | ((s.charCodeAt(1) & 0x1F) << 5) | (s.charCodeAt(2) & 0x1F);
            }
            var Box = /** @class */ (function () {
                function Box(boxtype, extendedType) {
                    this.boxtype = boxtype;
                    if (boxtype === 'uuid') {
                        this.userType = extendedType;
                    }
                }
                /**
                 * @param offset Position where writing will start in the output array
                 * @returns {number} Size of the written data
                 */
                Box.prototype.layout = function (offset) {
                    this.offset = offset;
                    var size = 8;
                    if (this.userType) {
                        size += 16;
                    }
                    this.size = size;
                    return size;
                };
                /**
                 * @param data Output array
                 * @returns {number} Amount of written bytes by this Box and its children only.
                 */
                Box.prototype.write = function (data) {
                    writeInt32(data, this.offset, this.size);
                    writeInt32(data, this.offset + 4, decodeInt32(this.boxtype));
                    if (!this.userType) {
                        return 8;
                    }
                    data.set(this.userType, this.offset + 8);
                    return 24;
                };
                Box.prototype.toUint8Array = function () {
                    var size = this.layout(0);
                    var data = new Uint8Array(size);
                    this.write(data);
                    return data;
                };
                return Box;
            }());
            Iso.Box = Box;
            var FullBox = /** @class */ (function (_super) {
                __extends(FullBox, _super);
                function FullBox(boxtype, version, flags) {
                    if (version === void 0) { version = 0; }
                    if (flags === void 0) { flags = 0; }
                    var _this = _super.call(this, boxtype) || this;
                    _this.version = version;
                    _this.flags = flags;
                    return _this;
                }
                FullBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                FullBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, (this.version << 24) | this.flags);
                    return offset + 4;
                };
                return FullBox;
            }(Box));
            Iso.FullBox = FullBox;
            var FileTypeBox = /** @class */ (function (_super) {
                __extends(FileTypeBox, _super);
                function FileTypeBox(majorBrand, minorVersion, compatibleBrands) {
                    var _this = _super.call(this, 'ftype') || this;
                    _this.majorBrand = majorBrand;
                    _this.minorVersion = minorVersion;
                    _this.compatibleBrands = compatibleBrands;
                    return _this;
                }
                FileTypeBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4 * (2 + this.compatibleBrands.length);
                    return this.size;
                };
                FileTypeBox.prototype.write = function (data) {
                    var _this = this;
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, decodeInt32(this.majorBrand));
                    writeInt32(data, this.offset + offset + 4, this.minorVersion);
                    offset += 8;
                    this.compatibleBrands.forEach(function (brand) {
                        writeInt32(data, _this.offset + offset, decodeInt32(brand));
                        offset += 4;
                    }, this);
                    return offset;
                };
                return FileTypeBox;
            }(Box));
            Iso.FileTypeBox = FileTypeBox;
            var BoxContainerBox = /** @class */ (function (_super) {
                __extends(BoxContainerBox, _super);
                function BoxContainerBox(type, children) {
                    var _this = _super.call(this, type) || this;
                    _this.children = children;
                    return _this;
                }
                BoxContainerBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    this.children.forEach(function (child) {
                        if (!child) {
                            return; // skipping undefined
                        }
                        size += child.layout(offset + size);
                    });
                    return (this.size = size);
                };
                BoxContainerBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    this.children.forEach(function (child) {
                        if (!child) {
                            return; // skipping undefined
                        }
                        offset += child.write(data);
                    });
                    return offset;
                };
                return BoxContainerBox;
            }(Box));
            Iso.BoxContainerBox = BoxContainerBox;
            var MovieBox = /** @class */ (function (_super) {
                __extends(MovieBox, _super);
                function MovieBox(header, tracks, extendsBox, userData) {
                    var _this = _super.call(this, 'moov', concatArrays([header], tracks, [extendsBox, userData])) || this;
                    _this.header = header;
                    _this.tracks = tracks;
                    _this.extendsBox = extendsBox;
                    _this.userData = userData;
                    return _this;
                }
                return MovieBox;
            }(BoxContainerBox));
            Iso.MovieBox = MovieBox;
            var MovieHeaderBox = /** @class */ (function (_super) {
                __extends(MovieHeaderBox, _super);
                function MovieHeaderBox(timescale, duration, nextTrackId, rate, volume, matrix, creationTime, modificationTime) {
                    if (rate === void 0) { rate = 1.0; }
                    if (volume === void 0) { volume = 1.0; }
                    if (matrix === void 0) { matrix = DEFAULT_MOVIE_MATRIX; }
                    if (creationTime === void 0) { creationTime = START_DATE; }
                    if (modificationTime === void 0) { modificationTime = START_DATE; }
                    var _this = _super.call(this, 'mvhd', 0, 0) || this;
                    _this.timescale = timescale;
                    _this.duration = duration;
                    _this.nextTrackId = nextTrackId;
                    _this.rate = rate;
                    _this.volume = volume;
                    _this.matrix = matrix;
                    _this.creationTime = creationTime;
                    _this.modificationTime = modificationTime;
                    return _this;
                }
                MovieHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 16 + 4 + 2 + 2 + 8 + 36 + 24 + 4;
                    return this.size;
                };
                MovieHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.timescale);
                    writeInt32(data, this.offset + offset + 12, this.duration);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.rate));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_8_8(this.volume) << 16);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.matrix[0]));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.matrix[1]));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.matrix[2]));
                    writeInt32(data, this.offset + offset + 12, encodeFloat_16_16(this.matrix[3]));
                    writeInt32(data, this.offset + offset + 16, encodeFloat_16_16(this.matrix[4]));
                    writeInt32(data, this.offset + offset + 20, encodeFloat_16_16(this.matrix[5]));
                    writeInt32(data, this.offset + offset + 24, encodeFloat_2_30(this.matrix[6]));
                    writeInt32(data, this.offset + offset + 28, encodeFloat_2_30(this.matrix[7]));
                    writeInt32(data, this.offset + offset + 32, encodeFloat_2_30(this.matrix[8]));
                    offset += 36;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, 0);
                    writeInt32(data, this.offset + offset + 20, 0);
                    offset += 24;
                    writeInt32(data, this.offset + offset, this.nextTrackId);
                    offset += 4;
                    return offset;
                };
                return MovieHeaderBox;
            }(FullBox));
            Iso.MovieHeaderBox = MovieHeaderBox;
            var TrackHeaderFlags;
            (function (TrackHeaderFlags) {
                TrackHeaderFlags[TrackHeaderFlags["TRACK_ENABLED"] = 1] = "TRACK_ENABLED";
                TrackHeaderFlags[TrackHeaderFlags["TRACK_IN_MOVIE"] = 2] = "TRACK_IN_MOVIE";
                TrackHeaderFlags[TrackHeaderFlags["TRACK_IN_PREVIEW"] = 4] = "TRACK_IN_PREVIEW";
            })(TrackHeaderFlags = Iso.TrackHeaderFlags || (Iso.TrackHeaderFlags = {}));
            var TrackHeaderBox = /** @class */ (function (_super) {
                __extends(TrackHeaderBox, _super);
                function TrackHeaderBox(flags, trackId, duration, width, height, volume, alternateGroup, layer, matrix, creationTime, modificationTime) {
                    if (alternateGroup === void 0) { alternateGroup = 0; }
                    if (layer === void 0) { layer = 0; }
                    if (matrix === void 0) { matrix = DEFAULT_MOVIE_MATRIX; }
                    if (creationTime === void 0) { creationTime = START_DATE; }
                    if (modificationTime === void 0) { modificationTime = START_DATE; }
                    var _this = _super.call(this, 'tkhd', 0, flags) || this;
                    _this.trackId = trackId;
                    _this.duration = duration;
                    _this.width = width;
                    _this.height = height;
                    _this.volume = volume;
                    _this.alternateGroup = alternateGroup;
                    _this.layer = layer;
                    _this.matrix = matrix;
                    _this.creationTime = creationTime;
                    _this.modificationTime = modificationTime;
                    return _this;
                }
                TrackHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 20 + 8 + 6 + 2 + 36 + 8;
                    return this.size;
                };
                TrackHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.trackId);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, this.duration);
                    offset += 20;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, (this.layer << 16) | this.alternateGroup);
                    writeInt32(data, this.offset + offset + 12, encodeFloat_8_8(this.volume) << 16);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.matrix[0]));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.matrix[1]));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.matrix[2]));
                    writeInt32(data, this.offset + offset + 12, encodeFloat_16_16(this.matrix[3]));
                    writeInt32(data, this.offset + offset + 16, encodeFloat_16_16(this.matrix[4]));
                    writeInt32(data, this.offset + offset + 20, encodeFloat_16_16(this.matrix[5]));
                    writeInt32(data, this.offset + offset + 24, encodeFloat_2_30(this.matrix[6]));
                    writeInt32(data, this.offset + offset + 28, encodeFloat_2_30(this.matrix[7]));
                    writeInt32(data, this.offset + offset + 32, encodeFloat_2_30(this.matrix[8]));
                    offset += 36;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.width));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.height));
                    offset += 8;
                    return offset;
                };
                return TrackHeaderBox;
            }(FullBox));
            Iso.TrackHeaderBox = TrackHeaderBox;
            var MediaHeaderBox = /** @class */ (function (_super) {
                __extends(MediaHeaderBox, _super);
                function MediaHeaderBox(timescale, duration, language, creationTime, modificationTime) {
                    if (language === void 0) { language = 'unk'; }
                    if (creationTime === void 0) { creationTime = START_DATE; }
                    if (modificationTime === void 0) { modificationTime = START_DATE; }
                    var _this = _super.call(this, 'mdhd', 0, 0) || this;
                    _this.timescale = timescale;
                    _this.duration = duration;
                    _this.language = language;
                    _this.creationTime = creationTime;
                    _this.modificationTime = modificationTime;
                    return _this;
                }
                MediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 16 + 4;
                    return this.size;
                };
                MediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.timescale);
                    writeInt32(data, this.offset + offset + 12, this.duration);
                    writeInt32(data, this.offset + offset + 16, encodeLang(this.language) << 16);
                    return offset + 20;
                };
                return MediaHeaderBox;
            }(FullBox));
            Iso.MediaHeaderBox = MediaHeaderBox;
            var HandlerBox = /** @class */ (function (_super) {
                __extends(HandlerBox, _super);
                function HandlerBox(handlerType, name) {
                    var _this = _super.call(this, 'hdlr', 0, 0) || this;
                    _this.handlerType = handlerType;
                    _this.name = name;
                    _this._encodedName = utf8decode(_this.name);
                    return _this;
                }
                HandlerBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8 + 12 + (this._encodedName.length + 1);
                    return this.size;
                };
                HandlerBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, decodeInt32(this.handlerType));
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, 0);
                    offset += 20;
                    data.set(this._encodedName, this.offset + offset);
                    data[this.offset + offset + this._encodedName.length] = 0;
                    offset += this._encodedName.length + 1;
                    return offset;
                };
                return HandlerBox;
            }(FullBox));
            Iso.HandlerBox = HandlerBox;
            var SoundMediaHeaderBox = /** @class */ (function (_super) {
                __extends(SoundMediaHeaderBox, _super);
                function SoundMediaHeaderBox(balance) {
                    if (balance === void 0) { balance = 0.0; }
                    var _this = _super.call(this, 'smhd', 0, 0) || this;
                    _this.balance = balance;
                    return _this;
                }
                SoundMediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                SoundMediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, encodeFloat_8_8(this.balance) << 16);
                    return offset + 4;
                };
                return SoundMediaHeaderBox;
            }(FullBox));
            Iso.SoundMediaHeaderBox = SoundMediaHeaderBox;
            var VideoMediaHeaderBox = /** @class */ (function (_super) {
                __extends(VideoMediaHeaderBox, _super);
                function VideoMediaHeaderBox(graphicsMode, opColor) {
                    if (graphicsMode === void 0) { graphicsMode = 0; }
                    if (opColor === void 0) { opColor = DEFAULT_OP_COLOR; }
                    var _this = _super.call(this, 'vmhd', 0, 0) || this;
                    _this.graphicsMode = graphicsMode;
                    _this.opColor = opColor;
                    return _this;
                }
                VideoMediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8;
                    return this.size;
                };
                VideoMediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, (this.graphicsMode << 16) | this.opColor[0]);
                    writeInt32(data, this.offset + offset + 4, (this.opColor[1] << 16) | this.opColor[2]);
                    return offset + 8;
                };
                return VideoMediaHeaderBox;
            }(FullBox));
            Iso.VideoMediaHeaderBox = VideoMediaHeaderBox;
            Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG = 0x000001;
            var DataEntryUrlBox = /** @class */ (function (_super) {
                __extends(DataEntryUrlBox, _super);
                function DataEntryUrlBox(flags, location) {
                    if (location === void 0) { location = null; }
                    var _this = _super.call(this, 'url ', 0, flags) || this;
                    _this.location = location;
                    if (!(flags & Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)) {
                        _this._encodedLocation = utf8decode(location);
                    }
                    return _this;
                }
                DataEntryUrlBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    if (this._encodedLocation) {
                        size += this._encodedLocation.length + 1;
                    }
                    return (this.size = size);
                };
                DataEntryUrlBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    if (this._encodedLocation) {
                        data.set(this._encodedLocation, this.offset + offset);
                        data[this.offset + offset + this._encodedLocation.length] = 0;
                        offset += this._encodedLocation.length;
                    }
                    return offset;
                };
                return DataEntryUrlBox;
            }(FullBox));
            Iso.DataEntryUrlBox = DataEntryUrlBox;
            var DataReferenceBox = /** @class */ (function (_super) {
                __extends(DataReferenceBox, _super);
                function DataReferenceBox(entries) {
                    var _this = _super.call(this, 'dref', 0, 0) || this;
                    _this.entries = entries;
                    return _this;
                }
                DataReferenceBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    this.entries.forEach(function (entry) {
                        size += entry.layout(offset + size);
                    });
                    return (this.size = size);
                };
                DataReferenceBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.entries.length);
                    this.entries.forEach(function (entry) {
                        offset += entry.write(data);
                    });
                    return offset;
                };
                return DataReferenceBox;
            }(FullBox));
            Iso.DataReferenceBox = DataReferenceBox;
            var DataInformationBox = /** @class */ (function (_super) {
                __extends(DataInformationBox, _super);
                function DataInformationBox(dataReference) {
                    var _this = _super.call(this, 'dinf', [dataReference]) || this;
                    _this.dataReference = dataReference;
                    return _this;
                }
                return DataInformationBox;
            }(BoxContainerBox));
            Iso.DataInformationBox = DataInformationBox;
            var SampleDescriptionBox = /** @class */ (function (_super) {
                __extends(SampleDescriptionBox, _super);
                function SampleDescriptionBox(entries) {
                    var _this = _super.call(this, 'stsd', 0, 0) || this;
                    _this.entries = entries;
                    return _this;
                }
                SampleDescriptionBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    size += 4;
                    this.entries.forEach(function (entry) {
                        size += entry.layout(offset + size);
                    });
                    return (this.size = size);
                };
                SampleDescriptionBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.entries.length);
                    offset += 4;
                    this.entries.forEach(function (entry) {
                        offset += entry.write(data);
                    });
                    return offset;
                };
                return SampleDescriptionBox;
            }(FullBox));
            Iso.SampleDescriptionBox = SampleDescriptionBox;
            var SampleTableBox = /** @class */ (function (_super) {
                __extends(SampleTableBox, _super);
                function SampleTableBox(sampleDescriptions, timeToSample, sampleToChunk, sampleSizes, // optional?
                chunkOffset) {
                    var _this = _super.call(this, 'stbl', [sampleDescriptions, timeToSample, sampleToChunk, sampleSizes, chunkOffset]) || this;
                    _this.sampleDescriptions = sampleDescriptions;
                    _this.timeToSample = timeToSample;
                    _this.sampleToChunk = sampleToChunk;
                    _this.sampleSizes = sampleSizes;
                    _this.chunkOffset = chunkOffset;
                    return _this;
                }
                return SampleTableBox;
            }(BoxContainerBox));
            Iso.SampleTableBox = SampleTableBox;
            var MediaInformationBox = /** @class */ (function (_super) {
                __extends(MediaInformationBox, _super);
                function MediaInformationBox(header, // SoundMediaHeaderBox|VideoMediaHeaderBox
                info, sampleTable) {
                    var _this = _super.call(this, 'minf', [header, info, sampleTable]) || this;
                    _this.header = header;
                    _this.info = info;
                    _this.sampleTable = sampleTable;
                    return _this;
                }
                return MediaInformationBox;
            }(BoxContainerBox));
            Iso.MediaInformationBox = MediaInformationBox;
            var MediaBox = /** @class */ (function (_super) {
                __extends(MediaBox, _super);
                function MediaBox(header, handler, info) {
                    var _this = _super.call(this, 'mdia', [header, handler, info]) || this;
                    _this.header = header;
                    _this.handler = handler;
                    _this.info = info;
                    return _this;
                }
                return MediaBox;
            }(BoxContainerBox));
            Iso.MediaBox = MediaBox;
            var TrackBox = /** @class */ (function (_super) {
                __extends(TrackBox, _super);
                function TrackBox(header, media) {
                    var _this = _super.call(this, 'trak', [header, media]) || this;
                    _this.header = header;
                    _this.media = media;
                    return _this;
                }
                return TrackBox;
            }(BoxContainerBox));
            Iso.TrackBox = TrackBox;
            var TrackExtendsBox = /** @class */ (function (_super) {
                __extends(TrackExtendsBox, _super);
                function TrackExtendsBox(trackId, defaultSampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
                    var _this = _super.call(this, 'trex', 0, 0) || this;
                    _this.trackId = trackId;
                    _this.defaultSampleDescriptionIndex = defaultSampleDescriptionIndex;
                    _this.defaultSampleDuration = defaultSampleDuration;
                    _this.defaultSampleSize = defaultSampleSize;
                    _this.defaultSampleFlags = defaultSampleFlags;
                    return _this;
                }
                TrackExtendsBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 20;
                    return this.size;
                };
                TrackExtendsBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.trackId);
                    writeInt32(data, this.offset + offset + 4, this.defaultSampleDescriptionIndex);
                    writeInt32(data, this.offset + offset + 8, this.defaultSampleDuration);
                    writeInt32(data, this.offset + offset + 12, this.defaultSampleSize);
                    writeInt32(data, this.offset + offset + 16, this.defaultSampleFlags);
                    return offset + 20;
                };
                return TrackExtendsBox;
            }(FullBox));
            Iso.TrackExtendsBox = TrackExtendsBox;
            var MovieExtendsBox = /** @class */ (function (_super) {
                __extends(MovieExtendsBox, _super);
                function MovieExtendsBox(header, tracDefaults, levels) {
                    var _this = _super.call(this, 'mvex', concatArrays([header], tracDefaults, [levels])) || this;
                    _this.header = header;
                    _this.tracDefaults = tracDefaults;
                    _this.levels = levels;
                    return _this;
                }
                return MovieExtendsBox;
            }(BoxContainerBox));
            Iso.MovieExtendsBox = MovieExtendsBox;
            var MetaBox = /** @class */ (function (_super) {
                __extends(MetaBox, _super);
                function MetaBox(handler, otherBoxes) {
                    var _this = _super.call(this, 'meta', 0, 0) || this;
                    _this.handler = handler;
                    _this.otherBoxes = otherBoxes;
                    return _this;
                }
                MetaBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    size += this.handler.layout(offset + size);
                    this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return (this.size = size);
                };
                MetaBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    offset += this.handler.write(data);
                    this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return MetaBox;
            }(FullBox));
            Iso.MetaBox = MetaBox;
            var MovieFragmentHeaderBox = /** @class */ (function (_super) {
                __extends(MovieFragmentHeaderBox, _super);
                function MovieFragmentHeaderBox(sequenceNumber) {
                    var _this = _super.call(this, 'mfhd', 0, 0) || this;
                    _this.sequenceNumber = sequenceNumber;
                    return _this;
                }
                MovieFragmentHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                MovieFragmentHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.sequenceNumber);
                    return offset + 4;
                };
                return MovieFragmentHeaderBox;
            }(FullBox));
            Iso.MovieFragmentHeaderBox = MovieFragmentHeaderBox;
            var TrackFragmentFlags;
            (function (TrackFragmentFlags) {
                TrackFragmentFlags[TrackFragmentFlags["BASE_DATA_OFFSET_PRESENT"] = 1] = "BASE_DATA_OFFSET_PRESENT";
                TrackFragmentFlags[TrackFragmentFlags["SAMPLE_DESCRIPTION_INDEX_PRESENT"] = 2] = "SAMPLE_DESCRIPTION_INDEX_PRESENT";
                TrackFragmentFlags[TrackFragmentFlags["DEFAULT_SAMPLE_DURATION_PRESENT"] = 8] = "DEFAULT_SAMPLE_DURATION_PRESENT";
                TrackFragmentFlags[TrackFragmentFlags["DEFAULT_SAMPLE_SIZE_PRESENT"] = 16] = "DEFAULT_SAMPLE_SIZE_PRESENT";
                TrackFragmentFlags[TrackFragmentFlags["DEFAULT_SAMPLE_FLAGS_PRESENT"] = 32] = "DEFAULT_SAMPLE_FLAGS_PRESENT";
            })(TrackFragmentFlags = Iso.TrackFragmentFlags || (Iso.TrackFragmentFlags = {}));
            var TrackFragmentHeaderBox = /** @class */ (function (_super) {
                __extends(TrackFragmentHeaderBox, _super);
                function TrackFragmentHeaderBox(flags, trackId, baseDataOffset, sampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
                    var _this = _super.call(this, 'tfhd', 0, flags) || this;
                    _this.trackId = trackId;
                    _this.baseDataOffset = baseDataOffset;
                    _this.sampleDescriptionIndex = sampleDescriptionIndex;
                    _this.defaultSampleDuration = defaultSampleDuration;
                    _this.defaultSampleSize = defaultSampleSize;
                    _this.defaultSampleFlags = defaultSampleFlags;
                    return _this;
                }
                TrackFragmentHeaderBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    var flags = this.flags;
                    if (!!(flags & 1 /* BASE_DATA_OFFSET_PRESENT */)) {
                        size += 8;
                    }
                    if (!!(flags & 2 /* SAMPLE_DESCRIPTION_INDEX_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 8 /* DEFAULT_SAMPLE_DURATION_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 16 /* DEFAULT_SAMPLE_SIZE_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 32 /* DEFAULT_SAMPLE_FLAGS_PRESENT */)) {
                        size += 4;
                    }
                    return (this.size = size);
                };
                TrackFragmentHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    var flags = this.flags;
                    writeInt32(data, this.offset + offset, this.trackId);
                    offset += 4;
                    if (!!(flags & 1 /* BASE_DATA_OFFSET_PRESENT */)) {
                        writeInt32(data, this.offset + offset, 0);
                        writeInt32(data, this.offset + offset + 4, this.baseDataOffset);
                        offset += 8;
                    }
                    if (!!(flags & 2 /* SAMPLE_DESCRIPTION_INDEX_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.sampleDescriptionIndex);
                        offset += 4;
                    }
                    if (!!(flags & 8 /* DEFAULT_SAMPLE_DURATION_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleDuration);
                        offset += 4;
                    }
                    if (!!(flags & 16 /* DEFAULT_SAMPLE_SIZE_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleSize);
                        offset += 4;
                    }
                    if (!!(flags & 32 /* DEFAULT_SAMPLE_FLAGS_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleFlags);
                        offset += 4;
                    }
                    return offset;
                };
                return TrackFragmentHeaderBox;
            }(FullBox));
            Iso.TrackFragmentHeaderBox = TrackFragmentHeaderBox;
            var TrackFragmentBaseMediaDecodeTimeBox = /** @class */ (function (_super) {
                __extends(TrackFragmentBaseMediaDecodeTimeBox, _super);
                function TrackFragmentBaseMediaDecodeTimeBox(baseMediaDecodeTime) {
                    var _this = _super.call(this, 'tfdt', 0, 0) || this;
                    _this.baseMediaDecodeTime = baseMediaDecodeTime;
                    return _this;
                }
                TrackFragmentBaseMediaDecodeTimeBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                TrackFragmentBaseMediaDecodeTimeBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.baseMediaDecodeTime);
                    return offset + 4;
                };
                return TrackFragmentBaseMediaDecodeTimeBox;
            }(FullBox));
            Iso.TrackFragmentBaseMediaDecodeTimeBox = TrackFragmentBaseMediaDecodeTimeBox;
            var TrackFragmentBox = /** @class */ (function (_super) {
                __extends(TrackFragmentBox, _super);
                function TrackFragmentBox(header, decodeTime, // move after run?
                run) {
                    var _this = _super.call(this, 'traf', [header, decodeTime, run]) || this;
                    _this.header = header;
                    _this.decodeTime = decodeTime;
                    _this.run = run;
                    return _this;
                }
                return TrackFragmentBox;
            }(BoxContainerBox));
            Iso.TrackFragmentBox = TrackFragmentBox;
            var SampleFlags;
            (function (SampleFlags) {
                SampleFlags[SampleFlags["IS_LEADING_MASK"] = 201326592] = "IS_LEADING_MASK";
                SampleFlags[SampleFlags["SAMPLE_DEPENDS_ON_MASK"] = 50331648] = "SAMPLE_DEPENDS_ON_MASK";
                SampleFlags[SampleFlags["SAMPLE_DEPENDS_ON_OTHER"] = 16777216] = "SAMPLE_DEPENDS_ON_OTHER";
                SampleFlags[SampleFlags["SAMPLE_DEPENDS_ON_NO_OTHERS"] = 33554432] = "SAMPLE_DEPENDS_ON_NO_OTHERS";
                SampleFlags[SampleFlags["SAMPLE_IS_DEPENDED_ON_MASK"] = 12582912] = "SAMPLE_IS_DEPENDED_ON_MASK";
                SampleFlags[SampleFlags["SAMPLE_HAS_REDUNDANCY_MASK"] = 3145728] = "SAMPLE_HAS_REDUNDANCY_MASK";
                SampleFlags[SampleFlags["SAMPLE_PADDING_VALUE_MASK"] = 917504] = "SAMPLE_PADDING_VALUE_MASK";
                SampleFlags[SampleFlags["SAMPLE_IS_NOT_SYNC"] = 65536] = "SAMPLE_IS_NOT_SYNC";
                SampleFlags[SampleFlags["SAMPLE_DEGRADATION_PRIORITY_MASK"] = 65535] = "SAMPLE_DEGRADATION_PRIORITY_MASK";
            })(SampleFlags = Iso.SampleFlags || (Iso.SampleFlags = {}));
            var TrackRunFlags;
            (function (TrackRunFlags) {
                TrackRunFlags[TrackRunFlags["DATA_OFFSET_PRESENT"] = 1] = "DATA_OFFSET_PRESENT";
                TrackRunFlags[TrackRunFlags["FIRST_SAMPLE_FLAGS_PRESENT"] = 4] = "FIRST_SAMPLE_FLAGS_PRESENT";
                TrackRunFlags[TrackRunFlags["SAMPLE_DURATION_PRESENT"] = 256] = "SAMPLE_DURATION_PRESENT";
                TrackRunFlags[TrackRunFlags["SAMPLE_SIZE_PRESENT"] = 512] = "SAMPLE_SIZE_PRESENT";
                TrackRunFlags[TrackRunFlags["SAMPLE_FLAGS_PRESENT"] = 1024] = "SAMPLE_FLAGS_PRESENT";
                TrackRunFlags[TrackRunFlags["SAMPLE_COMPOSITION_TIME_OFFSET"] = 2048] = "SAMPLE_COMPOSITION_TIME_OFFSET";
            })(TrackRunFlags = Iso.TrackRunFlags || (Iso.TrackRunFlags = {}));
            var TrackRunBox = /** @class */ (function (_super) {
                __extends(TrackRunBox, _super);
                function TrackRunBox(flags, samples, dataOffset, firstSampleFlags) {
                    var _this = _super.call(this, 'trun', 1, flags) || this;
                    _this.samples = samples;
                    _this.dataOffset = dataOffset;
                    _this.firstSampleFlags = firstSampleFlags;
                    return _this;
                }
                TrackRunBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    var samplesCount = this.samples.length;
                    var flags = this.flags;
                    if (!!(flags & 1 /* DATA_OFFSET_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 4 /* FIRST_SAMPLE_FLAGS_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 256 /* SAMPLE_DURATION_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 512 /* SAMPLE_SIZE_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 1024 /* SAMPLE_FLAGS_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 2048 /* SAMPLE_COMPOSITION_TIME_OFFSET */)) {
                        size += 4 * samplesCount;
                    }
                    return (this.size = size);
                };
                TrackRunBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    var samplesCount = this.samples.length;
                    var flags = this.flags;
                    writeInt32(data, this.offset + offset, samplesCount);
                    offset += 4;
                    if (!!(flags & 1 /* DATA_OFFSET_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.dataOffset);
                        offset += 4;
                    }
                    if (!!(flags & 4 /* FIRST_SAMPLE_FLAGS_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.firstSampleFlags);
                        offset += 4;
                    }
                    for (var i = 0; i < samplesCount; i++) {
                        var sample = this.samples[i];
                        if (!!(flags & 256 /* SAMPLE_DURATION_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.duration);
                            offset += 4;
                        }
                        if (!!(flags & 512 /* SAMPLE_SIZE_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.size);
                            offset += 4;
                        }
                        if (!!(flags & 1024 /* SAMPLE_FLAGS_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.flags);
                            offset += 4;
                        }
                        if (!!(flags & 2048 /* SAMPLE_COMPOSITION_TIME_OFFSET */)) {
                            writeInt32(data, this.offset + offset, sample.compositionTimeOffset);
                            offset += 4;
                        }
                    }
                    return offset;
                };
                return TrackRunBox;
            }(FullBox));
            Iso.TrackRunBox = TrackRunBox;
            var MovieFragmentBox = /** @class */ (function (_super) {
                __extends(MovieFragmentBox, _super);
                function MovieFragmentBox(header, trafs) {
                    var _this = _super.call(this, 'moof', concatArrays([header], trafs)) || this;
                    _this.header = header;
                    _this.trafs = trafs;
                    return _this;
                }
                return MovieFragmentBox;
            }(BoxContainerBox));
            Iso.MovieFragmentBox = MovieFragmentBox;
            var MediaDataBox = /** @class */ (function (_super) {
                __extends(MediaDataBox, _super);
                function MediaDataBox(chunks) {
                    var _this = _super.call(this, 'mdat') || this;
                    _this.chunks = chunks;
                    return _this;
                }
                MediaDataBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    this.chunks.forEach(function (chunk) {
                        size += chunk.length;
                    });
                    return (this.size = size);
                };
                MediaDataBox.prototype.write = function (data) {
                    var _this = this;
                    var offset = _super.prototype.write.call(this, data);
                    this.chunks.forEach(function (chunk) {
                        data.set(chunk, _this.offset + offset);
                        offset += chunk.length;
                    }, this);
                    return offset;
                };
                return MediaDataBox;
            }(Box));
            Iso.MediaDataBox = MediaDataBox;
            var SampleEntry = /** @class */ (function (_super) {
                __extends(SampleEntry, _super);
                function SampleEntry(format, dataReferenceIndex) {
                    var _this = _super.call(this, format) || this;
                    _this.dataReferenceIndex = dataReferenceIndex;
                    return _this;
                }
                SampleEntry.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8;
                    return this.size;
                };
                SampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, this.dataReferenceIndex);
                    return offset + 8;
                };
                return SampleEntry;
            }(Box));
            Iso.SampleEntry = SampleEntry;
            var AudioSampleEntry = /** @class */ (function (_super) {
                __extends(AudioSampleEntry, _super);
                function AudioSampleEntry(codingName, dataReferenceIndex, channelCount, sampleSize, sampleRate, otherBoxes) {
                    if (channelCount === void 0) { channelCount = 2; }
                    if (sampleSize === void 0) { sampleSize = 16; }
                    if (sampleRate === void 0) { sampleRate = 44100; }
                    if (otherBoxes === void 0) { otherBoxes = null; }
                    var _this = _super.call(this, codingName, dataReferenceIndex) || this;
                    _this.channelCount = channelCount;
                    _this.sampleSize = sampleSize;
                    _this.sampleRate = sampleRate;
                    _this.otherBoxes = otherBoxes;
                    return _this;
                }
                AudioSampleEntry.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 20;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return (this.size = size);
                };
                AudioSampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, (this.channelCount << 16) | this.sampleSize);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, (this.sampleRate << 16));
                    offset += 20;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return AudioSampleEntry;
            }(SampleEntry));
            Iso.AudioSampleEntry = AudioSampleEntry;
            Iso.COLOR_NO_ALPHA_VIDEO_SAMPLE_DEPTH = 0x0018;
            var VideoSampleEntry = /** @class */ (function (_super) {
                __extends(VideoSampleEntry, _super);
                function VideoSampleEntry(codingName, dataReferenceIndex, width, height, compressorName, horizResolution, vertResolution, frameCount, depth, otherBoxes) {
                    if (compressorName === void 0) { compressorName = ''; }
                    if (horizResolution === void 0) { horizResolution = 72; }
                    if (vertResolution === void 0) { vertResolution = 72; }
                    if (frameCount === void 0) { frameCount = 1; }
                    if (depth === void 0) { depth = Iso.COLOR_NO_ALPHA_VIDEO_SAMPLE_DEPTH; }
                    if (otherBoxes === void 0) { otherBoxes = null; }
                    var _this = _super.call(this, codingName, dataReferenceIndex) || this;
                    _this.width = width;
                    _this.height = height;
                    _this.compressorName = compressorName;
                    _this.horizResolution = horizResolution;
                    _this.vertResolution = vertResolution;
                    _this.frameCount = frameCount;
                    _this.depth = depth;
                    _this.otherBoxes = otherBoxes;
                    if (compressorName.length > 31) {
                        throw new Error('invalid compressor name');
                    }
                    return _this;
                }
                VideoSampleEntry.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 16 + 12 + 4 + 2 + 32 + 2 + 2;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return (this.size = size);
                };
                VideoSampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    offset += 16;
                    writeInt32(data, this.offset + offset, (this.width << 16) | this.height);
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.horizResolution));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.vertResolution));
                    offset += 12;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, (this.frameCount << 16));
                    offset += 6; // weird offset
                    data[this.offset + offset] = this.compressorName.length;
                    for (var i = 0; i < 31; i++) {
                        data[this.offset + offset + i + 1] = i < this.compressorName.length ? (this.compressorName.charCodeAt(i) & 127) : 0;
                    }
                    offset += 32;
                    writeInt32(data, this.offset + offset, (this.depth << 16) | 0xFFFF);
                    offset += 4;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return VideoSampleEntry;
            }(SampleEntry));
            Iso.VideoSampleEntry = VideoSampleEntry;
            var RawTag = /** @class */ (function (_super) {
                __extends(RawTag, _super);
                function RawTag(type, data) {
                    var _this = _super.call(this, type) || this;
                    _this.data = data;
                    return _this;
                }
                RawTag.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + this.data.length;
                    return this.size;
                };
                RawTag.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    data.set(this.data, this.offset + offset);
                    return offset + this.data.length;
                };
                return RawTag;
            }(Box));
            Iso.RawTag = RawTag;
        })(Iso = MP4.Iso || (MP4.Iso = {}));
    })(MP4 = RtmpJs.MP4 || (RtmpJs.MP4 = {}));
})(RtmpJs || (RtmpJs = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var MP4;
    (function (MP4) {
        function hex(s) {
            var len = s.length >> 1;
            var arr = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                arr[i] = parseInt(s.substr(i * 2, 2), 16);
            }
            return arr;
        }
        var SOUNDRATES = [5500, 11025, 22050, 44100];
        var SOUNDFORMATS = ['PCM', 'ADPCM', 'MP3', 'PCM le', 'Nellymouser16', 'Nellymouser8', 'Nellymouser', 'G.711 A-law', 'G.711 mu-law', null, 'AAC', 'Speex', 'MP3 8khz'];
        var MP3_SOUND_CODEC_ID = 2;
        var AAC_SOUND_CODEC_ID = 10;
        var AudioPacketType;
        (function (AudioPacketType) {
            AudioPacketType[AudioPacketType["HEADER"] = 0] = "HEADER";
            AudioPacketType[AudioPacketType["RAW"] = 1] = "RAW";
        })(AudioPacketType || (AudioPacketType = {}));
        function parseAudiodata(data) {
            var i = 0;
            var packetType = AudioPacketType.RAW;
            var flags = data[i];
            var codecId = flags >> 4;
            var soundRateId = (flags >> 2) & 3;
            var sampleSize = (flags & 2) !== 0 ? 16 : 8;
            var channels = (flags & 1) !== 0 ? 2 : 1;
            var samples;
            i++;
            switch (codecId) {
                case AAC_SOUND_CODEC_ID:
                    var type = data[i++];
                    packetType = type;
                    samples = 1024; // AAC implementations typically represent 1024 PCM audio samples
                    break;
                case MP3_SOUND_CODEC_ID:
                    var version = (data[i + 1] >> 3) & 3; // 3 - MPEG 1
                    var layer = (data[i + 1] >> 1) & 3; // 3 - Layer I, 2 - II, 1 - III
                    samples = layer === 1 ? (version === 3 ? 1152 : 576) :
                        (layer === 3 ? 384 : 1152);
                    break;
            }
            return {
                codecDescription: SOUNDFORMATS[codecId],
                codecId: codecId,
                data: data.subarray(i),
                rate: SOUNDRATES[soundRateId],
                size: sampleSize,
                channels: channels,
                samples: samples,
                packetType: packetType
            };
        }
        var VIDEOCODECS = [null, 'JPEG', 'Sorenson', 'Screen', 'VP6', 'VP6 alpha', 'Screen2', 'AVC'];
        var VP6_VIDEO_CODEC_ID = 4;
        var AVC_VIDEO_CODEC_ID = 7;
        var VideoFrameType;
        (function (VideoFrameType) {
            VideoFrameType[VideoFrameType["KEY"] = 1] = "KEY";
            VideoFrameType[VideoFrameType["INNER"] = 2] = "INNER";
            VideoFrameType[VideoFrameType["DISPOSABLE"] = 3] = "DISPOSABLE";
            VideoFrameType[VideoFrameType["GENERATED"] = 4] = "GENERATED";
            VideoFrameType[VideoFrameType["INFO"] = 5] = "INFO";
        })(VideoFrameType || (VideoFrameType = {}));
        var VideoPacketType;
        (function (VideoPacketType) {
            VideoPacketType[VideoPacketType["HEADER"] = 0] = "HEADER";
            VideoPacketType[VideoPacketType["NALU"] = 1] = "NALU";
            VideoPacketType[VideoPacketType["END"] = 2] = "END";
        })(VideoPacketType || (VideoPacketType = {}));
        function parseVideodata(data) {
            var i = 0;
            var frameType = data[i] >> 4;
            var codecId = data[i] & 15;
            i++;
            var result = {
                frameType: frameType,
                codecId: codecId,
                codecDescription: VIDEOCODECS[codecId]
            };
            switch (codecId) {
                case AVC_VIDEO_CODEC_ID:
                    var type = data[i++];
                    result.packetType = type;
                    result.compositionTime = ((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8)) >> 8;
                    i += 3;
                    break;
                case VP6_VIDEO_CODEC_ID:
                    result.packetType = VideoPacketType.NALU;
                    result.horizontalOffset = (data[i] >> 4) & 15;
                    result.verticalOffset = data[i] & 15;
                    result.compositionTime = 0;
                    i++;
                    break;
            }
            result.data = data.subarray(i);
            return result;
        }
        var AUDIO_PACKET = 8;
        var VIDEO_PACKET = 9;
        var MAX_PACKETS_IN_CHUNK = 200;
        var SPLIT_AT_KEYFRAMES = false;
        var MP4MuxState;
        (function (MP4MuxState) {
            MP4MuxState[MP4MuxState["CAN_GENERATE_HEADER"] = 0] = "CAN_GENERATE_HEADER";
            MP4MuxState[MP4MuxState["NEED_HEADER_DATA"] = 1] = "NEED_HEADER_DATA";
            MP4MuxState[MP4MuxState["MAIN_PACKETS"] = 2] = "MAIN_PACKETS";
        })(MP4MuxState || (MP4MuxState = {}));
        var MP4Mux = /** @class */ (function () {
            function MP4Mux(metadata) {
                var _this = this;
                this.oncodecinfo = function (codecs) {
                    //
                };
                this.ondata = function (data) {
                    throw new Error('MP4Mux.ondata is not set');
                };
                this.metadata = metadata;
                this.trackStates = this.metadata.tracks.map(function (t, index) {
                    var state = {
                        trackId: index + 1,
                        trackInfo: t,
                        cachedDuration: 0,
                        samplesProcessed: 0,
                        initializationData: []
                    };
                    if (_this.metadata.audioTrackId === index) {
                        _this.audioTrackState = state;
                    }
                    if (_this.metadata.videoTrackId === index) {
                        _this.videoTrackState = state;
                    }
                    return state;
                }, this);
                this._checkIfNeedHeaderData();
                this.filePos = 0;
                this.cachedPackets = [];
                this.chunkIndex = 0;
            }
            MP4Mux.prototype.pushPacket = function (type, data, timestamp) {
                if (this.state === MP4MuxState.CAN_GENERATE_HEADER) {
                    this._tryGenerateHeader();
                }
                switch (type) {
                    case AUDIO_PACKET:// audio
                        var audioTrack = this.audioTrackState;
                        var audioPacket = parseAudiodata(data);
                        if (!audioTrack || audioTrack.trackInfo.codecId !== audioPacket.codecId) {
                            throw new Error('Unexpected audio packet codec: ' + audioPacket.codecDescription);
                        }
                        switch (audioPacket.codecId) {
                            default:
                                throw new Error('Unsupported audio codec: ' + audioPacket.codecDescription);
                            case MP3_SOUND_CODEC_ID:
                                break; // supported codec
                            case AAC_SOUND_CODEC_ID:
                                if (audioPacket.packetType === AudioPacketType.HEADER) {
                                    audioTrack.initializationData.push(audioPacket.data);
                                    return;
                                }
                                break;
                        }
                        this.cachedPackets.push({ packet: audioPacket, timestamp: timestamp, trackId: audioTrack.trackId });
                        break;
                    case VIDEO_PACKET:
                        var videoTrack = this.videoTrackState;
                        var videoPacket = parseVideodata(data);
                        if (!videoTrack || videoTrack.trackInfo.codecId !== videoPacket.codecId) {
                            throw new Error('Unexpected video packet codec: ' + videoPacket.codecDescription);
                        }
                        switch (videoPacket.codecId) {
                            default:
                                throw new Error('unsupported video codec: ' + videoPacket.codecDescription);
                            case VP6_VIDEO_CODEC_ID:
                                break; // supported
                            case AVC_VIDEO_CODEC_ID:
                                if (videoPacket.packetType === VideoPacketType.HEADER) {
                                    videoTrack.initializationData.push(videoPacket.data);
                                    return;
                                }
                                break;
                        }
                        this.cachedPackets.push({ packet: videoPacket, timestamp: timestamp, trackId: videoTrack.trackId });
                        break;
                    default:
                        throw new Error('unknown packet type: ' + type);
                }
                if (this.state === MP4MuxState.NEED_HEADER_DATA) {
                    this._tryGenerateHeader();
                }
                if (this.cachedPackets.length >= MAX_PACKETS_IN_CHUNK &&
                    this.state === MP4MuxState.MAIN_PACKETS) {
                    this._chunk();
                }
            };
            MP4Mux.prototype.flush = function () {
                if (this.cachedPackets.length > 0) {
                    this._chunk();
                }
            };
            MP4Mux.prototype._checkIfNeedHeaderData = function () {
                if (this.trackStates.some(function (ts) {
                    return ts.trackInfo.codecId === AAC_SOUND_CODEC_ID || ts.trackInfo.codecId === AVC_VIDEO_CODEC_ID;
                })) {
                    this.state = MP4MuxState.NEED_HEADER_DATA;
                }
                else {
                    this.state = MP4MuxState.CAN_GENERATE_HEADER;
                }
            };
            MP4Mux.prototype._tryGenerateHeader = function () {
                var allInitializationDataExists = this.trackStates.every(function (ts) {
                    switch (ts.trackInfo.codecId) {
                        case AAC_SOUND_CODEC_ID:
                        case AVC_VIDEO_CODEC_ID:
                            return ts.initializationData.length > 0;
                        default:
                            return true;
                    }
                });
                if (!allInitializationDataExists) {
                    return; // not enough data, waiting more
                }
                var brands = ['isom'];
                var audioDataReferenceIndex = 1, videoDataReferenceIndex = 1;
                var traks = [];
                for (var i = 0; i < this.trackStates.length; i++) {
                    var trackState = this.trackStates[i];
                    var trackInfo = trackState.trackInfo;
                    var sampleEntry = void 0;
                    switch (trackInfo.codecId) {
                        case AAC_SOUND_CODEC_ID:
                            var audioSpecificConfig = trackState.initializationData[0];
                            sampleEntry = new MP4.Iso.AudioSampleEntry('mp4a', audioDataReferenceIndex, trackInfo.channels, trackInfo.samplesize, trackInfo.samplerate);
                            var esdsData = new Uint8Array(41 + audioSpecificConfig.length);
                            esdsData.set(hex('0000000003808080'), 0);
                            esdsData[8] = 32 + audioSpecificConfig.length;
                            esdsData.set(hex('00020004808080'), 9);
                            esdsData[16] = 18 + audioSpecificConfig.length;
                            esdsData.set(hex('40150000000000FA000000000005808080'), 17);
                            esdsData[34] = audioSpecificConfig.length;
                            esdsData.set(audioSpecificConfig, 35);
                            esdsData.set(hex('068080800102'), 35 + audioSpecificConfig.length);
                            sampleEntry.otherBoxes = [
                                new MP4.Iso.RawTag('esds', esdsData)
                            ];
                            var objectType = (audioSpecificConfig[0] >> 3); // TODO 31
                            // mp4a.40.objectType
                            trackState.mimeTypeCodec = 'mp4a.40.' + objectType;
                            break;
                        case MP3_SOUND_CODEC_ID:
                            sampleEntry = new MP4.Iso.AudioSampleEntry('.mp3', audioDataReferenceIndex, trackInfo.channels, trackInfo.samplesize, trackInfo.samplerate);
                            trackState.mimeTypeCodec = 'mp3';
                            break;
                        case AVC_VIDEO_CODEC_ID:
                            var avcC = trackState.initializationData[0];
                            sampleEntry = new MP4.Iso.VideoSampleEntry('avc1', videoDataReferenceIndex, trackInfo.width, trackInfo.height);
                            sampleEntry.otherBoxes = [
                                new MP4.Iso.RawTag('avcC', avcC)
                            ];
                            var codecProfile = (avcC[1] << 16) | (avcC[2] << 8) | avcC[3];
                            // avc1.XXYYZZ -- XX - profile + YY - constraints + ZZ - level
                            trackState.mimeTypeCodec = 'avc1.' + (0x1000000 | codecProfile).toString(16).substr(1);
                            brands.push('iso2', 'avc1', 'mp41');
                            break;
                        case VP6_VIDEO_CODEC_ID:
                            sampleEntry = new MP4.Iso.VideoSampleEntry('VP6F', videoDataReferenceIndex, trackInfo.width, trackInfo.height);
                            sampleEntry.otherBoxes = [
                                new MP4.Iso.RawTag('glbl', hex('00'))
                            ];
                            // TODO to lie about codec to get it playing in MSE?
                            trackState.mimeTypeCodec = 'avc1.42001E';
                            break;
                        default:
                            throw new Error('not supported track type');
                    }
                    var trak = void 0;
                    var trakFlags = 1 /* TRACK_ENABLED */ | 2 /* TRACK_IN_MOVIE */;
                    if (trackState === this.audioTrackState) {
                        trak = new MP4.Iso.TrackBox(new MP4.Iso.TrackHeaderBox(trakFlags, trackState.trackId, -1, 0 /*width*/, 0 /*height*/, 1.0, i), new MP4.Iso.MediaBox(new MP4.Iso.MediaHeaderBox(trackInfo.timescale, -1, trackInfo.language), new MP4.Iso.HandlerBox('soun', 'SoundHandler'), new MP4.Iso.MediaInformationBox(new MP4.Iso.SoundMediaHeaderBox(), new MP4.Iso.DataInformationBox(new MP4.Iso.DataReferenceBox([new MP4.Iso.DataEntryUrlBox(MP4.Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)])), new MP4.Iso.SampleTableBox(new MP4.Iso.SampleDescriptionBox([sampleEntry]), new MP4.Iso.RawTag('stts', hex('0000000000000000')), new MP4.Iso.RawTag('stsc', hex('0000000000000000')), new MP4.Iso.RawTag('stsz', hex('000000000000000000000000')), new MP4.Iso.RawTag('stco', hex('0000000000000000'))))));
                    }
                    else if (trackState === this.videoTrackState) {
                        trak = new MP4.Iso.TrackBox(new MP4.Iso.TrackHeaderBox(trakFlags, trackState.trackId, -1, trackInfo.width, trackInfo.height, 0 /* volume */, i), new MP4.Iso.MediaBox(new MP4.Iso.MediaHeaderBox(trackInfo.timescale, -1, trackInfo.language), new MP4.Iso.HandlerBox('vide', 'VideoHandler'), new MP4.Iso.MediaInformationBox(new MP4.Iso.VideoMediaHeaderBox(), new MP4.Iso.DataInformationBox(new MP4.Iso.DataReferenceBox([new MP4.Iso.DataEntryUrlBox(MP4.Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)])), new MP4.Iso.SampleTableBox(new MP4.Iso.SampleDescriptionBox([sampleEntry]), new MP4.Iso.RawTag('stts', hex('0000000000000000')), new MP4.Iso.RawTag('stsc', hex('0000000000000000')), new MP4.Iso.RawTag('stsz', hex('000000000000000000000000')), new MP4.Iso.RawTag('stco', hex('0000000000000000'))))));
                    }
                    traks.push(trak);
                }
                var mvex = new MP4.Iso.MovieExtendsBox(null, [
                    new MP4.Iso.TrackExtendsBox(1, 1, 0, 0, 0),
                    new MP4.Iso.TrackExtendsBox(2, 1, 0, 0, 0)
                ], null);
                var udat = new MP4.Iso.BoxContainerBox('udat', [
                    new MP4.Iso.MetaBox(new MP4.Iso.RawTag('hdlr', hex('00000000000000006D6469726170706C000000000000000000')), // notice weird stuff in reserved field
                    [new MP4.Iso.RawTag('ilst', hex('00000025A9746F6F0000001D6461746100000001000000004C61766635342E36332E313034'))])
                ]);
                var mvhd = new MP4.Iso.MovieHeaderBox(1000, 0 /* unknown duration */, this.trackStates.length + 1);
                var moov = new MP4.Iso.MovieBox(mvhd, traks, mvex, udat);
                var ftype = new MP4.Iso.FileTypeBox('isom', 0x00000200, brands);
                var ftypeSize = ftype.layout(0);
                var moovSize = moov.layout(ftypeSize);
                var header = new Uint8Array(ftypeSize + moovSize);
                ftype.write(header);
                moov.write(header);
                this.oncodecinfo(this.trackStates.map(function (ts) { return ts.mimeTypeCodec; }));
                this.ondata(header);
                this.filePos += header.length;
                this.state = MP4MuxState.MAIN_PACKETS;
            };
            MP4Mux.prototype._chunk = function () {
                var cachedPackets = this.cachedPackets;
                if (SPLIT_AT_KEYFRAMES) {
                    var j = cachedPackets.length - 1;
                    var videoTrackId = this.videoTrackState.trackId;
                    // Finding last video keyframe.
                    while (j > 0 &&
                        (cachedPackets[j].trackId !== videoTrackId || cachedPackets[j].packet.frameType !== VideoFrameType.KEY)) {
                        j--;
                    }
                    if (j > 0) {
                        // We have keyframes and not only the first frame is a keyframe...
                        cachedPackets = cachedPackets.slice(0, j);
                    }
                }
                if (cachedPackets.length === 0) {
                    return; // No data to produce.
                }
                var tdatParts = [];
                var tdatPosition = 0;
                var trafs = [];
                var trafDataStarts = [];
                var _loop_1 = function (i) {
                    var trackState = this_1.trackStates[i];
                    var trackInfo = trackState.trackInfo;
                    var trackId = trackState.trackId;
                    // Finding all packets for this track.
                    var trackPackets = cachedPackets.filter(function (cp) { return cp.trackId === trackId; });
                    if (trackPackets.length === 0) {
                        return "continue";
                    }
                    //let currentTimestamp = (trackPackets[0].timestamp * trackInfo.timescale / 1000) | 0;
                    var tfdt = new MP4.Iso.TrackFragmentBaseMediaDecodeTimeBox(trackState.cachedDuration);
                    var tfhd = void 0;
                    var trun = void 0;
                    var trunSamples = void 0;
                    var tfhdFlags = void 0, trunFlags = void 0;
                    trafDataStarts.push(tdatPosition);
                    switch (trackInfo.codecId) {
                        case AAC_SOUND_CODEC_ID:
                        case MP3_SOUND_CODEC_ID:
                            trunSamples = [];
                            for (var j = 0; j < trackPackets.length; j++) {
                                var audioPacket = trackPackets[j].packet;
                                var audioFrameDuration = Math.round(audioPacket.samples * trackInfo.timescale / trackInfo.samplerate);
                                tdatParts.push(audioPacket.data);
                                tdatPosition += audioPacket.data.length;
                                trunSamples.push({ duration: audioFrameDuration, size: audioPacket.data.length });
                                trackState.samplesProcessed += audioPacket.samples;
                            }
                            tfhdFlags = 32 /* DEFAULT_SAMPLE_FLAGS_PRESENT */;
                            tfhd = new MP4.Iso.TrackFragmentHeaderBox(tfhdFlags, trackId, 0 /* offset */, 0 /* index */, 0 /* duration */, 0 /* size */, 33554432 /* SAMPLE_DEPENDS_ON_NO_OTHERS */);
                            trunFlags = 1 /* DATA_OFFSET_PRESENT */ |
                                256 /* SAMPLE_DURATION_PRESENT */ | 512 /* SAMPLE_SIZE_PRESENT */;
                            trun = new MP4.Iso.TrackRunBox(trunFlags, trunSamples, 0 /* data offset */, 0 /* first flags */);
                            trackState.cachedDuration = Math.round(trackState.samplesProcessed * trackInfo.timescale / trackInfo.samplerate);
                            break;
                        case AVC_VIDEO_CODEC_ID:
                        case VP6_VIDEO_CODEC_ID:
                            trunSamples = [];
                            var samplesProcessed = trackState.samplesProcessed;
                            var decodeTime = samplesProcessed * trackInfo.timescale / trackInfo.framerate;
                            var lastTime = Math.round(decodeTime);
                            for (var j = 0; j < trackPackets.length; j++) {
                                var videoPacket = trackPackets[j].packet;
                                samplesProcessed++;
                                var nextTime = Math.round(samplesProcessed * trackInfo.timescale / trackInfo.framerate);
                                var videoFrameDuration = nextTime - lastTime;
                                lastTime = nextTime;
                                var compositionTime = Math.round(samplesProcessed * trackInfo.timescale / trackInfo.framerate +
                                    videoPacket.compositionTime * trackInfo.timescale / 1000);
                                tdatParts.push(videoPacket.data);
                                tdatPosition += videoPacket.data.length;
                                var frameFlags = videoPacket.frameType === VideoFrameType.KEY ?
                                    33554432 /* SAMPLE_DEPENDS_ON_NO_OTHERS */ :
                                    (16777216 /* SAMPLE_DEPENDS_ON_OTHER */ | 65536 /* SAMPLE_IS_NOT_SYNC */);
                                trunSamples.push({
                                    duration: videoFrameDuration, size: videoPacket.data.length,
                                    flags: frameFlags, compositionTimeOffset: (compositionTime - nextTime)
                                });
                            }
                            tfhdFlags = 32 /* DEFAULT_SAMPLE_FLAGS_PRESENT */;
                            tfhd = new MP4.Iso.TrackFragmentHeaderBox(tfhdFlags, trackId, 0 /* offset */, 0 /* index */, 0 /* duration */, 0 /* size */, 33554432 /* SAMPLE_DEPENDS_ON_NO_OTHERS */);
                            trunFlags = 1 /* DATA_OFFSET_PRESENT */ |
                                256 /* SAMPLE_DURATION_PRESENT */ | 512 /* SAMPLE_SIZE_PRESENT */ |
                                1024 /* SAMPLE_FLAGS_PRESENT */ | 2048 /* SAMPLE_COMPOSITION_TIME_OFFSET */;
                            trun = new MP4.Iso.TrackRunBox(trunFlags, trunSamples, 0 /* data offset */, 0 /* first flag */);
                            trackState.cachedDuration = lastTime;
                            trackState.samplesProcessed = samplesProcessed;
                            break;
                        default:
                            throw new Error('Un codec');
                    }
                    var traf = new MP4.Iso.TrackFragmentBox(tfhd, tfdt, trun);
                    trafs.push(traf);
                };
                var this_1 = this;
                for (var i = 0; i < this.trackStates.length; i++) {
                    _loop_1(i);
                }
                this.cachedPackets.splice(0, cachedPackets.length);
                var moofHeader = new MP4.Iso.MovieFragmentHeaderBox(++this.chunkIndex);
                var moof = new MP4.Iso.MovieFragmentBox(moofHeader, trafs);
                var moofSize = moof.layout(0);
                var mdat = new MP4.Iso.MediaDataBox(tdatParts);
                var mdatSize = mdat.layout(moofSize);
                var tdatOffset = moofSize + 8 /* 'mdat' header size */;
                for (var i = 0; i < trafs.length; i++) {
                    trafs[i].run.dataOffset = tdatOffset + trafDataStarts[i];
                }
                var chunk = new Uint8Array(moofSize + mdatSize);
                moof.write(chunk);
                mdat.write(chunk);
                this.ondata(chunk);
                this.filePos += chunk.length;
            };
            return MP4Mux;
        }());
        MP4.MP4Mux = MP4Mux;
        function parseFLVMetadata(metadata) {
            var tracks = [];
            var audioTrackId = -1;
            var videoTrackId = -1;
            var duration = +metadata.axGetPublicProperty('duration');
            var audioCodec, audioCodecId;
            var audioCodecCode = metadata.axGetPublicProperty('audiocodecid');
            switch (audioCodecCode) {
                case MP3_SOUND_CODEC_ID:
                case 'mp3':
                    audioCodec = 'mp3';
                    audioCodecId = MP3_SOUND_CODEC_ID;
                    break;
                case AAC_SOUND_CODEC_ID:
                case 'mp4a':
                    audioCodec = 'mp4a';
                    audioCodecId = AAC_SOUND_CODEC_ID;
                    break;
                default:
                    if (!isNaN(audioCodecCode)) {
                        throw new Error('Unsupported audio codec: ' + audioCodecCode);
                    }
                    audioCodec = null;
                    audioCodecId = -1;
                    break;
            }
            var videoCodec, videoCodecId;
            var videoCodecCode = metadata.axGetPublicProperty('videocodecid');
            switch (videoCodecCode) {
                case VP6_VIDEO_CODEC_ID:
                case 'vp6f':
                    videoCodec = 'vp6f';
                    videoCodecId = VP6_VIDEO_CODEC_ID;
                    break;
                case AVC_VIDEO_CODEC_ID:
                case 'avc1':
                    videoCodec = 'avc1';
                    videoCodecId = AVC_VIDEO_CODEC_ID;
                    break;
                default:
                    if (!isNaN(videoCodecCode)) {
                        throw new Error('Unsupported video codec: ' + videoCodecCode);
                    }
                    videoCodec = null;
                    videoCodecId = -1;
                    break;
            }
            var audioTrack = (audioCodec === null) ? null : {
                codecDescription: audioCodec,
                codecId: audioCodecId,
                language: 'und',
                timescale: +metadata.axGetPublicProperty('audiosamplerate') || 44100,
                samplerate: +metadata.axGetPublicProperty('audiosamplerate') || 44100,
                channels: +metadata.axGetPublicProperty('audiochannels') || 2,
                samplesize: 16
            };
            var videoTrack = (videoCodec === null) ? null : {
                codecDescription: videoCodec,
                codecId: videoCodecId,
                language: 'und',
                timescale: 60000,
                framerate: +metadata.axGetPublicProperty('videoframerate') ||
                    +metadata.axGetPublicProperty('framerate'),
                width: +metadata.axGetPublicProperty('width'),
                height: +metadata.axGetPublicProperty('height')
            };
            var trackInfos = metadata.axGetPublicProperty('trackinfo');
            if (trackInfos) {
                // Not in the Adobe's references, red5 specific?
                for (var i = 0; i < trackInfos.length; i++) {
                    var info = trackInfos[i];
                    var sampleDescription = info.axGetPublicProperty('sampledescription')[0];
                    if (sampleDescription.axGetPublicProperty('sampletype') === audioCodecCode) {
                        audioTrack.language = info.axGetPublicProperty('language');
                        audioTrack.timescale = +info.axGetPublicProperty('timescale');
                    }
                    else if (sampleDescription.axGetPublicProperty('sampletype') === videoCodecCode) {
                        videoTrack.language = info.axGetPublicProperty('language');
                        videoTrack.timescale = +info.axGetPublicProperty('timescale');
                    }
                }
            }
            if (videoTrack) {
                videoTrackId = tracks.length;
                tracks.push(videoTrack);
            }
            if (audioTrack) {
                audioTrackId = tracks.length;
                tracks.push(audioTrack);
            }
            return {
                tracks: tracks,
                duration: duration,
                audioTrackId: audioTrackId,
                videoTrackId: videoTrackId
            };
        }
        MP4.parseFLVMetadata = parseFLVMetadata;
    })(MP4 = RtmpJs.MP4 || (RtmpJs.MP4 = {}));
})(RtmpJs || (RtmpJs = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var FLV;
    (function (FLV) {
        var FLVParser = /** @class */ (function () {
            function FLVParser() {
                this.state = 0;
                this.state = 0;
                this.buffer = new ArrayBuffer(1024);
                this.bufferSize = 0;
                this.previousTagSize = 0;
                this.onError = null;
                this.onHeader = null;
                this.onTag = null;
                this.onClose = null;
            }
            FLVParser.prototype.push = function (data) {
                var parseBuffer;
                if (this.bufferSize > 0) {
                    var needLength = this.bufferSize + data.length;
                    if (this.buffer.byteLength < needLength) {
                        var tmp = new Uint8Array(this.buffer, 0, this.bufferSize);
                        this.buffer = new ArrayBuffer(needLength);
                        parseBuffer = new Uint8Array(this.buffer);
                        parseBuffer.set(tmp);
                    }
                    else {
                        parseBuffer = new Uint8Array(this.buffer, 0, needLength);
                    }
                    parseBuffer.set(data, this.bufferSize);
                }
                else {
                    parseBuffer = data;
                }
                var parsed = 0, end = parseBuffer.length;
                while (parsed < end) {
                    var chunkParsed = 0;
                    var flags = void 0;
                    switch (this.state) {
                        case 0:
                            if (parsed + 9 > end) {
                                break;
                            }
                            var headerLength = (parseBuffer[parsed + 5] << 24) | (parseBuffer[parsed + 6] << 16) |
                                (parseBuffer[parsed + 7] << 8) | parseBuffer[parsed + 8];
                            if (headerLength < 9) {
                                this._error('Invalid header length');
                                break;
                            }
                            if (parsed + headerLength > end) {
                                break;
                            }
                            if (parseBuffer[parsed] !== 0x46 /* F */ ||
                                parseBuffer[parsed + 1] !== 0x4C /* L */ ||
                                parseBuffer[parsed + 2] !== 0x56 /* V */ ||
                                parseBuffer[parsed + 3] !== 1 /* version 1 */ ||
                                (parseBuffer[parsed + 4] & 0xFA) !== 0) {
                                this._error('Invalid FLV header');
                                break;
                            }
                            flags = parseBuffer[parsed + 4];
                            var extra = headerLength > 9 ? parseBuffer.subarray(parsed + 9, parsed + headerLength) : null;
                            this.onHeader && this.onHeader({
                                hasAudio: !!(flags & 4),
                                hasVideo: !!(flags & 1),
                                extra: extra
                            });
                            this.state = 2;
                            chunkParsed = headerLength;
                            break;
                        case 2:
                            if (parsed + 4 + 11 > end) {
                                break;
                            }
                            var previousTagSize = (parseBuffer[parsed + 0] << 24) | (parseBuffer[parsed + 1] << 16) |
                                (parseBuffer[parsed + 2] << 8) | parseBuffer[parsed + 3];
                            if (previousTagSize !== this.previousTagSize) {
                                this._error('Invalid PreviousTagSize');
                                break;
                            }
                            var dataSize = (parseBuffer[parsed + 5] << 16) |
                                (parseBuffer[parsed + 6] << 8) | parseBuffer[parsed + 7];
                            var dataOffset = parsed + 4 + 11;
                            if (dataOffset + dataSize > end) {
                                break;
                            }
                            flags = parseBuffer[parsed + 4];
                            var streamID = (parseBuffer[parsed + 12] << 16) |
                                (parseBuffer[parsed + 13] << 8) | parseBuffer[parsed + 14];
                            if (streamID !== 0 || (flags & 0xC0) !== 0) {
                                this._error('Invalid FLV tag');
                                break;
                            }
                            var dataType = flags & 0x1F;
                            if (dataType !== 8 && dataType !== 9 && dataType !== 18) {
                                this._error('Invalid FLV tag type');
                                break;
                            }
                            var needPreprocessing = !!(flags & 0x20);
                            var timestamp = (parseBuffer[parsed + 8] << 16) |
                                (parseBuffer[parsed + 9] << 8) | parseBuffer[parsed + 10] |
                                (parseBuffer[parsed + 11] << 24) /* signed part */;
                            this.onTag && this.onTag({
                                type: dataType,
                                needPreprocessing: needPreprocessing,
                                timestamp: timestamp,
                                data: parseBuffer.subarray(dataOffset, dataOffset + dataSize)
                            });
                            chunkParsed += 4 + 11 + dataSize;
                            this.previousTagSize = dataSize + 11;
                            this.state = 2;
                            break;
                        default:
                            throw new Error('invalid state');
                    }
                    if (chunkParsed === 0) {
                        break; // not enough data
                    }
                    parsed += chunkParsed;
                }
                if (parsed < parseBuffer.length) {
                    this.bufferSize = parseBuffer.length - parsed;
                    if (this.buffer.byteLength < this.bufferSize) {
                        this.buffer = new ArrayBuffer(this.bufferSize);
                    }
                    new Uint8Array(this.buffer).set(parseBuffer.subarray(parsed));
                }
                else {
                    this.bufferSize = 0;
                }
            };
            FLVParser.prototype._error = function (message) {
                this.state = -1;
                this.onError && this.onError(message);
            };
            FLVParser.prototype.close = function () {
                this.onClose && this.onClose();
            };
            return FLVParser;
        }());
        FLV.FLVParser = FLVParser;
    })(FLV = RtmpJs.FLV || (RtmpJs.FLV = {}));
})(RtmpJs || (RtmpJs = {}));
///<reference path='external.ts' />
///<reference path='rtmp.ts' />
///<reference path='transport.ts' />
///<reference path='transport-browser.ts' />
///<reference path='mp4iso.ts' />
///<reference path='mp4mux.ts' />
///<reference path='flvparser.ts' />
// this is taken from AVM2 only for name parsing
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var lang;
        (function (lang) {
            var assert = Shumway.Debug.assert;
            var CONSTANT;
            (function (CONSTANT) {
                CONSTANT[CONSTANT["Undefined"] = 0] = "Undefined";
                CONSTANT[CONSTANT["Utf8"] = 1] = "Utf8";
                CONSTANT[CONSTANT["Float"] = 2] = "Float";
                CONSTANT[CONSTANT["Int"] = 3] = "Int";
                CONSTANT[CONSTANT["UInt"] = 4] = "UInt";
                CONSTANT[CONSTANT["PrivateNs"] = 5] = "PrivateNs";
                CONSTANT[CONSTANT["Double"] = 6] = "Double";
                CONSTANT[CONSTANT["QName"] = 7] = "QName";
                CONSTANT[CONSTANT["Namespace"] = 8] = "Namespace";
                CONSTANT[CONSTANT["Multiname"] = 9] = "Multiname";
                CONSTANT[CONSTANT["False"] = 10] = "False";
                CONSTANT[CONSTANT["True"] = 11] = "True";
                CONSTANT[CONSTANT["Null"] = 12] = "Null";
                CONSTANT[CONSTANT["QNameA"] = 13] = "QNameA";
                CONSTANT[CONSTANT["MultinameA"] = 14] = "MultinameA";
                CONSTANT[CONSTANT["RTQName"] = 15] = "RTQName";
                CONSTANT[CONSTANT["RTQNameA"] = 16] = "RTQNameA";
                CONSTANT[CONSTANT["RTQNameL"] = 17] = "RTQNameL";
                CONSTANT[CONSTANT["RTQNameLA"] = 18] = "RTQNameLA";
                CONSTANT[CONSTANT["NameL"] = 19] = "NameL";
                CONSTANT[CONSTANT["NameLA"] = 20] = "NameLA";
                CONSTANT[CONSTANT["NamespaceSet"] = 21] = "NamespaceSet";
                CONSTANT[CONSTANT["PackageNamespace"] = 22] = "PackageNamespace";
                CONSTANT[CONSTANT["PackageInternalNs"] = 23] = "PackageInternalNs";
                CONSTANT[CONSTANT["ProtectedNamespace"] = 24] = "ProtectedNamespace";
                CONSTANT[CONSTANT["ExplicitNamespace"] = 25] = "ExplicitNamespace";
                CONSTANT[CONSTANT["StaticProtectedNs"] = 26] = "StaticProtectedNs";
                CONSTANT[CONSTANT["MultinameL"] = 27] = "MultinameL";
                CONSTANT[CONSTANT["MultinameLA"] = 28] = "MultinameLA";
                CONSTANT[CONSTANT["TypeName"] = 29] = "TypeName";
                CONSTANT[CONSTANT["ClassSealed"] = 1] = "ClassSealed";
                CONSTANT[CONSTANT["ClassFinal"] = 2] = "ClassFinal";
                CONSTANT[CONSTANT["ClassInterface"] = 4] = "ClassInterface";
                CONSTANT[CONSTANT["ClassProtectedNs"] = 8] = "ClassProtectedNs";
            })(CONSTANT = lang.CONSTANT || (lang.CONSTANT = {}));
            var CONSTANTNames = ["Undefined", "Utf8|ClassSealed", "Float|ClassFinal", "Int", "UInt|ClassInterface", "PrivateNs", "Double", "QName", "Namespace|ClassProtectedNs", "Multiname", "False", "True", "Null", "QNameA", "MultinameA", "RTQName", "RTQNameA", "RTQNameL", "RTQNameLA", "NameL", "NameLA", "NamespaceSet", "PackageNamespace", "PackageInternalNs", "ProtectedNamespace", "ExplicitNamespace", "StaticProtectedNs", "MultinameL", "MultinameLA", "TypeName"];
            function getCONSTANTName(constant) {
                return release ? String(constant) : CONSTANTNames[constant];
            }
            lang.getCONSTANTName = getCONSTANTName;
            var NamespaceType;
            (function (NamespaceType) {
                NamespaceType[NamespaceType["Public"] = 0] = "Public";
                NamespaceType[NamespaceType["Protected"] = 1] = "Protected";
                NamespaceType[NamespaceType["PackageInternal"] = 2] = "PackageInternal";
                NamespaceType[NamespaceType["Private"] = 3] = "Private";
                NamespaceType[NamespaceType["Explicit"] = 4] = "Explicit";
                NamespaceType[NamespaceType["StaticProtected"] = 5] = "StaticProtected";
            })(NamespaceType = lang.NamespaceType || (lang.NamespaceType = {}));
            var namespaceTypeNames = ["Public", "Protected", "PackageInternal", "Private", "Explicit", "StaticProtected"];
            function getNamespaceTypeName(namespaceType) {
                return release ? String(namespaceType) : namespaceTypeNames[namespaceType];
            }
            lang.getNamespaceTypeName = getNamespaceTypeName;
            // Used in _hashNamespace so we don't need to allocate a new buffer each time.
            var namespaceHashingBuffer = new Int32Array(100);
            var Namespace = /** @class */ (function () {
                function Namespace(type, uri, prefix) {
                    this.type = type;
                    this.uri = uri;
                    this.prefix = prefix;
                    this.mangledName = null;
                    assert(type !== undefined);
                    this.mangleName();
                    if (!release) {
                        Object.freeze(this);
                    }
                }
                Namespace.prototype.toString = function () {
                    return getNamespaceTypeName(this.type) + (this.uri !== "" ? ":" + this.uri : "");
                };
                Namespace._hashNamespace = function (type, uri, prefix) {
                    uri = uri + '';
                    prefix = prefix + '';
                    var index = Namespace._knownNames.indexOf(uri);
                    if (index >= 0) {
                        return type << 2 | index;
                    }
                    var length = 1 + uri.length + prefix.length;
                    var data = length < 101 ? namespaceHashingBuffer : new Int32Array(length);
                    var j = 0;
                    data[j++] = type;
                    for (var i = 0; i < uri.length; i++) {
                        data[j++] = uri.charCodeAt(i);
                    }
                    for (var i = 0; i < prefix.length; i++) {
                        data[j++] = prefix.charCodeAt(i);
                    }
                    return Shumway.HashUtilities.hashBytesTo32BitsMD5(data, 0, j);
                };
                Namespace.prototype.mangleName = function () {
                    if (this.type === 0 /* Public */ && this.uri === '') {
                        this.mangledName = 'Bg';
                        return;
                    }
                    var nsHash = Namespace._hashNamespace(this.type, this.uri, this.prefix);
                    this.mangledName = Shumway.StringUtilities.variableLengthEncodeInt32(nsHash);
                };
                Namespace.prototype.isPublic = function () {
                    return this.type === 0 /* Public */;
                };
                Object.defineProperty(Namespace.prototype, "reflectedURI", {
                    get: function () {
                        // For public names without a URI, Tamarin uses `null`, we use `""`.
                        // Hence: special-casing for reflection.
                        return this.uri || (this.type === 0 /* Public */ ? null : this.uri);
                    },
                    enumerable: true,
                    configurable: true
                });
                Namespace._knownNames = [
                    ""
                ];
                return Namespace;
            }());
            lang.Namespace = Namespace;
            var _namespaces = {};
            function internNamespace(type, uri) {
                var key = type + uri;
                return _namespaces[key] || (_namespaces[key] = new Namespace(type, uri, ''));
            }
            lang.internNamespace = internNamespace;
            function internPrefixedNamespace(type, uri, prefix) {
                var key = type + uri + prefix;
                var ns = _namespaces[key];
                if (!ns) {
                    ns = _namespaces[key] = new Namespace(type, uri, prefix);
                }
                return ns;
            }
            lang.internPrefixedNamespace = internPrefixedNamespace;
            var ABCFile = /** @class */ (function () {
                function ABCFile(loaderInfo, _buffer) {
                }
                return ABCFile;
            }());
            lang.ABCFile = ABCFile;
            var Multiname = /** @class */ (function () {
                function Multiname(abc, index, kind, namespaces, name, parameterType) {
                    if (parameterType === void 0) { parameterType = null; }
                    this.abc = abc;
                    this.index = index;
                    this.kind = kind;
                    this.namespaces = namespaces;
                    this.name = name;
                    this.parameterType = parameterType;
                    this.id = Multiname._nextID++;
                    this._mangledName = null;
                    // ...
                }
                Multiname.FromFQNString = function (fqn, nsType) {
                    var lastDot = fqn.lastIndexOf('.');
                    var uri = lastDot === -1 ? '' : fqn.substr(0, lastDot);
                    var name = lastDot === -1 ? fqn : fqn.substr(lastDot + 1);
                    var ns = internNamespace(nsType, uri);
                    return new Multiname(null, 0, 15 /* RTQName */, [ns], name);
                };
                Multiname.prototype._nameToString = function () {
                    if (this.isAnyName()) {
                        return "*";
                    }
                    return this.isRuntimeName() ? "[" + this.name + "]" : this.name;
                };
                Multiname.prototype.isRuntime = function () {
                    switch (this.kind) {
                        case 7 /* QName */:
                        case 13 /* QNameA */:
                        case 9 /* Multiname */:
                        case 14 /* MultinameA */:
                            return false;
                    }
                    return true;
                };
                Multiname.prototype.isRuntimeName = function () {
                    switch (this.kind) {
                        case 17 /* RTQNameL */:
                        case 18 /* RTQNameLA */:
                        case 27 /* MultinameL */:
                        case 28 /* MultinameLA */:
                            return true;
                    }
                    return false;
                };
                Multiname.prototype.isRuntimeNamespace = function () {
                    switch (this.kind) {
                        case 15 /* RTQName */:
                        case 16 /* RTQNameA */:
                        case 17 /* RTQNameL */:
                        case 18 /* RTQNameLA */:
                            return true;
                    }
                    return false;
                };
                Multiname.prototype.isAnyName = function () {
                    return this.name === null;
                };
                Multiname.prototype.isAnyNamespace = function () {
                    if (this.isRuntimeNamespace() || this.namespaces.length > 1) {
                        return false;
                    }
                    return this.namespaces.length === 0 || this.namespaces[0].uri === "";
                    // x.* has the same meaning as x.*::*, so look for the former case and give
                    // it the same meaning of the latter.
                    // return !this.isRuntimeNamespace() &&
                    //  (this.namespaces.length === 0 || (this.isAnyName() && this.namespaces.length !== 1));
                };
                Multiname.prototype.isQName = function () {
                    var kind = this.kind;
                    var result = kind === 29 /* TypeName */ ||
                        kind === 7 /* QName */ || kind === 13 /* QNameA */ ||
                        kind >= 15 /* RTQName */ && kind <= 18 /* RTQNameLA */;
                    release || assert(!(result && this.namespaces.length !== 1));
                    return result;
                };
                Object.defineProperty(Multiname.prototype, "namespace", {
                    get: function () {
                        release || assert(this.isQName());
                        return this.namespaces[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multiname.prototype, "uri", {
                    get: function () {
                        release || assert(this.isQName());
                        return this.namespaces[0].uri;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multiname.prototype, "prefix", {
                    get: function () {
                        release || assert(this.isQName());
                        return this.namespaces[0].prefix;
                    },
                    set: function (prefix) {
                        release || assert(this.isQName());
                        var ns = this.namespaces[0];
                        if (ns.prefix === prefix) {
                            return;
                        }
                        this.namespaces[0] = internPrefixedNamespace(ns.type, ns.uri, prefix);
                    },
                    enumerable: true,
                    configurable: true
                });
                Multiname.prototype.equalsQName = function (mn) {
                    release || assert(this.isQName());
                    return this.name === mn.name && this.namespaces[0].uri === mn.namespaces[0].uri;
                };
                Multiname.prototype.matches = function (mn) {
                    release || assert(this.isQName());
                    var anyName = mn.isAnyName();
                    if (anyName && !mn.isQName()) {
                        return true;
                    }
                    if (!anyName && this.name !== mn.name) {
                        return false;
                    }
                    var uri = this.namespaces[0].uri;
                    for (var i = mn.namespaces.length; i--;) {
                        if (mn.namespaces[i].uri === uri) {
                            return true;
                        }
                    }
                    return false;
                };
                Multiname.prototype.isAttribute = function () {
                    switch (this.kind) {
                        case 13 /* QNameA */:
                        case 16 /* RTQNameA */:
                        case 18 /* RTQNameLA */:
                        case 14 /* MultinameA */:
                        case 28 /* MultinameLA */:
                            return true;
                    }
                    return false;
                };
                Multiname.prototype.getMangledName = function () {
                    release || assert(this.isQName());
                    return this._mangledName || this._mangleName();
                };
                Multiname.prototype._mangleName = function () {
                    release || assert(!this._mangledName);
                    var mangledName = "$" + this.namespaces[0].mangledName + (this.name);
                    if (!this.isRuntime()) {
                        this._mangledName = mangledName;
                    }
                    return mangledName;
                };
                Multiname.prototype.getPublicMangledName = function () {
                    if (Shumway.isNumeric(this.name)) {
                        return this.name;
                    }
                    return "$Bg" + (this.name);
                };
                Multiname.isPublicQualifiedName = function (value) {
                    return value.indexOf('$Bg') === 0;
                };
                Multiname.getPublicMangledName = function (name) {
                    if (Shumway.isNumeric(name)) {
                        return name;
                    }
                    return "$Bg" + name;
                };
                Multiname.prototype.toFQNString = function (useColons) {
                    release || assert(this.isQName());
                    var prefix = this.namespaces[0].uri;
                    if (prefix.length) {
                        prefix += (useColons ? '::' : '.');
                    }
                    return prefix + this.name;
                };
                Multiname.prototype.toString = function () {
                    var str = getCONSTANTName(this.kind) + " ";
                    str += this.isAttribute() ? "@" : "";
                    if (this.isRuntimeNamespace()) {
                        var namespaces = this.namespaces ? this.namespaces.map(function (x) { return String(x); }).join(", ") : null;
                        str += "[" + namespaces + "]::" + this._nameToString();
                    }
                    else if (this.isQName()) {
                        str += this.namespaces[0] + "::";
                        str += this._nameToString();
                    }
                    else {
                        str += "{" + this.namespaces.map(function (x) { return String(x); }).join(", ") + "}";
                        str += "::" + this._nameToString();
                    }
                    if (this.parameterType) {
                        str += "<" + this.parameterType + ">";
                    }
                    return str;
                };
                Multiname.prototype.toFlashlogString = function () {
                    var namespaceUri = this.uri;
                    return namespaceUri ? namespaceUri + "::" + this.name : this.name;
                };
                /**
                 * Removes the public prefix, or returns undefined if the prefix doesn't exist.
                 */
                Multiname.stripPublicMangledName = function (name) {
                    if (name.indexOf("$Bg") === 0) {
                        return name.substring(3);
                    }
                    return undefined;
                };
                Multiname.FromSimpleName = function (simpleName) {
                    var nameIndex = simpleName.lastIndexOf(".");
                    if (nameIndex <= 0) {
                        nameIndex = simpleName.lastIndexOf(" ");
                    }
                    var uri = '';
                    var name;
                    if (nameIndex > 0 && nameIndex < simpleName.length - 1) {
                        name = simpleName.substring(nameIndex + 1).trim();
                        uri = simpleName.substring(0, nameIndex).trim();
                    }
                    else {
                        name = simpleName;
                    }
                    var ns = internNamespace(0 /* Public */, uri);
                    return new Multiname(null, 0, 15 /* RTQName */, [ns], name);
                };
                Multiname._nextID = 1;
                return Multiname;
            }());
            lang.Multiname = Multiname;
            // Native classes
        })(lang = flash.lang || (flash.lang = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var lang;
        (function (lang) {
            var assert = Shumway.Debug.assert;
            var LegacyClass = flash.system.LegacyClass;
            var nativeClasses = Shumway.ObjectUtilities.createMap();
            var nativeFunctions = Shumway.ObjectUtilities.createMap();
            lang.nativeClassLoaderNames = [];
            function registerNativeClass(name, asClass, alias, nsType) {
                if (alias === void 0) { alias = name; }
                if (nsType === void 0) { nsType = 0 /* Public */; }
                release || assert(!nativeClasses[name], "Native class: " + name + " is already registered.");
                nativeClasses[name] = asClass;
                lang.nativeClassLoaderNames.push({ name: name, alias: alias, nsType: nsType });
            }
            lang.registerNativeClass = registerNativeClass;
            function registerNativeFunction(path, fun) {
                release || assert(!nativeFunctions[path], "Native function: " + path + " is already registered.");
                nativeFunctions[path] = fun;
            }
            lang.registerNativeFunction = registerNativeFunction;
            function createLegacyClass(name, proto) {
                function symbolClass() {
                    proto.jsClass.apply(this, arguments);
                }
                symbolClass.prototype = Object.create(proto.jsClass.prototype);
                symbolClass.prototype.constructor = symbolClass;
                return new LegacyClass(symbolClass);
            }
            lang.createLegacyClass = createLegacyClass;
            function getNativeClass(name) {
                return this.nativeClasses[name.toFQNString(false)] || null;
            }
            lang.getNativeClass = getNativeClass;
        })(lang = flash.lang || (flash.lang = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    Shumway.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer("AVX") : null;
    Shumway.counter = new Shumway.Metrics.Counter(!release);
    function countTimeline(name, value) {
        if (value === void 0) { value = 1; }
        Shumway.timelineBuffer && Shumway.timelineBuffer.count(name, value);
    }
    Shumway.countTimeline = countTimeline;
    function enterTimeline(name, data) {
        profile && Shumway.timelineBuffer && Shumway.timelineBuffer.enter(name, data);
    }
    Shumway.enterTimeline = enterTimeline;
    function leaveTimeline(data) {
        profile && Shumway.timelineBuffer && Shumway.timelineBuffer.leave(null, data);
    }
    Shumway.leaveTimeline = leaveTimeline;
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    /*
     * HTML Parser By John Resig (ejohn.org)
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     *
     * // Use like so:
     * HTMLParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     */
    // Regular Expressions for parsing tags and attributes
    var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[-A-Za-z0-9_]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/, endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/, attr = /([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
    // Empty Elements - HTML 4.01
    var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");
    // Block Elements - HTML 4.01
    var block = makeMap("address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul");
    // Inline Elements - HTML 4.01
    var inline = makeMap("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");
    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");
    // Attributes that have their values filled in disabled="disabled"
    var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");
    // Special Elements (can contain anything)
    var special = makeMap("script,style");
    function HTMLParser(html, handler) {
        var index, chars, match, stack = [], last = html;
        function top() {
            return stack[stack.length - 1];
        }
        while (html) {
            chars = true;
            // Make sure we're not in a script or style element
            if (!top() || !special[top()]) {
                // Comment
                if (html.indexOf("<!--") == 0) {
                    index = html.indexOf("-->");
                    if (index >= 0) {
                        if (handler.comment)
                            handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                    // end tag
                }
                else if (html.indexOf("</") == 0) {
                    match = html.match(endTag);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                    // start tag
                }
                else if (html.indexOf("<") == 0) {
                    match = html.match(startTag);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(startTag, parseStartTag);
                        chars = false;
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars)
                        handler.chars(text);
                }
            }
            else {
                html = html.replace(new RegExp("(.*)<\/" + top() + "[^>]*>"), function (all, text) {
                    text = text.replace(/<!--(.*?)-->/g, "$1")
                        .replace(/<!\[CDATA\[(.*?)]]>/g, "$1");
                    if (handler.chars)
                        handler.chars(text);
                    return "";
                });
                parseEndTag("", top());
            }
            if (html == last)
                throw "Parse Error: " + html;
            last = html;
        }
        // Clean up any remaining tags
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = tagName.toLowerCase();
            if (block[tagName]) {
                while (top() && inline[top()]) {
                    parseEndTag("", top());
                }
            }
            if (closeSelf[tagName] && top() == tagName) {
                parseEndTag("", tagName);
            }
            var unary_ = empty[tagName] || !!unary;
            if (!unary_)
                stack.push(tagName);
            if (handler.start) {
                var attrs_1 = Object.create(null);
                rest.replace(attr, function (match, name) {
                    name = name.toLowerCase();
                    var value = arguments[2] ? arguments[2] :
                        arguments[3] ? arguments[3] :
                            arguments[4] ? arguments[4] :
                                fillAttrs[name] ? name : "";
                    attrs_1[name] = value;
                    return match;
                });
                if (handler.start)
                    handler.start(tagName, attrs_1, unary_);
            }
        }
        function parseEndTag(tag, tagName) {
            // If no tag name is provided, clean shop
            var pos;
            if (!tagName)
                pos = 0;
            else
                for (pos = stack.length - 1; pos >= 0; pos--)
                    if (stack[pos] == tagName)
                        break;
            if (pos >= 0) {
                // Close all the open elements, up the stack
                for (var i = stack.length - 1; i >= pos; i--)
                    if (handler.end)
                        handler.end(stack[i]);
                // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }
    Shumway.HTMLParser = HTMLParser;
    function makeMap(str) {
        var obj = {}, items = str.split(",");
        for (var i = 0; i < items.length; i++)
            obj[items[i]] = true;
        return obj;
    }
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var notImplemented = Shumway.Debug.notImplemented;
    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
    var Bounds = Shumway.Bounds;
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ColorUtilities = Shumway.ColorUtilities;
    var flash = Shumway.flash;
    var altTieBreakRound = Shumway.NumberUtilities.altTieBreakRound;
    var TextContentFlags;
    (function (TextContentFlags) {
        TextContentFlags[TextContentFlags["None"] = 0] = "None";
        TextContentFlags[TextContentFlags["DirtyBounds"] = 1] = "DirtyBounds";
        TextContentFlags[TextContentFlags["DirtyContent"] = 2] = "DirtyContent";
        TextContentFlags[TextContentFlags["DirtyStyle"] = 4] = "DirtyStyle";
        TextContentFlags[TextContentFlags["DirtyFlow"] = 8] = "DirtyFlow";
        TextContentFlags[TextContentFlags["Dirty"] = 15] = "Dirty";
    })(TextContentFlags = Shumway.TextContentFlags || (Shumway.TextContentFlags = {}));
    var _decodeHTMLMap = {
        lt: '<',
        gt: '>',
        amp: '&',
        quot: '"',
        apos: "'",
        nbsp: "\u00A0"
    };
    /**
     * Decodes strings of the format:
     *
     * &#0000;
     * &#x0000;
     * &#x0000;
     * &amp;
     * &lthello
     *
     * This is complete enough to handle encoded HTML produced by the Flash IDE.
     */
    function decodeHTML(s) {
        var r = "";
        for (var i = 0; i < s.length; i++) {
            var c = s.charAt(i);
            if (c !== '&') {
                r += c;
            }
            else {
                // Look for the first '&' or ';', both of these can terminate
                // the current char code.
                var j = Shumway.StringUtilities.indexOfAny(s, ['&', ';'], i + 1);
                if (j > 0) {
                    var v = s.substring(i + 1, j);
                    if (v.length > 1 && v.charAt(0) === "#") {
                        var n = 0;
                        if (v.length > 2 && v.charAt(1) === "x") {
                            n = parseInt(v.substring(1));
                        }
                        else {
                            n = parseInt(v.substring(2), 16);
                        }
                        r += String.fromCharCode(n);
                    }
                    else {
                        if (_decodeHTMLMap[v] !== undefined) {
                            r += _decodeHTMLMap[v];
                        }
                        else {
                            Shumway.Debug.unexpected(v);
                        }
                    }
                    i = j;
                }
                else {
                    // Flash sometimes generates entities that don't have terminators,
                    // like &bthello. Strong bad sometimes encodes this that way.
                    for (var k in _decodeHTMLMap) {
                        if (s.indexOf(k, i + 1) === i + 1) {
                            r += _decodeHTMLMap[k];
                            i += k.length;
                            break;
                        }
                    }
                }
            }
        }
        return r;
    }
    var TextContent = /** @class */ (function () {
        function TextContent(sec, defaultTextFormat) {
            this._sec = sec;
            this._id = flash.display.DisplayObject.getNextSyncID();
            this._bounds = new Bounds(0, 0, 0, 0);
            this._plainText = '';
            this._backgroundColor = 0;
            this._borderColor = 0;
            this._autoSize = 0;
            this._wordWrap = false;
            this._scrollV = 1;
            this._scrollH = 0;
            this.flags = 0 /* None */;
            this.defaultTextFormat = defaultTextFormat || sec.text.TextFormat.create();
            this.textRuns = [];
            this.textRunData = new DataBuffer();
            this.matrix = null;
            this.coords = null;
        }
        TextContent.prototype.parseHtml = function (htmlText, styleSheet, multiline) {
            var _this = this;
            var plainText = '';
            var textRuns = this.textRuns;
            textRuns.length = 0;
            var beginIndex = 0;
            var endIndex = 0;
            var textFormat = this.defaultTextFormat.clone();
            var prevTextRun = null;
            var stack = [];
            var handler;
            Shumway.HTMLParser(htmlText, handler = {
                chars: function (text) {
                    text = decodeHTML(text);
                    plainText += text;
                    endIndex += text.length;
                    if (endIndex - beginIndex) {
                        if (prevTextRun && prevTextRun.textFormat.equals(textFormat)) {
                            prevTextRun.endIndex = endIndex;
                        }
                        else {
                            prevTextRun = _this._sec.text.TextRun.create([beginIndex, endIndex, textFormat]);
                            textRuns.push(prevTextRun);
                        }
                        beginIndex = endIndex;
                    }
                },
                start: function (tagName, attributes) {
                    var hasStyle = false;
                    if (styleSheet) {
                        hasStyle = styleSheet.hasStyle(tagName);
                        if (hasStyle) {
                            stack.push(textFormat);
                            textFormat = textFormat.clone();
                            styleSheet.applyStyle(textFormat, tagName);
                        }
                    }
                    switch (tagName) {
                        case 'a':
                            stack.push(textFormat);
                            somewhatImplemented('<a/>');
                            var target = attributes.target || textFormat.target;
                            var url = attributes.url || textFormat.url;
                            if (target !== textFormat.target || url !== textFormat.url) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.target = target;
                                textFormat.url = url;
                            }
                            break;
                        case 'b':
                            stack.push(textFormat);
                            if (!textFormat.bold) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.bold = true;
                            }
                            break;
                        case 'font':
                            stack.push(textFormat);
                            var color = ColorUtilities.isValidHexColor(attributes.color) ? ColorUtilities.hexToRGB(attributes.color) : textFormat.color;
                            var font = attributes.face || textFormat.font;
                            var size = isNaN(attributes.size) ? textFormat.size : +attributes.size;
                            var letterSpacing = isNaN(attributes.letterspacing) ? textFormat.letterSpacing : +attributes.letterspacing;
                            var kerning = isNaN(attributes.kerning) ? textFormat.kerning : +attributes.kerning;
                            if (color !== textFormat.color ||
                                font !== textFormat.font ||
                                size !== textFormat.size ||
                                letterSpacing !== textFormat.letterSpacing ||
                                kerning !== textFormat.kerning) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.color = color;
                                textFormat.font = font;
                                textFormat.size = size;
                                textFormat.letterSpacing = letterSpacing;
                                textFormat.kerning = kerning;
                            }
                            break;
                        case 'img':
                            notImplemented('<img/>');
                            break;
                        case 'i':
                            stack.push(textFormat);
                            if (!textFormat.italic) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.italic = true;
                            }
                            break;
                        case 'li':
                            stack.push(textFormat);
                            if (!textFormat.bullet) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.bullet = true;
                            }
                            if (plainText[plainText.length - 1] === '\r') {
                                break;
                            }
                        case 'br':
                        case 'sbr':
                            if (multiline) {
                                handler.chars('\r');
                            }
                            break;
                        case 'span':
                        case 'p':
                            var hasClassStyle = false;
                            stack.push(textFormat);
                            if (styleSheet && attributes.class) {
                                var cssClass = '.' + attributes.class;
                                hasClassStyle = styleSheet.hasStyle(cssClass);
                                if (hasClassStyle) {
                                    if (!hasStyle) {
                                        textFormat = textFormat.clone();
                                    }
                                    styleSheet.applyStyle(textFormat, cssClass);
                                }
                            }
                            if (tagName === 'span') {
                                break;
                            }
                            var align = attributes.align;
                            if (flash.text.TextFormatAlign.toNumber(align) > -1 && align !== textFormat.align) {
                                if (!(hasStyle || hasClassStyle)) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.align = align;
                            }
                            break;
                        case 'textformat':
                            stack.push(textFormat);
                            var blockIndent = isNaN(attributes.blockindent) ? textFormat.blockIndent : +attributes.blockindent;
                            var indent = isNaN(attributes.indent) ? textFormat.indent : +attributes.indent;
                            var leading = isNaN(attributes.leading) ? textFormat.leading : +attributes.leading;
                            var leftMargin = isNaN(attributes.leftmargin) ? textFormat.leftMargin : +attributes.leftmargin;
                            var rightMargin = isNaN(attributes.rightmargin) ? textFormat.rightMargin : +attributes.rightmargin;
                            //let tabStops = attributes.tabstops || textFormat.tabStops;
                            if (blockIndent !== textFormat.blockIndent ||
                                indent !== textFormat.indent ||
                                leading !== textFormat.leading ||
                                leftMargin !== textFormat.leftMargin ||
                                rightMargin !== textFormat.rightMargin /*||
              tabStops !== textFormat.tabStops*/) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.blockIndent = blockIndent;
                                textFormat.indent = indent;
                                textFormat.leading = leading;
                                textFormat.leftMargin = leftMargin;
                                textFormat.rightMargin = rightMargin;
                                //textFormat.tabStops = tabStops;
                            }
                            break;
                        case 'u':
                            stack.push(textFormat);
                            if (!textFormat.underline) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                textFormat.underline = true;
                            }
                            break;
                    }
                },
                end: function (tagName) {
                    switch (tagName) {
                        case 'li':
                        case 'p':
                            if (multiline) {
                                handler.chars('\r');
                            }
                        case 'a':
                        case 'b':
                        case 'font':
                        case 'i':
                        case 'textformat':
                        case 'u':
                            textFormat = stack.pop();
                            if (styleSheet && styleSheet.hasStyle(tagName)) {
                                textFormat = stack.pop();
                            }
                    }
                }
            });
            this._plainText = plainText;
            this._serializeTextRuns();
        };
        Object.defineProperty(TextContent.prototype, "plainText", {
            get: function () {
                return this._plainText;
            },
            set: function (value) {
                this._plainText = value.split('\n').join('\r');
                this.textRuns.length = 0;
                if (value) {
                    var textRun = this._sec.text.TextRun.create([0, value.length, this.defaultTextFormat]);
                    this.textRuns[0] = textRun;
                }
                this._serializeTextRuns();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "bounds", {
            get: function () {
                return this._bounds;
            },
            set: function (bounds) {
                this._bounds.copyFrom(bounds);
                this.flags |= 1 /* DirtyBounds */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "autoSize", {
            get: function () {
                return this._autoSize;
            },
            set: function (value) {
                if (value === this._autoSize) {
                    return;
                }
                this._autoSize = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "wordWrap", {
            get: function () {
                return this._wordWrap;
            },
            set: function (value) {
                if (value === this._wordWrap) {
                    return;
                }
                this._wordWrap = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "scrollV", {
            get: function () {
                return this._scrollV;
            },
            set: function (value) {
                if (value === this._scrollV) {
                    return;
                }
                this._scrollV = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "scrollH", {
            get: function () {
                return this._scrollH;
            },
            set: function (value) {
                if (value === this._scrollH) {
                    return;
                }
                this._scrollH = value;
                if (this._plainText) {
                    this.flags |= 8 /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "backgroundColor", {
            get: function () {
                return this._backgroundColor;
            },
            set: function (value) {
                if (value === this._backgroundColor) {
                    return;
                }
                this._backgroundColor = value;
                this.flags |= 4 /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, "borderColor", {
            get: function () {
                return this._borderColor;
            },
            set: function (value) {
                if (value === this._borderColor) {
                    return;
                }
                this._borderColor = value;
                this.flags |= 4 /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });
        TextContent.prototype._serializeTextRuns = function () {
            var textRuns = this.textRuns;
            this.textRunData.clear();
            for (var i = 0; i < textRuns.length; i++) {
                this._writeTextRun(textRuns[i]);
            }
            this.flags |= 2 /* DirtyContent */;
        };
        TextContent.prototype._writeTextRun = function (textRun) {
            var textRunData = this.textRunData;
            textRunData.writeInt(textRun.beginIndex);
            textRunData.writeInt(textRun.endIndex);
            var textFormat = textRun.textFormat;
            var size = +textFormat.size;
            textRunData.writeInt(size);
            var fontClass = this._sec.text;
            var font = fontClass.getByNameAndStyle(textFormat.font, textFormat.style) ||
                fontClass.getDefaultFont();
            if (font.fontType === flash.text.FontType.EMBEDDED) {
                textRunData.writeUTF('swffont' + font._id);
            }
            else {
                textRunData.writeUTF(font._fontFamily);
            }
            textRunData.writeInt(altTieBreakRound(font.ascent * size, true));
            textRunData.writeInt(altTieBreakRound(font.descent * size, false));
            textRunData.writeInt(textFormat.leading === null ? font.leading * size : +textFormat.leading);
            // For embedded fonts, always set bold and italic to false. They're fully identified by name.
            var bold = false;
            var italic = false;
            if (font.fontType === flash.text.FontType.DEVICE) {
                if (textFormat.bold === null) {
                    bold = font.fontStyle === flash.text.FontStyle.BOLD ||
                        font.fontStyle === flash.text.FontStyle.BOLD_ITALIC;
                }
                else {
                    bold = !!textFormat.bold;
                }
                if (textFormat.italic === null) {
                    italic = font.fontStyle === flash.text.FontStyle.ITALIC ||
                        font.fontStyle === flash.text.FontStyle.BOLD_ITALIC;
                }
                else {
                    italic = !!textFormat.italic;
                }
            }
            textRunData.writeBoolean(bold);
            textRunData.writeBoolean(italic);
            textRunData.writeInt(+textFormat.color);
            textRunData.writeInt(flash.text.TextFormatAlign.toNumber(textFormat.align));
            textRunData.writeBoolean(!!textFormat.bullet);
            //textRunData.writeInt(textFormat.display);
            textRunData.writeInt(+textFormat.indent);
            //textRunData.writeInt(textFormat.blockIndent);
            textRunData.writeInt(+textFormat.kerning);
            textRunData.writeInt(+textFormat.leftMargin);
            textRunData.writeInt(+textFormat.letterSpacing);
            textRunData.writeInt(+textFormat.rightMargin);
            //textRunData.writeInt(textFormat.tabStops);
            textRunData.writeBoolean(!!textFormat.underline);
        };
        TextContent.prototype.appendText = function (newText, format) {
            if (!format) {
                format = this.defaultTextFormat;
            }
            var plainText = this._plainText;
            var newRun = this._sec.text.TextRun.create([plainText.length,
                plainText.length + newText.length, format]);
            this._plainText = plainText + newText;
            this.textRuns.push(newRun);
            this._writeTextRun(newRun);
        };
        TextContent.prototype.prependText = function (newText, format) {
            if (!format) {
                format = this.defaultTextFormat;
            }
            var plainText = this._plainText;
            this._plainText = newText + plainText;
            var textRuns = this.textRuns;
            var shift = newText.length;
            for (var i = 0; i < textRuns.length; i++) {
                var run = textRuns[i];
                run.beginIndex += shift;
                run.endIndex += shift;
            }
            textRuns.unshift(this._sec.text.TextRun.create([0, shift, format]));
            this._serializeTextRuns();
        };
        TextContent.prototype.replaceText = function (beginIndex, endIndex, newText, format) {
            if (endIndex < beginIndex || !newText) {
                return;
            }
            if (endIndex === 0) {
                // Insert text at the beginning.
                this.prependText(newText, format);
                return;
            }
            var plainText = this._plainText;
            // When inserting text to the end, we can simply add a new text run without changing any
            // existing ones.
            if (beginIndex >= plainText.length) {
                this.appendText(newText, format);
                return;
            }
            var defaultTextFormat = this.defaultTextFormat;
            // A text format used for new text runs will have unset properties merged in from the default
            // text format.
            var newFormat = defaultTextFormat;
            if (format) {
                newFormat = newFormat.clone();
                newFormat.merge(format);
            }
            // If replacing the whole text, just regenerate runs by setting plainText.
            if (beginIndex <= 0 && endIndex >= plainText.length) {
                if (format) {
                    // Temporarily set the passed text format as default.
                    this.defaultTextFormat = newFormat;
                    this.plainText = newText;
                    // Restore the original default when finished.
                    this.defaultTextFormat = defaultTextFormat;
                }
                else {
                    this.plainText = newText;
                }
                return;
            }
            var textRuns = this.textRuns;
            var newTextRuns = [];
            var newEndIndex = beginIndex + newText.length;
            var shift = newEndIndex - endIndex;
            for (var i = 0; i < textRuns.length; i++) {
                var run = textRuns[i];
                var isLast = i >= textRuns.length - 1;
                if (beginIndex < run.endIndex) {
                    // Skip all following steps (including adding the current run to the new list of runs) if
                    // the inserted text overlaps the current run, which is not the last one.
                    if (!isLast && beginIndex <= run.beginIndex && newEndIndex >= run.endIndex) {
                        continue;
                    }
                    var containsBeginIndex = run.containsIndex(beginIndex);
                    var containsEndIndex = run.containsIndex(endIndex) ||
                        (isLast && endIndex >= run.endIndex);
                    if (containsBeginIndex && containsEndIndex) {
                        // The current run spans over the inserted text.
                        if (format) {
                            // Split up the current run.
                            var clone = run.clone();
                            clone.endIndex = beginIndex;
                            newTextRuns.push(clone);
                            i--;
                            run.beginIndex = beginIndex + 1;
                            continue;
                        }
                    }
                    else if (containsBeginIndex) {
                        // Run is intersecting on the left. Adjust its length.
                        run.endIndex = beginIndex;
                    }
                    else if (containsEndIndex) {
                        // If a a text format was passed, a new run needs to be inserted.
                        if (format) {
                            newTextRuns.push(this._sec.text.TextRun.create([beginIndex, newEndIndex, newFormat]));
                            run.beginIndex = newEndIndex;
                        }
                        else {
                            // Otherwise make the current run span over the inserted text.
                            run.beginIndex = beginIndex;
                            run.endIndex += shift;
                        }
                    }
                    else {
                        // No intersection, shift entire run to the right.
                        run.beginIndex += shift;
                        run.endIndex += shift;
                    }
                }
                // Ignore empty runs.
                if (run.endIndex > run.beginIndex) {
                    newTextRuns.push(run);
                }
            }
            this._plainText = plainText.substring(0, beginIndex) + newText + plainText.substring(endIndex);
            this.textRuns = newTextRuns;
            this._serializeTextRuns();
        };
        return TextContent;
    }());
    Shumway.TextContent = TextContent;
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var OptionSet = Shumway.Options.OptionSet;
    var shumwayOptions = Shumway.Settings.shumwayOptions;
    Shumway.flashOptions = shumwayOptions.register(new OptionSet("Flash Options"));
    Shumway.traceEventsOption = Shumway.flashOptions.register(new Shumway.Options.Option("te", "Trace Events", "boolean", false, "Trace dispatching of events."));
    Shumway.traceLoaderOption = Shumway.flashOptions.register(new Shumway.Options.Option("tp", "Trace Loader", "boolean", false, "Trace loader execution."));
    Shumway.disableAudioOption = Shumway.flashOptions.register(new Shumway.Options.Option("da", "Disable Audio", "boolean", false, "Disables audio."));
    Shumway.webAudioOption = Shumway.flashOptions.register(new Shumway.Options.Option(null, "Use WebAudio for Sound", "boolean", false, "Enables WebAudio API for MovieClip sound stream. (MP3 format is an exception)"));
    Shumway.webAudioMP3Option = Shumway.flashOptions.register(new Shumway.Options.Option(null, "Use MP3 decoding to WebAudio", "boolean", false, "Enables WebAudio API and software MP3 decoding and disables any AUDIO tag usage for MP3 format"));
    Shumway.mediaSourceOption = Shumway.flashOptions.register(new Shumway.Options.Option(null, "Use Media Source for Video", "boolean", false, "Enables Media Source Extension API for NetStream."));
    Shumway.mediaSourceMP3Option = Shumway.flashOptions.register(new Shumway.Options.Option(null, "Use Media Source for MP3", "boolean", true, "Enables Media Source Extension API for MP3 streams."));
    Shumway.flvOption = Shumway.flashOptions.register(new Shumway.Options.Option(null, "FLV support.", "string", "unsupported", "Defines how to deal with FLV streams."));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Timeline;
    (function (Timeline) {
        var isInteger = Shumway.isInteger;
        var assert = Shumway.Debug.assert;
        var Bounds = Shumway.Bounds;
        /**
         * TODO document
         */
        var Symbol = /** @class */ (function () {
            function Symbol(data, symbolDefaultClass) {
                release || assert(isInteger(data.id));
                this.data = data;
                if (data.className) {
                    var app = data.env.app;
                    this.symbolClass = symbolDefaultClass;
                    //TODO: @ivanpopelyshev IMPLEMENT lazy
                    /*
                                    try {
                    
                                        let symbolClass = app.getClass(flash.lang.Multiname.FromFQNString(data.className,
                                            flash.lang.NamespaceType.Public));
                    
                                        this.symbolClass = <flash.system.LegacyClass><any>symbolClass;
                                        // The symbolClass should have received a lazy symbol resolver in Loader#_applyLoadUpdate.
                                        release || assert(symbolClass.prototype.hasOwnProperty('_symbol'));
                                        // Replace it by this symbol without triggering the resolver and causing an infinite
                                        // recursion.
                                        Object.defineProperty(symbolClass.prototype, '_symbol', {value: this});
                                    } catch (e) {
                                        warning("Symbol " + data.id + " bound to non-existing class " + data.className);
                                        this.symbolClass = symbolDefaultClass;
                                    }*/
                }
                else {
                    this.symbolClass = symbolDefaultClass;
                }
                this.isAVM1Object = false;
            }
            Object.defineProperty(Symbol.prototype, "id", {
                get: function () {
                    return this.data.id;
                },
                enumerable: true,
                configurable: true
            });
            return Symbol;
        }());
        Timeline.Symbol = Symbol;
        var DisplaySymbol = /** @class */ (function (_super) {
            __extends(DisplaySymbol, _super);
            function DisplaySymbol(data, symbolClass, dynamic) {
                var _this = _super.call(this, data, symbolClass) || this;
                _this.dynamic = dynamic;
                return _this;
            }
            DisplaySymbol.prototype._setBoundsFromData = function (data) {
                this.fillBounds = data.fillBounds ? Bounds.FromUntyped(data.fillBounds) : null;
                this.lineBounds = data.lineBounds ? Bounds.FromUntyped(data.lineBounds) : null;
                if (!this.lineBounds && this.fillBounds) {
                    this.lineBounds = this.fillBounds.clone();
                }
            };
            return DisplaySymbol;
        }(Symbol));
        Timeline.DisplaySymbol = DisplaySymbol;
        var BinarySymbol = /** @class */ (function (_super) {
            __extends(BinarySymbol, _super);
            function BinarySymbol(data, sec) {
                return _super.call(this, data, sec.utils.ByteArray) || this;
            }
            BinarySymbol.FromData = function (data, loaderInfo) {
                var symbol = new BinarySymbol(data, loaderInfo.app._sec);
                symbol.buffer = data.data;
                symbol.byteLength = data.data.byteLength;
                return symbol;
            };
            return BinarySymbol;
        }(Symbol));
        Timeline.BinarySymbol = BinarySymbol;
        var SoundStart = /** @class */ (function () {
            function SoundStart(soundId, soundInfo) {
                this.soundId = soundId;
                this.soundInfo = soundInfo;
            }
            return SoundStart;
        }());
        Timeline.SoundStart = SoundStart;
    })(Timeline = Shumway.Timeline || (Shumway.Timeline = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Matrix
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var PI = Math.PI;
            var HalfPI = PI / 2;
            var PacPI = PI + HalfPI;
            var TwoPI = PI * 2;
            function cos(angle) {
                switch (angle) {
                    case HalfPI:
                    case -PacPI:
                        return 0;
                    case PI:
                    case -PI:
                        return -1;
                    case PacPI:
                    case -HalfPI:
                        return 0;
                    default:
                        return Math.cos(angle);
                }
            }
            function sin(angle) {
                switch (angle) {
                    case HalfPI:
                    case -PacPI:
                        return 1;
                    case PI:
                    case -PI:
                        return 0;
                    case PacPI:
                    case -HalfPI:
                        return -1;
                    default:
                        return Math.sin(angle);
                }
            }
            var Matrix = /** @class */ (function (_super) {
                __extends(Matrix, _super);
                // "invert", "identity", "createBox",
                // "createGradientBox", "rotate", "translate",
                // "scale", "deltaTransformPoint", "transformPoint",
                // "copyFrom", "setTo", "copyRowTo", "copyColumnTo",
                // "copyRowFrom", "copyColumnFrom", "clone",
                // "toString"];
                function Matrix(a, b, c, d, tx, ty) {
                    if (a === void 0) { a = 1; }
                    if (b === void 0) { b = 0; }
                    if (c === void 0) { c = 0; }
                    if (d === void 0) { d = 1; }
                    if (tx === void 0) { tx = 0; }
                    if (ty === void 0) { ty = 0; }
                    var _this = _super.call(this) || this;
                    var m = _this._data = new Float64Array(6);
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    return _this;
                }
                Object.defineProperty(Matrix.prototype, "a", {
                    get: function () {
                        return this._data[0];
                    },
                    set: function (a) {
                        this._data[0] = a;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "b", {
                    get: function () {
                        return this._data[1];
                    },
                    set: function (b) {
                        this._data[1] = b;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "c", {
                    get: function () {
                        return this._data[2];
                    },
                    set: function (c) {
                        this._data[2] = c;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "d", {
                    get: function () {
                        return this._data[3];
                    },
                    set: function (d) {
                        this._data[3] = d;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "tx", {
                    get: function () {
                        return this._data[4];
                    },
                    set: function (tx) {
                        this._data[4] = tx;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "ty", {
                    get: function () {
                        return this._data[5];
                    },
                    set: function (ty) {
                        this._data[5] = ty;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * this = this * other
                 */
                Matrix.prototype.concat = function (other) {
                    var m = this._data, n = other._data;
                    var a = m[0] * n[0];
                    var b = 0.0;
                    var c = 0.0;
                    var d = m[3] * n[3];
                    var tx = m[4] * n[0] + n[4];
                    var ty = m[5] * n[3] + n[5];
                    if (m[1] !== 0.0 || m[2] !== 0.0 || n[1] !== 0.0 || n[2] !== 0.0) {
                        a += m[1] * n[2];
                        d += m[2] * n[1];
                        b += m[0] * n[1] + m[1] * n[3];
                        c += m[2] * n[0] + m[3] * n[2];
                        tx += m[5] * n[2];
                        ty += m[4] * n[1];
                    }
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                };
                /**
                 * this = other * this
                 */
                Matrix.prototype.preMultiply = function (other) {
                    this.preMultiplyInto(other, this);
                };
                /**
                 * target = other * this
                 */
                Matrix.prototype.preMultiplyInto = function (other, target) {
                    var m = this._data, n = other._data, t = target._data;
                    var a = n[0] * m[0];
                    var b = 0.0;
                    var c = 0.0;
                    var d = n[3] * m[3];
                    var tx = n[4] * m[0] + m[4];
                    var ty = n[5] * m[3] + m[5];
                    if (n[1] !== 0.0 || n[2] !== 0.0 || m[1] !== 0.0 || m[2] !== 0.0) {
                        a += n[1] * m[2];
                        d += n[2] * m[1];
                        b += n[0] * m[1] + n[1] * m[3];
                        c += n[2] * m[0] + n[3] * m[2];
                        tx += n[5] * m[2];
                        ty += n[4] * m[1];
                    }
                    t[0] = a;
                    t[1] = b;
                    t[2] = c;
                    t[3] = d;
                    t[4] = tx;
                    t[5] = ty;
                };
                Matrix.prototype.invert = function () {
                    this.invertInto(this);
                };
                Matrix.prototype.invertInto = function (target) {
                    var m = this._data, t = target._data;
                    var b = m[1];
                    var c = m[2];
                    var tx = m[4];
                    var ty = m[5];
                    if (b === 0 && c === 0) {
                        var a_1 = t[0] = 1 / m[0];
                        var d_1 = t[3] = 1 / m[3];
                        t[1] = t[2] = 0;
                        t[4] = -a_1 * tx;
                        t[5] = -d_1 * ty;
                        return;
                    }
                    var a = m[0];
                    var d = m[3];
                    var determinant = a * d - b * c;
                    if (determinant === 0) {
                        target.identity();
                        return;
                    }
                    /**
                     * Multiplying by reciprocal of the |determinant| is only accurate if the reciprocal is
                     * representable without loss of precision. This is usually only the case for powers of
                     * two: 1/2, 1/4 ...
                     */
                    determinant = 1 / determinant;
                    var k = 0;
                    k = t[0] = d * determinant;
                    b = t[1] = -b * determinant;
                    c = t[2] = -c * determinant;
                    d = t[3] = a * determinant;
                    t[4] = -(k * tx + c * ty);
                    t[5] = -(b * tx + d * ty);
                };
                Matrix.prototype.identity = function () {
                    var m = this._data;
                    m[0] = m[3] = 1;
                    m[1] = m[2] = m[4] = m[5] = 0;
                };
                Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
                    if (rotation === void 0) { rotation = 0; }
                    if (tx === void 0) { tx = 0; }
                    if (ty === void 0) { ty = 0; }
                    var m = this._data;
                    if (rotation !== 0) {
                        var u = cos(rotation);
                        var v = sin(rotation);
                        m[0] = u * scaleX;
                        m[1] = v * scaleY;
                        m[2] = -v * scaleX;
                        m[3] = u * scaleY;
                    }
                    else {
                        m[0] = scaleX;
                        m[1] = 0;
                        m[2] = 0;
                        m[3] = scaleY;
                    }
                    m[4] = tx;
                    m[5] = ty;
                };
                Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
                    if (rotation === void 0) { rotation = 0; }
                    if (tx === void 0) { tx = 0; }
                    if (ty === void 0) { ty = 0; }
                    this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
                };
                Matrix.prototype.rotate = function (angle) {
                    angle = +angle;
                    if (angle !== 0) {
                        var m = this._data;
                        var u = cos(angle);
                        var v = sin(angle);
                        var ta = m[0];
                        var tb = m[1];
                        var tc = m[2];
                        var td = m[3];
                        var ttx = m[4];
                        var tty = m[5];
                        m[0] = ta * u - tb * v;
                        m[1] = ta * v + tb * u;
                        m[2] = tc * u - td * v;
                        m[3] = tc * v + td * u;
                        m[4] = ttx * u - tty * v;
                        m[5] = ttx * v + tty * u;
                    }
                };
                Matrix.prototype.translate = function (dx, dy) {
                    var m = this._data;
                    m[4] += dx;
                    m[5] += dy;
                };
                Matrix.prototype.scale = function (sx, sy) {
                    var m = this._data;
                    if (sx !== 1) {
                        m[0] *= sx;
                        m[2] *= sx;
                        m[4] *= sx;
                    }
                    if (sy !== 1) {
                        m[1] *= sy;
                        m[3] *= sy;
                        m[5] *= sy;
                    }
                };
                Matrix.prototype.deltaTransformPoint = function (point) {
                    var x = this._data[0] * point.x + this._data[2] * point.y;
                    var y = this._data[1] * point.x + this._data[3] * point.y;
                    return this._sec.geom.Point.create([x, y]);
                };
                Matrix.prototype.transformX = function (x, y) {
                    var m = this._data;
                    return m[0] * x + m[2] * y + m[4];
                };
                Matrix.prototype.transformY = function (x, y) {
                    var m = this._data;
                    return m[1] * x + m[3] * y + m[5];
                };
                Matrix.prototype.transformPoint = function (point) {
                    var m = this._data;
                    return this._sec.geom.Point.create([m[0] * point.x + m[2] * point.y + m[4],
                        m[1] * point.x + m[3] * point.y + m[5]]);
                };
                Matrix.prototype.transformPointInPlace = function (point) {
                    var m = this._data;
                    point.setTo(m[0] * point.x + m[2] * point.y + m[4], m[1] * point.x + m[3] * point.y + m[5]);
                    return point;
                };
                Matrix.prototype.transformBounds = function (bounds) {
                    var m = this._data;
                    var a = m[0];
                    var b = m[1];
                    var c = m[2];
                    var d = m[3];
                    var tx = m[4];
                    var ty = m[5];
                    var x = bounds.xMin;
                    var y = bounds.yMin;
                    var w = bounds.width;
                    var h = bounds.height;
                    var x0 = Math.round(a * x + c * y + tx);
                    var y0 = Math.round(b * x + d * y + ty);
                    var x1 = Math.round(a * (x + w) + c * y + tx);
                    var y1 = Math.round(b * (x + w) + d * y + ty);
                    var x2 = Math.round(a * (x + w) + c * (y + h) + tx);
                    var y2 = Math.round(b * (x + w) + d * (y + h) + ty);
                    var x3 = Math.round(a * x + c * (y + h) + tx);
                    var y3 = Math.round(b * x + d * (y + h) + ty);
                    var tmp = 0;
                    // Manual Min/Max is a lot faster than calling Math.min/max
                    // X Min-Max
                    if (x0 > x1) {
                        tmp = x0;
                        x0 = x1;
                        x1 = tmp;
                    }
                    if (x2 > x3) {
                        tmp = x2;
                        x2 = x3;
                        x3 = tmp;
                    }
                    bounds.xMin = x0 < x2 ? x0 : x2;
                    bounds.xMax = x1 > x3 ? x1 : x3;
                    // Y Min-Max
                    if (y0 > y1) {
                        tmp = y0;
                        y0 = y1;
                        y1 = tmp;
                    }
                    if (y2 > y3) {
                        tmp = y2;
                        y2 = y3;
                        y3 = tmp;
                    }
                    bounds.yMin = y0 < y2 ? y0 : y2;
                    bounds.yMax = y1 > y3 ? y1 : y3;
                };
                Matrix.prototype.getDeterminant = function () {
                    var m = this._data;
                    return m[0] * m[3] - m[1] * m[2];
                };
                Matrix.prototype.getScaleX = function () {
                    var m = this._data;
                    if (m[0] === 1 && m[1] === 0) {
                        return 1;
                    }
                    var result = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
                    return this.getDeterminant() < 0 ? -result : result;
                };
                Matrix.prototype.getScaleY = function () {
                    var m = this._data;
                    if (m[2] === 0 && m[3] === 1) {
                        return 1;
                    }
                    var result = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
                    return this.getDeterminant() < 0 ? -result : result;
                };
                Matrix.prototype.getAbsoluteScaleX = function () {
                    return Math.abs(this.getScaleX());
                };
                Matrix.prototype.getAbsoluteScaleY = function () {
                    return Math.abs(this.getScaleY());
                };
                Matrix.prototype.getSkewX = function () {
                    return Math.atan2(this._data[3], this._data[2]) - (Math.PI / 2);
                };
                Matrix.prototype.getSkewY = function () {
                    return Math.atan2(this._data[1], this._data[0]);
                };
                Matrix.prototype.copyFrom = function (other) {
                    var m = this._data, n = other._data;
                    m[0] = n[0];
                    m[1] = n[1];
                    m[2] = n[2];
                    m[3] = n[3];
                    m[4] = n[4];
                    m[5] = n[5];
                };
                Matrix.prototype.copyFromUntyped = function (object) {
                    var m = this._data;
                    m[0] = object.a;
                    m[1] = object.b;
                    m[2] = object.c;
                    m[3] = object.d;
                    m[4] = object.tx;
                    m[5] = object.ty;
                };
                Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                    var m = this._data;
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                };
                Matrix.prototype.toTwipsInPlace = function () {
                    var m = this._data;
                    m[4] = (m[4] * 20) | 0;
                    m[5] = (m[5] * 20) | 0;
                    return this;
                };
                Matrix.prototype.toPixelsInPlace = function () {
                    var m = this._data;
                    m[4] /= 20;
                    m[5] /= 20;
                    return this;
                };
                Matrix.prototype.toSerializedScaleInPlace = function () {
                    var m = this._data;
                    m[0] *= 819.2;
                    m[1] *= 819.2;
                    m[2] *= 819.2;
                    m[3] *= 819.2;
                    return this;
                };
                Matrix.prototype.copyRowTo = function (row, vector3D) {
                    var m = this._data;
                    row = row >>> 0;
                    if (row === 0) {
                        vector3D.x = m[0];
                        vector3D.y = m[2];
                        vector3D.z = m[4];
                    }
                    else if (row === 1) {
                        vector3D.x = m[1];
                        vector3D.y = m[3];
                        vector3D.z = m[5];
                    }
                    else if (row === 2) {
                        vector3D.x = 0;
                        vector3D.y = 0;
                        vector3D.z = 1;
                    }
                };
                Matrix.prototype.copyColumnTo = function (column, vector3D) {
                    var m = this._data;
                    column = column >>> 0;
                    if (column === 0) {
                        vector3D.x = m[0];
                        vector3D.y = m[1];
                        vector3D.z = 0;
                    }
                    else if (column === 1) {
                        vector3D.x = m[2];
                        vector3D.y = m[3];
                        vector3D.z = 0;
                    }
                    else if (column === 2) {
                        vector3D.x = m[4];
                        vector3D.y = m[5];
                        vector3D.z = 1;
                    }
                };
                Matrix.prototype.copyRowFrom = function (row, vector3D) {
                    var m = this._data;
                    row = row >>> 0;
                    if (row === 0) {
                        m[0] = vector3D.x;
                        m[2] = vector3D.y;
                        m[4] = vector3D.z;
                    }
                    else if (row === 1) {
                        m[1] = vector3D.x;
                        m[3] = vector3D.y;
                        m[5] = vector3D.z;
                    }
                };
                Matrix.prototype.copyColumnFrom = function (column, vector3D) {
                    var m = this._data;
                    column = column >>> 0;
                    if (column === 0) {
                        m[0] = vector3D.x;
                        m[2] = vector3D.y;
                        m[4] = vector3D.z;
                    }
                    else if (column === 1) {
                        m[1] = vector3D.x;
                        m[3] = vector3D.y;
                        m[5] = vector3D.z;
                    }
                };
                /**
                 * Updates the scale and skew componenets of the matrix.
                 */
                Matrix.prototype.updateScaleAndRotation = function (scaleX, scaleY, skewX, skewY) {
                    var m = this._data;
                    // The common case.
                    if ((skewX === 0 || skewX === TwoPI) && (skewY === 0 || skewY === TwoPI)) {
                        m[0] = scaleX;
                        m[1] = m[2] = 0;
                        m[3] = scaleY;
                        return;
                    }
                    var u = cos(skewX);
                    var v = sin(skewX);
                    if (skewX === skewY) {
                        m[0] = u * scaleX;
                        m[1] = v * scaleX;
                    }
                    else {
                        m[0] = cos(skewY) * scaleX;
                        m[1] = sin(skewY) * scaleX;
                    }
                    m[2] = -v * scaleY;
                    m[3] = u * scaleY;
                };
                Matrix.prototype.clone = function () {
                    return this._sec.geom.Matrix.clone(this);
                };
                Matrix.prototype.equals = function (other) {
                    var m = this._data, n = other._data;
                    return m[0] === n[0] && m[1] === n[1] &&
                        m[2] === n[2] && m[3] === n[3] &&
                        m[4] === n[4] && m[5] === n[5];
                };
                Matrix.prototype.toString = function () {
                    var m = this._data;
                    return "(a=" + m[0] + ", b=" + m[1] + ", c=" + m[2] + ", d=" + m[3] + ", tx=" + m[4] + ", ty=" + m[5] + ")";
                };
                // Keep in sync with static FromDataBuffer above!
                Matrix.prototype.writeExternal = function (output) {
                    var m = this._data;
                    output.writeFloat(m[0]);
                    output.writeFloat(m[1]);
                    output.writeFloat(m[2]);
                    output.writeFloat(m[3]);
                    output.writeFloat(m[4]);
                    output.writeFloat(m[5]);
                };
                Matrix.classInitializer = null;
                Matrix.classSymbols = null; // [];
                Matrix.instanceSymbols = null; // ["a", "b", "c", "d", "tx", "ty", "concat",
                return Matrix;
            }(flash.LegacyEntity));
            geom.Matrix = Matrix;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Matrix3D
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var notImplemented = Shumway.Debug.notImplemented;
            /*
             * _matrix stores data by columns
             *  | 0  4  8  12 |
             *  | 1  5  9  13 |
             *  | 2  6 10  14 |
             *  | 3  7 11  15 |
             */
            var precision = 1e-7;
            var transposeTransform = new Uint32Array([
                0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15
            ]);
            function getRotationMatrix(theta, u, v, w, a, b, c, sec) {
                // http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/
                var u2 = u * u, v2 = v * v, w2 = w * w;
                var L2 = u2 + v2 + w2, L = Math.sqrt(L2);
                u /= L;
                v /= L;
                w /= L;
                u2 /= L2;
                v2 /= L2;
                w2 /= L2;
                var cos = Math.cos(theta), sin = Math.sin(theta);
                return sec.geom.Matrix3D.FromArray([
                    u2 + (v2 + w2) * cos,
                    u * v * (1 - cos) + w * sin,
                    u * w * (1 - cos) - v * sin,
                    0,
                    u * v * (1 - cos) - w * sin,
                    v2 + (u2 + w2) * cos,
                    v * w * (1 - cos) + u * sin,
                    0,
                    u * w * (1 - cos) + v * sin,
                    v * w * (1 - cos) - u * sin,
                    w2 + (u2 + v2) * cos,
                    0,
                    (a * (v2 + w2) - u * (b * v + c * w)) * (1 - cos) + (b * w - c * v) * sin,
                    (b * (u2 + w2) - v * (a * u + c * w)) * (1 - cos) + (c * u - a * w) * sin,
                    (c * (u2 + v2) - w * (a * u + b * v)) * (1 - cos) + (a * v - b * u) * sin,
                    1
                ]);
            }
            var Matrix3D = /** @class */ (function (_super) {
                __extends(Matrix3D, _super);
                function Matrix3D(v) {
                    if (v === void 0) { v = null; }
                    var _this = _super.call(this) || this;
                    _this._matrix = new Float32Array(16);
                    if (v && v.length >= 16) {
                        _this.copyRawDataFrom(v, 0, false);
                    }
                    else {
                        _this.identity();
                    }
                    return _this;
                }
                Matrix3D.interpolate = function (thisMat, toMat, percent) {
                    thisMat = thisMat;
                    toMat = toMat;
                    percent = +percent;
                    release || notImplemented("public flash.geom.Matrix3D::static interpolate");
                    return null;
                };
                Matrix3D.prototype.setTargetDisplayObject = function (object) {
                    if (this._displayObject) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.Matrix3DRefCannontBeShared);
                    }
                    this._displayObject = object;
                };
                Matrix3D.prototype.resetTargetDisplayObject = function () {
                    release || Shumway.Debug.assert(this._displayObject);
                    this._displayObject = null;
                };
                Object.defineProperty(Matrix3D.prototype, "rawData", {
                    get: function () {
                        var result = new Float64Array(16);
                        this.copyRawDataTo(result, 0, false);
                        return result;
                    },
                    set: function (v) {
                        this.copyRawDataFrom(v, 0, false);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix3D.prototype, "position", {
                    get: function () {
                        var m = this._matrix;
                        return this._sec.geom.Vector3D.create([m[12], m[13], m[14]]);
                    },
                    set: function (pos) {
                        var m = this._matrix;
                        m[12] = pos.x;
                        m[13] = pos.y;
                        m[14] = pos.z;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix3D.prototype, "determinant", {
                    get: function () {
                        var m = this._matrix;
                        var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                        var d;
                        d = m11 * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24)) -
                            m21 * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14)) +
                            m31 * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14)) -
                            m41 * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                        return d;
                    },
                    enumerable: true,
                    configurable: true
                });
                Matrix3D.prototype.clone = function () {
                    return this._sec.geom.Matrix3D.FromArray(this._matrix);
                };
                Matrix3D.prototype.copyToMatrix3D = function (dest) {
                    dest = dest;
                    dest._matrix.set(this._matrix);
                };
                Matrix3D.prototype.append = function (lhs) {
                    var ma = lhs._matrix, mb = this._matrix, m = this._matrix;
                    var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];
                    var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];
                    m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                    m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                    m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                    m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;
                    m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                    m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                    m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                    m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;
                    m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                    m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                    m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                    m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;
                    m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                    m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                    m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                    m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                };
                Matrix3D.prototype.prepend = function (rhs) {
                    var ma = this._matrix, mb = rhs._matrix, m = this._matrix;
                    var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];
                    var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];
                    m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                    m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                    m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                    m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;
                    m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                    m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                    m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                    m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;
                    m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                    m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                    m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                    m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;
                    m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                    m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                    m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                    m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                };
                Matrix3D.prototype.invert = function () {
                    var d = this.determinant;
                    if (Math.abs(d) < precision) {
                        return false;
                    }
                    d = 1 / d;
                    var m = this._matrix;
                    // operating on transposed matrix
                    var m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];
                    m[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                    m[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                    m[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                    m[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                    m[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                    m[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                    m[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                    m[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                    m[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                    m[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                    m[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                    m[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                    m[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                    m[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                    m[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                    m[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
                    return true;
                };
                Matrix3D.prototype.identity = function () {
                    var m = this._matrix;
                    m[0] = m[5] = m[10] = m[15] = 1;
                    m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
                };
                Matrix3D.prototype.decompose = function (orientationStyle) {
                    if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
                    release || notImplemented("public flash.geom.Matrix3D::decompose");
                    return null;
                };
                Matrix3D.prototype.recompose = function (components, orientationStyle) {
                    if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
                    release || notImplemented("public flash.geom.Matrix3D::recompose");
                    return false;
                };
                Matrix3D.prototype.appendTranslation = function (x, y, z) {
                    x = +x;
                    y = +y;
                    z = +z;
                    var m = this._matrix;
                    var m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                    m[0] += x * m41;
                    m[1] += y * m41;
                    m[2] += z * m41;
                    m[4] += x * m42;
                    m[5] += y * m42;
                    m[6] += z * m42;
                    m[8] += x * m43;
                    m[9] += y * m43;
                    m[10] += z * m43;
                    m[12] += x * m44;
                    m[13] += y * m44;
                    m[14] += z * m44;
                };
                Matrix3D.prototype.appendRotation = function (degrees, axis, pivotPoint) {
                    if (pivotPoint === void 0) { pivotPoint = null; }
                    degrees = +degrees;
                    axis = axis;
                    pivotPoint = pivotPoint;
                    this.append(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0, this._sec));
                };
                Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
                    xScale = +xScale;
                    yScale = +yScale;
                    zScale = +zScale;
                    var m = this._matrix;
                    m[0] *= xScale;
                    m[1] *= yScale;
                    m[2] *= zScale;
                    m[4] *= xScale;
                    m[5] *= yScale;
                    m[6] *= zScale;
                    m[8] *= xScale;
                    m[9] *= yScale;
                    m[10] *= zScale;
                    m[12] *= xScale;
                    m[13] *= yScale;
                    m[14] *= zScale;
                };
                Matrix3D.prototype.prependTranslation = function (x, y, z) {
                    x = +x;
                    y = +y;
                    z = +z;
                    var m = this._matrix;
                    var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                    m[12] += m11 * x + m12 * y + m13 * z;
                    m[13] += m21 * x + m22 * y + m23 * z;
                    m[14] += m31 * x + m32 * y + m33 * z;
                    m[15] += m41 * x + m42 * y + m43 * z;
                };
                Matrix3D.prototype.prependRotation = function (degrees, axis, pivotPoint) {
                    if (pivotPoint === void 0) { pivotPoint = null; }
                    degrees = +degrees;
                    axis = axis;
                    pivotPoint = pivotPoint;
                    this.prepend(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0, this._sec));
                };
                Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
                    xScale = +xScale;
                    yScale = +yScale;
                    zScale = +zScale;
                    var m = this._matrix;
                    m[0] *= xScale;
                    m[1] *= xScale;
                    m[2] *= xScale;
                    m[3] *= xScale;
                    m[4] *= yScale;
                    m[5] *= yScale;
                    m[6] *= yScale;
                    m[7] *= yScale;
                    m[8] *= zScale;
                    m[9] *= zScale;
                    m[10] *= zScale;
                    m[11] *= zScale;
                };
                Matrix3D.prototype.transformVector = function (v) {
                    var m = this._matrix;
                    var x = v.x, y = v.y, z = v.z;
                    return this._sec.geom.Vector3D.create([
                        m[0] * x + m[4] * y + m[8] * z + m[12],
                        m[1] * x + m[5] * y + m[9] * z + m[13],
                        m[2] * x + m[6] * y + m[10] * z + m[14]
                    ]);
                };
                Matrix3D.prototype.deltaTransformVector = function (v) {
                    var m = this._matrix;
                    var x = v.x, y = v.y, z = v.z;
                    return this._sec.geom.Vector3D.create([
                        m[0] * x + m[4] * y + m[8] * z,
                        m[1] * x + m[5] * y + m[9] * z,
                        m[2] * x + m[6] * y + m[10] * z
                    ]);
                };
                Matrix3D.prototype.transformVectors = function (vin, vout) {
                    var m = this._matrix;
                    var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                    for (var i = 0; i < vin.length - 2; i += 3) {
                        var x = vin.axGetNumericProperty(i), y = vin.axGetNumericProperty(i + 1), z = vin.axGetNumericProperty(i + 2);
                        vout.push(m11 * x + m12 * y + m13 * z + m14);
                        vout.push(m21 * x + m22 * y + m23 * z + m24);
                        vout.push(m31 * x + m32 * y + m33 * z + m34);
                    }
                };
                Matrix3D.prototype.transpose = function () {
                    var m = this._matrix;
                    var tmp;
                    tmp = m[1];
                    m[1] = m[4];
                    m[4] = tmp;
                    tmp = m[2];
                    m[2] = m[8];
                    m[5] = tmp;
                    tmp = m[3];
                    m[3] = m[12];
                    m[12] = tmp;
                    tmp = m[6];
                    m[6] = m[9];
                    m[9] = tmp;
                    tmp = m[7];
                    m[7] = m[13];
                    m[13] = tmp;
                    tmp = m[11];
                    m[11] = m[14];
                    m[14] = tmp;
                };
                Matrix3D.prototype.pointAt = function (pos, at, up) {
                    if (at === void 0) { at = null; }
                    if (up === void 0) { up = null; }
                    pos = pos;
                    at = at;
                    up = up;
                    release || notImplemented("public flash.geom.Matrix3D::pointAt");
                    return;
                };
                Matrix3D.prototype.interpolateTo = function (toMat, percent) {
                    toMat = toMat;
                    percent = +percent;
                    release || notImplemented("public flash.geom.Matrix3D::interpolateTo");
                    return;
                };
                Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
                    sourceMatrix3D = sourceMatrix3D;
                    this._matrix.set(sourceMatrix3D._matrix);
                };
                Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
                    if (index === void 0) { index = 0; }
                    if (transpose === void 0) { transpose = false; }
                    vector = vector;
                    index = index >>> 0;
                    transpose = !!transpose;
                    var m = this._matrix;
                    if (transpose) {
                        for (var i = 0, j = index | 0; i < 16; i++, j++) {
                            vector.axSetNumericProperty(j, m[transposeTransform[i]]);
                        }
                    }
                    else {
                        for (var i = 0, j = index | 0; i < 16; i++, j++) {
                            vector.axSetNumericProperty(j, m[i]);
                        }
                    }
                };
                Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
                    if (index === void 0) { index = 0; }
                    if (transpose === void 0) { transpose = false; }
                    index = index >>> 0;
                    transpose = !!transpose;
                    var m = this._matrix;
                    if (transpose) {
                        for (var i = 0, j = index | 0; i < 16; i++, j++) {
                            m[transposeTransform[i]] = vector[j] || 0; // removing NaN
                        }
                    }
                    else {
                        for (var i = 0, j = index | 0; i < 16; i++, j++) {
                            m[i] = vector[j] || 0; // removing NaN
                        }
                    }
                };
                Matrix3D.prototype.copyRowTo = function (row /*uint*/, vector3D) {
                    row = row >>> 0;
                    vector3D = vector3D;
                    var offset = row | 0;
                    var m = this._matrix;
                    vector3D.x = m[offset];
                    vector3D.y = m[offset + 4];
                    vector3D.z = m[offset + 8];
                    vector3D.w = m[offset + 12];
                };
                Matrix3D.prototype.copyColumnTo = function (column /*uint*/, vector3D) {
                    column = column >>> 0;
                    vector3D = vector3D;
                    var offset = column << 2;
                    var m = this._matrix;
                    vector3D.x = m[offset];
                    vector3D.y = m[offset + 1];
                    vector3D.z = m[offset + 2];
                    vector3D.w = m[offset + 3];
                };
                Matrix3D.prototype.copyRowFrom = function (row /*uint*/, vector3D) {
                    row = row >>> 0;
                    vector3D = vector3D;
                    var offset = row | 0;
                    var m = this._matrix;
                    m[offset] = vector3D.x;
                    m[offset + 4] = vector3D.y;
                    m[offset + 8] = vector3D.z;
                    m[offset + 12] = vector3D.w;
                };
                Matrix3D.prototype.copyColumnFrom = function (column /*uint*/, vector3D) {
                    column = column >>> 0;
                    vector3D = vector3D;
                    var offset = column << 2;
                    var m = this._matrix;
                    m[offset] = vector3D.x;
                    m[offset + 1] = vector3D.y;
                    m[offset + 2] = vector3D.z;
                    m[offset + 3] = vector3D.w;
                };
                return Matrix3D;
            }(flash.LegacyEntity));
            geom.Matrix3D = Matrix3D;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Orientation3D
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var Orientation3D;
            (function (Orientation3D) {
                Orientation3D["EULER_ANGLES"] = "eulerAngles";
                Orientation3D["AXIS_ANGLE"] = "axisAngle";
                Orientation3D["QUATERNION"] = "quaternion";
            })(Orientation3D = geom.Orientation3D || (geom.Orientation3D = {}));
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: PerspectiveProjection
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            /**
             * Initial values for the projection as used in Flash. Only for `root` will a different center
             * be used: constructing an instance manually will get 250,250.
             */
            var DefaultPerspectiveProjection;
            (function (DefaultPerspectiveProjection) {
                DefaultPerspectiveProjection[DefaultPerspectiveProjection["FOV"] = 55] = "FOV";
                DefaultPerspectiveProjection[DefaultPerspectiveProjection["CenterX"] = 250] = "CenterX";
                DefaultPerspectiveProjection[DefaultPerspectiveProjection["CenterY"] = 250] = "CenterY";
            })(DefaultPerspectiveProjection = geom.DefaultPerspectiveProjection || (geom.DefaultPerspectiveProjection = {}));
            var PerspectiveProjection = /** @class */ (function (_super) {
                __extends(PerspectiveProjection, _super);
                function PerspectiveProjection() {
                    var _this = _super.call(this) || this;
                    _this._fieldOfView = 55 /* FOV */;
                    _this._centerX = 250 /* CenterX */;
                    _this._centerY = 250 /* CenterY */;
                    return _this;
                }
                Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
                    get: function () {
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::get fieldOfView");
                        return this._displayObject ?
                            this._displayObject._perspectiveProjectionFOV :
                            this._fieldOfView;
                    },
                    set: function (fieldOfViewAngleInDegrees) {
                        fieldOfViewAngleInDegrees = +fieldOfViewAngleInDegrees;
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::set fieldOfView");
                        if (this._displayObject) {
                            this._displayObject._perspectiveProjectionFOV = fieldOfViewAngleInDegrees;
                        }
                        else {
                            this._fieldOfView = fieldOfViewAngleInDegrees;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PerspectiveProjection.prototype, "projectionCenter", {
                    get: function () {
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::get projectionCenter");
                        var centerX;
                        var centerY;
                        if (this._displayObject) {
                            centerX = this._displayObject._perspectiveProjectionCenterX;
                            centerY = this._displayObject._perspectiveProjectionCenterY;
                        }
                        else {
                            centerX = this._centerX;
                            centerY = this._centerY;
                        }
                        return this._sec.geom.Point.create([centerX, centerY]);
                    },
                    set: function (p) {
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::set projectionCenter");
                        if (this._displayObject) {
                            this._displayObject._perspectiveProjectionCenterX = +p.x;
                            this._displayObject._perspectiveProjectionCenterY = +p.y;
                        }
                        else {
                            this._centerX = +p.x;
                            this._centerY = +p.y;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
                    get: function () {
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::get focalLength");
                        var fov;
                        var centerX;
                        if (this._displayObject) {
                            fov = this._displayObject._perspectiveProjectionFOV;
                            centerX = this._displayObject._perspectiveProjectionCenterX;
                        }
                        else {
                            fov = this._fieldOfView;
                            centerX = this._centerX;
                        }
                        return 1 / Math.tan(fov * Math.PI / 180 / 2) * centerX;
                    },
                    set: function (value) {
                        value = +value;
                        release || somewhatImplemented("public flash.geom.PerspectiveProjection::set focalLength");
                        var centerX = this._displayObject ?
                            this._displayObject._perspectiveProjectionCenterX :
                            this._centerX;
                        var fov = 2 * Math.atan(centerX / value);
                        if (this._displayObject) {
                            this._displayObject._perspectiveProjectionFOV = fov;
                        }
                        else {
                            this._fieldOfView = fov;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                PerspectiveProjection.prototype.toMatrix3D = function () {
                    release || somewhatImplemented("public flash.geom.PerspectiveProjection::toMatrix3D");
                    return this._sec.geom.Matrix3D.create();
                };
                PerspectiveProjection.prototype.clone = function () {
                    return this._sec.geom.PerspectiveProjection.clone(this);
                };
                return PerspectiveProjection;
            }(flash.LegacyEntity));
            geom.PerspectiveProjection = PerspectiveProjection;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Point
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var Point = /** @class */ (function (_super) {
                __extends(Point, _super);
                function Point(x, y) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    var _this = _super.call(this) || this;
                    _this.x = +x;
                    _this.y = +y;
                    return _this;
                }
                Object.defineProperty(Point.prototype, "native_x", {
                    get: function () {
                        return this.x;
                    },
                    set: function (x) {
                        this.x = x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Point.prototype, "native_y", {
                    get: function () {
                        return this.y;
                    },
                    set: function (y) {
                        this.y = y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Point.prototype.Point = function (x, y) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    this.x = x;
                    this.y = y;
                };
                Object.defineProperty(Point.prototype, "length", {
                    get: function () {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    },
                    enumerable: true,
                    configurable: true
                });
                Point.interpolate = function (p1, p2, f) {
                    return flash.system._currentDomain.geom.Point.interpolate(p1, p2, f);
                };
                Point.distance = function (p1, p2) {
                    var dx = p2.x - p1.x;
                    var dy = p2.y - p1.y;
                    return (dx === 0) ? Math.abs(dy) : (dy === 0) ? Math.abs(dx) : Math.sqrt(dx * dx + dy * dy);
                };
                Point.polar = function (length, angle) {
                    return flash.system._currentDomain.geom.Point.polar(length, angle);
                };
                Point.prototype.clone = function () {
                    return this._sec.geom.Point.clone(this);
                };
                Point.prototype.offset = function (dx, dy) {
                    this.x += +dx;
                    this.y += +dy;
                };
                Point.prototype.equals = function (toCompare) {
                    return this.x === toCompare.x && this.y === toCompare.y;
                };
                Point.prototype.subtract = function (v) {
                    return this._sec.geom.Point.create([this.x - v.x, this.y - v.y]);
                };
                Point.prototype.add = function (v) {
                    return this._sec.geom.Point.create([this.x + v.x, this.y + v.y]);
                };
                Point.prototype.normalize = function (thickness) {
                    if (this.x !== 0 || this.y !== 0) {
                        var relativeThickness = +thickness / this.length;
                        this.x *= relativeThickness;
                        this.y *= relativeThickness;
                    }
                };
                Point.prototype.copyFrom = function (sourcePoint) {
                    this.x = sourcePoint.x;
                    this.y = sourcePoint.y;
                };
                Point.prototype.setTo = function (x, y) {
                    this.x = +x;
                    this.y = +y;
                };
                Point.prototype.toTwips = function () {
                    this.x = (this.x * 20) | 0;
                    this.y = (this.y * 20) | 0;
                    return this;
                };
                Point.prototype.toPixels = function () {
                    this.x /= 20;
                    this.y /= 20;
                    return this;
                };
                Point.prototype.round = function () {
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    return this;
                };
                Point.prototype.toString = function () {
                    return "(x=" + this.x + ", y=" + this.y + ")";
                };
                return Point;
            }(flash.LegacyEntity));
            geom.Point = Point;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Rectangle
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var Rectangle = /** @class */ (function (_super) {
                __extends(Rectangle, _super);
                function Rectangle(x, y, width, height) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = 0; }
                    if (height === void 0) { height = 0; }
                    var _this = _super.call(this) || this;
                    x = +x;
                    y = +y;
                    width = +width;
                    height = +height;
                    _this.x = x;
                    _this.y = y;
                    _this.width = width;
                    _this.height = height;
                    return _this;
                }
                Object.defineProperty(Rectangle.prototype, "native_x", {
                    get: function () {
                        return this.x;
                    },
                    set: function (x) {
                        this.x = x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "native_y", {
                    get: function () {
                        return this.y;
                    },
                    set: function (y) {
                        this.y = y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "native_width", {
                    get: function () {
                        return this.width;
                    },
                    set: function (width) {
                        this.width = +width;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "native_height", {
                    get: function () {
                        return this.height;
                    },
                    set: function (height) {
                        this.height = +height;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "left", {
                    get: function () {
                        return this.x;
                    },
                    set: function (value) {
                        value = +value;
                        this.width += this.x - value;
                        this.x = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "right", {
                    get: function () {
                        return this.x + this.width;
                    },
                    set: function (value) {
                        value = +value;
                        this.width = value - this.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "top", {
                    get: function () {
                        return this.y;
                    },
                    set: function (value) {
                        value = +value;
                        this.height += this.y - value;
                        this.y = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "bottom", {
                    get: function () {
                        return this.y + this.height;
                    },
                    set: function (value) {
                        value = +value;
                        this.height = value - this.y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "topLeft", {
                    get: function () {
                        return this._sec.geom.Point.create([this.left, this.top]);
                    },
                    set: function (value) {
                        this.top = value.y;
                        this.left = value.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "bottomRight", {
                    get: function () {
                        return this._sec.geom.Point.create([this.right, this.bottom]);
                    },
                    set: function (value) {
                        this.bottom = value.y;
                        this.right = value.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "size", {
                    get: function () {
                        return this._sec.geom.Point.create([this.width, this.height]);
                    },
                    set: function (value) {
                        this.width = value.x;
                        this.height = value.y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Rectangle.prototype, "area", {
                    get: function () {
                        return this.width * this.height;
                    },
                    enumerable: true,
                    configurable: true
                });
                Rectangle.prototype.clone = function () {
                    return this._sec.geom.Rectangle.clone(this);
                };
                Rectangle.prototype.isEmpty = function () {
                    return this.width <= 0 || this.height <= 0;
                };
                Rectangle.prototype.setEmpty = function () {
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    return this;
                };
                Rectangle.prototype.inflate = function (dx, dy) {
                    dx = +dx;
                    dy = +dy;
                    this.x -= dx;
                    this.y -= dy;
                    this.width += (dx * 2);
                    this.height += (dy * 2);
                };
                Rectangle.prototype.inflatePoint = function (point) {
                    this.inflate(point.x, point.y);
                };
                Rectangle.prototype.offset = function (dx, dy) {
                    this.x += +dx;
                    this.y += +dy;
                };
                Rectangle.prototype.offsetPoint = function (point) {
                    this.offset(point.x, point.y);
                };
                Rectangle.prototype.contains = function (x, y) {
                    x = +x;
                    y = +y;
                    return x >= this.x && x < this.right &&
                        y >= this.y && y < this.bottom;
                };
                Rectangle.prototype.containsPoint = function (point) {
                    return this.contains(point.x, point.y);
                };
                Rectangle.prototype.containsRect = function (rect) {
                    var r1 = rect.x + rect.width;
                    var b1 = rect.y + rect.height;
                    var r2 = this.x + this.width;
                    var b2 = this.y + this.height;
                    return (rect.x >= this.x) &&
                        (rect.x < r2) &&
                        (rect.y >= this.y) &&
                        (rect.y < b2) &&
                        (r1 > this.x) &&
                        (r1 <= r2) &&
                        (b1 > this.y) &&
                        (b1 <= b2);
                };
                Rectangle.prototype.intersection = function (toIntersect) {
                    return this.clone().intersectInPlace(toIntersect);
                };
                Rectangle.prototype.intersects = function (toIntersect) {
                    return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right) &&
                        Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
                };
                Rectangle.prototype.intersectInPlace = function (clipRect) {
                    var x0 = this.x;
                    var y0 = this.y;
                    var x1 = clipRect.x;
                    var y1 = clipRect.y;
                    var l = Math.max(x0, x1);
                    var r = Math.min(x0 + this.width, x1 + clipRect.width);
                    if (l <= r) {
                        var t = Math.max(y0, y1);
                        var b = Math.min(y0 + this.height, y1 + clipRect.height);
                        if (t <= b) {
                            this.setTo(l, t, r - l, b - t);
                            return this;
                        }
                    }
                    this.setEmpty();
                    return this;
                };
                Rectangle.prototype.intersectInPlaceInt32 = function (clipRect) {
                    var x0 = this.x | 0;
                    var y0 = this.y | 0;
                    var w0 = this.width | 0;
                    var h0 = this.height | 0;
                    var x1 = clipRect.x | 0;
                    var w1 = clipRect.width | 0;
                    var l = Math.max(x0, x1) | 0;
                    var r = Math.min(x0 + w0 | 0, x1 + w1 | 0) | 0;
                    if (l <= r) {
                        var y1 = clipRect.y | 0;
                        var h1 = clipRect.height | 0;
                        var t = Math.max(y0, y1) | 0;
                        var b = Math.min(y0 + h0 | 0, y1 + h1 | 0);
                        if (t <= b) {
                            this.setTo(l, t, r - l, b - t);
                            return this;
                        }
                    }
                    this.setEmpty();
                    return this;
                };
                Rectangle.prototype.union = function (toUnion) {
                    return this.clone().unionInPlace(toUnion);
                };
                Rectangle.prototype.unionInPlace = function (toUnion) {
                    if (toUnion.isEmpty()) {
                        return this;
                    }
                    if (this.isEmpty()) {
                        this.copyFrom(toUnion);
                        return this;
                    }
                    var l = Math.min(this.x, toUnion.x);
                    var t = Math.min(this.y, toUnion.y);
                    this.setTo(l, t, Math.max(this.right, toUnion.right) - l, Math.max(this.bottom, toUnion.bottom) - t);
                    return this;
                };
                Rectangle.prototype.equals = function (toCompare) {
                    return this === toCompare ||
                        this.x === toCompare.x && this.y === toCompare.y
                            && this.width === toCompare.width && this.height === toCompare.height;
                };
                Rectangle.prototype.copyFrom = function (sourceRect) {
                    this.x = sourceRect.x;
                    this.y = sourceRect.y;
                    this.width = sourceRect.width;
                    this.height = sourceRect.height;
                };
                Rectangle.prototype.setTo = function (x, y, width, height) {
                    this.x = +x;
                    this.y = +y;
                    this.width = +width;
                    this.height = +height;
                };
                Rectangle.prototype.toTwips = function () {
                    this.x = (this.x * 20) | 0;
                    this.y = (this.y * 20) | 0;
                    this.width = (this.width * 20) | 0;
                    this.height = (this.height * 20) | 0;
                    return this;
                };
                Rectangle.prototype.getBaseWidth = function (angle) {
                    var u = Math.abs(Math.cos(angle));
                    var v = Math.abs(Math.sin(angle));
                    return u * this.width + v * this.height;
                };
                Rectangle.prototype.getBaseHeight = function (angle) {
                    var u = Math.abs(Math.cos(angle));
                    var v = Math.abs(Math.sin(angle));
                    return v * this.width + u * this.height;
                };
                Rectangle.prototype.toPixels = function () {
                    this.x /= 20;
                    this.y /= 20;
                    this.width /= 20;
                    this.height /= 20;
                    return this;
                };
                Rectangle.prototype.snapInPlace = function () {
                    var x1 = Math.ceil(this.x + this.width);
                    var y1 = Math.ceil(this.y + this.height);
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.width = x1 - this.x;
                    this.height = y1 - this.y;
                    return this;
                };
                Rectangle.prototype.roundInPlace = function () {
                    var x1 = Math.round(this.x + this.width);
                    var y1 = Math.round(this.y + this.height);
                    this.x = Math.round(this.x);
                    this.y = Math.round(this.y);
                    this.width = x1 - this.x;
                    this.height = y1 - this.y;
                    return this;
                };
                Rectangle.prototype.toString = function () {
                    return "(x=" + this.x + ", y=" + this.y + ", w=" + this.width + ", h=" + this.height + ")";
                };
                Rectangle.prototype.hashCode = function () {
                    var hash = 0;
                    hash += this.x * 20 | 0;
                    hash *= 37;
                    hash += this.y * 20 | 0;
                    hash *= 37;
                    hash += this.width * 20 | 0;
                    hash *= 37;
                    hash += this.height * 20 | 0;
                    return hash;
                };
                Rectangle.prototype.writeExternal = function (output) {
                    output.writeFloat(this.x);
                    output.writeFloat(this.y);
                    output.writeFloat(this.width);
                    output.writeFloat(this.height);
                };
                Rectangle.prototype.readExternal = function (input) {
                    this.x = input.readFloat();
                    this.y = input.readFloat();
                    this.width = input.readFloat();
                    this.height = input.readFloat();
                };
                return Rectangle;
            }(flash.LegacyEntity));
            geom.Rectangle = Rectangle;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Transform
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Transform = /** @class */ (function (_super) {
                __extends(Transform, _super);
                function Transform(displayObject) {
                    var _this = _super.call(this) || this;
                    if (!displayObject) {
                        _this._sec.throwError("ArgumentError", Shumway.Errors.NullPointerError, "displayObject");
                    }
                    _this._displayObject = displayObject;
                    return _this;
                }
                Object.defineProperty(Transform.prototype, "matrix", {
                    get: function () {
                        if (this._displayObject._matrix3D) {
                            return null;
                        }
                        return this._displayObject._getMatrix().clone().toPixelsInPlace();
                    },
                    set: function (value) {
                        if (this._displayObject._matrix3D) {
                            this._displayObject._matrix3D.resetTargetDisplayObject();
                            this._displayObject._matrix3D = null;
                        }
                        this._displayObject._setMatrix(value, true);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Transform.prototype, "colorTransform", {
                    get: function () {
                        return this._displayObject._colorTransform.clone();
                    },
                    set: function (value) {
                        this._displayObject._setColorTransform(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Transform.prototype, "concatenatedMatrix", {
                    get: function () {
                        var matrix = this._displayObject._getConcatenatedMatrix().clone().toPixelsInPlace();
                        // For some reason, all dimensions are scale 5x for off-stage objects.
                        if (!this._displayObject._stage) {
                            matrix.scale(5, 5);
                        }
                        return matrix;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Transform.prototype, "concatenatedColorTransform", {
                    get: function () {
                        return this._displayObject._getConcatenatedColorTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Transform.prototype, "pixelBounds", {
                    get: function () {
                        // Only somewhat implemented because this is largely untested.
                        release || somewhatImplemented("public flash.geom.Transform::get pixelBounds");
                        var stage = this._displayObject.stage;
                        var targetCoordinateSpace = stage || this._displayObject;
                        var rect = this._displayObject.getRect(targetCoordinateSpace);
                        // For some reason, all dimensions are scale 5x for off-stage objects.
                        if (!stage) {
                            rect.width *= 5;
                            rect.height *= 5;
                        }
                        return rect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Transform.prototype, "matrix3D", {
                    get: function () {
                        release || somewhatImplemented("public flash.geom.Transform::get matrix3D");
                        // Note: matrix3D returns the original object, *not* a clone.
                        return this._displayObject._matrix3D;
                    },
                    set: function (m) {
                        if (!(this._sec.geom.Matrix3D.axIsType(m))) {
                            this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, m, 'flash.geom.Matrix3D');
                        }
                        release || somewhatImplemented("public flash.geom.Transform::set matrix3D");
                        // Setting the displayObject on the matrix can throw an error, so do that first.
                        m.setTargetDisplayObject(this._displayObject);
                        // Note: matrix3D stores the original object, *not* a clone.
                        this._displayObject._matrix3D = m;
                    },
                    enumerable: true,
                    configurable: true
                });
                Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
                    Shumway.checkNullParameter(relativeTo, "relativeTo", this._sec);
                    release || somewhatImplemented("public flash.geom.Transform::getRelativeMatrix3D");
                    var matrix3D = this._displayObject._matrix3D;
                    // TODO: actually calculate the relative matrix.
                    return matrix3D ? matrix3D.clone() : null;
                };
                Object.defineProperty(Transform.prototype, "perspectiveProjection", {
                    get: function () {
                        release || somewhatImplemented("public flash.geom.Transform::get perspectiveProjection");
                        if (!this._displayObject._hasFlags(262144 /* HasPerspectiveProjection */)) {
                            return null;
                        }
                        var PerspectiveProjectionClass = this._sec.geom.PerspectiveProjection;
                        return PerspectiveProjectionClass.FromDisplayObject(this._displayObject);
                    },
                    set: function (projection) {
                        release || somewhatImplemented("public flash.geom.Transform::set perspectiveProjection");
                        if (!projection) {
                            this._displayObject._removeFlags(262144 /* HasPerspectiveProjection */);
                            return;
                        }
                        this._displayObject._setFlags(262144 /* HasPerspectiveProjection */);
                        this._displayObject._perspectiveProjectionCenterX = +projection._centerX;
                        this._displayObject._perspectiveProjectionCenterY = +projection._centerY;
                        this._displayObject._perspectiveProjectionFOV = +projection._fieldOfView;
                    },
                    enumerable: true,
                    configurable: true
                });
                Transform.classInitializer = null;
                return Transform;
            }(flash.LegacyEntity));
            geom.Transform = Transform;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Utils3D
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var notImplemented = Shumway.Debug.notImplemented;
            var Utils3D = /** @class */ (function (_super) {
                __extends(Utils3D, _super);
                function Utils3D() {
                    return _super.call(this) || this;
                }
                // AS -> JS Bindings
                Utils3D.projectVector = function (m, v) {
                    m = m;
                    v = v;
                    release || notImplemented("public flash.geom.Utils3D::static projectVector");
                    return null;
                };
                Utils3D.projectVectors = function (m, verts, projectedVerts, uvts) {
                    m = m;
                    verts = verts;
                    projectedVerts = projectedVerts;
                    uvts = uvts;
                    release || notImplemented("public flash.geom.Utils3D::static projectVectors");
                    return;
                };
                Utils3D.pointTowards = function (percent, mat, pos, at, up) {
                    if (at === void 0) { at = null; }
                    if (up === void 0) { up = null; }
                    percent = +percent;
                    mat = mat;
                    pos = pos;
                    at = at;
                    up = up;
                    release || notImplemented("public flash.geom.Utils3D::static pointTowards");
                    return null;
                };
                // Called whenever the class is initialized.
                Utils3D.classInitializer = null;
                // List of static symbols to link.
                Utils3D.classSymbols = null; // [];
                // List of instance symbols to link.
                Utils3D.instanceSymbols = null; // [];
                return Utils3D;
            }(flash.LegacyEntity));
            geom.Utils3D = Utils3D;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Vector3D
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var Vector3D = /** @class */ (function (_super) {
                __extends(Vector3D, _super);
                function Vector3D(x, y, z, w) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (z === void 0) { z = 0; }
                    if (w === void 0) { w = 0; }
                    var _this = _super.call(this) || this;
                    _this.x = +x;
                    _this.y = +y;
                    _this.z = +z;
                    _this.w = +w;
                    return _this;
                }
                Vector3D.classInitializer = function () {
                    var th = this;
                    th.X_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                    th.Y_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                    th.Z_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                };
                Vector3D.Create = function (x, y, z, w) {
                    var v = flash.system._currentDomain.geom.Vector3D.create();
                    v.x = x;
                    v.y = y;
                    v.z = z;
                    v.w = w;
                    return v;
                };
                Object.defineProperty(Vector3D.prototype, "native_x", {
                    get: function () {
                        return this.x;
                    },
                    set: function (x) {
                        this.x = x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Vector3D.prototype, "native_y", {
                    get: function () {
                        return this.y;
                    },
                    set: function (y) {
                        this.y = y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Vector3D.prototype, "native_z", {
                    get: function () {
                        return this.z;
                    },
                    set: function (z) {
                        this.z = z;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Vector3D.prototype, "native_w", {
                    get: function () {
                        return this.w;
                    },
                    set: function (w) {
                        this.w = w;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Vector3D.prototype, "length", {
                    get: function () {
                        return Math.sqrt(this.lengthSquared);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Vector3D.prototype, "lengthSquared", {
                    get: function () {
                        return this.x * this.x +
                            this.y * this.y +
                            this.z * this.z;
                    },
                    enumerable: true,
                    configurable: true
                });
                Vector3D.angleBetween = function (a, b) {
                    // http://chemistry.about.com/od/workedchemistryproblems/a/scalar-product-vectors-problem.htm
                    return Math.acos(a.dotProduct(b) / (a.length * b.length));
                };
                Vector3D.distance = function (pt1, pt2) {
                    // http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions
                    return pt1.subtract(pt2).length;
                };
                Vector3D.prototype.dotProduct = function (a) {
                    return this.x * a.x +
                        this.y * a.y +
                        this.z * a.z;
                };
                Vector3D.prototype.crossProduct = function (a) {
                    return this._sec.geom.Vector3D.create([this.y * a.z - this.z * a.y,
                        this.z * a.x - this.x * a.z,
                        this.x * a.y - this.y * a.x,
                        1.0]);
                };
                Vector3D.prototype.normalize = function () {
                    var length = this.length;
                    if (length !== 0) {
                        this.x /= length;
                        this.y /= length;
                        this.z /= length;
                    }
                    else {
                        this.x = this.y = this.z = 0;
                    }
                    return length;
                };
                Vector3D.prototype.scaleBy = function (s) {
                    s = +s;
                    this.x *= s;
                    this.y *= s;
                    this.z *= s;
                };
                Vector3D.prototype.incrementBy = function (a) {
                    this.x += a.x;
                    this.y += a.y;
                    this.z += a.z;
                };
                Vector3D.prototype.decrementBy = function (a) {
                    this.x -= a.x;
                    this.y -= a.y;
                    this.z -= a.z;
                };
                Vector3D.prototype.add = function (a) {
                    return this._sec.geom.Vector3D.create([this.x + a.x, this.y + a.y, this.z + a.z]);
                };
                Vector3D.prototype.subtract = function (a) {
                    return this._sec.geom.Vector3D.create([this.x - a.x, this.y - a.y, this.z - a.z]);
                };
                Vector3D.prototype.negate = function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                };
                Vector3D.prototype.equals = function (toCompare, allFour) {
                    return (this.x === toCompare.x)
                        && (this.y === toCompare.y)
                        && (this.z === toCompare.z)
                        && (!allFour || (this.w === toCompare.w));
                };
                Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
                    return (Math.abs(this.x - toCompare.x) < tolerance)
                        && (Math.abs(this.y - toCompare.y) < tolerance)
                        && (Math.abs(this.z - toCompare.z) < tolerance)
                        && (!allFour || (Math.abs(this.w - toCompare.w) < tolerance));
                };
                Vector3D.prototype.project = function () {
                    this.x /= this.w;
                    this.y /= this.w;
                    this.z /= this.w;
                };
                Vector3D.prototype.copyFrom = function (sourceVector3D) {
                    this.x = sourceVector3D.x;
                    this.y = sourceVector3D.y;
                    this.z = sourceVector3D.z;
                };
                Vector3D.prototype.setTo = function (xa, ya, za) {
                    this.x = +xa;
                    this.y = +ya;
                    this.z = +za;
                };
                Vector3D.prototype.clone = function () {
                    return this._sec.geom.Vector3D.create([this.x, this.y, this.z, this.w]);
                };
                Vector3D.prototype.toString = function () {
                    return "Vector3D(" + this.x + ", " + this.y + ", " + this.z + ")";
                };
                return Vector3D;
            }(flash.LegacyEntity));
            geom.Vector3D = Vector3D;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Accessibility
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var accessibility;
        (function (accessibility) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Accessibility = /** @class */ (function (_super) {
                __extends(Accessibility, _super);
                function Accessibility() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Object.defineProperty(Accessibility, "active", {
                    get: function () {
                        release || somewhatImplemented("public flash.accessibility.Accessibility::get active");
                        return Accessibility._active;
                    },
                    enumerable: true,
                    configurable: true
                });
                Accessibility.sendEvent = function (source, childID /*uint*/, eventType /*uint*/, nonHTML) {
                    if (nonHTML === void 0) { nonHTML = false; }
                    source = source;
                    childID = childID >>> 0;
                    eventType = eventType >>> 0;
                    nonHTML = !!nonHTML;
                    release || release || notImplemented("public flash.accessibility.Accessibility::static sendEvent");
                    return;
                };
                Accessibility.updateProperties = function () {
                    release || release || notImplemented("public flash.accessibility.Accessibility::static updateProperties");
                    return;
                };
                // AS -> JS Bindings
                Accessibility._active = false;
                return Accessibility;
            }(flash.LegacyEntity));
            accessibility.Accessibility = Accessibility;
        })(accessibility = flash.accessibility || (flash.accessibility = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: AccessibilityImplementation
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var accessibility;
        (function (accessibility) {
            var AccessibilityImplementation = /** @class */ (function (_super) {
                __extends(AccessibilityImplementation, _super);
                function AccessibilityImplementation() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return AccessibilityImplementation;
            }(flash.LegacyEntity));
            accessibility.AccessibilityImplementation = AccessibilityImplementation;
        })(accessibility = flash.accessibility || (flash.accessibility = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: AccessibilityProperties
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var accessibility;
        (function (accessibility) {
            var AccessibilityProperties = /** @class */ (function (_super) {
                __extends(AccessibilityProperties, _super);
                function AccessibilityProperties() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return AccessibilityProperties;
            }(flash.LegacyEntity));
            accessibility.AccessibilityProperties = AccessibilityProperties;
        })(accessibility = flash.accessibility || (flash.accessibility = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Event
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var Event = /** @class */ (function (_super) {
                __extends(Event, _super);
                function Event(type, bubbles, cancelable) {
                    var _this = _super.call(this) || this;
                    _this._type = type;
                    _this._bubbles = !!bubbles;
                    _this._cancelable = !!cancelable;
                    _this._target = null;
                    _this._currentTarget = null;
                    _this._eventPhase = events.EventPhase.AT_TARGET;
                    _this._stopPropagation = false;
                    _this._stopImmediatePropagation = false;
                    _this._isDefaultPrevented = false;
                    return _this;
                }
                /**
                 * http://stackoverflow.com/questions/16900176/as3enterframe-event-propagation-understanding-issue
                 */
                Event.isBroadcastEventType = function (type) {
                    switch (type) {
                        case Event.ENTER_FRAME:
                        case Event.EXIT_FRAME:
                        case Event.FRAME_CONSTRUCTED:
                        case Event.RENDER:
                        case Event.ACTIVATE:
                        case Event.DEACTIVATE:
                            return true;
                    }
                    return false;
                };
                Object.defineProperty(Event.prototype, "type", {
                    get: function () {
                        return this._type;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Event.prototype, "bubbles", {
                    get: function () {
                        return this._bubbles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Event.prototype, "cancelable", {
                    get: function () {
                        return this._cancelable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Event.prototype, "target", {
                    get: function () {
                        return this._target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Event.prototype, "currentTarget", {
                    get: function () {
                        return this._currentTarget;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Event.prototype, "eventPhase", {
                    get: function () {
                        return this._eventPhase;
                    },
                    enumerable: true,
                    configurable: true
                });
                Event.prototype.stopPropagation = function () {
                    this._stopPropagation = true;
                };
                Event.prototype.stopImmediatePropagation = function () {
                    this._stopImmediatePropagation = this._stopPropagation = true;
                };
                Event.prototype.preventDefault = function () {
                    if (this._cancelable) {
                        this._isDefaultPrevented = true;
                    }
                };
                Event.prototype.isDefaultPrevented = function () {
                    return this._isDefaultPrevented;
                };
                Event.prototype.isBroadcastEvent = function () {
                    return this._isBroadcastEvent;
                };
                Event.prototype.clone = function () {
                    return this._sec.events.Event.create([this._type, this._bubbles,
                        this._cancelable]);
                };
                Event.prototype.toString = function () {
                    return this.formatToString('Event', 'type', 'bubbles', 'cancelable', 'eventPhase');
                };
                Event.prototype.formatToString = function (className) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var str = '[' + className;
                    for (var i = 0; i < args.length; i++) {
                        var field = args[i];
                        var value = this[field];
                        if (typeof value === 'string') {
                            value = '"' + value + '"';
                        }
                        str += ' ' + field + '=' + value;
                    }
                    return str + ']';
                };
                // JS -> AS Bindings
                Event.ACTIVATE = "activate";
                Event.ADDED = "added";
                Event.ADDED_TO_STAGE = "addedToStage";
                Event.CANCEL = "cancel";
                Event.CHANGE = "change";
                Event.CLEAR = "clear";
                Event.CLOSE = "close";
                Event.COMPLETE = "complete";
                Event.CONNECT = "connect";
                Event.COPY = "copy";
                Event.CUT = "cut";
                Event.DEACTIVATE = "deactivate";
                Event.ENTER_FRAME = "enterFrame";
                Event.FRAME_CONSTRUCTED = "frameConstructed";
                Event.EXIT_FRAME = "exitFrame";
                Event.FRAME_LABEL = "frameLabel";
                Event.ID3 = "id3";
                Event.INIT = "init";
                Event.MOUSE_LEAVE = "mouseLeave";
                Event.OPEN = "open";
                Event.PASTE = "paste";
                Event.REMOVED = "removed";
                Event.REMOVED_FROM_STAGE = "removedFromStage";
                Event.RENDER = "render";
                Event.RESIZE = "resize";
                Event.SCROLL = "scroll";
                Event.TEXT_INTERACTION_MODE_CHANGE = "textInteractionModeChange";
                Event.SELECT = "select";
                Event.SELECT_ALL = "selectAll";
                Event.SOUND_COMPLETE = "soundComplete";
                Event.TAB_CHILDREN_CHANGE = "tabChildrenChange";
                Event.TAB_ENABLED_CHANGE = "tabEnabledChange";
                Event.TAB_INDEX_CHANGE = "tabIndexChange";
                Event.UNLOAD = "unload";
                Event.FULLSCREEN = "fullScreen";
                Event.CONTEXT3D_CREATE = "context3DCreate";
                Event.TEXTURE_READY = "textureReady";
                Event.VIDEO_FRAME = "videoFrame";
                Event.SUSPEND = "suspend";
                Event.AVM1_INIT = "initialize";
                Event.AVM1_CONSTRUCT = "construct";
                Event.AVM1_LOAD = "load";
                return Event;
            }(flash.LegacyEntity));
            events.Event = Event;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: EventDispatcher
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var isNullOrUndefined = Shumway.isNullOrUndefined;
            var assert = Shumway.Debug.assert;
            var EventListenerEntry = /** @class */ (function () {
                function EventListenerEntry(listener, useCapture, priority) {
                    this.listener = listener;
                    this.useCapture = useCapture;
                    this.priority = priority;
                }
                return EventListenerEntry;
            }());
            /**
             * Implements Copy-On-Write for event listener lists. Event handlers can add and/or remove
             * event handlers while the events are processed. The easiest way to implement this is to
             * clone the event listener list before executing the event listeners. This however can be
             * wasteful, since most of the time, event handlers don't mutate the event list. Here we
             * implement a simple copy-on-write strategy that clones the entry list if it's been
             * snapshotted and it's about to be mutated.
             */
            var EventListenerList = /** @class */ (function () {
                function EventListenerList() {
                    /**
                     * The number of times the current entry list has been aliased (or snapshotted).
                     */
                    this._aliasCount = 0;
                    this._entries = [];
                }
                EventListenerList.prototype.isEmpty = function () {
                    return this._entries.length === 0;
                };
                EventListenerList.prototype.insert = function (listener, useCapture, priority) {
                    var entries = this._entries;
                    var index = entries.length;
                    for (var i = index - 1; i >= 0; i--) {
                        var entry = entries[i];
                        if (entry.listener === listener) {
                            return;
                        }
                        if (priority > entry.priority) {
                            index = i;
                        }
                        else {
                            break;
                        }
                    }
                    entries = this.ensureNonAliasedEntries();
                    entries.splice(index, 0, new EventListenerEntry(listener, useCapture, priority));
                };
                /**
                 * Make sure we get a fresh list if it's been aliased.
                 */
                EventListenerList.prototype.ensureNonAliasedEntries = function () {
                    var entries = this._entries;
                    if (this._aliasCount > 0) {
                        entries = this._entries = entries.slice();
                        this._aliasCount = 0;
                    }
                    return entries;
                };
                EventListenerList.prototype.remove = function (listener) {
                    var entries = this._entries;
                    for (var i = 0; i < entries.length; i++) {
                        var item = entries[i];
                        if (item.listener === listener) {
                            this.ensureNonAliasedEntries().splice(i, 1);
                            return;
                        }
                    }
                };
                /**
                 * Get a snapshot of the current entry list.
                 */
                EventListenerList.prototype.snapshot = function () {
                    this._aliasCount++;
                    return this._entries;
                };
                /**
                 * Release the snapshot, hopefully no other mutations occured so we can reuse the entry list.
                 */
                EventListenerList.prototype.releaseSnapshot = function (snapshot) {
                    // We ignore any non current snapshots.
                    if (this._entries !== snapshot) {
                        return;
                    }
                    if (this._aliasCount > 0) {
                        this._aliasCount--;
                    }
                };
                return EventListenerList;
            }());
            /**
             * Broadcast Events
             *
             * The logic here is pretty much copied from:
             * http://www.senocular.com/flash/tutorials/orderofoperations/
             */
            var BroadcastEventDispatchQueue = /** @class */ (function () {
                function BroadcastEventDispatchQueue() {
                    this.reset();
                }
                BroadcastEventDispatchQueue.prototype.reset = function () {
                    this._queues = Object.create(null);
                };
                BroadcastEventDispatchQueue.prototype.add = function (type, target) {
                    release || assert(events.Event.isBroadcastEventType(type), "Can only register broadcast events.");
                    var queue = this._queues[type] || (this._queues[type] = []);
                    if (queue.indexOf(target) >= 0) {
                        return;
                    }
                    queue.push(target);
                };
                BroadcastEventDispatchQueue.prototype.remove = function (type, target) {
                    release || assert(events.Event.isBroadcastEventType(type), "Can only unregister broadcast events.");
                    var queue = this._queues[type];
                    release || assert(queue, "There should already be a queue for this.");
                    var index = queue.indexOf(target);
                    release || assert(index >= 0, "Target should be somewhere in this queue.");
                    queue[index] = null;
                    release || assert(queue.indexOf(target) < 0, "Target shouldn't be in this queue anymore.");
                };
                BroadcastEventDispatchQueue.prototype.dispatchEvent = function (event) {
                    release || assert(event.isBroadcastEvent(), "Cannot dispatch non-broadcast events.");
                    var queue = this._queues[event._type];
                    if (!queue) {
                        return;
                    }
                    if (!release && Shumway.traceEventsOption.value) {
                        console.log('Broadcast event of type ' + event._type + ' to ' + queue.length +
                            ' listeners');
                    }
                    var nullCount = 0;
                    for (var i = 0; i < queue.length; i++) {
                        var target = queue[i];
                        if (target === null) {
                            nullCount++;
                        }
                        else {
                            target.dispatchEvent(event);
                        }
                    }
                    // Compact the queue if there are too many holes in it.
                    if (nullCount > 16 && nullCount > (queue.length >> 1)) {
                        var compactedQueue = [];
                        for (var i = 0; i < queue.length; i++) {
                            if (queue[i]) {
                                compactedQueue.push(queue[i]);
                            }
                        }
                        this._queues[event.type] = compactedQueue;
                    }
                };
                BroadcastEventDispatchQueue.prototype.getQueueLength = function (type) {
                    return this._queues[type] ? this._queues[type].length : 0;
                };
                return BroadcastEventDispatchQueue;
            }());
            events.BroadcastEventDispatchQueue = BroadcastEventDispatchQueue;
            /**
             * The EventDispatcher class is the base class for all classes that dispatch events.
             * The EventDispatcher class implements the IEventDispatcher interface and is the base class for
             * the DisplayObject class. The EventDispatcher class allows any object on the display list to be
             * an event target and as such, to use the methods of the IEventDispatcher interface.
             */
            var EventDispatcher = /** @class */ (function (_super) {
                __extends(EventDispatcher, _super);
                function EventDispatcher(target) {
                    if (target === void 0) { target = null; }
                    var _this = _super.call(this) || this;
                    _this.preInit();
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields(target || _this);
                    }
                    return _this;
                }
                EventDispatcher.prototype.preInit = function () {
                };
                EventDispatcher.prototype._initializeFields = function (target) {
                    release || assert(!this._fieldsInitialized);
                    this._fieldsInitialized = true;
                    this._target = target;
                    this._captureListeners = null;
                    this._targetOrBubblingListeners = null;
                };
                EventDispatcher.prototype.toString = function () {
                    // EventDispatcher's toString doesn't actually do anything. It just introduces a trait that
                    // forwards to Object.prototype's toString method.
                    // @ivanpopelyshev: fix it
                    // return this.sec.AXObject.dPrototype.$BgtoString.axCall(this);
                    return "EventDispatcher";
                };
                /**
                 * Don't lazily construct listener lists if all we're doing is looking for listener types that
                 * don't exist yet.
                 */
                EventDispatcher.prototype._getListenersForType = function (useCapture, type) {
                    var listeners = useCapture ? this._captureListeners : this._targetOrBubblingListeners;
                    if (listeners) {
                        return listeners[type];
                    }
                    return null;
                };
                /**
                 * Lazily construct listeners lists to avoid object allocation.
                 */
                EventDispatcher.prototype._getListeners = function (useCapture) {
                    if (useCapture) {
                        return this._captureListeners || (this._captureListeners = Object.create(null));
                    }
                    return this._targetOrBubblingListeners || (this._targetOrBubblingListeners = Object.create(null));
                };
                EventDispatcher.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                    if (useCapture === void 0) { useCapture = false; }
                    if (priority === void 0) { priority = 0; }
                    if (useWeakReference === void 0) { useWeakReference = false; }
                    // The error message always says "2", even though up to five arguments are valid.
                    if (arguments.length < 2 || arguments.length > 5) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/addEventListener()", 2, arguments.length);
                    }
                    if (isNullOrUndefined(type)) {
                        this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                    }
                    useCapture = !!useCapture;
                    priority |= 0;
                    useWeakReference = !!useWeakReference;
                    var listeners = this._getListeners(useCapture);
                    var list = listeners[type] || (listeners[type] = new EventListenerList());
                    list.insert(listener, useCapture, priority);
                    // Notify the broadcast event queue. If |useCapture| is set then the Flash player
                    // doesn't seem to register this target.
                    if (!useCapture && events.Event.isBroadcastEventType(type)) {
                        this._sec.events.broadcastEventDispatchQueue.add(type, this);
                    }
                };
                EventDispatcher.prototype.removeEventListener = function (type, listener, useCapture) {
                    if (useCapture === void 0) { useCapture = false; }
                    // The error message always says "2", even though 3 arguments are valid.
                    if (arguments.length < 2 || arguments.length > 3) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/removeEventListener()", 2, arguments.length);
                    }
                    if (isNullOrUndefined(type)) {
                        this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                    }
                    var listeners = this._getListeners(!!useCapture);
                    var list = listeners[type];
                    if (list) {
                        list.remove(listener);
                        if (list.isEmpty()) {
                            // Notify the broadcast event queue of the removal.
                            if (!useCapture && events.Event.isBroadcastEventType(type)) {
                                this._sec.events.broadcastEventDispatchQueue.remove(type, this);
                            }
                            listeners[type] = null;
                        }
                    }
                };
                EventDispatcher.prototype._hasTargetOrBubblingEventListener = function (type) {
                    return !!(this._targetOrBubblingListeners && this._targetOrBubblingListeners[type]);
                };
                EventDispatcher.prototype._hasCaptureEventListener = function (type) {
                    return !!(this._captureListeners && this._captureListeners[type]);
                };
                /**
                 * Faster internal version of |hasEventListener| that doesn't do any argument checking.
                 */
                EventDispatcher.prototype._hasEventListener = function (type) {
                    return this._hasTargetOrBubblingEventListener(type) || this._hasCaptureEventListener(type);
                };
                EventDispatcher.prototype.hasEventListener = function (type) {
                    if (arguments.length !== 1) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/hasEventListener()", 1, arguments.length);
                    }
                    if (isNullOrUndefined(type)) {
                        this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                    }
                    return this._hasEventListener(type);
                };
                EventDispatcher.prototype.willTrigger = function (type) {
                    if (arguments.length !== 1) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/hasEventListener()", 1, arguments.length);
                    }
                    if (isNullOrUndefined(type)) {
                        this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                    }
                    if (this._hasEventListener(type)) {
                        return true;
                    }
                    if (this._sec.display.DisplayObject.axIsType(this)) {
                        var node = this._parent;
                        do {
                            if (node._hasEventListener(type)) {
                                return true;
                            }
                        } while ((node = node._parent));
                    }
                    return false;
                };
                /**
                 * Check to see if we can skip event dispatching in case there are no event listeners
                 * for this |event|.
                 */
                EventDispatcher.prototype._skipDispatchEvent = function (event) {
                    if (this._hasEventListener(event.type)) {
                        return false;
                    }
                    // Broadcast events don't have capturing or bubbling phases so it's a simple check.
                    if (event.isBroadcastEvent()) {
                        return true;
                    }
                    else if (event._bubbles && this._sec.display.DisplayObject.axIsType(this)) {
                        // Check to see if there are any event listeners on the path to the root.
                        for (var node = this._parent; node; node = node._parent) {
                            if (node._hasEventListener(event.type)) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                EventDispatcher.prototype.dispatchEvent = function (event) {
                    if (arguments.length !== 1) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.WrongArgumentCountError, "flash.events::EventDispatcher/dispatchEvent()", 1, arguments.length);
                    }
                    if (this._skipDispatchEvent(event)) {
                        return true;
                    }
                    if (!release && Shumway.traceEventsOption.value) {
                        console.log('Dispatch event of type ' + event._type);
                    }
                    release || Shumway.counter.count("EventDispatcher::dispatchEvent");
                    var type = event._type;
                    var target = this._target;
                    release || Shumway.counter.count("EventDispatcher::dispatchEvent(" + type + ")");
                    /**
                     * 1. Capturing Phase
                     */
                    var keepPropagating = true;
                    var ancestors = [];
                    if (!event.isBroadcastEvent() && this._sec.display.DisplayObject.axIsType(this)) {
                        var node = this._parent;
                        // Gather all parent display objects that have event listeners for this event type.
                        while (node) {
                            if (node._hasEventListener(type)) {
                                ancestors.push(node);
                            }
                            node = node._parent;
                        }
                        for (var i = ancestors.length - 1; i >= 0 && keepPropagating; i--) {
                            var ancestor = ancestors[i];
                            if (!ancestor._hasCaptureEventListener(type)) {
                                continue;
                            }
                            var list = ancestor._getListenersForType(true, type);
                            release || assert(list);
                            keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.CAPTURING_PHASE);
                        }
                    }
                    /**
                     * 2. At Target
                     */
                    if (keepPropagating) {
                        var list = this._getListenersForType(false, type);
                        if (list) {
                            keepPropagating = EventDispatcher.callListeners(list, event, target, target, events.EventPhase.AT_TARGET);
                        }
                    }
                    /**
                     * 3. Bubbling Phase
                     */
                    if (!event.isBroadcastEvent() && keepPropagating && event.bubbles) {
                        for (var i = 0; i < ancestors.length && keepPropagating; i++) {
                            var ancestor = ancestors[i];
                            if (!ancestor._hasTargetOrBubblingEventListener(type)) {
                                continue;
                            }
                            var list = ancestor._getListenersForType(false, type);
                            keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.BUBBLING_PHASE);
                        }
                    }
                    return !event._isDefaultPrevented;
                };
                EventDispatcher.callListeners = function (list, event, target, currentTarget, eventPhase) {
                    if (list.isEmpty()) {
                        return true;
                    }
                    /**
                     * If the target is already set then we must clone the event. We can reuse the event object
                     * for all listener callbacks but not when bubbling.
                     */
                    if (event._target) {
                        event = event.clone();
                    }
                    var snapshot = list.snapshot();
                    try {
                        for (var i = 0; i < snapshot.length; i++) {
                            var entry = snapshot[i];
                            event._target = target;
                            event._currentTarget = currentTarget;
                            event._eventPhase = eventPhase;
                            typeof entry.listener === 'function' ?
                                entry.listener(event) :
                                entry.listener.call(entry.listener, event);
                            if (event._stopImmediatePropagation) {
                                break;
                            }
                        }
                    }
                    catch (e) {
                        Shumway.Debug.warning('Uncaught error in handler for event ' + event._type + ': ', e);
                    }
                    list.releaseSnapshot(snapshot);
                    return !event._stopPropagation;
                };
                return EventDispatcher;
            }(flash.LegacyEntity));
            events.EventDispatcher = EventDispatcher;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: EventPhase
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var EventPhase;
            (function (EventPhase) {
                // JS -> AS Bindings
                EventPhase[EventPhase["CAPTURING_PHASE"] = 1] = "CAPTURING_PHASE";
                EventPhase[EventPhase["AT_TARGET"] = 2] = "AT_TARGET";
                EventPhase[EventPhase["BUBBLING_PHASE"] = 3] = "BUBBLING_PHASE";
            })(EventPhase = events.EventPhase || (events.EventPhase = {}));
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var notImplemented = Shumway.Debug.notImplemented;
            var TextEvent = /** @class */ (function (_super) {
                __extends(TextEvent, _super);
                function TextEvent(type, bubbles, cancelable, text) {
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._text = text;
                    return _this;
                }
                Object.defineProperty(TextEvent.prototype, "text", {
                    get: function () {
                        return this._text;
                    },
                    set: function (value) {
                        this._text = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                TextEvent.prototype.clone = function () {
                    var textEvent = this._sec.events.TextEvent.create([this.type, this.bubbles,
                        this.cancelable, this.text]);
                    //this.copyNativeData(textEvent);
                    return textEvent;
                };
                TextEvent.prototype.toString = function () {
                    return this.formatToString('TextEvent', 'type', 'bubbles', 'cancelable', 'text');
                };
                TextEvent.prototype.copyNativeData = function (event) {
                    release || notImplemented("public flash.events.TextEvent::copyNativeData");
                };
                TextEvent.LINK = "link";
                TextEvent.TEXT_INPUT = "textInput";
                return TextEvent;
            }(flash.events.Event));
            events.TextEvent = TextEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ErrorEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var ErrorEvent = /** @class */ (function (_super) {
                __extends(ErrorEvent, _super);
                function ErrorEvent(type, bubbles, cancelable, text, id) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (text === void 0) { text = ""; }
                    if (id === void 0) { id = 0; }
                    var _this = _super.call(this, type, bubbles, cancelable, text) || this;
                    _this.setID(id);
                    return _this;
                }
                ErrorEvent.prototype.setID = function (id) {
                    this._id = id;
                };
                Object.defineProperty(ErrorEvent.prototype, "errorID", {
                    get: function () {
                        return this._id;
                    },
                    enumerable: true,
                    configurable: true
                });
                ErrorEvent.prototype.clone = function () {
                    return this._sec.events.ErrorEvent.create([this.type, this.bubbles,
                        this.cancelable, this.text, this.errorID]);
                };
                ErrorEvent.prototype.toString = function () {
                    return this.formatToString('ErrorEvent', 'type', 'bubbles', 'cancelable', 'text', 'errorID');
                };
                // JS -> AS Bindings
                ErrorEvent.ERROR = "error";
                return ErrorEvent;
            }(flash.events.TextEvent));
            events.ErrorEvent = ErrorEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: AsyncErrorEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var AsyncErrorEvent = /** @class */ (function (_super) {
                __extends(AsyncErrorEvent, _super);
                function AsyncErrorEvent(type, bubbles, cancelable, text, error) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (text === void 0) { text = ""; }
                    if (error === void 0) { error = null; }
                    var _this = _super.call(this, type, bubbles, cancelable, text) || this;
                    _this.error = error;
                    return _this;
                }
                AsyncErrorEvent.prototype.clone = function () {
                    return this._sec.events.AsyncErrorEvent.create([this._type, this._bubbles, this._cancelable,
                        this._text, this.error]);
                };
                AsyncErrorEvent.prototype.toString = function () {
                    return this.formatToString('AsyncErrorEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'text', 'error');
                };
                return AsyncErrorEvent;
            }(flash.events.ErrorEvent));
            events.AsyncErrorEvent = AsyncErrorEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var GameInputEvent = /** @class */ (function (_super) {
                __extends(GameInputEvent, _super);
                function GameInputEvent(type, bubbles, cancelable, device) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (device === void 0) { device = null; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    // TODO: coerce
                    _this.device = device;
                    return _this;
                }
                GameInputEvent.classInitializer = null;
                GameInputEvent.classSymbols = null;
                GameInputEvent.instanceSymbols = null;
                // JS -> AS Bindings
                GameInputEvent.DEVICE_ADDED = "deviceAdded";
                GameInputEvent.DEVICE_REMOVED = "deviceRemoved";
                return GameInputEvent;
            }(flash.events.Event));
            events.GameInputEvent = GameInputEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GestureEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var GestureEvent = /** @class */ (function (_super) {
                __extends(GestureEvent, _super);
                function GestureEvent(type, bubbles, cancelable, phase, localX, localY, ctrlKey, altKey, shiftKey) {
                    if (bubbles === void 0) { bubbles = true; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (phase === void 0) { phase = null; }
                    if (localX === void 0) { localX = 0; }
                    if (localY === void 0) { localY = 0; }
                    if (ctrlKey === void 0) { ctrlKey = false; }
                    if (altKey === void 0) { altKey = false; }
                    if (shiftKey === void 0) { shiftKey = false; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._phase = phase;
                    _this._localX = +localX;
                    _this._localY = +localY;
                    _this._ctrlKey = !!ctrlKey;
                    _this._altKey = !!altKey;
                    _this._shiftKey = !!shiftKey;
                    return _this;
                }
                Object.defineProperty(GestureEvent.prototype, "localX", {
                    // AS -> JS Bindings
                    get: function () {
                        return this._localX;
                    },
                    set: function (value) {
                        this._localX = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "localY", {
                    get: function () {
                        return this._localY;
                    },
                    set: function (value) {
                        this._localY = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "stageX", {
                    get: function () {
                        release || somewhatImplemented("public flash.events.GestureEvent::stageX");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "stageY", {
                    get: function () {
                        release || somewhatImplemented("public flash.events.GestureEvent::stageY");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "ctrlKey", {
                    get: function () {
                        return this._ctrlKey;
                    },
                    set: function (value) {
                        this._ctrlKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "altKey", {
                    get: function () {
                        return this._altKey;
                    },
                    set: function (value) {
                        this._altKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "shiftKey", {
                    get: function () {
                        return this._shiftKey;
                    },
                    set: function (value) {
                        this._shiftKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GestureEvent.prototype, "phase", {
                    get: function () {
                        return this._phase;
                    },
                    set: function (value) {
                        this._phase = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                GestureEvent.prototype.updateAfterEvent = function () {
                    release || somewhatImplemented("public flash.events.GestureEvent::updateAfterEvent");
                };
                GestureEvent.prototype.NativeCtor = function (phase, localX, localY, ctrlKey, altKey, shiftKey) {
                    this._phase = phase;
                    this._localX = +localX;
                    this._localY = +localY;
                    this._ctrlKey = !!ctrlKey;
                    this._altKey = !!altKey;
                    this._shiftKey = !!shiftKey;
                };
                GestureEvent.prototype.clone = function () {
                    return this._sec.events.GestureEvent.create([this.type, this.bubbles,
                        this.cancelable, this.phase,
                        this.localX, this.localY,
                        this.ctrlKey, this.altKey,
                        this.shiftKey]);
                };
                GestureEvent.prototype.toString = function () {
                    return this.formatToString('GestureEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'localX', 'localY', 'ctrlKey', 'altKey', 'shiftKey');
                };
                // JS -> AS Bindings
                GestureEvent.GESTURE_TWO_FINGER_TAP = "gestureTwoFingerTap";
                return GestureEvent;
            }(flash.events.Event));
            events.GestureEvent = GestureEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: HTTPStatusEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var HTTPStatusEvent = /** @class */ (function (_super) {
                __extends(HTTPStatusEvent, _super);
                function HTTPStatusEvent(type, bubbles, cancelable, status) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (status === void 0) { status = 0; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this.responseHeaders = null;
                    _this.responseURL = "";
                    _this._status = status | 0;
                    return _this;
                }
                HTTPStatusEvent.prototype._setStatus = function (value) {
                    this._status = value;
                };
                Object.defineProperty(HTTPStatusEvent.prototype, "status", {
                    get: function () {
                        return this._status;
                    },
                    enumerable: true,
                    configurable: true
                });
                HTTPStatusEvent.prototype.clone = function () {
                    return this._sec.events.HTTPStatusEvent.create([this.type, this.bubbles, this.cancelable,
                        this.status]);
                };
                HTTPStatusEvent.prototype.toString = function () {
                    return this.formatToString('HTTPStatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'status');
                };
                HTTPStatusEvent.HTTP_STATUS = "httpStatus";
                HTTPStatusEvent.HTTP_RESPONSE_STATUS = "httpResponseStatus";
                return HTTPStatusEvent;
            }(flash.events.Event));
            events.HTTPStatusEvent = HTTPStatusEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: IOErrorEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var IOErrorEvent = /** @class */ (function (_super) {
                __extends(IOErrorEvent, _super);
                function IOErrorEvent(type, bubbles, cancelable, text, id) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (text === void 0) { text = ""; }
                    if (id === void 0) { id = 0; }
                    return _super.call(this, type, bubbles, cancelable, text, id) || this;
                }
                IOErrorEvent.prototype.clone = function () {
                    var event = this._sec.events.IOErrorEvent.create([this.type, this.bubbles,
                        this.cancelable, this.text,
                        this.errorID]);
                    //this.copyNativeData(event);
                    return event;
                };
                IOErrorEvent.prototype.toString = function () {
                    return this.formatToString('IOErrorEvent', 'type', 'bubbles', 'cancelable', 'text', 'errorID');
                };
                IOErrorEvent.classInitializer = null;
                IOErrorEvent.classSymbols = null;
                IOErrorEvent.instanceSymbols = null;
                // JS -> AS Bindings
                IOErrorEvent.IO_ERROR = "ioError";
                IOErrorEvent.NETWORK_ERROR = "networkError";
                IOErrorEvent.DISK_ERROR = "diskError";
                IOErrorEvent.VERIFY_ERROR = "verifyError";
                return IOErrorEvent;
            }(flash.events.ErrorEvent));
            events.IOErrorEvent = IOErrorEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: KeyboardEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var KeyboardEvent = /** @class */ (function (_super) {
                __extends(KeyboardEvent, _super);
                function KeyboardEvent(type, bubbles, cancelable, charCodeValue, keyCodeValue, keyLocationValue, ctrlKeyValue, altKeyValue, shiftKeyValue) {
                    if (bubbles === void 0) { bubbles = true; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (charCodeValue === void 0) { charCodeValue = 0; }
                    if (keyCodeValue === void 0) { keyCodeValue = 0; }
                    if (keyLocationValue === void 0) { keyLocationValue = 0; }
                    if (ctrlKeyValue === void 0) { ctrlKeyValue = false; }
                    if (altKeyValue === void 0) { altKeyValue = false; }
                    if (shiftKeyValue === void 0) { shiftKeyValue = false; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._charCode = charCodeValue >>> 0;
                    _this._keyCode = keyCodeValue >>> 0;
                    _this._keyLocation = keyLocationValue >>> 0;
                    _this._ctrlKey = !!ctrlKeyValue;
                    _this._altKey = !!altKeyValue;
                    _this._shiftKey = !!shiftKeyValue;
                    return _this;
                }
                Object.defineProperty(KeyboardEvent.prototype, "charCode", {
                    get: function () {
                        return this._charCode;
                    },
                    set: function (value) {
                        this._charCode = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardEvent.prototype, "keyCode", {
                    get: function () {
                        return this._keyCode;
                    },
                    set: function (value) {
                        this._keyCode = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardEvent.prototype, "keyLocation", {
                    get: function () {
                        return this._keyLocation;
                    },
                    set: function (value) {
                        this._keyLocation = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardEvent.prototype, "ctrlKey", {
                    get: function () {
                        return this._ctrlKey;
                    },
                    set: function (value) {
                        this._ctrlKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardEvent.prototype, "altKey", {
                    get: function () {
                        return this._altKey;
                    },
                    set: function (value) {
                        this._altKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(KeyboardEvent.prototype, "shiftKey", {
                    get: function () {
                        return this._shiftKey;
                    },
                    set: function (value) {
                        this._shiftKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                KeyboardEvent.prototype.clone = function () {
                    return this._sec.events.KeyboardEvent.create([this.type, this.bubbles,
                        this.cancelable, this.charCode,
                        this.keyCode, this.keyLocation,
                        this.ctrlKey, this.altKey,
                        this.shiftKey]);
                };
                KeyboardEvent.prototype.toString = function () {
                    return this.formatToString('KeyboardEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'charCode', 'keyCode', 'keyLocation', 'ctrlKey', 'altKey', 'shiftKey');
                };
                KeyboardEvent.prototype.updateAfterEvent = function () {
                    this._sec.player.requestRendering();
                };
                KeyboardEvent.KEY_DOWN = "keyDown";
                KeyboardEvent.KEY_UP = "keyUp";
                return KeyboardEvent;
            }(flash.events.Event));
            events.KeyboardEvent = KeyboardEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MouseEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var notImplemented = Shumway.Debug.notImplemented;
            var MouseEvent = /** @class */ (function (_super) {
                __extends(MouseEvent, _super);
                function MouseEvent(type, bubbles, cancelable, localX, localY, relatedObject, ctrlKey, altKey, shiftKey, buttonDown, delta) {
                    if (bubbles === void 0) { bubbles = true; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (localX === void 0) { localX = undefined; }
                    if (localY === void 0) { localY = undefined; }
                    if (relatedObject === void 0) { relatedObject = null; }
                    if (ctrlKey === void 0) { ctrlKey = false; }
                    if (altKey === void 0) { altKey = false; }
                    if (shiftKey === void 0) { shiftKey = false; }
                    if (buttonDown === void 0) { buttonDown = false; }
                    if (delta === void 0) { delta = 0; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._localX = localX;
                    _this._localY = localY;
                    _this._relatedObject = relatedObject;
                    _this._ctrlKey = ctrlKey;
                    _this._altKey = altKey;
                    _this._shiftKey = shiftKey;
                    _this._buttonDown = buttonDown;
                    _this._delta = delta;
                    return _this;
                }
                /**
                 * AS3 mouse event names don't match DOM even names, so map them here.
                 */
                MouseEvent.typeFromDOMType = function (name) {
                    switch (name) {
                        case "click":
                            return MouseEvent.CLICK;
                        case "dblclick":
                            return MouseEvent.DOUBLE_CLICK;
                        case "mousedown":
                            return MouseEvent.MOUSE_DOWN;
                        case "mouseout":
                        case "mouseover":
                        case "mousemove":
                            return MouseEvent.MOUSE_MOVE;
                        case "mouseup":
                            return MouseEvent.MOUSE_UP;
                        default:
                            notImplemented(name);
                    }
                    return "";
                };
                Object.defineProperty(MouseEvent.prototype, "localX", {
                    get: function () {
                        return (this._localX / 20) | 0;
                    },
                    set: function (value) {
                        this._localX = (value * 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "localY", {
                    get: function () {
                        return (this._localY / 20) | 0;
                    },
                    set: function (value) {
                        this._localY = (value * 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "stageX", {
                    get: function () {
                        if (isNaN(this.localX + this.localY)) {
                            return Number.NaN;
                        }
                        return (this._getGlobalPoint().x / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "stageY", {
                    get: function () {
                        if (isNaN(this.localX + this.localY)) {
                            return Number.NaN;
                        }
                        return (this._getGlobalPoint().y / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "movementX", {
                    get: function () {
                        return this._movementX || 0;
                    },
                    set: function (value) {
                        this._movementX = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "movementY", {
                    get: function () {
                        return this._movementY || 0;
                    },
                    set: function (value) {
                        this._movementY = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "delta", {
                    get: function () {
                        return this._delta;
                    },
                    set: function (value) {
                        this._delta = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "ctrlKey", {
                    get: function () {
                        return this._ctrlKey;
                    },
                    set: function (value) {
                        this._ctrlKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "altKey", {
                    get: function () {
                        return this._altKey;
                    },
                    set: function (value) {
                        this._altKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "shiftKey", {
                    get: function () {
                        return this._shiftKey;
                    },
                    set: function (value) {
                        this._shiftKey = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "buttonDown", {
                    get: function () {
                        return this._buttonDown;
                    },
                    set: function (value) {
                        this._buttonDown = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "relatedObject", {
                    get: function () {
                        return this._relatedObject;
                    },
                    set: function (value) {
                        this._relatedObject = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseEvent.prototype, "isRelatedObjectInaccessible", {
                    get: function () {
                        return this._isRelatedObjectInaccessible;
                    },
                    set: function (value) {
                        this._isRelatedObjectInaccessible = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                MouseEvent.prototype.updateAfterEvent = function () {
                    this._sec.player.requestRendering();
                };
                MouseEvent.prototype._getGlobalPoint = function () {
                    var point = this._position;
                    if (!point) {
                        point = this._position = this._sec.geom.Point.create();
                    }
                    if (this.target) {
                        point.setTo(this._localX, this._localY);
                        var m = this._target._getConcatenatedMatrix();
                        m.transformPointInPlace(point);
                    }
                    else {
                        point.setTo(0, 0);
                    }
                    return point;
                };
                MouseEvent.prototype.clone = function () {
                    return this._sec.events.MouseEvent.create([this.type, this.bubbles,
                        this.cancelable,
                        this.localX, this.localY,
                        this.relatedObject, this.ctrlKey,
                        this.altKey, this.shiftKey,
                        this.buttonDown, this.delta]);
                };
                MouseEvent.prototype.toString = function () {
                    return this.formatToString('MouseEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'localX', "localY", 'relatedObject', 'ctrlKey', 'altKey', 'shiftKey', 'buttonDown', 'delta');
                };
                // JS -> AS Bindings
                MouseEvent.CLICK = "click";
                MouseEvent.DOUBLE_CLICK = "doubleClick";
                MouseEvent.MOUSE_DOWN = "mouseDown";
                MouseEvent.MOUSE_MOVE = "mouseMove";
                MouseEvent.MOUSE_OUT = "mouseOut";
                MouseEvent.MOUSE_OVER = "mouseOver";
                MouseEvent.MOUSE_UP = "mouseUp";
                MouseEvent.RELEASE_OUTSIDE = "releaseOutside";
                MouseEvent.MOUSE_WHEEL = "mouseWheel";
                MouseEvent.ROLL_OUT = "rollOut";
                MouseEvent.ROLL_OVER = "rollOver";
                MouseEvent.MIDDLE_CLICK = "middleClick";
                MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
                MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
                MouseEvent.RIGHT_CLICK = "rightClick";
                MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
                MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
                MouseEvent.CONTEXT_MENU = "contextMenu";
                return MouseEvent;
            }(flash.events.Event));
            events.MouseEvent = MouseEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetStatusEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var NetStatusEvent = /** @class */ (function (_super) {
                __extends(NetStatusEvent, _super);
                function NetStatusEvent(type, bubbles, cancelable, info) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (info === void 0) { info = null; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._info = info;
                    return _this;
                }
                Object.defineProperty(NetStatusEvent.prototype, "info", {
                    get: function () {
                        return this._info;
                    },
                    set: function (value) {
                        this._info = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetStatusEvent.prototype.clone = function () {
                    return this._sec.events.NetStatusEvent.create([this.type, this.bubbles,
                        this.cancelable, this.info]);
                };
                NetStatusEvent.prototype.toString = function () {
                    return this.formatToString('NetStatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'info');
                };
                NetStatusEvent.classInitializer = null;
                NetStatusEvent.classSymbols = null;
                NetStatusEvent.instanceSymbols = null;
                // JS -> AS Bindings
                NetStatusEvent.NET_STATUS = "netStatus";
                return NetStatusEvent;
            }(flash.events.Event));
            events.NetStatusEvent = NetStatusEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ProgressEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var ProgressEvent = /** @class */ (function (_super) {
                __extends(ProgressEvent, _super);
                function ProgressEvent(type, bubbles, cancelable, bytesLoaded, bytesTotal) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (bytesLoaded === void 0) { bytesLoaded = 0; }
                    if (bytesTotal === void 0) { bytesTotal = 0; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._bytesLoaded = bytesLoaded;
                    _this._bytesTotal = bytesTotal;
                    return _this;
                }
                Object.defineProperty(ProgressEvent.prototype, "bytesLoaded", {
                    get: function () {
                        return this._bytesLoaded;
                    },
                    set: function (value) {
                        this._bytesLoaded = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ProgressEvent.prototype, "bytesTotal", {
                    get: function () {
                        return this._bytesTotal;
                    },
                    set: function (value) {
                        this._bytesTotal = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                ProgressEvent.prototype.clone = function () {
                    return this._sec.events.ProgressEvent.create([this._type, this._bubbles,
                        this._cancelable, this._bytesLoaded,
                        this._bytesTotal]);
                };
                ProgressEvent.prototype.toString = function () {
                    return this.formatToString('ProgressEvent', 'bubbles', 'cancelable', 'eventPhase', 'bytesLoaded', 'bytesTotal');
                };
                // JS -> AS Bindings
                ProgressEvent.PROGRESS = "progress";
                ProgressEvent.SOCKET_DATA = "socketData";
                return ProgressEvent;
            }(events.Event));
            events.ProgressEvent = ProgressEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SecurityErrorEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var SecurityErrorEvent = /** @class */ (function (_super) {
                __extends(SecurityErrorEvent, _super);
                function SecurityErrorEvent(type, bubbles, cancelable, text, id) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (text === void 0) { text = ""; }
                    if (id === void 0) { id = 0; }
                    return _super.call(this, type, bubbles, cancelable, text, id) || this;
                }
                SecurityErrorEvent.classInitializer = null;
                SecurityErrorEvent.classSymbols = null;
                SecurityErrorEvent.instanceSymbols = null;
                // JS -> AS Bindings
                SecurityErrorEvent.SECURITY_ERROR = "securityError";
                return SecurityErrorEvent;
            }(flash.events.ErrorEvent));
            events.SecurityErrorEvent = SecurityErrorEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StatusEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var StatusEvent = /** @class */ (function (_super) {
                __extends(StatusEvent, _super);
                function StatusEvent(type, bubbles, cancelable, code, level) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (code === void 0) { code = ""; }
                    if (level === void 0) { level = ""; }
                    var _this = _super.call(this, type, bubbles, cancelable) || this;
                    _this._code = code;
                    _this._level = level;
                    return _this;
                }
                Object.defineProperty(StatusEvent.prototype, "level", {
                    get: function () {
                        return this._level;
                    },
                    set: function (value) {
                        this._level = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StatusEvent.prototype, "code", {
                    get: function () {
                        return this._code;
                    },
                    set: function (value) {
                        this._code = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                StatusEvent.prototype.clone = function () {
                    return this._sec.events.StatusEvent.create([this._type, this._bubbles, this._cancelable,
                        this._code, this._level]);
                };
                StatusEvent.prototype.toString = function () {
                    return this.formatToString('StatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'code', 'level');
                };
                StatusEvent.STATUS = "status";
                return StatusEvent;
            }(flash.events.Event));
            events.StatusEvent = StatusEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TimerEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var TimerEvent = /** @class */ (function (_super) {
                __extends(TimerEvent, _super);
                function TimerEvent(type, bubbles, cancelable) {
                    return _super.call(this, type, bubbles, cancelable) || this;
                }
                TimerEvent.prototype.clone = function () {
                    return this._sec.events.TimerEvent.create([this.type, this.bubbles,
                        this.cancelable]);
                };
                TimerEvent.prototype.toString = function () {
                    return this.formatToString('TimerEvent', 'type', 'bubbles', 'cancelable', 'eventPhase');
                };
                TimerEvent.prototype.updateAfterEvent = function () {
                    this._sec.player.requestRendering();
                };
                // JS -> AS Bindings
                TimerEvent.TIMER = "timer";
                TimerEvent.TIMER_COMPLETE = "timerComplete";
                return TimerEvent;
            }(flash.events.Event));
            events.TimerEvent = TimerEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TouchEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var TouchEvent = /** @class */ (function (_super) {
                __extends(TouchEvent, _super);
                function TouchEvent(type, bubbles, cancelable, touchPointID, isPrimaryTouchPoint, localX, localY, sizeX, sizeY, pressure, relatedObject, ctrlKey, altKey, shiftKey) {
                    if (bubbles === void 0) { bubbles = true; }
                    if (cancelable === void 0) { cancelable = false; }
                    if (touchPointID === void 0) { touchPointID = 0; }
                    if (isPrimaryTouchPoint === void 0) { isPrimaryTouchPoint = false; }
                    if (localX === void 0) { localX = NaN; }
                    if (localY === void 0) { localY = NaN; }
                    if (sizeX === void 0) { sizeX = NaN; }
                    if (sizeY === void 0) { sizeY = NaN; }
                    if (pressure === void 0) { pressure = NaN; }
                    if (relatedObject === void 0) { relatedObject = null; }
                    if (ctrlKey === void 0) { ctrlKey = false; }
                    if (altKey === void 0) { altKey = false; }
                    if (shiftKey === void 0) { shiftKey = false; }
                    return _super.call(this, type, bubbles, cancelable) || this;
                }
                Object.defineProperty(TouchEvent.prototype, "touchPointID", {
                    get: function () {
                        return this._touchPointID;
                    },
                    set: function (value) {
                        this._touchPointID = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "isPrimaryTouchPoint", {
                    get: function () {
                        return this._isPrimaryTouchPoint;
                    },
                    set: function (value) {
                        this._isPrimaryTouchPoint = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "localX", {
                    get: function () {
                        return this._localX;
                    },
                    set: function (value) {
                        this._localX = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "localY", {
                    get: function () {
                        return this._localY;
                    },
                    set: function (value) {
                        this._localY = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "sizeX", {
                    get: function () {
                        return this._sizeX;
                    },
                    set: function (value) {
                        this._sizeX = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "sizeY", {
                    get: function () {
                        return this._sizeY;
                    },
                    set: function (value) {
                        this._sizeY = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "pressure", {
                    get: function () {
                        return this._pressure;
                    },
                    set: function (value) {
                        this._pressure = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "relatedObject", {
                    get: function () {
                        return this._relatedObject;
                    },
                    set: function (value) {
                        this._relatedObject = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "ctrlKey", {
                    get: function () {
                        return this._ctrlKey;
                    },
                    set: function (value) {
                        this._ctrlKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "altKey", {
                    get: function () {
                        return this._altKey;
                    },
                    set: function (value) {
                        this._altKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "shiftKey", {
                    get: function () {
                        return this._shiftKey;
                    },
                    set: function (value) {
                        this._shiftKey = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "stageX", {
                    get: function () {
                        somewhatImplemented('TouchEvent::get stageX');
                        return this._localX;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "stageY", {
                    get: function () {
                        somewhatImplemented('TouchEvent::get stageY');
                        return this._localY;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TouchEvent.prototype, "isRelatedObjectInaccessible", {
                    get: function () {
                        return this._isRelatedObjectInaccessible;
                    },
                    set: function (value) {
                        this._isRelatedObjectInaccessible = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                TouchEvent.prototype.clone = function () {
                    return this._sec.events.TouchEvent.create([this.type, this.bubbles,
                        this.cancelable, this.touchPointID,
                        this.isPrimaryTouchPoint, this.localX,
                        this.localY, this.sizeX, this.sizeY,
                        this.pressure, this.relatedObject,
                        this.ctrlKey, this.altKey,
                        this.shiftKey]);
                };
                TouchEvent.prototype.toString = function () {
                    return this.formatToString('TouchEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'touchPointID', 'isPrimaryTouchPoint', 'localX', 'localY', 'sizeX', 'sizeY', 'pressure', 'relatedObject', 'ctrlKey', 'altKey', 'shiftKey');
                };
                TouchEvent.prototype.updateAfterEvent = function () {
                    this._sec.player.requestRendering();
                };
                // JS -> AS Bindings
                TouchEvent.TOUCH_BEGIN = "touchBegin";
                TouchEvent.TOUCH_END = "touchEnd";
                TouchEvent.TOUCH_MOVE = "touchMove";
                TouchEvent.TOUCH_OVER = "touchOver";
                TouchEvent.TOUCH_OUT = "touchOut";
                TouchEvent.TOUCH_ROLL_OVER = "touchRollOver";
                TouchEvent.TOUCH_ROLL_OUT = "touchRollOut";
                TouchEvent.TOUCH_TAP = "touchTap";
                TouchEvent.PROXIMITY_BEGIN = "proximityBegin";
                TouchEvent.PROXIMITY_END = "proximityEnd";
                TouchEvent.PROXIMITY_MOVE = "proximityMove";
                TouchEvent.PROXIMITY_OUT = "proximityOut";
                TouchEvent.PROXIMITY_OVER = "proximityOver";
                TouchEvent.PROXIMITY_ROLL_OUT = "proximityRollOut";
                TouchEvent.PROXIMITY_ROLL_OVER = "proximityRollOver";
                return TouchEvent;
            }(flash.events.Event));
            events.TouchEvent = TouchEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: UncaughtErrorEvent
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var UncaughtErrorEvent = /** @class */ (function (_super) {
                __extends(UncaughtErrorEvent, _super);
                function UncaughtErrorEvent(type, bubbles, cancelable, error_in) {
                    if (type === void 0) { type = "uncaughtError"; }
                    if (bubbles === void 0) { bubbles = true; }
                    if (cancelable === void 0) { cancelable = true; }
                    if (error_in === void 0) { error_in = null; }
                    return _super.call(this, type, bubbles, cancelable, error_in) || this;
                }
                UncaughtErrorEvent.classInitializer = null;
                UncaughtErrorEvent.classSymbols = null;
                UncaughtErrorEvent.instanceSymbols = null;
                // JS -> AS Bindings
                UncaughtErrorEvent.UNCAUGHT_ERROR = "uncaughtError";
                return UncaughtErrorEvent;
            }(flash.events.ErrorEvent));
            events.UncaughtErrorEvent = UncaughtErrorEvent;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: UncaughtErrorEvents
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var events;
        (function (events) {
            var UncaughtErrorEvents = /** @class */ (function (_super) {
                __extends(UncaughtErrorEvents, _super);
                function UncaughtErrorEvents() {
                    return _super.call(this) || this;
                }
                return UncaughtErrorEvents;
            }(flash.events.EventDispatcher));
            events.UncaughtErrorEvents = UncaughtErrorEvents;
        })(events = flash.events || (flash.events = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Flash bugs to keep in mind:
 *
 * http://aaronhardy.com/flex/displayobject-quirks-and-tips/
 * http://blog.anselmbradford.com/2009/02/12/flash-movie-clip-transformational-properties-explorer-x-y-width-height-more/
 * http://gskinner.com/blog/archives/2007/08/annoying_as3_bu.html
 * http://blog.dennisrobinson.name/getbounds-getrect-unexpected-results/
 *
 */
// Class: DisplayObject
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var isNullOrUndefined = Shumway.isNullOrUndefined;
            var assert = Shumway.Debug.assert;
            var Bounds = Shumway.Bounds;
            var events = flash.events;
            /*
             * Invalid Bits:
             *
             * Invalid bits are used to mark path dependent properties of display objects as stale. To compute these properties we either have to
             * walk the tree all the way the root, or visit all children.
             *
             *       +---+
             *       | A |
             *       +---+
             *       /   \
             *   +---+   +---+
             *   | B |   | C |
             *   +---+   +---+
             *           /   \
             *       +---+   +---+
             *       | D |   | E |
             *       +---+   +---+
             *
             * We use a combination of eager invalid bit propagation and lazy property evaluation. If a node becomes invalid because one of its
             * local properties has changed, we mark all of its valid descendents as invalid. When computing dependent properties, we walk up
             * the tree until we find a valid node and propagate the computation lazily downwards, marking all the nodes along the path as
             * valid.
             *
             * Suppose we mark A as invalid, this causes nodes B, C, D, and E to become invalid. We then compute a path dependent property
             * on E, causing A, and C to become valid. If we mark A as invalid again, A and C become invalid again. We don't need to mark
             * parts of the tree that are already invalid.
             *
             *
             * Dirty Bits:
             *
             * These are used to mark properties as having been changed.
             */
            var DisplayObjectFlags;
            (function (DisplayObjectFlags) {
                DisplayObjectFlags[DisplayObjectFlags["None"] = 0] = "None";
                /**
                 * Display object is visible.
                 */
                DisplayObjectFlags[DisplayObjectFlags["Visible"] = 1] = "Visible";
                /**
                 * Display object has invalid line bounds.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidLineBounds"] = 2] = "InvalidLineBounds";
                /**
                 * Display object has invalid fill bounds.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidFillBounds"] = 4] = "InvalidFillBounds";
                /**
                 * Display object has an invalid matrix because one of its local properties: x, y, scaleX, ...
                 * has been mutated.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidMatrix"] = 8] = "InvalidMatrix";
                /**
                 * Display object has an invalid inverted matrix because its matrix has been mutated.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidInvertedMatrix"] = 16] = "InvalidInvertedMatrix";
                /**
                 * Display object has an invalid concatenated matrix because its matrix or one of its
                 * ancestor's matrices has been mutated.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidConcatenatedMatrix"] = 32] = "InvalidConcatenatedMatrix";
                /**
                 * Display object has an invalid inverted concatenated matrix because its matrix or one of its
                 * ancestor's matrices has been mutated. We don't always need to compute the inverted matrix.
                 * This is why we use a sepearete invalid flag for it and don't roll it under the
                 * |InvalidConcatenatedMatrix| flag.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidInvertedConcatenatedMatrix"] = 64] = "InvalidInvertedConcatenatedMatrix";
                /**
                 * Display object has an invalid concatenated color transform because its color transform or
                 * one of its ancestor's color transforms has been mutated.
                 */
                DisplayObjectFlags[DisplayObjectFlags["InvalidConcatenatedColorTransform"] = 128] = "InvalidConcatenatedColorTransform";
                /**
                 * The display object's constructor has been executed or any of the derived class constructors
                 * have executed. It may be that the derived class doesn't call super, in such cases this flag
                 * must be set manually elsewhere.
                 */
                DisplayObjectFlags[DisplayObjectFlags["Constructed"] = 256] = "Constructed";
                /**
                 * Display object has been removed by the timeline but it no longer recieves any event.
                 */
                DisplayObjectFlags[DisplayObjectFlags["Destroyed"] = 512] = "Destroyed";
                /**
                 * Indicates wether an AVM1 load event needs to be dispatched on this display object.
                 */
                DisplayObjectFlags[DisplayObjectFlags["NeedsLoadEvent"] = 1024] = "NeedsLoadEvent";
                /**
                 * Display object is owned by the timeline, meaning that it is under the control of the
                 * timeline and that a reference to this object has not leaked into AS3 code via the
                 * DisplayObjectContainer methods |getChildAt|,  |getChildByName| or through the execution of
                 * the symbol class constructor.
                 */
                DisplayObjectFlags[DisplayObjectFlags["OwnedByTimeline"] = 2048] = "OwnedByTimeline";
                /**
                 * Display object is animated by the timeline. It may no longer be owned by the timeline
                 * (|OwnedByTimeline|) but it is still animated by it. If AS3 code mutates any property on the
                 * display object, this flag is cleared and further timeline mutations are ignored.
                 */
                DisplayObjectFlags[DisplayObjectFlags["AnimatedByTimeline"] = 4096] = "AnimatedByTimeline";
                /**
                 * MovieClip object has reached a frame with a frame script or ran a frame script that attached
                 * a new one to the current frame. To run the script, it has to be appended to the queue of
                 * scripts.
                 */
                DisplayObjectFlags[DisplayObjectFlags["HasFrameScriptPending"] = 8192] = "HasFrameScriptPending";
                /**
                 * DisplayObjectContainer contains at least one descendant with the HasFrameScriptPending flag
                 * set.
                 */
                DisplayObjectFlags[DisplayObjectFlags["ContainsFrameScriptPendingChildren"] = 16384] = "ContainsFrameScriptPendingChildren";
                /**
                 * Indicates whether this display object is a MorphShape or contains at least one descendant
                 * that is.
                 */
                DisplayObjectFlags[DisplayObjectFlags["ContainsMorph"] = 32768] = "ContainsMorph";
                /**
                 * Indicates whether this display object should be cached as a bitmap. The display object may
                 * be cached as bitmap even if this flag is not set, depending on whether any filters are
                 * applied or if the bitmap is too large or we've run out of memory.
                 */
                DisplayObjectFlags[DisplayObjectFlags["CacheAsBitmap"] = 65536] = "CacheAsBitmap";
                /**
                 * Indicates whether an AVM1 timeline needs to initialize an object after place object
                 * occurred.
                 */
                DisplayObjectFlags[DisplayObjectFlags["HasPlaceObjectInitPending"] = 131072] = "HasPlaceObjectInitPending";
                /**
                 * Indicates whether a transform.perspectiveProjection was set.
                 */
                DisplayObjectFlags[DisplayObjectFlags["HasPerspectiveProjection"] = 262144] = "HasPerspectiveProjection";
                /**
                 * Indicates whether this display object has dirty descendents. If this flag is set then the
                 * subtree need to be synchronized.
                 */
                DisplayObjectFlags[DisplayObjectFlags["DirtyDescendents"] = 536870912] = "DirtyDescendents";
                /**
                 * Masks flags that need to be propagated up when this display object gets added to a parent.
                 */
                DisplayObjectFlags[DisplayObjectFlags["Bubbling"] = 536920064] = "Bubbling";
            })(DisplayObjectFlags = display.DisplayObjectFlags || (display.DisplayObjectFlags = {}));
            var DisplayObjectDirtyFlags;
            (function (DisplayObjectDirtyFlags) {
                /**
                 * Indicates whether this display object's matrix has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyMatrix"] = 1] = "DirtyMatrix";
                /**
                 * Indicates whether this display object's children list is dirty.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyChildren"] = 2] = "DirtyChildren";
                /**
                 * Indicates whether this display object's graphics has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyGraphics"] = 4] = "DirtyGraphics";
                /**
                 * Indicates whether this display object's text content has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyTextContent"] = 8] = "DirtyTextContent";
                /**
                 * Indicates whether this display object's bitmap data has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyBitmapData"] = 16] = "DirtyBitmapData";
                /**
                 * Indicates whether this display object's bitmap data has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyNetStream"] = 32] = "DirtyNetStream";
                /**
                 * Indicates whether this display object's color transform has changed since the last time it
                 * was synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyColorTransform"] = 64] = "DirtyColorTransform";
                /**
                 * Indicates whether this display object's mask has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyMask"] = 128] = "DirtyMask";
                /**
                 * Indicates whether this display object's clip depth has changed since the last time it was
                 * synchronized.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyClipDepth"] = 256] = "DirtyClipDepth";
                /**
                 * Indicates whether this display object's other properties have changed. We need to split this
                 * up in multiple bits so we don't serialize as much:
                 *
                 * So far we only mark these properties here:
                 *
                 * blendMode,
                 * scale9Grid,
                 * cacheAsBitmap,
                 * filters,
                 * visible,
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["DirtyMiscellaneousProperties"] = 512] = "DirtyMiscellaneousProperties";
                /**
                 * All synchronizable properties are dirty.
                 */
                DisplayObjectDirtyFlags[DisplayObjectDirtyFlags["Dirty"] = 1023] = "Dirty";
            })(DisplayObjectDirtyFlags = display.DisplayObjectDirtyFlags || (display.DisplayObjectDirtyFlags = {}));
            /**
             * Controls how the visitor walks the display tree.
             */
            var VisitorFlags;
            (function (VisitorFlags) {
                /**
                 * None
                 */
                VisitorFlags[VisitorFlags["None"] = 0] = "None";
                /**
                 * Continue with normal traversal.
                 */
                VisitorFlags[VisitorFlags["Continue"] = 0] = "Continue";
                /**
                 * Not used yet, should probably just stop the visitor.
                 */
                VisitorFlags[VisitorFlags["Stop"] = 1] = "Stop";
                /**
                 * Skip processing current node.
                 */
                VisitorFlags[VisitorFlags["Skip"] = 2] = "Skip";
                /**
                 * Visit front to back.
                 */
                VisitorFlags[VisitorFlags["FrontToBack"] = 8] = "FrontToBack";
                /**
                 * Only visit the nodes matching a certain flag set.
                 */
                VisitorFlags[VisitorFlags["Filter"] = 16] = "Filter";
            })(VisitorFlags = display.VisitorFlags || (display.VisitorFlags = {}));
            var HitTestingType;
            (function (HitTestingType) {
                HitTestingType[HitTestingType["HitTestBounds"] = 0] = "HitTestBounds";
                HitTestingType[HitTestingType["HitTestBoundsAndMask"] = 1] = "HitTestBoundsAndMask";
                HitTestingType[HitTestingType["HitTestShape"] = 2] = "HitTestShape";
                HitTestingType[HitTestingType["Mouse"] = 3] = "Mouse";
                HitTestingType[HitTestingType["ObjectsUnderPoint"] = 4] = "ObjectsUnderPoint";
                HitTestingType[HitTestingType["Drop"] = 5] = "Drop";
            })(HitTestingType = display.HitTestingType || (display.HitTestingType = {}));
            var HitTestingResult;
            (function (HitTestingResult) {
                HitTestingResult[HitTestingResult["None"] = 0] = "None";
                HitTestingResult[HitTestingResult["Bounds"] = 1] = "Bounds";
                HitTestingResult[HitTestingResult["Shape"] = 2] = "Shape";
            })(HitTestingResult = display.HitTestingResult || (display.HitTestingResult = {}));
            var displayObjectSyncID = 0;
            var DisplayObject = /** @class */ (function (_super) {
                __extends(DisplayObject, _super);
                function DisplayObject() {
                    var _this = _super.call(this) || this;
                    _this._cacheStage = null;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    _this._addReference();
                    _this._setFlags(256 /* Constructed */);
                    return _this;
                }
                /**
                 * Every displayObject is assigned an unique integer ID.
                 */
                DisplayObject.getNextSyncID = function () {
                    return displayObjectSyncID++;
                };
                /**
                 * Creates a new display object from a symbol and initializes its animated display properties.
                 * Calling its constructor is optional at this point, since that can happen in a later frame
                 * phase.
                 */
                DisplayObject.prototype.createAnimatedDisplayObject = function (symbol, placeObjectTag, callConstructor) {
                    var symbolClass = symbol.symbolClass;
                    var bitmapDataClass = this._sec.display.BitmapData;
                    if (bitmapDataClass.isSymbol(symbolClass) ||
                        bitmapDataClass.isSymbolPrototype(symbolClass)) {
                        symbolClass = this._sec.display.Bitmap;
                    }
                    var instance = flash.system.constructClassFromSymbol(symbol, symbolClass);
                    if (placeObjectTag.flags & 32 /* HasName */) {
                        instance._name = placeObjectTag.name;
                    }
                    instance._setFlags(4096 /* AnimatedByTimeline */);
                    instance._animate(placeObjectTag);
                    if (callConstructor) {
                        instance.constructor();
                    }
                    return instance;
                };
                DisplayObject.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this, this);
                    this._id = DisplayObject.getNextSyncID();
                    this._flags = 1 /* Visible */ |
                        2 /* InvalidLineBounds */ |
                        4 /* InvalidFillBounds */ |
                        32 /* InvalidConcatenatedMatrix */ |
                        64 /* InvalidInvertedConcatenatedMatrix */ |
                        536870912 /* DirtyDescendents */;
                    this._dirtyFlags = 4 /* DirtyGraphics */ |
                        1 /* DirtyMatrix */ |
                        64 /* DirtyColorTransform */ |
                        128 /* DirtyMask */ |
                        256 /* DirtyClipDepth */ |
                        512 /* DirtyMiscellaneousProperties */;
                    this._root = null;
                    this._stage = null;
                    this._setInitialName();
                    this._parent = null;
                    this._mask = null;
                    this._z = 0;
                    this._scaleX = 1;
                    this._scaleY = 1;
                    this._skewX = 0;
                    this._skewY = 0;
                    this._scaleZ = 1;
                    this._rotation = 0;
                    this._rotationX = 0;
                    this._rotationY = 0;
                    this._rotationZ = 0;
                    this._width = 0;
                    this._height = 0;
                    this._opaqueBackground = null;
                    this._scrollRect = null;
                    this._filters = null;
                    this._blendMode = display.BlendMode.NORMAL;
                    // No need to take ownership: scale9Grid is never changed.
                    this._scale9Grid = this._symbol ? this._symbol.scale9Grid : null;
                    this._loaderInfo = null;
                    this._accessibilityProperties = null;
                    this._fillBounds = new Bounds(0, 0, 0, 0);
                    this._lineBounds = new Bounds(0, 0, 0, 0);
                    this._clipDepth = -1;
                    var matrixClass = this._sec.geom.Matrix;
                    this._concatenatedMatrix = matrixClass.create();
                    this._invertedConcatenatedMatrix = matrixClass.create();
                    this._matrix = matrixClass.create();
                    this._invertedMatrix = matrixClass.create();
                    this._matrix3D = null;
                    this._perspectiveProjectionFOV = 55 /* FOV */;
                    this._perspectiveProjectionCenterX = 250 /* CenterX */;
                    this._perspectiveProjectionCenterY = 250 /* CenterY */;
                    var colorTransformClass = this._sec.geom.ColorTransform;
                    this._colorTransform = colorTransformClass.create();
                    this._concatenatedColorTransform = colorTransformClass.create();
                    this._depth = -1;
                    this._ratio = 0;
                    this._index = -1;
                    this._maskedObject = null;
                    this._mouseOver = false;
                    this._mouseDown = false;
                    this._graphics = null;
                    this._children = null;
                    this._referenceCount = 0;
                };
                /**
                 * Sets the object's initial name to adhere to the 'instanceN' naming scheme.
                 */
                DisplayObject.prototype._setInitialName = function () {
                    this._name = 'instance' +
                        (this._sec.display._instanceID++);
                };
                DisplayObject.prototype._setParent = function (parent, depth) {
                    var oldParent = this._parent;
                    release || assert(parent !== this);
                    this._parent = parent;
                    this._setDepth(depth);
                    if (parent) {
                        this._addReference();
                        var bubblingFlags = 0 /* None */;
                        if (this._hasFlags(8192 /* HasFrameScriptPending */)) {
                            bubblingFlags |= 16384 /* ContainsFrameScriptPendingChildren */;
                        }
                        if (this._hasAnyDirtyFlags(1023 /* Dirty */)) {
                            bubblingFlags |= 536870912 /* DirtyDescendents */;
                        }
                        if (this._hasAnyFlags(536920064 /* Bubbling */)) {
                            bubblingFlags |= this._flags & 536920064 /* Bubbling */;
                        }
                        if (bubblingFlags) {
                            parent._propagateFlagsUp(bubblingFlags);
                        }
                    }
                    if (oldParent) {
                        this._removeReference();
                    }
                };
                DisplayObject.prototype._setDepth = function (value) {
                    if (value > -1) {
                        this._setFlags(2048 /* OwnedByTimeline */);
                    }
                    else {
                        this._removeFlags(2048 /* OwnedByTimeline */);
                    }
                    this._depth = value;
                };
                DisplayObject.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                    this._fillBounds.width = width;
                    this._fillBounds.height = height;
                    this._lineBounds.width = width;
                    this._lineBounds.height = height;
                    this._removeFlags(2 /* InvalidLineBounds */ | 4 /* InvalidFillBounds */);
                    this._invalidateParentFillAndLineBounds(true, true);
                };
                DisplayObject.prototype._setFillAndLineBoundsFromSymbol = function (symbol) {
                    release || assert(symbol.fillBounds || symbol.lineBounds, "Fill or Line bounds are not defined in the symbol.");
                    if (symbol.fillBounds) {
                        this._fillBounds.copyFrom(symbol.fillBounds);
                        this._removeFlags(4 /* InvalidFillBounds */);
                    }
                    if (symbol.lineBounds) {
                        this._lineBounds.copyFrom(symbol.lineBounds);
                        this._removeFlags(2 /* InvalidLineBounds */);
                    }
                    this._invalidateParentFillAndLineBounds(!!symbol.fillBounds, !!symbol.lineBounds);
                };
                DisplayObject.prototype._setFlags = function (flags) {
                    this._flags |= flags;
                };
                /**
                 * Use this to set dirty flags so that we can also propagate the dirty child bit.
                 */
                DisplayObject.prototype._setDirtyFlags = function (flags) {
                    this._dirtyFlags |= flags;
                    if (this._parent) {
                        // Notify parent that it has a dirty descendent.
                        this._parent._propagateFlagsUp(536870912 /* DirtyDescendents */);
                    }
                };
                DisplayObject.prototype._removeDirtyFlags = function (flags) {
                    this._dirtyFlags &= ~flags;
                };
                DisplayObject.prototype._hasDirtyFlags = function (flags) {
                    return (this._dirtyFlags & flags) === flags;
                };
                DisplayObject.prototype._hasAnyDirtyFlags = function (flags) {
                    return !!(this._dirtyFlags & flags);
                };
                DisplayObject.prototype._toggleFlags = function (flags, on) {
                    if (on) {
                        this._flags |= flags;
                    }
                    else {
                        this._flags &= ~flags;
                    }
                };
                DisplayObject.prototype._removeFlags = function (flags) {
                    this._flags &= ~flags;
                };
                DisplayObject.prototype._hasFlags = function (flags) {
                    return (this._flags & flags) === flags;
                };
                DisplayObject.prototype._hasAnyFlags = function (flags) {
                    return !!(this._flags & flags);
                };
                /**
                 * Propagates flags up the display list. Propagation stops if all flags are already set.
                 */
                DisplayObject.prototype._propagateFlagsUp = function (flags) {
                    if (this._hasFlags(flags)) {
                        return;
                    }
                    this._setFlags(flags);
                    var parent = this._parent;
                    if (parent) {
                        parent._propagateFlagsUp(flags);
                    }
                };
                /**
                 * Propagates flags down the display list. Non-containers just set the flags on themselves.
                 *
                 * Overridden in DisplayObjectContainer.
                 */
                DisplayObject.prototype._propagateFlagsDown = function (flags) {
                    this._setFlags(flags);
                };
                /**
                 * Finds the nearest ancestor with a given set of flags that are either turned on or off.
                 */
                DisplayObject.prototype._findNearestAncestor = function (flags, on) {
                    var node = this;
                    while (node) {
                        if (node._hasFlags(flags) === on) {
                            return node;
                        }
                        node = node._parent;
                    }
                    return null;
                };
                DisplayObject.prototype._findFurthestAncestorOrSelf = function () {
                    var node = this;
                    while (node) {
                        if (!node._parent) {
                            return node;
                        }
                        node = node._parent;
                    }
                    return null;
                };
                /**
                 * Tests if this display object is an ancestor of the specified display object.
                 */
                DisplayObject.prototype._isAncestor = function (child) {
                    var node = child;
                    while (node) {
                        if (node === this) {
                            return true;
                        }
                        node = node._parent;
                    }
                    return false;
                };
                /**
                 * Clamps the rotation value to the range (-180, 180).
                 */
                DisplayObject._clampRotation = function (value) {
                    value %= 360;
                    if (value > 180) {
                        value -= 360;
                    }
                    else if (value < -180) {
                        value += 360;
                    }
                    return value;
                };
                /**
                 * Return's a list of ancestors excluding the |last|, the return list is reused.
                 */
                DisplayObject._getAncestors = function (node, last) {
                    var path = DisplayObject._path;
                    path.length = 0;
                    while (node && node !== last) {
                        path.push(node);
                        node = node._parent;
                    }
                    release || assert(node === last, "Last ancestor is not an ancestor.");
                    return path;
                };
                /**
                 * Computes the combined transformation matrixes of this display object and all of its parents.
                 * It is not the same as |transform.concatenatedMatrix|, the latter also includes the screen
                 * space matrix.
                 */
                DisplayObject.prototype._getConcatenatedMatrix = function () {
                    if (this._hasFlags(32 /* InvalidConcatenatedMatrix */)) {
                        if (this._parent) {
                            this._parent._getConcatenatedMatrix().preMultiplyInto(this._getMatrix(), this._concatenatedMatrix);
                        }
                        else {
                            this._concatenatedMatrix.copyFrom(this._getMatrix());
                        }
                        this._removeFlags(32 /* InvalidConcatenatedMatrix */);
                    }
                    return this._concatenatedMatrix;
                };
                DisplayObject.prototype._getInvertedConcatenatedMatrix = function () {
                    if (this._hasFlags(64 /* InvalidInvertedConcatenatedMatrix */)) {
                        this._getConcatenatedMatrix().invertInto(this._invertedConcatenatedMatrix);
                        this._removeFlags(64 /* InvalidInvertedConcatenatedMatrix */);
                    }
                    return this._invertedConcatenatedMatrix;
                };
                DisplayObject.prototype._setMatrix = function (matrix, toTwips) {
                    if (!toTwips && this._matrix.equals(matrix)) {
                        // No need to dirty the matrix if it's equal to the current matrix.
                        return;
                    }
                    var m = this._matrix;
                    m.copyFrom(matrix);
                    if (toTwips) {
                        m.toTwipsInPlace();
                    }
                    this._scaleX = m.getScaleX();
                    this._scaleY = m.getScaleY();
                    this._skewX = matrix.getSkewX();
                    this._skewY = matrix.getSkewY();
                    this._rotation = DisplayObject._clampRotation(this._skewY * 180 / Math.PI);
                    this._removeFlags(8 /* InvalidMatrix */);
                    this._setFlags(16 /* InvalidInvertedMatrix */);
                    this._setDirtyFlags(1 /* DirtyMatrix */);
                    this._invalidatePosition();
                };
                /**
                 * Returns an updated matrix if the current one is invalid.
                 */
                DisplayObject.prototype._getMatrix = function () {
                    if (this._hasFlags(8 /* InvalidMatrix */)) {
                        this._matrix.updateScaleAndRotation(this._scaleX, this._scaleY, this._skewX, this._skewY);
                        this._removeFlags(8 /* InvalidMatrix */);
                    }
                    return this._matrix;
                };
                DisplayObject.prototype._getInvertedMatrix = function () {
                    if (this._hasFlags(16 /* InvalidInvertedMatrix */)) {
                        this._getMatrix().invertInto(this._invertedMatrix);
                        this._removeFlags(16 /* InvalidInvertedMatrix */);
                    }
                    return this._invertedMatrix;
                };
                /**
                 * Computes the combined transformation color matrixes of this display object and all of its
                 * ancestors.
                 */
                DisplayObject.prototype._getConcatenatedColorTransform = function () {
                    if (!this.stage) {
                        return this._colorTransform.clone();
                    }
                    // Compute the concatenated color transforms for this node and all of its ancestors.
                    if (this._hasFlags(128 /* InvalidConcatenatedColorTransform */)) {
                        var ancestor = this._findNearestAncestor(128 /* InvalidConcatenatedColorTransform */, false);
                        var path = DisplayObject._getAncestors(this, ancestor);
                        var i = path.length - 1;
                        var stageClass = this._sec.display.Stage;
                        if (stageClass.axIsType(path[i])) {
                            i--;
                        }
                        var m = ancestor && !stageClass.axIsType(ancestor) ?
                            ancestor._concatenatedColorTransform.clone() :
                            this._sec.geom.ColorTransform.create();
                        while (i >= 0) {
                            ancestor = path[i--];
                            release || assert(ancestor._hasFlags(128 /* InvalidConcatenatedColorTransform */));
                            m.preMultiply(ancestor._colorTransform);
                            m.convertToFixedPoint();
                            ancestor._concatenatedColorTransform.copyFrom(m);
                            ancestor._removeFlags(128 /* InvalidConcatenatedColorTransform */);
                        }
                    }
                    return this._concatenatedColorTransform;
                };
                DisplayObject.prototype._setColorTransform = function (colorTransform) {
                    if (this._colorTransform.equals(colorTransform)) {
                        return;
                    }
                    this._colorTransform.copyFrom(colorTransform);
                    this._colorTransform.convertToFixedPoint();
                    this._propagateFlagsDown(128 /* InvalidConcatenatedColorTransform */);
                    this._setDirtyFlags(64 /* DirtyColorTransform */);
                };
                /**
                 * Invalidates the fill- and lineBounds of this display object along with all of its ancestors.
                 */
                DisplayObject.prototype._invalidateFillAndLineBounds = function (fill, line) {
                    /* TODO: We should only propagate this bit if the bounds are actually changed. We can do the
                     * bounds computation eagerly if the number of children is low. If there are no changes in the
                     * bounds we don't need to propagate the bit. */
                    this._propagateFlagsUp((line ? 2 /* InvalidLineBounds */ : 0) |
                        (fill ? 4 /* InvalidFillBounds */ : 0));
                };
                DisplayObject.prototype._invalidateParentFillAndLineBounds = function (fill, line) {
                    if (this._parent) {
                        this._parent._invalidateFillAndLineBounds(fill, line);
                    }
                };
                /**
                 * Computes the bounding box for all of this display object's content, its graphics and all of
                 * its children.
                 */
                DisplayObject.prototype._getContentBounds = function (includeStrokes) {
                    if (includeStrokes === void 0) { includeStrokes = true; }
                    // Tobias: What about filters?
                    var invalidFlag;
                    var bounds;
                    if (includeStrokes) {
                        invalidFlag = 2 /* InvalidLineBounds */;
                        bounds = this._lineBounds;
                    }
                    else {
                        invalidFlag = 4 /* InvalidFillBounds */;
                        bounds = this._fillBounds;
                    }
                    if (this._hasFlags(invalidFlag)) {
                        var graphics = this._getGraphics();
                        if (graphics) {
                            bounds.copyFrom(graphics._getContentBounds(includeStrokes));
                        }
                        else {
                            bounds.setToSentinels();
                        }
                        this._getChildBounds(bounds, includeStrokes);
                        this._removeFlags(invalidFlag);
                    }
                    return bounds;
                };
                /**
                 * Empty base case: DisplayObject cannot have children, but several distinct subclasses can.
                 * Overridden in DisplayObjectContainer, SimpleButton, and AVM1Movie.
                 */
                DisplayObject.prototype._getChildBounds = function (bounds, includeStrokes) {
                    // TSLint thinks empty methods are uncool. I think TSLint is uncool.
                };
                /**
                 * Gets the bounds of this display object relative to another coordinate space. The
                 * transformation matrix from the local coordinate space to the target coordinate space is
                 * computed using:
                 *
                 *   this.concatenatedMatrix * inverse(target.concatenatedMatrix)
                 *
                 * If the |targetCoordinateSpace| is |null| then assume the identity coordinate space.
                 */
                DisplayObject.prototype._getTransformedBounds = function (targetCoordinateSpace, includeStroke) {
                    var bounds = this._getContentBounds(includeStroke).clone();
                    if (targetCoordinateSpace === this || bounds.isEmpty()) {
                        return bounds;
                    }
                    var m;
                    if (targetCoordinateSpace) {
                        m = this._sec.geom.TEMP_MATRIX;
                        var invertedTargetMatrix = targetCoordinateSpace._getInvertedConcatenatedMatrix();
                        invertedTargetMatrix.preMultiplyInto(this._getConcatenatedMatrix(), m);
                    }
                    else {
                        m = this._getConcatenatedMatrix();
                    }
                    m.transformBounds(bounds);
                    return bounds;
                };
                /**
                 * Detaches this object from being animated by the timeline. This happens whenever a display
                 * property of this object is changed by user code.
                 */
                DisplayObject.prototype._stopTimelineAnimation = function () {
                    this._removeFlags(4096 /* AnimatedByTimeline */);
                };
                /**
                 * Marks this object as having its matrix changed.
                 *
                 * Propagates flags both up- and (via invalidatePosition) downwards, so is quite costly.
                 * TODO: check if we can usefully combine all upwards-propagated flags here.
                 */
                DisplayObject.prototype._invalidateMatrix = function () {
                    this._setDirtyFlags(1 /* DirtyMatrix */);
                    this._setFlags(8 /* InvalidMatrix */ | 16 /* InvalidInvertedMatrix */);
                    this._invalidatePosition();
                };
                /**
                 * Marks this object as having been moved in its parent display object.
                 */
                DisplayObject.prototype._invalidatePosition = function () {
                    this._propagateFlagsDown(32 /* InvalidConcatenatedMatrix */ |
                        64 /* InvalidInvertedConcatenatedMatrix */);
                    this._invalidateParentFillAndLineBounds(true, true);
                };
                /**
                 * Animates this object's display properties.
                 */
                DisplayObject.prototype._animate = function (placeObjectTag) {
                    release || assert(this._hasFlags(4096 /* AnimatedByTimeline */));
                    var reset = !(placeObjectTag.flags & 1 /* Move */) &&
                        placeObjectTag.flags & 2 /* HasCharacter */;
                    var matrixClass = this._sec.geom;
                    if (placeObjectTag.flags & 4 /* HasMatrix */) {
                        matrixClass.TEMP_MATRIX.copyFromUntyped(placeObjectTag.matrix);
                        this._setMatrix(matrixClass.TEMP_MATRIX, false);
                    }
                    else if (reset) {
                        this._setMatrix(matrixClass.FROZEN_IDENTITY_MATRIX, false);
                    }
                    var colorTransformClass = matrixClass;
                    if (placeObjectTag.flags & 8 /* HasColorTransform */) {
                        colorTransformClass.TEMP_COLOR_TRANSFORM.copyFromUntyped(placeObjectTag.cxform);
                        this._setColorTransform(colorTransformClass.TEMP_COLOR_TRANSFORM);
                    }
                    else if (reset) {
                        this._setColorTransform(colorTransformClass.FROZEN_IDENTITY_COLOR_TRANSFORM);
                    }
                    if (placeObjectTag.flags & 16 /* HasRatio */ || reset) {
                        var ratio = placeObjectTag.ratio | 0;
                        if (ratio !== this._ratio) {
                            release || assert(ratio >= 0 && ratio <= 0xffff);
                            this._ratio = ratio;
                            this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                        }
                    }
                    if (placeObjectTag.flags & 64 /* HasClipDepth */ || reset) {
                        var clipDepth = placeObjectTag.clipDepth === undefined ? -1 : placeObjectTag.clipDepth;
                        if (clipDepth !== this._clipDepth) {
                            this._clipDepth = clipDepth;
                            this._setDirtyFlags(256 /* DirtyClipDepth */);
                        }
                    }
                    if (placeObjectTag.flags & 256 /* HasFilterList */) {
                        var filtersPackage = this._sec.filters;
                        var filters_1 = [];
                        var swfFilters = placeObjectTag.filters;
                        for (var i = 0; i < swfFilters.length; i++) {
                            var obj = swfFilters[i];
                            var filterClass = filtersPackage.swfFilterTypes[obj.type];
                            var filter = void 0;
                            if (!filterClass) {
                                release || assert(filterClass, "Unknown filter type.");
                            }
                            else {
                                filter = filterClass.FromUntyped(obj);
                            }
                            filters_1.push(filter);
                        }
                        this._filters = filters_1;
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    }
                    else if (reset && this._filters) {
                        this._filters = null;
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    }
                    if (placeObjectTag.flags & 512 /* HasBlendMode */ || reset) {
                        var blendMode = flash.display.BlendMode.fromNumber(placeObjectTag.blendMode === undefined ?
                            1 : placeObjectTag.blendMode);
                        if (blendMode !== this._blendMode) {
                            this._blendMode = blendMode;
                            this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                        }
                    }
                    if (placeObjectTag.flags & 1024 /* HasCacheAsBitmap */ || reset) {
                        var cacheAsBitmap = placeObjectTag.bmpCache > 0;
                        if (cacheAsBitmap !== this._hasFlags(65536 /* CacheAsBitmap */)) {
                            this._toggleFlags(65536 /* CacheAsBitmap */, cacheAsBitmap);
                            this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                        }
                    }
                    if (placeObjectTag.flags & 8192 /* HasVisible */ || reset) {
                        var visible = placeObjectTag.visibility === undefined || placeObjectTag.visibility;
                        if (visible !== this._hasFlags(1 /* Visible */)) {
                            this._toggleFlags(1 /* Visible */, visible);
                            this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                        }
                    }
                };
                /**
                 * Dispatches an event on this object and all its descendants.
                 */
                DisplayObject.prototype._propagateEvent = function (event) {
                    // @ivanpopelyshev: stop double events
                    // link is not responding, adobe jura doesnt have this issue
                    // http://bugs.adobe.com/jira/browse/FP-1569
                    this.visit(function (node) {
                        if (event.type === events.Event.ADDED_TO_STAGE) {
                            if (node._cacheStage !== null) {
                                return 0 /* None */;
                            }
                            node._cacheStage = node.stage;
                        }
                        if (event.type === events.Event.REMOVED_FROM_STAGE) {
                            if (node._cacheStage === null) {
                                return 0 /* None */;
                            }
                            node._cacheStage = null;
                        }
                        node.dispatchEvent(event);
                        return 0 /* Continue */;
                    }, 0 /* None */);
                };
                Object.defineProperty(DisplayObject.prototype, "x", {
                    get: function () {
                        return this._getX();
                    },
                    set: function (value) {
                        value = (value * 20) | 0;
                        this._stopTimelineAnimation();
                        if (this._canHaveTextContent()) {
                            var bounds = this._getContentBounds();
                            value -= bounds.xMin;
                        }
                        if (value === this._matrix.tx) {
                            return;
                        }
                        this._matrix.tx = value;
                        this._invertedMatrix.tx = -value;
                        this._invalidatePosition();
                        this._setDirtyFlags(1 /* DirtyMatrix */);
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getX = function () {
                    var value = this._matrix.tx;
                    if (this._canHaveTextContent()) {
                        var bounds = this._getContentBounds();
                        value += bounds.xMin;
                    }
                    return value / 20;
                };
                Object.defineProperty(DisplayObject.prototype, "y", {
                    get: function () {
                        return this._getY();
                    },
                    set: function (value) {
                        value = (value * 20) | 0;
                        this._stopTimelineAnimation();
                        if (this._canHaveTextContent()) {
                            var bounds = this._getContentBounds();
                            value -= bounds.yMin;
                        }
                        if (value === this._matrix.ty) {
                            return;
                        }
                        this._matrix.ty = value;
                        this._invertedMatrix.ty = -value;
                        this._invalidatePosition();
                        this._setDirtyFlags(1 /* DirtyMatrix */);
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getY = function () {
                    var value = this._matrix.ty;
                    if (this._canHaveTextContent()) {
                        var bounds = this._getContentBounds();
                        value += bounds.yMin;
                    }
                    return value / 20;
                };
                Object.defineProperty(DisplayObject.prototype, "scaleX", {
                    /**
                     * In Flash player, this always returns a positive number for some reason. This however, is not
                     * the case for scaleY.
                     */
                    get: function () {
                        return Math.abs(this._scaleX);
                    },
                    set: function (value) {
                        value = +value;
                        this._stopTimelineAnimation();
                        if (value === this._scaleX) {
                            return;
                        }
                        this._scaleX = value;
                        this._invalidateMatrix();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "scaleY", {
                    get: function () {
                        return this._scaleY;
                    },
                    set: function (value) {
                        value = +value;
                        this._stopTimelineAnimation();
                        if (value === this._scaleY) {
                            return;
                        }
                        this._scaleY = value;
                        this._invalidateMatrix();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "scaleZ", {
                    get: function () {
                        return this._scaleZ;
                    },
                    set: function (value) {
                        value = +value;
                        release || somewhatImplemented("public DisplayObject::set scaleZ");
                        this._scaleZ = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "rotation", {
                    get: function () {
                        return this._rotation;
                    },
                    set: function (value) {
                        value = +value;
                        this._stopTimelineAnimation();
                        value = DisplayObject._clampRotation(value);
                        if (value === this._rotation) {
                            return;
                        }
                        var delta = value - this._rotation;
                        var angle = delta / 180 * Math.PI;
                        this._skewX += angle;
                        this._skewY += angle;
                        this._rotation = value;
                        this._invalidateMatrix();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "rotationX", {
                    get: function () {
                        return this._rotationX;
                    },
                    set: function (value) {
                        value = +value;
                        release || somewhatImplemented("public DisplayObject::set rotationX");
                        this._rotationZ = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "rotationY", {
                    get: function () {
                        return this._rotationY;
                    },
                    set: function (value) {
                        value = +value;
                        release || somewhatImplemented("public DisplayObject::set rotationY");
                        this._rotationY = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "rotationZ", {
                    get: function () {
                        return this._rotationZ;
                    },
                    set: function (value) {
                        value = +value;
                        release || somewhatImplemented("public DisplayObject::set rotationZ");
                        this._rotationZ = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "width", {
                    /**
                     * The width of this display object in its parent coordinate space.
                     */
                    get: function () {
                        return this._getWidth();
                    },
                    /**
                     * Attempts to change the width of this display object by changing its scaleX / scaleY
                     * properties. The scaleX property is set to the specified |width| value / baseWidth
                     * of the object in its parent cooridnate space with rotation applied.
                     */
                    set: function (value) {
                        this._setWidth(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                // `get width` is overriden in `Stage` and has to be able to call this.
                DisplayObject.prototype._getWidth = function () {
                    return this._getTransformedBounds(this._parent, true).width / 20;
                };
                // `set width` is overriden in `Stage` and has to be able to call this.
                DisplayObject.prototype._setWidth = function (value) {
                    value = (value * 20) | 0;
                    this._stopTimelineAnimation();
                    if (value < 0) {
                        return;
                    }
                    var contentBounds = this._getContentBounds(true);
                    if (this._canHaveTextContent()) {
                        var bounds_1 = this._getContentBounds();
                        this._setFillAndLineBoundsFromWidthAndHeight(value, contentBounds.height);
                        return;
                    }
                    var bounds = this._getTransformedBounds(this._parent, true);
                    var angle = this._rotation / 180 * Math.PI;
                    var baseWidth = contentBounds.getBaseWidth(angle);
                    if (!baseWidth) {
                        return;
                    }
                    var baseHeight = contentBounds.getBaseHeight(angle);
                    this._scaleY = bounds.height / baseHeight;
                    this._scaleX = value / baseWidth;
                    this._invalidateMatrix();
                };
                Object.defineProperty(DisplayObject.prototype, "height", {
                    /**
                     * The height of this display object in its parent coordinate space.
                     */
                    get: function () {
                        return this._getHeight();
                    },
                    /**
                     * Attempts to change the height of this display object by changing its scaleY / scaleX
                     * properties. The scaleY property is set to the specified |height| value / baseHeight
                     * of the object in its parent cooridnate space with rotation applied.
                     */
                    set: function (value) {
                        this._setHeight(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                // `get height` is overriden in `Stage` and has to be able to call this.
                DisplayObject.prototype._getHeight = function () {
                    var bounds = this._getTransformedBounds(this._parent, true);
                    return bounds.height / 20;
                };
                // `set height` is overriden in `Stage` and has to be able to call this.
                DisplayObject.prototype._setHeight = function (value) {
                    value = (value * 20) | 0;
                    this._stopTimelineAnimation();
                    if (value < 0) {
                        return;
                    }
                    var contentBounds = this._getContentBounds(true);
                    if (this._canHaveTextContent()) {
                        var bounds_2 = this._getContentBounds();
                        this._setFillAndLineBoundsFromWidthAndHeight(contentBounds.width, value);
                        return;
                    }
                    var bounds = this._getTransformedBounds(this._parent, true);
                    var angle = this._rotation / 180 * Math.PI;
                    var baseHeight = contentBounds.getBaseHeight(angle);
                    if (!baseHeight) {
                        return;
                    }
                    var baseWidth = contentBounds.getBaseWidth(angle);
                    this._scaleY = value / baseHeight;
                    this._scaleX = bounds.width / baseWidth;
                    this._invalidateMatrix();
                };
                Object.defineProperty(DisplayObject.prototype, "mask", {
                    get: function () {
                        return this._mask;
                    },
                    /**
                     * Sets the mask for this display object. This does not affect the bounds.
                     */
                    set: function (value) {
                        if (this._mask === value || value === this) {
                            return;
                        }
                        if (value && value._maskedObject) {
                            value._maskedObject.mask = null;
                        }
                        if (this._mask) {
                            this._mask._maskedObject = null;
                        }
                        this._mask = value;
                        if (value) {
                            value._maskedObject = this;
                        }
                        this._setDirtyFlags(128 /* DirtyMask */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "transform", {
                    get: function () {
                        return this._getTransform();
                    },
                    set: function (value) {
                        this._stopTimelineAnimation();
                        if (value.matrix3D) {
                            this._matrix3D = value.matrix3D;
                        }
                        else {
                            this._setMatrix(value.matrix, true);
                        }
                        this._setColorTransform(value.colorTransform);
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getTransform = function () {
                    return this._sec.geom.Transform.create([this]);
                };
                DisplayObject.prototype.destroy = function () {
                    this._setFlags(512 /* Destroyed */);
                };
                Object.defineProperty(DisplayObject.prototype, "root", {
                    /**
                     * Walks up the tree to find this display object's root. An object is classified
                     * as a root if its _root property points to itself. Root objects are the Stage,
                     * the main timeline object and a Loader's content.
                     */
                    get: function () {
                        var node = this;
                        do {
                            if (node._root === node) {
                                return node;
                            }
                            node = node._parent;
                        } while (node);
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "stage", {
                    /**
                     * Walks up the tree to find this display object's stage, the first object whose
                     * |_stage| property points to itself.
                     */
                    get: function () {
                        var node = this;
                        do {
                            if (node._stage === node) {
                                release || assert(this._sec.display.Stage.axIsType(node));
                                return node;
                            }
                            node = node._parent;
                        } while (node);
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "name", {
                    get: function () {
                        return this._name;
                    },
                    set: function (value) {
                        Shumway.checkNullParameter(value, "name", this._sec);
                        if (this._hasFlags(2048 /* OwnedByTimeline */)) {
                            // In AVM2, setting the name of a timline-placed DisplayObject throws.
                            if (this._symbol && !this._symbol.isAVM1Object) {
                                this._sec.throwError('IllegalOperationError', Shumway.Errors.TimelineObjectNameSealedError);
                            }
                            return;
                        }
                        this._name = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "parent", {
                    get: function () {
                        return this._parent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "alpha", {
                    get: function () {
                        return this._colorTransform.alphaMultiplier;
                    },
                    set: function (value) {
                        this._stopTimelineAnimation();
                        value = +value;
                        if (value === this._colorTransform.alphaMultiplier) {
                            return;
                        }
                        this._colorTransform.alphaMultiplier = value;
                        this._colorTransform.convertToFixedPoint();
                        this._propagateFlagsDown(128 /* InvalidConcatenatedColorTransform */);
                        this._setDirtyFlags(64 /* DirtyColorTransform */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "blendMode", {
                    get: function () {
                        return this._blendMode;
                    },
                    set: function (value) {
                        this._stopTimelineAnimation();
                        if (value === this._blendMode) {
                            return;
                        }
                        if (display.BlendMode.toNumber(value) < 0) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.InvalidEnumError, "blendMode");
                        }
                        this._blendMode = value;
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "scale9Grid", {
                    get: function () {
                        return this._getScale9Grid();
                    },
                    set: function (innerRectangle) {
                        this._stopTimelineAnimation();
                        this._scale9Grid = Bounds.FromRectangle(innerRectangle);
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getScale9Grid = function () {
                    var rectangleClass = this._sec.geom.Rectangle;
                    return this._scale9Grid ? rectangleClass.FromBounds(this._scale9Grid) : null;
                };
                Object.defineProperty(DisplayObject.prototype, "cacheAsBitmap", {
                    /**
                     * This is always true if a filter is applied.
                     */
                    get: function () {
                        return this._getCacheAsBitmap();
                    },
                    set: function (value) {
                        if (this._hasFlags(65536 /* CacheAsBitmap */)) {
                            return;
                        }
                        this._toggleFlags(65536 /* CacheAsBitmap */, !!value);
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getCacheAsBitmap = function () {
                    return (this._filters && this._filters.length > 0) || this._hasFlags(65536 /* CacheAsBitmap */);
                };
                Object.defineProperty(DisplayObject.prototype, "filters", {
                    /**
                     * References to the internal |_filters| array and its BitmapFilter objects are never leaked
                     * outside of this class. The get/set filters accessors always return deep clones of this
                     * array.
                     */
                    get: function () {
                        return this._getFilters();
                    },
                    set: function (value_) {
                        var value = value_ ? value_ : null;
                        if (!this._filters) {
                            this._filters = [];
                        }
                        var changed = false;
                        if (isNullOrUndefined(value)) {
                            changed = this._filters.length > 0;
                            this._filters.length = 0;
                        }
                        else {
                            var bitmapFilterClass_1 = this._sec.filters.BitmapFilter;
                            this._filters = value.map(function (x) {
                                if (!bitmapFilterClass_1.axIsType(x)) {
                                    this._sec.throwError('TypeError', Shumway.Errors.ParamTypeError, '0', 'Filter');
                                }
                                return x.clone();
                            });
                            changed = true;
                        }
                        if (changed) {
                            this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getFilters = function () {
                    var filters = this._filters ? this._filters.map(function (x) {
                        return x.clone();
                    }) : [];
                    return filters;
                };
                Object.defineProperty(DisplayObject.prototype, "visible", {
                    get: function () {
                        return this._hasFlags(1 /* Visible */);
                    },
                    /**
                     * Marks this display object as visible / invisible. This does not affect the bounds.
                     */
                    set: function (value) {
                        value = !!value;
                        if (value === this._hasFlags(1 /* Visible */)) {
                            return;
                        }
                        this._toggleFlags(1 /* Visible */, value);
                        this._setDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "z", {
                    get: function () {
                        return this._z;
                    },
                    set: function (value) {
                        value = +value;
                        this._z = value;
                        release || somewhatImplemented("public DisplayObject::set z");
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
                    targetCoordinateSpace = targetCoordinateSpace || this;
                    var rectangleClass = this._sec.geom.Rectangle;
                    return rectangleClass.FromBounds(this._getTransformedBounds(targetCoordinateSpace, true));
                };
                DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
                    targetCoordinateSpace = targetCoordinateSpace || this;
                    var rectangleClass = this._sec.geom.Rectangle;
                    return rectangleClass.FromBounds(this._getTransformedBounds(targetCoordinateSpace, false));
                };
                /**
                 * Converts a point from the global coordinate space into the local coordinate space.
                 */
                DisplayObject.prototype.globalToLocal = function (point) {
                    var m = this._getInvertedConcatenatedMatrix();
                    var p = m.transformPointInPlace(point.clone().toTwips()).round();
                    return p.toPixels();
                };
                /**
                 * Converts a point form the local coordinate sapce into the global coordinate space.
                 */
                DisplayObject.prototype.localToGlobal = function (point) {
                    var m = this._getConcatenatedMatrix();
                    var p = m.transformPointInPlace(point.clone().toTwips()).round();
                    return p.toPixels();
                };
                DisplayObject.prototype.globalToLocal3D = function (point) {
                    release || notImplemented("public DisplayObject::globalToLocal3D");
                    return null;
                };
                DisplayObject.prototype.localToGlobal3D = function (point) {
                    release || notImplemented("public DisplayObject::localToGlobal3D");
                    return null;
                };
                DisplayObject.prototype.local3DToGlobal = function (point3d) {
                    release || notImplemented("public DisplayObject::local3DToGlobal");
                    return null;
                };
                /**
                 * Tree visitor that lets you skip nodes or return early.
                 */
                DisplayObject.prototype.visit = function (visitor, visitorFlags, displayObjectFlags) {
                    if (displayObjectFlags === void 0) { displayObjectFlags = 0 /* None */; }
                    var stack;
                    var displayObject;
                    var displayObjectContainer;
                    var frontToBack = visitorFlags & 8 /* FrontToBack */;
                    stack = [this];
                    while (stack.length > 0) {
                        displayObject = stack.pop();
                        var flags = 0 /* None */;
                        if (visitorFlags & 16 /* Filter */ && !displayObject._hasAnyFlags(displayObjectFlags)) {
                            flags = 2 /* Skip */;
                        }
                        else {
                            flags = visitor(displayObject);
                        }
                        if (flags === 0 /* Continue */) {
                            var children = displayObject._children;
                            if (children) {
                                var length_6 = children.length;
                                for (var i = 0; i < length_6; i++) {
                                    var child = children[frontToBack ? i : length_6 - 1 - i];
                                    stack.push(child);
                                }
                            }
                        }
                        else if (flags === 1 /* Stop */) {
                            return;
                        }
                    }
                };
                Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
                    /**
                     * Returns the loader info for this display object's root.
                     */
                    get: function () {
                        var root = this.root;
                        if (root) {
                            release || assert(root._loaderInfo, "No LoaderInfo object found on root.");
                            return root._loaderInfo;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Only these objects can have graphics.
                 */
                DisplayObject.prototype._canHaveGraphics = function () {
                    return false;
                };
                /**
                 * Gets the graphics object of this object. Shapes, MorphShapes, and Sprites override this.
                 */
                DisplayObject.prototype._getGraphics = function () {
                    return null;
                };
                /**
                 * Only these objects can have text content.
                 */
                DisplayObject.prototype._canHaveTextContent = function () {
                    return false;
                };
                /**
                 * Gets the text content of this object. StaticTexts and TextFields override this.
                 */
                DisplayObject.prototype._getTextContent = function () {
                    return null;
                };
                /**
                 * Lazily construct a graphics object.
                 */
                DisplayObject.prototype._ensureGraphics = function () {
                    release || assert(this._canHaveGraphics());
                    if (this._graphics) {
                        return this._graphics;
                    }
                    this._graphics = this._sec.display.Graphics.create();
                    this._graphics._setParent(this);
                    this._invalidateFillAndLineBounds(true, true);
                    this._setDirtyFlags(4 /* DirtyGraphics */);
                    return this._graphics;
                };
                /**
                 * Sets this object's graphics or text content. Happens when an animated Shape or StaticText
                 * object is initialized from a symbol or replaced by a timeline command using the same symbol
                 * as this object was initialized from.
                 */
                DisplayObject.prototype._setStaticContentFromSymbol = function (symbol) {
                    release || assert(!symbol.dynamic);
                    if (symbol instanceof flash.display.ShapeSymbol) {
                        release || assert(this._canHaveGraphics());
                        var newGraphics = symbol.graphics;
                        if (this._graphics === newGraphics) {
                            return;
                        }
                        this._graphics = newGraphics;
                        this._setDirtyFlags(4 /* DirtyGraphics */);
                    }
                    else if (symbol instanceof flash.text.TextSymbol) {
                        release || assert(this._sec.text.StaticText.axIsType(this));
                        var newTextContent = symbol.textContent;
                        if (this._textContent === newTextContent) {
                            return;
                        }
                        this._textContent = newTextContent;
                        this._setDirtyFlags(8 /* DirtyTextContent */);
                    }
                    this._symbol = symbol;
                    this._setFillAndLineBoundsFromSymbol(symbol);
                };
                /**
                 * Checks if the bounding boxes of two display objects overlap, this happens in the global
                 * coordinate coordinate space.
                 *
                 * Two objects overlap even if one or both are not on the stage, as long as their bounds
                 * in the global coordinate space overlap.
                 */
                DisplayObject.prototype.hitTestObject = function (other) {
                    release || assert(other && this._sec.display.DisplayObject.axIsType(other));
                    var a = this, b = other;
                    var aBounds = a._getContentBounds(false).clone();
                    var bBounds = b._getContentBounds(false).clone();
                    a._getConcatenatedMatrix().transformBounds(aBounds);
                    b._getConcatenatedMatrix().transformBounds(bBounds);
                    return aBounds.intersects(bBounds);
                };
                /**
                 * The |globalX| and |globalY| arguments are in global coordinates. The |shapeFlag| indicates
                 * whether the hit test should be on the actual shape of the object or just its bounding box.
                 *
                 * Note: shapeFlag is optional, but the type coercion will do the right thing for it, so we
                 * don't need to take the overhead from being explicit about that.
                 */
                DisplayObject.prototype.hitTestPoint = function (globalX, globalY, shapeFlag) {
                    globalX = +globalX * 20 | 0;
                    globalY = +globalY * 20 | 0;
                    shapeFlag = !!shapeFlag;
                    var testingType = shapeFlag ?
                        2 /* HitTestShape */ :
                        0 /* HitTestBounds */;
                    return !!this._containsGlobalPoint(globalX, globalY, testingType, null);
                };
                /**
                 * Internal implementation of all point intersection checks.
                 *
                 * _containsPoint is used for
                 *  - mouse/drop target finding
                 *  - getObjectsUnderPoint
                 *  - hitTestPoint
                 *
                 * Mouse/Drop target finding and getObjectsUnderPoint require checking against the exact shape,
                 * and making sure that the checked coordinates aren't hidden through masking or clipping.
                 *
                 * hitTestPoint never checks for clipping, and masking only for testingType HitTestShape.
                 *
                 * The `objects` object is used for collecting objects for `getObjectsUnderPoint` or looking
                 * for a drop target. If it is supplied, objects for which `_containsPointDirectly` is true are
                 * added to it.
                 *
                 * Overridden in DisplayObjectContainer, Sprite and SimpleButton.
                 */
                DisplayObject.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                    var result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                    // We're done if either we don't have a hit, or if we're only interested in matching bounds
                    // or bounds + mask. That is true for HitTestPoint without shapeFlag set.
                    if (result === 0 /* None */ || testingType < 2 /* HitTestShape */) {
                        return result;
                    }
                    var containsPoint = this._containsPointDirectly(localX, localY, globalX, globalY);
                    if (containsPoint && objects) {
                        if (testingType === 5 /* Drop */) {
                            // For Drop, replace previous hit with current one.
                            objects[0] = this;
                        }
                        else if (testingType === 4 /* ObjectsUnderPoint */ ||
                            this._sec.display.InteractiveObject.axIsType(this) &&
                                this._mouseEnabled) {
                            // For getObjectsUnderPoint, push all direct hits, for mouse target finding
                            // InteractiveObjects only.
                            objects.push(this);
                        }
                    }
                    return containsPoint ? 2 /* Shape */ : result;
                };
                DisplayObject.prototype._containsGlobalPoint = function (globalX, globalY, testingType, objects) {
                    var matrix = this._getInvertedConcatenatedMatrix();
                    var localX = matrix.transformX(globalX, globalY);
                    var localY = matrix.transformY(globalX, globalY);
                    return this._containsPoint(globalX, globalY, localX, localY, testingType, objects);
                };
                /**
                 * Fast check if a point can intersect the receiver object. Returns true if
                 * - the object is visible OR hit testing is performed for one of the `hitTest{Point,Object}`
                 *   methods.
                 * - the point is within the receiver's bounds
                 * - for testingType values other than HitTestBounds, the point intersects with the a mask,
                 *   if the object has one.
                 *
                 * Note that the callers are expected to have both local and global coordinates available
                 * anyway, so _boundsAndMaskContainPoint takes both to avoid recalculating them.
                 */
                DisplayObject.prototype._boundsAndMaskContainPoint = function (globalX, globalY, localX, localY, testingType) {
                    if (testingType >= 1 /* HitTestBoundsAndMask */ &&
                        this._hasFlags(32768 /* ContainsMorph */)) {
                        // If this display object is a MorphShape or contains at least one descendant that is, then
                        // bailing out too early might lead to a wrong hit test result, since the reported bounds
                        // of MorphShapes are always the one of their start shapes and don't take the current morph
                        // ratio into account. We have to make sure we always hit test MorphShape instances on
                        // graphics level.
                        return 1 /* Bounds */;
                    }
                    if (testingType >= 3 /* Mouse */ && !this._hasFlags(1 /* Visible */) ||
                        !this._getContentBounds().contains(localX, localY)) {
                        return 0 /* None */;
                    }
                    if (testingType === 0 /* HitTestBounds */ || !this._mask) {
                        return 1 /* Bounds */;
                    }
                    return this._mask._containsGlobalPoint(globalX, globalY, 1 /* HitTestBoundsAndMask */, null);
                };
                /**
                 * Tests if the receiver's own visual content intersects with the given point.
                 * In the base implementation, this just returns false, because not all DisplayObjects can
                 * ever match.
                 * Overridden in Shape, MorphShape, Sprite, Bitmap, Video, and TextField.
                 */
                DisplayObject.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    return false;
                };
                Object.defineProperty(DisplayObject.prototype, "scrollRect", {
                    get: function () {
                        return this._getScrollRect();
                    },
                    set: function (value) {
                        value = value;
                        this._scrollRect = value ? value.clone() : null;
                        /* TODO: Figure out how to deal with the bounds and hit testing when scroll rects are applied.
                         * The Flash implementation appears to be broken. */
                        release || somewhatImplemented("public DisplayObject::set scrollRect");
                        return;
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype._getScrollRect = function () {
                    return this._scrollRect ? this._scrollRect.clone() : null;
                };
                Object.defineProperty(DisplayObject.prototype, "opaqueBackground", {
                    get: function () {
                        return this._opaqueBackground;
                    },
                    /**
                     * Sets the opaque background color. By default this is |null|, which indicates that no opaque
                     * color is set. Otherwise this is an unsinged number.
                     */
                    set: function (value) {
                        release || assert(value === null || Shumway.isInteger(value));
                        this._opaqueBackground = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Returns the distance between this object and a given ancestor.
                 */
                DisplayObject.prototype._getDistance = function (ancestor) {
                    var d = 0;
                    var node = this;
                    while (node && node !== ancestor) {
                        d++;
                        node = node._parent;
                    }
                    return d;
                };
                /**
                 * Finds the nearest common ancestor with a given node.
                 */
                DisplayObject.prototype.findNearestCommonAncestor = function (node) {
                    if (!node) {
                        return null;
                    }
                    var ancestor = this;
                    var d1 = ancestor._getDistance(null);
                    var d2 = node._getDistance(null);
                    while (d1 > d2) {
                        ancestor = ancestor._parent;
                        d1--;
                    }
                    while (d2 > d1) {
                        node = node._parent;
                        d2--;
                    }
                    while (ancestor !== node) {
                        ancestor = ancestor._parent;
                        node = node._parent;
                    }
                    return ancestor;
                };
                /**
                 * Returns the current mouse position relative to this object.
                 */
                DisplayObject.prototype._getLocalMousePosition = function () {
                    var position = this._sec.ui.Mouse._currentPosition;
                    return this.globalToLocal(position);
                };
                Object.defineProperty(DisplayObject.prototype, "mouseX", {
                    get: function () {
                        return this._getLocalMousePosition().x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "mouseY", {
                    get: function () {
                        return this._getLocalMousePosition().y;
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype.debugName = function (withFlags) {
                    if (withFlags === void 0) { withFlags = false; }
                    var name = this._id + " [" + this._depth + "]: (" + this._referenceCount + ") " + this;
                    if (withFlags) {
                        var flagNames = [];
                        for (var i = 0; i < 32; i++) {
                            if (this._hasFlags(1 << i)) {
                                flagNames.push(String([1 << i]));
                            }
                        }
                        name += " " + flagNames.join("|");
                    }
                    return name;
                };
                DisplayObject.prototype.debugNameShort = function () {
                    return "[" + this._depth + ":" + this._id + "]: (" + this._referenceCount + ") {" + this._flags + "} " + this;
                };
                DisplayObject.prototype.hashCode = function () {
                    return this.getBounds(null).hashCode();
                };
                DisplayObject.prototype.getAncestorCount = function () {
                    return 0;
                };
                DisplayObject.prototype.debugTrace = function (writer, maxDistance, name) {
                    if (writer === void 0) { writer = new Shumway.IndentingWriter(); }
                    if (maxDistance === void 0) { maxDistance = 1024; }
                    if (name === void 0) { name = ""; }
                    var self = this;
                    this.visit(function (node) {
                        var distance = node._getDistance(self);
                        if (distance > maxDistance) {
                            return 2 /* Skip */;
                        }
                        var prefix = name + Shumway.StringUtilities.multiple(" ", distance);
                        writer.writeLn(prefix + node.debugNameShort() + ", bounds: " + node.getBounds(null).toString());
                        return 0 /* Continue */;
                    }, 0 /* None */);
                };
                DisplayObject.prototype._addReference = function () {
                    this._referenceCount++;
                };
                DisplayObject.prototype._removeReference = function () {
                    // TODO: Uncomment this assertion once we're sure reference counting works correctly.
                    // assert (this._referenceCount > 0);
                    this._referenceCount--;
                    if (this._referenceCount !== 0 || !this._children) {
                        return;
                    }
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        children[i]._removeReference();
                    }
                };
                /**
                 * Returns script precedence sequence based on placeObjectTag. Creates every
                 * time a new array, so it's safe to modify it.
                 * @private
                 */
                DisplayObject.prototype._getScriptPrecedence = function () {
                    if (!this._parent) {
                        return [];
                    }
                    var result = this._parent._getScriptPrecedence();
                    if (this._placeObjectTag) {
                        result.push(this._placeObjectTag.actionBlocksPrecedence);
                    }
                    return result;
                };
                Object.defineProperty(DisplayObject.prototype, "accessibilityProperties", {
                    get: function () {
                        return this._accessibilityProperties;
                    },
                    set: function (value) {
                        // In Flash this does not do copying.
                        // TODO: coerce to the correct type.
                        this._accessibilityProperties = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObject.prototype, "blendShader", {
                    set: function (value /* flash.display.Shader */) {
                        release || somewhatImplemented("public DisplayObject::set blendShader");
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayObject.prototype.axSetPublicProperty = function (name, value) {
                };
                DisplayObject.prototype.axGetPublicProperty = function (name) {
                };
                // Called whenever the class is initialized.
                DisplayObject.classInitializer = null;
                // List of static symbols to link.
                DisplayObject.classSymbols = null; // [];
                // List of instance symbols to link.
                DisplayObject.instanceSymbols = null; // ["hitTestObject", "hitTestPoint"];
                /**
                 * Used as a temporary array to avoid allocations.
                 */
                DisplayObject._path = [];
                return DisplayObject;
            }(flash.events.EventDispatcher));
            display.DisplayObject = DisplayObject;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Bitmap
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var Bitmap = /** @class */ (function (_super) {
                __extends(Bitmap, _super);
                function Bitmap(bitmapData, pixelSnapping, smoothing) {
                    if (bitmapData === void 0) { bitmapData = null; }
                    if (pixelSnapping === void 0) { pixelSnapping = "auto"; }
                    if (smoothing === void 0) { smoothing = false; }
                    var _this = _super.call(this) || this;
                    if (!_this._symbol) {
                        _this.bitmapData = bitmapData;
                        _this._pixelSnapping = pixelSnapping;
                        _this._smoothing = !!smoothing;
                    }
                    return _this;
                }
                Bitmap.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    this._initializeFields();
                    var symbol = this._symbol;
                    var symbolClass = symbol.symbolClass;
                    // If the symbol class inherits from Bitmap, we are already within its initializer.
                    // Make sure to create a BitmapData instance here to avoid recursively calling the
                    // initializer again.
                    var bitmapClass = this._sec.display.Bitmap;
                    if (bitmapClass.isSymbolPrototype(symbolClass)) {
                        symbolClass = this._sec.display.BitmapData;
                    }
                    // TODO: I don't think BitmapData symbol objects can change, so they don't need back
                    // references to this Bitmap.
                    this._bitmapData = flash.system.constructClassFromSymbol(symbol, symbolClass);
                    this._pixelSnapping = null;
                    this._smoothing = null;
                    this._setFillAndLineBoundsFromWidthAndHeight(symbol.width * 20 | 0, symbol.height * 20 | 0);
                };
                Bitmap.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                Object.defineProperty(Bitmap.prototype, "pixelSnapping", {
                    get: function () {
                        return this._pixelSnapping;
                    },
                    set: function (value) {
                        if (display.PixelSnapping.toNumber(value) < 0) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.InvalidEnumError, "pixelSnapping");
                        }
                        this._pixelSnapping = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bitmap.prototype, "smoothing", {
                    get: function () {
                        return this._smoothing;
                    },
                    set: function (value) {
                        this._smoothing = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bitmap.prototype, "bitmapData", {
                    get: function () {
                        return this._bitmapData;
                    },
                    set: function (value) {
                        if (this._bitmapData !== value) {
                            if (this._bitmapData) {
                                this._bitmapData._removeBitmapReferrer(this);
                            }
                            if (value) {
                                value._addBitmapReferrer(this);
                            }
                        }
                        this._bitmapData = value;
                        if (value) {
                            this._setFillAndLineBoundsFromWidthAndHeight(value.width * 20 | 0, value.height * 20 | 0);
                        }
                        this._invalidateParentFillAndLineBounds(true, true);
                        this._setDirtyFlags(16 /* DirtyBitmapData */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Bitmap.prototype._getContentBounds = function (includeStrokes) {
                    if (includeStrokes === void 0) { includeStrokes = true; }
                    if (this._bitmapData) {
                        return this._bitmapData._getContentBounds();
                    }
                    return new Shumway.Bounds(0, 0, 0, 0);
                };
                Bitmap.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    // If this override is reached, the content bounds have already been checked, which is all
                    // we need to do.
                    release || assert(this._getContentBounds().contains(localX, localY));
                    return true;
                };
                // Called whenever the class is initialized.
                Bitmap.classInitializer = null;
                // List of static symbols to link.
                Bitmap.classSymbols = null; // [];
                // List of instance symbols to link.
                Bitmap.instanceSymbols = null; // [];
                return Bitmap;
            }(flash.display.DisplayObject));
            display.Bitmap = Bitmap;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Shape
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var warning = Shumway.Debug.warning;
            var Shape = /** @class */ (function (_super) {
                __extends(Shape, _super);
                function Shape() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    return _this;
                }
                Shape.prototype.applySymbol = function () {
                    this._initializeFields();
                    release || assert(this._symbol);
                    // TODO: Check what do do if the computed bounds of the graphics object don't
                    // match those given by the symbol.
                    this._setStaticContentFromSymbol(this._symbol);
                };
                Shape.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                Shape.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._graphics = null;
                };
                Shape.prototype._canHaveGraphics = function () {
                    return true;
                };
                Shape.prototype._getGraphics = function () {
                    return this._graphics;
                };
                Object.defineProperty(Shape.prototype, "graphics", {
                    get: function () {
                        return this._ensureGraphics();
                    },
                    enumerable: true,
                    configurable: true
                });
                Shape.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    var graphics = this._getGraphics();
                    return !!graphics && graphics._containsPoint(localX, localY, true, 0);
                };
                return Shape;
            }(flash.display.DisplayObject));
            display.Shape = Shape;
            var ShapeSymbol = /** @class */ (function (_super) {
                __extends(ShapeSymbol, _super);
                function ShapeSymbol(data, symbolClass) {
                    var _this = _super.call(this, data, symbolClass, false) || this;
                    _this.graphics = null;
                    return _this;
                }
                ShapeSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new ShapeSymbol(data, loaderInfo._sec.display.Shape);
                    symbol._setBoundsFromData(data);
                    symbol.graphics = flash.display.Graphics.FromData(data, loaderInfo);
                    symbol.processRequires(data.require, loaderInfo);
                    return symbol;
                };
                ShapeSymbol.prototype.processRequires = function (dependencies, loaderInfo) {
                    if (!dependencies) {
                        return;
                    }
                    var textures = this.graphics.getUsedTextures();
                    for (var i = 0; i < dependencies.length; i++) {
                        var symbol = loaderInfo.getSymbolById(dependencies[i]);
                        if (!symbol) {
                            if (dependencies[i] !== 65535) {
                                // Id 65535 is somehow used invalidly in lots of embedded shapes created by the
                                // authoring tool, so don't warn about that.
                                warning("Bitmap symbol " + dependencies[i] + " required by shape, but not defined.");
                            }
                            textures.push(null);
                            // TODO: handle null-textures from invalid SWFs correctly.
                            continue;
                        }
                        textures.push(symbol.getSharedInstance());
                    }
                };
                return ShapeSymbol;
            }(Shumway.Timeline.DisplaySymbol));
            display.ShapeSymbol = ShapeSymbol;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: InteractiveObject
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var events = flash.events;
            var InteractiveObject = /** @class */ (function (_super) {
                __extends(InteractiveObject, _super);
                function InteractiveObject() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    return _this;
                }
                InteractiveObject.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._tabEnabled = false;
                    this._tabIndex = -1;
                    this._focusRect = null;
                    this._mouseEnabled = true;
                    this._doubleClickEnabled = false;
                    this._accessibilityImplementation = null;
                    this._softKeyboardInputAreaOfInterest = null;
                    this._needsSoftKeyboard = false;
                    this._contextMenu = null;
                };
                Object.defineProperty(InteractiveObject.prototype, "tabEnabled", {
                    get: function () {
                        return this._tabEnabled;
                    },
                    set: function (enabled) {
                        enabled = !!enabled;
                        var old = this._tabEnabled;
                        this._tabEnabled = enabled;
                        if (old !== enabled) {
                            this.dispatchEvent(this._sec.events.getInstance(events.Event.TAB_ENABLED_CHANGE, true));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "tabIndex", {
                    get: function () {
                        return this._tabIndex;
                    },
                    set: function (index /*int*/) {
                        index = index | 0;
                        var old = this._tabIndex;
                        this._tabIndex = index;
                        if (old !== index) {
                            this.dispatchEvent(this._sec.events.getInstance(events.Event.TAB_INDEX_CHANGE, true));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "focusRect", {
                    get: function () {
                        return this._focusRect;
                    },
                    /**
                     * The given |focusRect| can be one of: |true|, |false| or |null|.
                     */
                    set: function (focusRect) {
                        release || somewhatImplemented("public flash.display.InteractiveObject::set focusRect");
                        this._focusRect = focusRect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "mouseEnabled", {
                    get: function () {
                        return this._mouseEnabled;
                    },
                    set: function (enabled) {
                        this._mouseEnabled = !!enabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "doubleClickEnabled", {
                    get: function () {
                        return this._doubleClickEnabled;
                    },
                    set: function (enabled) {
                        this._doubleClickEnabled = !!enabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "accessibilityImplementation", {
                    get: function () {
                        return this._accessibilityImplementation;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.display.InteractiveObject::set" +
                            " accessibilityImplementation");
                        this._accessibilityImplementation = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "softKeyboardInputAreaOfInterest", {
                    get: function () {
                        return this._softKeyboardInputAreaOfInterest;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.display.InteractiveObject::set" +
                            " softKeyboardInputAreaOfInterest");
                        this._softKeyboardInputAreaOfInterest = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "needsSoftKeyboard", {
                    get: function () {
                        return this._needsSoftKeyboard;
                    },
                    set: function (value) {
                        value = !!value;
                        release || somewhatImplemented("public flash.display.InteractiveObject::set needsSoftKeyboard");
                        this._needsSoftKeyboard = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InteractiveObject.prototype, "contextMenu", {
                    get: function () {
                        return this._contextMenu;
                    },
                    set: function (cm) {
                        cm = cm;
                        release || somewhatImplemented("public flash.display.InteractiveObject::set contextMenu");
                        this._contextMenu = cm;
                    },
                    enumerable: true,
                    configurable: true
                });
                InteractiveObject.prototype.requestSoftKeyboard = function () {
                    release || somewhatImplemented("public flash.display.InteractiveObject::requestSoftKeyboard");
                    return false;
                };
                return InteractiveObject;
            }(flash.display.DisplayObject));
            display.InteractiveObject = InteractiveObject;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SimpleButton
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;
            var SimpleButton = /** @class */ (function (_super) {
                __extends(SimpleButton, _super);
                function SimpleButton(upState, overState, downState, hitTestState) {
                    var _this = _super.call(this) || this;
                    _this._sec.display._advancableInstances.push(_this);
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    if (!_this._symbol) {
                        if (upState) {
                            _this.upState = upState;
                        }
                        if (overState) {
                            _this.overState = overState;
                        }
                        if (downState) {
                            _this.downState = downState;
                        }
                        if (hitTestState) {
                            _this.hitTestState = hitTestState;
                        }
                        _this._updateButton();
                    }
                    return _this;
                }
                SimpleButton.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    this._initializeFields();
                    var symbol = this._symbol;
                    if (symbol.upState) {
                        this._upState = this.createAnimatedDisplayObject(symbol.upState.symbol, symbol.upState.placeObjectTag, true);
                    }
                    if (symbol.overState) {
                        this._overState = this.createAnimatedDisplayObject(symbol.overState.symbol, symbol.overState.placeObjectTag, true);
                    }
                    if (symbol.downState) {
                        this._downState = this.createAnimatedDisplayObject(symbol.downState.symbol, symbol.downState.placeObjectTag, true);
                    }
                    if (symbol.hitTestState) {
                        this._hitTestState = this.createAnimatedDisplayObject(symbol.hitTestState.symbol, symbol.hitTestState.placeObjectTag, true);
                    }
                    this._updateButton();
                };
                SimpleButton.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._useHandCursor = true;
                    this._enabled = true;
                    this._trackAsMenu = false;
                    this._upState = null;
                    this._overState = null;
                    this._downState = null;
                    this._hitTestState = null;
                    this._currentState = null;
                    this._children = [];
                };
                SimpleButton.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                SimpleButton.prototype._initFrame = function (advance) {
                    if (advance) {
                        this._updateButton();
                    }
                };
                SimpleButton.prototype._constructFrame = function () {
                    // ...
                };
                Object.defineProperty(SimpleButton.prototype, "useHandCursor", {
                    get: function () {
                        return this._useHandCursor;
                    },
                    set: function (value) {
                        this._useHandCursor = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "enabled", {
                    get: function () {
                        return this._enabled;
                    },
                    set: function (value) {
                        this._enabled = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "trackAsMenu", {
                    get: function () {
                        return this._trackAsMenu;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.display.SimpleButton::set trackAsMenu");
                        return;
                        // this._trackAsMenu = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "upState", {
                    get: function () {
                        return this._upState;
                    },
                    set: function (value) {
                        var old = this._upState;
                        if (value._parent) {
                            value._parent.removeChild(value);
                        }
                        this._upState = value;
                        if (this._currentState === old) {
                            this._updateButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "overState", {
                    get: function () {
                        return this._overState;
                    },
                    set: function (value) {
                        var old = this._overState;
                        if (value._parent) {
                            value._parent.removeChild(value);
                        }
                        this._overState = value;
                        if (this._currentState === old) {
                            this._updateButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "downState", {
                    get: function () {
                        return this._downState;
                    },
                    set: function (value) {
                        var old = this._downState;
                        if (value._parent) {
                            value._parent.removeChild(value);
                        }
                        this._downState = value;
                        if (this._currentState === old) {
                            this._updateButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "hitTestState", {
                    get: function () {
                        return this._hitTestState;
                    },
                    set: function (value) {
                        this._hitTestState = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SimpleButton.prototype, "soundTransform", {
                    get: function () {
                        release || notImplemented("public flash.display.SimpleButton::get soundTransform");
                        return null;
                        // return this._soundTransform;
                    },
                    set: function (sndTransform) {
                        sndTransform = sndTransform;
                        release || notImplemented("public flash.display.SimpleButton::set soundTransform");
                        return;
                        // this._soundTransform = sndTransform;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Override of DisplayObject#_containsPoint that applies the test on hitTestState if
                 * that is defined.
                 */
                SimpleButton.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                    var target = testingType === 3 /* Mouse */ ? this._hitTestState : this._currentState;
                    if (!target) {
                        return 0 /* None */;
                    }
                    // Hit testing relies on being able to get combined transforms and all that, so, a parent.
                    target._parent = this;
                    var result = target._containsGlobalPoint(globalX, globalY, testingType, objects);
                    target._parent = null;
                    // For mouse target finding, SimpleButtons always return themselves as the hit.
                    if (result !== 0 /* None */ && testingType === 3 /* Mouse */ &&
                        objects && this._mouseEnabled) {
                        objects[0] = this;
                        release || assert(objects.length === 1);
                    }
                    return result;
                };
                /**
                 * Override of DisplayObject#_getChildBounds that retrieves the current hitTestState's bounds.
                 */
                SimpleButton.prototype._getChildBounds = function (bounds, includeStrokes) {
                    if (!this._currentState) {
                        return;
                    }
                    this._currentState._parent = this;
                    bounds.unionInPlace(this._currentState._getTransformedBounds(this, includeStrokes));
                    this._currentState._parent = null;
                };
                SimpleButton.prototype._propagateFlagsDown = function (flags) {
                    if (this._hasFlags(flags)) {
                        return;
                    }
                    this._setFlags(flags);
                    this._upState && this._upState._propagateFlagsDown(flags);
                    this._overState && this._overState._propagateFlagsDown(flags);
                    this._downState && this._downState._propagateFlagsDown(flags);
                    this._hitTestState && this._hitTestState._propagateFlagsDown(flags);
                };
                SimpleButton.prototype._updateButton = function () {
                    var state;
                    if (this._mouseOver) {
                        state = this._mouseDown ? this._downState : this._overState;
                    }
                    else {
                        state = this._upState;
                    }
                    if (state === this._currentState) {
                        return;
                    }
                    if (this._currentState) {
                        // TODO dispatch removedFromStage event
                    }
                    this._currentState = state;
                    if (this._stage) {
                        // TODO dispatch addedToStage event
                    }
                    if (state) {
                        this._children[0] = state;
                    }
                    else {
                        this._children.length = 0;
                    }
                    this._setDirtyFlags(2 /* DirtyChildren */);
                    this._invalidateFillAndLineBounds(true, true);
                };
                // Called whenever the class is initialized.
                SimpleButton.classInitializer = null;
                // List of static symbols to link.
                SimpleButton.classSymbols = null; // [];
                // List of instance symbols to link.
                SimpleButton.instanceSymbols = null; // [];
                return SimpleButton;
            }(flash.display.InteractiveObject));
            display.SimpleButton = SimpleButton;
            var ButtonState = /** @class */ (function () {
                function ButtonState(symbol, placeObjectTag) {
                    this.symbol = symbol;
                    this.placeObjectTag = placeObjectTag;
                }
                return ButtonState;
            }());
            display.ButtonState = ButtonState;
            var ButtonSymbol = /** @class */ (function (_super) {
                __extends(ButtonSymbol, _super);
                function ButtonSymbol(data, loaderInfo) {
                    var _this = _super.call(this, data, loaderInfo._sec.display.SimpleButton, true) || this;
                    _this.upState = null;
                    _this.overState = null;
                    _this.downState = null;
                    _this.hitTestState = null;
                    _this.loaderInfo = loaderInfo;
                    return _this;
                }
                ButtonSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new ButtonSymbol(data, loaderInfo);
                    if (loaderInfo.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                        symbol.isAVM1Object = true;
                    }
                    var states = data.states;
                    var character = null;
                    var placeObjectTag;
                    for (var stateName in states) {
                        var controlTags = states[stateName];
                        if (controlTags.length === 1) {
                            placeObjectTag = controlTags[0];
                            character = loaderInfo.getSymbolById(placeObjectTag.symbolId);
                            if (!character) {
                                continue;
                            }
                        }
                        else {
                            placeObjectTag = {
                                code: 4 /* CODE_PLACE_OBJECT */,
                                flags: 1 /* Move */,
                                depth: 1
                            };
                            character = new flash.display.SpriteSymbol({ id: -1, className: null, env: null }, loaderInfo);
                            character.frames.push(new Shumway.SWF.SWFFrame(controlTags));
                        }
                        symbol[stateName + 'State'] = new ButtonState(character, placeObjectTag);
                    }
                    return symbol;
                };
                return ButtonSymbol;
            }(Shumway.Timeline.DisplaySymbol));
            display.ButtonSymbol = ButtonSymbol;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='../references.ts' />
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var mixHash = Shumway.HashUtilities.mixHash;
            var clamp = Shumway.NumberUtilities.clamp;
            var events = flash.events;
            var LookupChildOptions;
            (function (LookupChildOptions) {
                LookupChildOptions[LookupChildOptions["DEFAULT"] = 0] = "DEFAULT";
                LookupChildOptions[LookupChildOptions["IGNORE_CASE"] = 1] = "IGNORE_CASE";
                LookupChildOptions[LookupChildOptions["INCLUDE_NON_INITIALIZED"] = 2] = "INCLUDE_NON_INITIALIZED";
            })(LookupChildOptions = display.LookupChildOptions || (display.LookupChildOptions = {}));
            var DisplayObjectContainer = /** @class */ (function (_super) {
                __extends(DisplayObjectContainer, _super);
                function DisplayObjectContainer() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    _this._setDirtyFlags(2 /* DirtyChildren */);
                    return _this;
                }
                DisplayObjectContainer.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._tabChildren = true;
                    this._mouseChildren = true;
                    // Might already have been initialized from a symbol.
                    this._children = this._children || [];
                };
                /**
                 * This object's children have changed.
                 */
                DisplayObjectContainer.prototype._invalidateChildren = function () {
                    this._setDirtyFlags(2 /* DirtyChildren */);
                    this._invalidateFillAndLineBounds(true, true);
                };
                /**
                 * Propagates flags down the display list. Propagation stops if all flags are already set.
                 */
                DisplayObjectContainer.prototype._propagateFlagsDown = function (flags) {
                    if (this._hasFlags(flags)) {
                        return;
                    }
                    this._setFlags(flags);
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        children[i]._propagateFlagsDown(flags);
                    }
                };
                /**
                 * Calls the constructors of new children placed by timeline commands.
                 */
                DisplayObjectContainer.prototype._constructChildren = function () {
                    release || Shumway.counter.count("DisplayObjectContainer::_constructChildren");
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child._hasFlags(256 /* Constructed */)) {
                            continue;
                        }
                        try {
                            child.axInitializer();
                        }
                        catch (e) {
                            Shumway.Debug.warning('caught error executing child constructor in constructChildren: ', e);
                        }
                        //child.class.instanceConstructorNoInitialize.call(child);
                        child._removeReference();
                        if (child._name) {
                            this.axSetPublicProperty(child._name, child);
                            //child._addReference();
                        }
                        child._setFlags(256 /* Constructed */);
                        var eventClass = this._sec.events;
                        if (child._hasFlags(131072 /* HasPlaceObjectInitPending */)) {
                            child._removeFlags(131072 /* HasPlaceObjectInitPending */);
                            var avm1Context = child._symbol.avm1Context;
                            // @ivanpopelyshev: AVM1
                            Shumway.AVM1.Lib.initializeAVM1Object(child, avm1Context, child._placeObjectTag);
                            try {
                                child.dispatchEvent(eventClass.getInstance(events.Event.AVM1_INIT));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under DisplayObjectContainer AVM1_INIT event: ', e);
                            }
                            try {
                                child.dispatchEvent(eventClass.getInstance(events.Event.AVM1_CONSTRUCT));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under DisplayObjectContainer AVM1_CONSTRUCT event: ', e);
                            }
                            if (child.hasEventListener(events.Event.AVM1_LOAD)) {
                                child._setFlags(1024 /* NeedsLoadEvent */);
                                this._propagateFlagsUp(16384 /* ContainsFrameScriptPendingChildren */);
                            }
                        }
                        try {
                            child.dispatchEvent(eventClass.getInstance(events.Event.ADDED, true));
                        }
                        catch (e) {
                            Shumway.Debug.warning('caught error under DisplayObject ADDED event: ', e);
                        }
                        if (child.stage) {
                            try {
                                child.dispatchEvent(eventClass.getInstance(events.Event.ADDED_TO_STAGE));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under DisplayObject ADDED_TO_STAGE event: ', e);
                            }
                        }
                    }
                };
                DisplayObjectContainer.prototype._enqueueFrameScripts = function () {
                    if (this._hasFlags(16384 /* ContainsFrameScriptPendingChildren */)) {
                        this._removeFlags(16384 /* ContainsFrameScriptPendingChildren */);
                        var children = this._children;
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            if (this._sec.display.DisplayObjectContainer.axIsType(child) ||
                                this._sec.display.AVM1Movie.axIsType(child)) {
                                child._enqueueFrameScripts();
                            }
                        }
                    }
                };
                Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
                    get: function () {
                        return this._getNumChildren();
                    },
                    enumerable: true,
                    configurable: true
                });
                // `get numChildren` is overridden in `Stage` and has to be able to call this.
                DisplayObjectContainer.prototype._getNumChildren = function () {
                    return this._children.length;
                };
                Object.defineProperty(DisplayObjectContainer.prototype, "textSnapshot", {
                    get: function () {
                        release || notImplemented("public DisplayObjectContainer::get textSnapshot");
                        return null;
                        // return this._textSnapshot;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayObjectContainer.prototype, "tabChildren", {
                    get: function () {
                        return this._getTabChildren();
                    },
                    set: function (enable) {
                        this._setTabChildren(enable);
                    },
                    enumerable: true,
                    configurable: true
                });
                // `get tabChildren` is overridden in `Stage` and has to be able to call this.
                DisplayObjectContainer.prototype._getTabChildren = function () {
                    return this._tabChildren;
                };
                // `set tabChildren` is overridden in `Stage` and has to be able to call this.
                DisplayObjectContainer.prototype._setTabChildren = function (enable) {
                    enable = !!enable;
                    var old = this._tabChildren;
                    this._tabChildren = enable;
                    if (old !== enable) {
                        this.dispatchEvent(this._sec.events.getInstance(events.Event.TAB_CHILDREN_CHANGE, true));
                    }
                };
                Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
                    get: function () {
                        return this._getMouseChildren();
                    },
                    set: function (enable) {
                        this._setMouseChildren(enable);
                    },
                    enumerable: true,
                    configurable: true
                });
                // `get mouseChildren` is overridden in `Stage` and has to be able to call this.
                DisplayObjectContainer.prototype._getMouseChildren = function () {
                    return this._mouseChildren;
                };
                // `set mouseChildren` is overridden in `Stage` and has to be able to call this.
                DisplayObjectContainer.prototype._setMouseChildren = function (enable) {
                    this._mouseChildren = !!enable;
                };
                DisplayObjectContainer.prototype.addChild = function (child) {
                    return this.addChildAt(child, this._children.length);
                };
                /**
                 * Adds a child at a given index. The index must be within the range [0 ... children.length].
                 * Note that this is different than the range setChildIndex expects.
                 */
                DisplayObjectContainer.prototype.addChildAt = function (child, index /*int*/) {
                    var flashContext = this._sec;
                    flashContext.display.DisplayObject.checkParameterType(child, "child");
                    release || Shumway.counter.count("DisplayObjectContainer::addChildAt");
                    index = index | 0;
                    release || assert(child._hasFlags(256 /* Constructed */), "Child is not fully constructed.");
                    if (child === this) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.CantAddSelfError);
                    }
                    if (flashContext.display.DisplayObjectContainer.axIsType(child) &&
                        child.contains(this)) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.CantAddParentError);
                    }
                    var children = this._children;
                    if (index < 0 || index > children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    if (child._parent === this) {
                        this.setChildIndex(child, clamp(index, 0, children.length - 1));
                        return child;
                    }
                    // TODO: check what happens if a listener for REMOVE throws an error. Does the element get
                    // reparented nevertheless?
                    if (child._parent) {
                        // Loader overrides removeChildAt to throw an exception. We still want to use it, so we
                        // always call the original version here.
                        DisplayObjectContainer.prototype.removeChildAt.call(child._parent, child._parent.getChildIndex(child));
                        // The children list could have been mutated as a result of |removeChild|.
                        index = clamp(index, 0, children.length);
                    }
                    for (var i = children.length - 1; i >= index; i--) {
                        children[i]._index++;
                    }
                    children.splice(index, 0, child);
                    child._setParent(this, -1);
                    child._index = index;
                    child._invalidatePosition();
                    this._invalidateChildren();
                    child._addReference();
                    child.dispatchEvent(this._sec.events.getInstance(events.Event.ADDED, true));
                    // ADDED event handlers may remove the child from the stage, in such cases
                    // we should not dispatch the ADDED_TO_STAGE event.
                    if (child.stage) {
                        child._propagateEvent(this._sec.events.getInstance(events.Event.ADDED_TO_STAGE));
                    }
                    return child;
                };
                /**
                 * Adds a timeline object to this container. The new child is added after the last object that
                 * exists at a smaller depth, or before the first object that exists at a greater depth. If no
                 * other timeline object is found, the new child is added to the front(top) of all other
                 * children.
                 *
                 * Note that this differs from `addChildAt` in that the depth isn't an index in the `children`
                 * array, and doesn't have to be in the dense range [0..children.length].
                 */
                DisplayObjectContainer.prototype.addTimelineObjectAtDepth = function (child, depth /*int*/) {
                    release || Shumway.counter.count("DisplayObjectContainer::addTimelineObjectAtDepth");
                    depth = depth | 0;
                    var children = this._children;
                    var maxIndex = children.length - 1;
                    var index = maxIndex + 1;
                    for (var i = maxIndex; i >= 0; i--) {
                        var current = children[i];
                        if (current._depth > -1) {
                            if (current._depth < depth) {
                                index = i + 1;
                                break;
                            }
                            index = i;
                        }
                    }
                    if (index > maxIndex) {
                        children.push(child);
                        child._index = index;
                    }
                    else {
                        children.splice(index, 0, child);
                        for (var i = index; i < children.length; i++) {
                            children[i]._index = i;
                        }
                    }
                    child._setParent(this, depth);
                    child._invalidatePosition();
                    this._invalidateChildren();
                };
                DisplayObjectContainer.prototype.removeChild = function (child) {
                    this._sec.display.DisplayObject.checkParameterType(child, "child");
                    return this.removeChildAt(this.getChildIndex(child));
                };
                DisplayObjectContainer.prototype.removeChildAt = function (index) {
                    release || Shumway.counter.count("DisplayObjectContainer::removeChildAt");
                    index = index | 0;
                    var children = this._children;
                    if (index < 0 || index >= children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    var child = children[index];
                    if (child._hasFlags(256 /* Constructed */)) {
                        child.dispatchEvent(this._sec.events.getInstance(events.Event.REMOVED, true));
                        if (this.stage) {
                            child._propagateEvent(this._sec.events.getInstance(events.Event.REMOVED_FROM_STAGE));
                        }
                        // Children list might have been mutated by the REMOVED or REMOVED_FROM_STAGE event,
                        // we may need to operate on the new index of the child.
                        index = this.getChildIndex(child);
                    }
                    children.splice(index, 1);
                    for (var i = children.length - 1; i >= index; i--) {
                        children[i]._index--;
                    }
                    child._setParent(null, -1);
                    child._index = -1;
                    child._invalidatePosition();
                    this._invalidateChildren();
                    return child;
                };
                DisplayObjectContainer.prototype.getChildIndex = function (child) {
                    this._sec.display.DisplayObject.checkParameterType(child, "child");
                    if (child._parent !== this) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.NotAChildError);
                    }
                    return child._index;
                };
                /**
                 * Sets the index of a child. The index must be within the range [0 ... children.length - 1].
                 */
                DisplayObjectContainer.prototype.setChildIndex = function (child, index /*int*/) {
                    index = index | 0;
                    this._sec.display.DisplayObject.checkParameterType(child, "child");
                    var children = this._children;
                    if (index < 0 || index >= children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    if (child._parent !== this) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.NotAChildError);
                    }
                    child._setDepth(-1);
                    var currentIndex = this.getChildIndex(child);
                    if (children.length === 1 || currentIndex === index) {
                        return;
                    }
                    if (index === currentIndex + 1 || index === currentIndex - 1) {
                        // We can't call |swapChildrenAt| here because we don't want to affect the depth value.
                        this._swapChildrenAt(currentIndex, index);
                    }
                    else {
                        children.splice(currentIndex, 1);
                        children.splice(index, 0, child);
                        var i = currentIndex < index ? currentIndex : index;
                        while (i < children.length) {
                            children[i]._index = i++;
                        }
                    }
                    this._invalidateChildren();
                };
                DisplayObjectContainer.prototype.getChildAt = function (index) {
                    index = index | 0;
                    var children = this._children;
                    if (index < 0 || index >= children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    var child = this._lookupChildByIndex(index, 0 /* DEFAULT */);
                    if (!child) {
                        return null;
                    }
                    child._addReference();
                    return child;
                };
                /**
                 * Returns the timeline object that exists at the specified depth.
                 */
                DisplayObjectContainer.prototype.getTimelineObjectAtDepth = function (depth /*int*/) {
                    depth = depth | 0;
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child._depth > depth) {
                            break;
                        }
                        if (child._depth === depth) {
                            return child;
                        }
                    }
                    return null;
                };
                /**
                 * Returns the last child index that is covered by the clip depth.
                 */
                DisplayObjectContainer.prototype.getClipDepthIndex = function (depth) {
                    depth = depth | 0;
                    var children = this._children;
                    var index = this._children.length - 1;
                    var first = true;
                    for (var i = index; i >= 0; i--) {
                        var child = children[i];
                        // Ignore children that don't have a depth value.
                        if (child._depth < 0) {
                            continue;
                        }
                        // Usually we return the index of the first child that has a depth value less than or
                        // equal to the specified depth. However, Flash seems to clip all remaining children,
                        // including those that don't have a depth value if the clip appears at the end.
                        if (child._depth <= depth) {
                            return first ? index : i;
                        }
                        first = false;
                    }
                    return 0;
                };
                DisplayObjectContainer.prototype.getChildByName = function (name) {
                    var child = this._lookupChildByName(name, 0 /* DEFAULT */);
                    if (child) {
                        child._addReference();
                        return child;
                    }
                    return null;
                };
                /**
                 * Returns the child display object instance that exists at given index without creating a
                 * reference nor taking ownership.
                 */
                DisplayObjectContainer.prototype._lookupChildByIndex = function (index, options) {
                    var child = this._children[index];
                    if (child && (child._hasFlags(256 /* Constructed */) ||
                        options & 2 /* INCLUDE_NON_INITIALIZED */)) {
                        return child;
                    }
                    return null;
                };
                /**
                 * Returns the child display object that exists with given name without creating a reference
                 * nor taking ownership.
                 */
                DisplayObjectContainer.prototype._lookupChildByName = function (name, options) {
                    var children = this._children;
                    if (children.length === 0) {
                        return null;
                    }
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (!child._hasFlags(256 /* Constructed */) &&
                            !(options & 2 /* INCLUDE_NON_INITIALIZED */)) {
                            continue;
                        }
                        if (child._name === name) {
                            return child;
                        }
                    }
                    if (!(options & 1 /* IGNORE_CASE */)) {
                        return null;
                    }
                    // Trying again in non-case sensitive mode (mostly for AVM1).
                    name = name.toLowerCase();
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (!child._hasFlags(256 /* Constructed */) &&
                            !(options & 2 /* INCLUDE_NON_INITIALIZED */)) {
                            continue;
                        }
                        if (child._name.toLowerCase() === name) {
                            return child;
                        }
                    }
                    return null;
                };
                /**
                 * Override of DisplayObject#_containsPoint that takes children into consideration.
                 */
                DisplayObjectContainer.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                    return this._containsPointImpl(globalX, globalY, localX, localY, testingType, objects, false);
                };
                DisplayObjectContainer.prototype._containsPointImpl = function (globalX, globalY, localX, localY, testingType, objects, skipBoundsCheck) {
                    var result;
                    if (!skipBoundsCheck) {
                        result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                        // Same as in the DisplayObject base case, we're done if we don't have a hit or are only
                        // looking for bounds + mask checks.
                        if (result === 0 /* None */ || testingType < 2 /* HitTestShape */) {
                            return result;
                        }
                    }
                    var anyChildHit = false;
                    var children = this._getUnclippedChildren(testingType, globalX, globalY);
                    for (var i = children ? children.length : 0; i--;) {
                        var child = children[i];
                        if (child._maskedObject) {
                            continue;
                        }
                        result = child._containsGlobalPoint(globalX, globalY, testingType, objects);
                        if (result !== 2 /* Shape */) {
                            continue;
                        }
                        // For hit testing, a single match suffices.
                        if (testingType < 3 /* Mouse */) {
                            return result;
                        }
                        anyChildHit = true;
                        if (testingType >= 4 /* ObjectsUnderPoint */) {
                            continue;
                        }
                        release || assert(testingType === 3 /* Mouse */);
                        release || assert(objects.length <= 1);
                        // If this object itself is mouse-disabled, we have to ensure that no nested object is
                        // returned as a result.
                        if (!this._mouseEnabled) {
                            objects.length = 0;
                            return result;
                        }
                        // If this container disables mouseChildren, any matched child establish the container as
                        // the match.
                        if (!this._mouseChildren) {
                            objects[0] = this;
                        }
                        if (objects.length !== 0) {
                            release || assert(this._sec.display.InteractiveObject.axIsType(objects[0]));
                            return 2 /* Shape */;
                        }
                    }
                    // We need to always test the container itself for getObjectsUnderPoint or when looking for a
                    // drop target. Otherwise, it's only required if no child (interactive or not) was hit.
                    if (anyChildHit && testingType < 4 /* ObjectsUnderPoint */) {
                        if (testingType === 3 /* Mouse */ && objects.length === 0) {
                            objects[0] = this;
                        }
                        return 2 /* Shape */;
                    }
                    var selfHit = this._containsPointDirectly(localX, localY, globalX, globalY);
                    if (selfHit) {
                        if (testingType === 5 /* Drop */) {
                            // For Drop, replace previous hit with current one.
                            objects[0] = this;
                        }
                        else if (testingType === 4 /* ObjectsUnderPoint */ || objects && this._mouseEnabled) {
                            objects.push(this);
                        }
                    }
                    return anyChildHit || selfHit ? 2 /* Shape */ : 0 /* None */;
                };
                DisplayObjectContainer.prototype._getUnclippedChildren = function (testingType, globalX, globalY) {
                    // Clipping masks complicate hit testing: for mouse target finding, where performance is
                    // most important, we want to test highest children first, then go down. OTOH, we want to
                    // test clipping masks before the elements they clip, potentially saving costly tests against
                    // lots of elements. However, clipping masks affect siblings with higher child indices, so
                    // by going top-to-bottom, we discover them after the clipped content. To get around that,
                    // we iterate over the children once and detect any clipping masks. If we find at least one,
                    // we copy all the non-clipped elements into a new array, over which we then iterate without
                    // having to test clipping.
                    // Note: if speed is an issue, we could set a flag on containers that have at least one
                    // clipping mask and do this step only if that flag is set.
                    var children = this._children;
                    if (!children) {
                        return null;
                    }
                    var unclippedChildren; // Lazily created.
                    for (var i = 0; children && i < children.length; i++) {
                        var child = children[i];
                        if (child._clipDepth !== -1) {
                            if (!unclippedChildren) {
                                unclippedChildren = children.slice(0, i);
                            }
                            // Clipping masks are simply ignored for HitTestPoint purposes.
                            if (testingType === 2 /* HitTestShape */) {
                                continue;
                            }
                            release || assert(testingType >= 3 /* Mouse */);
                            // If the point isn't contained in the clipping mask, we can skip all the clipped objects.
                            // We pass HitTestShape here because we never want to collect hit objects, which the
                            // higher testing types would attempt to do.
                            var containsPoint = child._containsGlobalPoint(globalX, globalY, 2 /* HitTestShape */, null);
                            if (!containsPoint) {
                                i = this.getClipDepthIndex(child._clipDepth);
                            }
                            continue;
                        }
                        if (unclippedChildren) {
                            unclippedChildren.push(child);
                        }
                    }
                    return unclippedChildren || children;
                };
                /**
                 * Override of DisplayObject#_getChildBounds that union all childrens's
                 * bounds into the bounds.
                 */
                DisplayObjectContainer.prototype._getChildBounds = function (bounds, includeStrokes) {
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        bounds.unionInPlace(children[i]._getTransformedBounds(this, includeStrokes));
                    }
                };
                /**
                 * Returns an array of all leaf objects under the given point in global coordinates.
                 * A leaf node in this context is an object that itself contains visual content, so it can be
                 * any of Shape, Sprite, MovieClip, Bitmap, Video, and TextField.
                 * Note that, while the Flash documentation makes it sound like it doesn't, the result also
                 * contains the receiver object if that matches the criteria above.
                 */
                DisplayObjectContainer.prototype.getObjectsUnderPoint = function (globalPoint) {
                    release || Shumway.counter.count("DisplayObjectContainer::getObjectsUnderPoint");
                    var globalX = globalPoint.x * 20 | 0;
                    var globalY = globalPoint.y * 20 | 0;
                    var objects = [];
                    this._containsGlobalPoint(globalX, globalY, 4 /* ObjectsUnderPoint */, objects);
                    // getObjectsUnderPoint returns results in exactly the opposite order we collect them in.
                    return objects.reverse();
                };
                DisplayObjectContainer.prototype.areInaccessibleObjectsUnderPoint = function (point) {
                    point = point;
                    release || notImplemented("public DisplayObjectContainer::areInaccessibleObjectsUnderPoint");
                    return false;
                };
                DisplayObjectContainer.prototype.contains = function (child) {
                    this._sec.display.DisplayObject.checkParameterType(child, "child");
                    return this._isAncestor(child);
                };
                DisplayObjectContainer.prototype.swapChildrenAt = function (index1 /*int*/, index2 /*int*/) {
                    index1 = index1 | 0;
                    index2 = index2 | 0;
                    var children = this._children;
                    if (index1 < 0 || index1 >= children.length ||
                        index2 < 0 || index2 >= children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    // Always call _swapChildrenAt to make sure _setDepth(-1) is called on both children.
                    this._swapChildrenAt(index1, index2);
                    if (index1 !== index2) {
                        this._invalidateChildren();
                    }
                };
                DisplayObjectContainer.prototype._swapChildrenAt = function (index1, index2) {
                    var children = this._children;
                    var child1 = children[index1];
                    var child2 = children[index2];
                    children[index2] = child1;
                    child1._setDepth(-1);
                    child1._index = index2;
                    children[index1] = child2;
                    child2._setDepth(-1);
                    child2._index = index1;
                };
                DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
                    // Flash prints out 'child' for both non-null |child1| and |child2|.
                    this._sec.display.DisplayObject.checkParameterType(child1, "child");
                    this._sec.display.DisplayObject.checkParameterType(child2, "child");
                    this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
                };
                DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
                    if (beginIndex === void 0) { beginIndex = 0; }
                    if (endIndex === void 0) { endIndex = 2147483647; }
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    if (beginIndex < 0 || endIndex < 0 || endIndex < beginIndex || endIndex >= this._children.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    var count = endIndex - beginIndex + 1;
                    if (count > 0) {
                        while (count--) {
                            this.removeChildAt(beginIndex);
                        }
                    }
                };
                DisplayObjectContainer.prototype.hashCode = function () {
                    var hash = 0;
                    for (var i = 0; i < this.numChildren; i++) {
                        var child = this.getChildAt(i);
                        if (child) {
                            hash = mixHash(hash, this.getChildAt(i).hashCode());
                        }
                    }
                    return mixHash(hash, this.getBounds(null).hashCode());
                };
                /**
                 * This is a very slow recursive function that should not be used in performance critical code.
                 */
                DisplayObjectContainer.prototype.getAncestorCount = function () {
                    var count = 0;
                    for (var i = 0; i < this.numChildren; i++) {
                        var child = this.getChildAt(i);
                        if (child) {
                            count += 1 + this.getChildAt(i).getAncestorCount();
                        }
                    }
                    return count;
                };
                return DisplayObjectContainer;
            }(flash.display.InteractiveObject));
            display.DisplayObjectContainer = DisplayObjectContainer;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: JointStyle
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var JointStyle;
            (function (JointStyle) {
                JointStyle["ROUND"] = "round";
                JointStyle["BEVEL"] = "bevel";
                JointStyle["MITER"] = "miter";
            })(JointStyle = display.JointStyle || (display.JointStyle = {}));
            (function (JointStyle) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return JointStyle.ROUND;
                        case 1:
                            return JointStyle.BEVEL;
                        case 2:
                            return JointStyle.MITER;
                        default:
                            return null;
                    }
                }
                JointStyle.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case JointStyle.ROUND:
                            return 0;
                        case JointStyle.BEVEL:
                            return 1;
                        case JointStyle.MITER:
                            return 2;
                        default:
                            return -1;
                    }
                }
                JointStyle.toNumber = toNumber;
            })(JointStyle = display.JointStyle || (display.JointStyle = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: CapsStyle
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var CapsStyle;
            (function (CapsStyle) {
                // JS -> AS Bindings
                CapsStyle["ROUND"] = "round";
                CapsStyle["NONE"] = "none";
                CapsStyle["SQUARE"] = "square";
                // AS -> JS Bindings
            })(CapsStyle = display.CapsStyle || (display.CapsStyle = {}));
            (function (CapsStyle) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return CapsStyle.ROUND;
                        case 1:
                            return CapsStyle.NONE;
                        case 2:
                            return CapsStyle.SQUARE;
                        default:
                            return null;
                    }
                }
                CapsStyle.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case CapsStyle.ROUND:
                            return 0;
                        case CapsStyle.NONE:
                            return 1;
                        case CapsStyle.SQUARE:
                            return 2;
                        default:
                            return -1;
                    }
                }
                CapsStyle.toNumber = toNumber;
            })(CapsStyle = display.CapsStyle || (display.CapsStyle = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: LineScaleMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var LineScaleMode;
            (function (LineScaleMode) {
                LineScaleMode["NORMAL"] = "normal";
                LineScaleMode["VERTICAL"] = "vertical";
                LineScaleMode["HORIZONTAL"] = "horizontal";
                LineScaleMode["NONE"] = "none";
            })(LineScaleMode = display.LineScaleMode || (display.LineScaleMode = {}));
            (function (LineScaleMode) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return LineScaleMode.NONE;
                        case 1:
                            return LineScaleMode.NORMAL;
                        case 2:
                            return LineScaleMode.VERTICAL;
                        case 3:
                            return LineScaleMode.HORIZONTAL;
                        default:
                            return null;
                    }
                }
                LineScaleMode.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case LineScaleMode.NONE:
                            return 0;
                        case LineScaleMode.NORMAL:
                            return 1;
                        case LineScaleMode.VERTICAL:
                            return 2;
                        case LineScaleMode.HORIZONTAL:
                            return 3;
                        default:
                            return -1;
                    }
                }
                LineScaleMode.toNumber = toNumber;
            })(LineScaleMode = display.LineScaleMode || (display.LineScaleMode = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GradientType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GradientType;
            (function (GradientType) {
                GradientType["LINEAR"] = "linear";
                GradientType["RADIAL"] = "radial";
            })(GradientType = display.GradientType || (display.GradientType = {}));
            (function (GradientType) {
                function fromNumber(n) {
                    switch (n) {
                        case 16 /* Linear */:
                            return GradientType.LINEAR;
                        case 18 /* Radial */:
                            return GradientType.RADIAL;
                        default:
                            return null;
                    }
                }
                GradientType.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case GradientType.LINEAR:
                            return 16 /* Linear */;
                        case GradientType.RADIAL:
                            return 18 /* Radial */;
                        default:
                            return -1;
                    }
                }
                GradientType.toNumber = toNumber;
            })(GradientType = display.GradientType || (display.GradientType = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SpreadMethod
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var SpreadMethod;
            (function (SpreadMethod) {
                SpreadMethod["PAD"] = "pad";
                SpreadMethod["REFLECT"] = "reflect";
                SpreadMethod["REPEAT"] = "repeat";
            })(SpreadMethod = display.SpreadMethod || (display.SpreadMethod = {}));
            (function (SpreadMethod) {
                function fromNumber(n) {
                    switch (n) {
                        case 0 /* Pad */:
                            return SpreadMethod.PAD;
                        case 1 /* Reflect */:
                            return SpreadMethod.REFLECT;
                        case 2 /* Repeat */:
                            return SpreadMethod.REPEAT;
                        default:
                            return null;
                    }
                }
                SpreadMethod.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case SpreadMethod.PAD:
                            return 0 /* Pad */;
                        case SpreadMethod.REFLECT:
                            return 1 /* Reflect */;
                        case SpreadMethod.REPEAT:
                            return 2 /* Repeat */;
                        default:
                            return -1;
                    }
                }
                SpreadMethod.toNumber = toNumber;
            })(SpreadMethod = display.SpreadMethod || (display.SpreadMethod = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: InterpolationMethod
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var InterpolationMethod;
            (function (InterpolationMethod) {
                InterpolationMethod["RGB"] = "rgb";
                InterpolationMethod["LINEAR_RGB"] = "linearRGB";
            })(InterpolationMethod = display.InterpolationMethod || (display.InterpolationMethod = {}));
            (function (InterpolationMethod) {
                // AS -> JS Bindings
                function fromNumber(n) {
                    switch (n) {
                        case 0 /* RGB */:
                            return InterpolationMethod.RGB;
                        case 1 /* LinearRGB */:
                            return InterpolationMethod.LINEAR_RGB;
                        default:
                            return null;
                    }
                }
                InterpolationMethod.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case InterpolationMethod.RGB:
                            return 0 /* RGB */;
                        case InterpolationMethod.LINEAR_RGB:
                            return 1 /* LinearRGB */;
                        default:
                            return -1;
                    }
                }
                InterpolationMethod.toNumber = toNumber;
            })(InterpolationMethod = display.InterpolationMethod || (display.InterpolationMethod = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsBitmapFill
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsBitmapFill = /** @class */ (function (_super) {
                __extends(GraphicsBitmapFill, _super);
                function GraphicsBitmapFill(bitmapData, matrix, repeat, smooth) {
                    if (bitmapData === void 0) { bitmapData = null; }
                    if (matrix === void 0) { matrix = null; }
                    if (repeat === void 0) { repeat = true; }
                    if (smooth === void 0) { smooth = false; }
                    var _this = _super.call(this) || this;
                    _this.bitmapData = bitmapData;
                    _this.matrix = matrix;
                    _this.repeat = !!repeat;
                    _this.smooth = !!smooth;
                    return _this;
                }
                return GraphicsBitmapFill;
            }(flash.LegacyEntity));
            display.GraphicsBitmapFill = GraphicsBitmapFill;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsEndFill
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsEndFill = /** @class */ (function (_super) {
                __extends(GraphicsEndFill, _super);
                function GraphicsEndFill() {
                    return _super.call(this) || this;
                }
                return GraphicsEndFill;
            }(flash.LegacyEntity));
            display.GraphicsEndFill = GraphicsEndFill;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsGradientFill
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsGradientFill = /** @class */ (function (_super) {
                __extends(GraphicsGradientFill, _super);
                function GraphicsGradientFill(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                    if (type === void 0) { type = display.GradientType.LINEAR; }
                    if (colors === void 0) { colors = null; }
                    if (alphas === void 0) { alphas = null; }
                    if (ratios === void 0) { ratios = null; }
                    if (matrix === void 0) { matrix = null; }
                    if (spreadMethod === void 0) { spreadMethod = display.SpreadMethod.PAD; }
                    if (interpolationMethod === void 0) { interpolationMethod = display.InterpolationMethod.RGB; }
                    if (focalPointRatio === void 0) { focalPointRatio = 0; }
                    var _this = _super.call(this) || this;
                    _this.type = type;
                    _this.colors = colors;
                    _this.alphas = alphas;
                    _this.ratios = ratios;
                    _this.matrix = matrix;
                    _this.spreadMethod = spreadMethod;
                    _this.interpolationMethod = interpolationMethod;
                    _this.focalPointRatio = +focalPointRatio;
                    return _this;
                }
                return GraphicsGradientFill;
            }(flash.LegacyEntity));
            display.GraphicsGradientFill = GraphicsGradientFill;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsPath
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsPath = /** @class */ (function (_super) {
                __extends(GraphicsPath, _super);
                // @ivanpopelyshev: Int32Vector
                function GraphicsPath(commands, data, winding) {
                    if (commands === void 0) { commands = null; }
                    if (data === void 0) { data = null; }
                    if (winding === void 0) { winding = "evenOdd"; }
                    var _this = _super.call(this) || this;
                    _this.commands = commands;
                    _this.data = data;
                    _this.winding = winding;
                    return _this;
                }
                return GraphicsPath;
            }(flash.LegacyEntity));
            display.GraphicsPath = GraphicsPath;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsPathCommand
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsPathCommand;
            (function (GraphicsPathCommand) {
                GraphicsPathCommand[GraphicsPathCommand["NO_OP"] = undefined] = "NO_OP";
                GraphicsPathCommand[GraphicsPathCommand["MOVE_TO"] = 1] = "MOVE_TO";
                GraphicsPathCommand[GraphicsPathCommand["LINE_TO"] = 2] = "LINE_TO";
                GraphicsPathCommand[GraphicsPathCommand["CURVE_TO"] = 3] = "CURVE_TO";
                GraphicsPathCommand[GraphicsPathCommand["WIDE_MOVE_TO"] = 4] = "WIDE_MOVE_TO";
                GraphicsPathCommand[GraphicsPathCommand["WIDE_LINE_TO"] = 5] = "WIDE_LINE_TO";
                GraphicsPathCommand[GraphicsPathCommand["CUBIC_CURVE_TO"] = 6] = "CUBIC_CURVE_TO";
                // AS -> JS Bindings
            })(GraphicsPathCommand = display.GraphicsPathCommand || (display.GraphicsPathCommand = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsPathWinding
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsPathWinding;
            (function (GraphicsPathWinding) {
                GraphicsPathWinding["EVEN_ODD"] = "evenOdd";
                GraphicsPathWinding["NON_ZERO"] = "nonZero";
            })(GraphicsPathWinding = display.GraphicsPathWinding || (display.GraphicsPathWinding = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsSolidFill
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsSolidFill = /** @class */ (function (_super) {
                __extends(GraphicsSolidFill, _super);
                function GraphicsSolidFill(color, alpha) {
                    if (color === void 0) { color = 0; }
                    if (alpha === void 0) { alpha = 1; }
                    var _this = _super.call(this) || this;
                    _this.color = color >>> 0;
                    _this.alpha = +alpha;
                    return _this;
                }
                return GraphicsSolidFill;
            }(flash.LegacyEntity));
            display.GraphicsSolidFill = GraphicsSolidFill;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsStroke
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsStroke = /** @class */ (function (_super) {
                __extends(GraphicsStroke, _super);
                function GraphicsStroke(thickness, pixelHinting, scaleMode, caps, joints, miterLimit, fill) {
                    if (thickness === void 0) { thickness = NaN; }
                    if (pixelHinting === void 0) { pixelHinting = false; }
                    if (scaleMode === void 0) { scaleMode = "normal"; }
                    if (caps === void 0) { caps = "none"; }
                    if (joints === void 0) { joints = "round"; }
                    if (miterLimit === void 0) { miterLimit = 3; }
                    if (fill === void 0) { fill = null; }
                    var _this = _super.call(this) || this;
                    _this.thickness = +thickness;
                    _this.pixelHinting = !!pixelHinting;
                    _this.scaleMode = scaleMode;
                    _this.caps = caps;
                    _this.joints = joints;
                    _this.miterLimit = +miterLimit;
                    _this.fill = fill;
                    return _this;
                }
                // Called whenever the class is initialized.
                GraphicsStroke.classInitializer = null;
                // List of static symbols to link.
                GraphicsStroke.classSymbols = null; // [];
                // List of instance symbols to link.
                GraphicsStroke.instanceSymbols = null; // ["thickness", "pixelHinting", "miterLimit", "fill", "_scaleMode", "_caps", "_joints", "scaleMode", "scaleMode", "caps", "caps", "joints", "joints"];
                return GraphicsStroke;
            }(flash.LegacyEntity));
            display.GraphicsStroke = GraphicsStroke;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GraphicsTrianglePath
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var GraphicsTrianglePath = /** @class */ (function (_super) {
                __extends(GraphicsTrianglePath, _super);
                function GraphicsTrianglePath(vertices, indices, uvtData, culling) {
                    if (vertices === void 0) { vertices = null; }
                    if (indices === void 0) { indices = null; }
                    if (uvtData === void 0) { uvtData = null; }
                    if (culling === void 0) { culling = "none"; }
                    var _this = _super.call(this) || this;
                    // TODO: coerce to vector types
                    _this.vertices = vertices;
                    _this.indices = indices;
                    _this.uvtData = uvtData;
                    _this.culling = culling;
                    return _this;
                }
                return GraphicsTrianglePath;
            }(flash.LegacyEntity));
            display.GraphicsTrianglePath = GraphicsTrianglePath;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Graphics
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var clamp = Shumway.NumberUtilities.clamp;
            var Bounds = Shumway.Bounds;
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var GradientType = flash.display.GradientType;
            var SpreadMethod = flash.display.SpreadMethod;
            var InterpolationMethod = flash.display.InterpolationMethod;
            var LineScaleMode = flash.display.LineScaleMode;
            var CapsStyle = flash.display.CapsStyle;
            var JointStyle = flash.display.JointStyle;
            var ShapeData = Shumway.ShapeData;
            function distanceSq(x1, y1, x2, y2) {
                var dX = x2 - x1;
                var dY = y2 - y1;
                return dX * dX + dY * dY;
            }
            function quadraticBezier(from, cp, to, t) {
                var inverseT = 1 - t;
                return from * inverseT * inverseT + 2 * cp * inverseT * t + to * t * t;
            }
            function quadraticBezierExtreme(from, cp, to) {
                var t = (from - cp) / (from - 2 * cp + to);
                if (t < 0) {
                    return from;
                }
                if (t > 1) {
                    return to;
                }
                return quadraticBezier(from, cp, to, t);
            }
            function cubicBezier(from, cp, cp2, to, t) {
                var tSq = t * t;
                var inverseT = 1 - t;
                var inverseTSq = inverseT * inverseT;
                return from * inverseT * inverseTSq + 3 * cp * t * inverseTSq +
                    3 * cp2 * inverseT * tSq + to * t * tSq;
            }
            function cubicBezierExtremes(from, cp, cp2, to) {
                var d1 = cp - from;
                var d2 = cp2 - cp;
                // We only ever need d2 * 2
                d2 *= 2;
                var d3 = to - cp2;
                // Prevent division by zero by very slightly changing d3 if that would happen
                if (d1 + d3 === d2) {
                    d3 *= 1.0001;
                }
                var fHead = 2 * d1 - d2;
                var part1 = d2 - 2 * d1;
                var fCenter = Math.sqrt(part1 * part1 - 4 * d1 * (d1 - d2 + d3));
                var fTail = 2 * (d1 - d2 + d3);
                var t1 = (fHead + fCenter) / fTail;
                var t2 = (fHead - fCenter) / fTail;
                var result = [];
                if (t1 >= 0 && t1 <= 1) {
                    result.push(Math.round(cubicBezier(from, cp, cp2, to, t1)));
                }
                if (t2 >= 0 && t2 <= 1) {
                    result.push(Math.round(cubicBezier(from, cp, cp2, to, t2)));
                }
                return result;
            }
            function cubicXAtY(x0, y0, cx, cy, cx1, cy1, x1, y1, y) {
                var dX = 3.0 * (cx - x0);
                var dY = 3.0 * (cy - y0);
                var bX = 3.0 * (cx1 - cx) - dX;
                var bY = 3.0 * (cy1 - cy) - dY;
                var c3X = x1 - x0 - dX - bX;
                var c3Y = y1 - y0 - dY - bY;
                // Find one root - any root - then factor out (t-r) to get a quadratic poly.
                function f(t) {
                    return t * (dY + t * (bY + t * c3Y)) + y0 - y;
                }
                function pointAt(t) {
                    if (t < 0) {
                        t = 0;
                    }
                    else if (t > 1) {
                        t = 1;
                    }
                    return x0 + t * (dX + t * (bX + t * c3X));
                }
                // Bisect the specified range to isolate an interval with a root.
                function bisectCubicBezierRange(f, l, r, limit) {
                    if (Math.abs(r - l) <= limit) {
                        return;
                    }
                    var middle = 0.5 * (l + r);
                    if (f(l) * f(r) <= 0) {
                        left = l;
                        right = r;
                        return;
                    }
                    bisectCubicBezierRange(f, l, middle, limit);
                    bisectCubicBezierRange(f, middle, r, limit);
                }
                // some curves that loop around on themselves may require bisection
                var left = 0;
                var right = 1;
                bisectCubicBezierRange(f, 0, 1, 0.05);
                // experiment with tolerance - but not too tight :)
                var t0 = findRoot(left, right, f, 50, 0.000001);
                var evalResult = Math.abs(f(t0));
                if (evalResult > 0.00001) {
                    return [];
                }
                var result = [];
                if (t0 <= 1) {
                    result.push(pointAt(t0));
                }
                // Factor theorem: t-r is a factor of the cubic polynomial if r is a root.
                // Use this to reduce to a quadratic poly. using synthetic division
                var a = c3Y;
                var b = t0 * a + bY;
                var c = t0 * b + dY;
                // Process the quadratic for the remaining two possible roots
                var d = b * b - 4 * a * c;
                if (d < 0) {
                    return result;
                }
                d = Math.sqrt(d);
                a = 1 / (a + a);
                var t1 = (d - b) * a;
                var t2 = (-b - d) * a;
                if (t1 >= 0 && t1 <= 1) {
                    result.push(pointAt(t1));
                }
                if (t2 >= 0 && t2 <= 1) {
                    result.push(pointAt(t2));
                }
                return result;
            }
            function findRoot(x0, x2, f, maxIterations, epsilon) {
                var x1;
                var y0;
                var y1;
                var y2;
                var b;
                var c;
                var y10;
                var y20;
                var y21;
                var xm;
                var ym;
                var temp;
                var xmlast = x0;
                y0 = f(x0);
                if (y0 === 0) {
                    return x0;
                }
                y2 = f(x2);
                if (y2 === 0) {
                    return x2;
                }
                if (y2 * y0 > 0) {
                    // dispatchEvent( new Event(ERROR) );
                    return x0;
                }
                var __iter = 0;
                for (var i = 0; i < maxIterations; ++i) {
                    __iter++;
                    x1 = 0.5 * (x2 + x0);
                    y1 = f(x1);
                    if (y1 === 0) {
                        return x1;
                    }
                    if (Math.abs(x1 - x0) < epsilon) {
                        return x1;
                    }
                    if (y1 * y0 > 0) {
                        temp = x0;
                        x0 = x2;
                        x2 = temp;
                        temp = y0;
                        y0 = y2;
                        y2 = temp;
                    }
                    y10 = y1 - y0;
                    y21 = y2 - y1;
                    y20 = y2 - y0;
                    if (y2 * y20 < 2 * y1 * y10) {
                        x2 = x1;
                        y2 = y1;
                    }
                    else {
                        b = (x1 - x0) / y10;
                        c = (y10 - y21) / (y21 * y20);
                        xm = x0 - b * y0 * (1 - c * y1);
                        ym = f(xm);
                        if (ym === 0) {
                            return xm;
                        }
                        if (Math.abs(xm - xmlast) < epsilon) {
                            return xm;
                        }
                        xmlast = xm;
                        if (ym * y0 < 0) {
                            x2 = xm;
                            y2 = ym;
                        }
                        else {
                            x0 = xm;
                            y0 = ym;
                            x2 = x1;
                            y2 = y1;
                        }
                    }
                }
                return x1;
            }
            // See http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
            function rayIntersectsLine(x, y, x1, y1, x2, y2) {
                return (y2 > y) !== (y1 > y) && x < (x1 - x2) * (y - y2) / (y1 - y2) + x2;
            }
            function rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY) {
                if ((cpY > y) === (fromY > y) && (toY > y) === (fromY > y)) {
                    return false;
                }
                if (fromX >= x && cpX >= x && toX >= x) {
                    return true;
                }
                // Finding the intersections with our ray means solving a quadratic
                // equation of the form y = ax^2 + bx + c for y.
                // See http://en.wikipedia.org/wiki/Quadratic_equation and
                // http://code.google.com/p/degrafa/source/browse/trunk/Degrafa/com/degrafa/geometry/AdvancedQuadraticBezier.as?r=613#394
                var a = fromY - 2 * cpY + toY;
                var c = fromY - y;
                var b = 2 * (cpY - fromY);
                var d = b * b - 4 * a * c;
                if (d < 0) {
                    return false;
                }
                d = Math.sqrt(d);
                a = 1 / (a + a);
                var t1 = (d - b) * a;
                var t2 = (-b - d) * a;
                var crosses = false;
                if (t1 >= 0 && t1 <= 1 && quadraticBezier(fromX, cpX, toX, t1) > x) {
                    crosses = !crosses;
                }
                if (t2 >= 0 && t2 <= 1 && quadraticBezier(fromX, cpX, toX, t2) > x) {
                    crosses = !crosses;
                }
                return crosses;
            }
            function rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY) {
                var curveStartsAfterY = fromY > y;
                if ((cpY > y) === curveStartsAfterY && (cp2Y > y) === curveStartsAfterY &&
                    (toY > y) === curveStartsAfterY) {
                    return false;
                }
                if (fromX < x && cpX < x && cp2X < x && toX < x) {
                    return false;
                }
                var crosses = false;
                var roots = cubicXAtY(fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY, y);
                for (var i = roots.length; i; i--) {
                    if (roots[i] >= x) {
                        crosses = !crosses;
                    }
                }
                return crosses;
            }
            // end of GFX geometry.ts
            var Graphics = /** @class */ (function (_super) {
                __extends(Graphics, _super);
                function Graphics() {
                    var _this = _super.call(this) || this;
                    _this._id = flash.display.DisplayObject.getNextSyncID();
                    _this._graphicsData = new ShapeData();
                    _this._textures = [];
                    _this._fillBounds = new Bounds(0x8000000, 0x8000000, 0x8000000, 0x8000000);
                    _this._lineBounds = new Bounds(0x8000000, 0x8000000, 0x8000000, 0x8000000);
                    _this._lastX = _this._lastY = 0;
                    _this._boundsIncludeLastCoordinates = true;
                    _this._parent = null;
                    _this._topLeftStrokeWidth = _this._bottomRightStrokeWidth = 0;
                    _this._isDirty = true;
                    return _this;
                }
                Graphics.FromData = function (data, loaderInfo) {
                    var graphics = loaderInfo._sec.display.Graphics.create();
                    graphics._graphicsData = ShapeData.FromPlainObject(data.shape);
                    if (data.lineBounds) {
                        graphics._lineBounds.copyFrom(data.lineBounds);
                        graphics._fillBounds.copyFrom(data.fillBounds || data.lineBounds);
                    }
                    return graphics;
                };
                Graphics.prototype.getGraphicsData = function () {
                    return this._graphicsData;
                };
                Graphics.prototype.getUsedTextures = function () {
                    return this._textures;
                };
                /**
                 * Flash special-cases lines that are 1px and 3px wide.
                 * They're offset by 0.5px to the bottom-right.
                 */
                Graphics.prototype._setStrokeWidth = function (width) {
                    switch (width) {
                        case 1:
                            this._topLeftStrokeWidth = 0;
                            this._bottomRightStrokeWidth = 1;
                            break;
                        case 3:
                            this._topLeftStrokeWidth = 1;
                            this._bottomRightStrokeWidth = 2;
                            break;
                        default:
                            var half = Math.ceil(width * 0.5) | 0;
                            this._topLeftStrokeWidth = half;
                            this._bottomRightStrokeWidth = half;
                            break;
                    }
                };
                Graphics.prototype._setParent = function (parent) {
                    release || assert(!this._parent);
                    this._parent = parent;
                };
                Graphics.prototype._invalidate = function () {
                    release || assert(this._parent, "Graphics instances must have a parent.");
                    this._parent._invalidateFillAndLineBounds(true, true);
                    this._parent._propagateFlagsUp(536870912 /* DirtyDescendents */);
                    this._isDirty = true;
                };
                Graphics.prototype._getContentBounds = function (includeStrokes) {
                    if (includeStrokes === void 0) { includeStrokes = true; }
                    return includeStrokes ? this._lineBounds : this._fillBounds;
                };
                Graphics.prototype.clear = function () {
                    if (this._graphicsData.isEmpty()) {
                        return;
                    }
                    this._graphicsData.clear();
                    this._textures.length = 0;
                    this._fillBounds.setToSentinels();
                    this._lineBounds.setToSentinels();
                    this._lastX = this._lastY = 0;
                    this._boundsIncludeLastCoordinates = false;
                    this._invalidate();
                };
                /**
                 * Sets a solid color and opacity as the fill for subsequent drawing commands.
                 *
                 * @see http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/display/Graphics.html#beginFill%28%29
                 * @param color
                 * @param alpha While any Number is a valid input, the value is clamped to [0,1] and then scaled
                 * to an integer in the interval [0,0xff].
                 */
                Graphics.prototype.beginFill = function (color /*uint*/, alpha) {
                    if (alpha === void 0) { alpha = 1; }
                    color = color >>> 0 & 0xffffff;
                    alpha = Math.round(clamp(+alpha, -1, 1) * 0xff) | 0;
                    this._graphicsData.beginFill((color << 8) | alpha);
                };
                Graphics.prototype.beginGradientFill = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                    if (matrix === void 0) { matrix = null; }
                    if (spreadMethod === void 0) { spreadMethod = "pad"; }
                    if (interpolationMethod === void 0) { interpolationMethod = "rgb"; }
                    if (focalPointRatio === void 0) { focalPointRatio = 0; }
                    this._writeGradientStyle(2 /* BeginGradientFill */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, false);
                };
                Graphics.prototype.beginBitmapFill = function (bitmap, matrix, repeat, smooth) {
                    if (matrix === void 0) { matrix = null; }
                    if (repeat === void 0) { repeat = true; }
                    if (smooth === void 0) { smooth = false; }
                    this._writeBitmapStyle(3 /* BeginBitmapFill */, bitmap, matrix, repeat, smooth, false);
                };
                Graphics.prototype.endFill = function () {
                    this._graphicsData.endFill();
                };
                //    beginShaderFill(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                //      //shader = shader; matrix = matrix;
                //      release || notImplemented("public flash.display.Graphics::beginShaderFill"); return;
                //    }
                Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
                    if (color === void 0) { color = 0; }
                    if (alpha === void 0) { alpha = 1; }
                    if (pixelHinting === void 0) { pixelHinting = false; }
                    if (scaleMode === void 0) { scaleMode = "normal"; }
                    if (caps === void 0) { caps = null; }
                    if (joints === void 0) { joints = null; }
                    if (miterLimit === void 0) { miterLimit = 3; }
                    thickness = +thickness;
                    color = color >>> 0 & 0xffffff;
                    alpha = Math.round(clamp(+alpha, -1, 1) * 0xff);
                    pixelHinting = !!pixelHinting;
                    miterLimit = clamp(+miterLimit | 0, 0, 0xff);
                    // Flash stops drawing strokes whenever a thickness is supplied that can't be coerced to a
                    // number.
                    if (isNaN(thickness)) {
                        this._setStrokeWidth(0);
                        this._graphicsData.endLine();
                        return;
                    }
                    thickness = clamp(+thickness, 0, 0xff) * 20 | 0;
                    this._setStrokeWidth(thickness);
                    // If `scaleMode` is invalid, "normal" is used.
                    var lineScaleMode = LineScaleMode.toNumber(scaleMode);
                    if (lineScaleMode < 0) {
                        lineScaleMode = LineScaleMode.toNumber(LineScaleMode.NORMAL);
                    }
                    // If `caps` is invalid, "normal" is used.
                    var capsStyle = CapsStyle.toNumber(caps);
                    if (capsStyle < 0) {
                        capsStyle = CapsStyle.toNumber(CapsStyle.ROUND);
                    }
                    // If `joints` is invalid, "normal" is used.
                    var jointStyle = JointStyle.toNumber(joints);
                    if (jointStyle < 0) {
                        jointStyle = JointStyle.toNumber(JointStyle.ROUND);
                    }
                    this._graphicsData.lineStyle(thickness, (color << 8) | alpha, pixelHinting, lineScaleMode, capsStyle, jointStyle, miterLimit);
                };
                Graphics.prototype.lineGradientStyle = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                    if (matrix === void 0) { matrix = null; }
                    if (spreadMethod === void 0) { spreadMethod = "pad"; }
                    if (interpolationMethod === void 0) { interpolationMethod = "rgb"; }
                    if (focalPointRatio === void 0) { focalPointRatio = 0; }
                    this._writeGradientStyle(6 /* LineStyleGradient */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, !this._graphicsData.hasLines);
                };
                Graphics.prototype.lineBitmapStyle = function (bitmap, matrix, repeat, smooth) {
                    if (matrix === void 0) { matrix = null; }
                    if (repeat === void 0) { repeat = true; }
                    if (smooth === void 0) { smooth = false; }
                    this._writeBitmapStyle(7 /* LineStyleBitmap */, bitmap, matrix, repeat, smooth, !this._graphicsData.hasLines);
                };
                Graphics.prototype.drawRect = function (x, y, width, height) {
                    x = x * 20 | 0;
                    y = y * 20 | 0;
                    var x2 = x + (width * 20 | 0);
                    var y2 = y + (height * 20 | 0);
                    if (x !== this._lastX || y !== this._lastY) {
                        this._graphicsData.moveTo(x, y);
                    }
                    this._graphicsData.lineTo(x2, y);
                    this._graphicsData.lineTo(x2, y2);
                    this._graphicsData.lineTo(x, y2);
                    this._graphicsData.lineTo(x, y);
                    this._extendBoundsByPoint(x2, y2);
                    this._applyLastCoordinates(x, y);
                    this._invalidate();
                };
                Graphics.prototype.drawRoundRect = function (x, y, width, height, ellipseWidth, ellipseHeight) {
                    x = +x;
                    y = +y;
                    width = +width;
                    height = +height;
                    ellipseWidth = +ellipseWidth;
                    ellipseHeight = +ellipseHeight;
                    if (!ellipseHeight || !ellipseWidth) {
                        this.drawRect(x, y, width, height);
                        return;
                    }
                    var radiusX = (ellipseWidth / 2) | 0;
                    var radiusY = (ellipseHeight / 2) | 0;
                    var hw = width / 2;
                    var hh = height / 2;
                    if (radiusX > hw) {
                        radiusX = hw;
                    }
                    if (radiusY > hh) {
                        radiusY = hh;
                    }
                    if (hw === radiusX && hh === radiusY) {
                        if (radiusX === radiusY) {
                            this.drawCircle(x + radiusX, y + radiusY, radiusX);
                        }
                        else {
                            this.drawEllipse(x, y, radiusX * 2, radiusY * 2);
                        }
                        return;
                    }
                    //    A-----B
                    //  H         C
                    //  G         D
                    //    F-----E
                    //
                    // Drawing starts and stops at `D`. This is visible when the drawn shape forms part of a
                    // larger shape, with which it is then connected at `D`.
                    var right = x + width;
                    var bottom = y + height;
                    var xlw = x + radiusX;
                    var xrw = right - radiusX;
                    var ytw = y + radiusY;
                    var ybw = bottom - radiusY;
                    this.moveTo(right, ybw);
                    this.curveTo(right, bottom, xrw, bottom);
                    this.lineTo(xlw, bottom);
                    this.curveTo(x, bottom, x, ybw);
                    this.lineTo(x, ytw);
                    this.curveTo(x, y, xlw, y);
                    this.lineTo(xrw, y);
                    this.curveTo(right, y, right, ytw);
                    this.lineTo(right, ybw);
                };
                Graphics.prototype.drawRoundRectComplex = function (x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
                    x = +x;
                    y = +y;
                    width = +width;
                    height = +height;
                    topLeftRadius = +topLeftRadius;
                    topRightRadius = +topRightRadius;
                    bottomLeftRadius = +bottomLeftRadius;
                    bottomRightRadius = +bottomRightRadius;
                    if (!(topLeftRadius | topRightRadius | bottomLeftRadius | bottomRightRadius)) {
                        this.drawRect(x, y, width, height);
                        return;
                    }
                    var right = x + width;
                    var bottom = y + height;
                    var xtl = x + topLeftRadius;
                    this.moveTo(right, bottom - bottomRightRadius);
                    this.curveTo(right, bottom, right - bottomRightRadius, bottom);
                    this.lineTo(x + bottomLeftRadius, bottom);
                    this.curveTo(x, bottom, x, bottom - bottomLeftRadius);
                    this.lineTo(x, y + topLeftRadius);
                    this.curveTo(x, y, xtl, y);
                    this.lineTo(right - topRightRadius, y);
                    this.curveTo(right, y, right, y + topRightRadius);
                    this.lineTo(right, bottom - bottomRightRadius);
                };
                Graphics.prototype.drawCircle = function (x, y, radius) {
                    // TODO: Implement these using arcs not ellipses. The latter is not
                    // visually correct when the stroke is very thick and the circle is
                    // very small.
                    radius = +radius;
                    this.drawEllipse(+x - radius, +y - radius, radius * 2, radius * 2);
                };
                /**
                 * Here x and y are the top-left coordinates of the bounding box of the
                 * ellipse not the center as is the case for circles.
                 */
                Graphics.prototype.drawEllipse = function (x, y, width, height) {
                    x = +x;
                    y = +y;
                    width = +width;
                    height = +height;
                    /*
                     *          , - ~ 3 ~ - ,
                     *      , '               ' ,
                     *    ,                       ,
                     *   ,                         ,
                     *  ,                           ,
                     *  2             o             0
                     *  ,                           ,
                     *   ,                         ,
                     *    ,                       ,
                     *      ,                  , '
                     *        ' - , _ 1 _ ,  '
                     */
                    var rx = width / 2;
                    var ry = height / 2;
                    // Move x, y to the middle of the ellipse.
                    x += rx;
                    y += ry;
                    var currentX = x + rx;
                    var currentY = y;
                    this.moveTo(currentX, currentY); // 0
                    var startAngle = 0;
                    var u = 1;
                    var v = 0;
                    for (var i = 0; i < 4; i++) {
                        var endAngle = startAngle + Math.PI / 2;
                        var kappa = (4 / 3) * Math.tan((endAngle - startAngle) / 4);
                        var cp1x = currentX - v * kappa * rx;
                        var cp1y = currentY + u * kappa * ry;
                        u = Math.cos(endAngle);
                        v = Math.sin(endAngle);
                        currentX = x + u * rx;
                        currentY = y + v * ry;
                        var cp2x = currentX + v * kappa * rx;
                        var cp2y = currentY - u * kappa * ry;
                        this.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, currentX, currentY);
                        startAngle = endAngle;
                    }
                };
                Graphics.prototype.moveTo = function (x, y) {
                    x = x * 20 | 0;
                    y = y * 20 | 0;
                    this._graphicsData.moveTo(x, y);
                    // Don't use _applyLastCoordinates because that extends the bounds objects, too.
                    this._lastX = x;
                    this._lastY = y;
                    this._boundsIncludeLastCoordinates = false;
                };
                Graphics.prototype.lineTo = function (x, y) {
                    x = x * 20 | 0;
                    y = y * 20 | 0;
                    this._graphicsData.lineTo(x, y);
                    this._applyLastCoordinates(x, y);
                    this._invalidate();
                };
                Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
                    controlX = controlX * 20 | 0;
                    controlY = controlY * 20 | 0;
                    anchorX = anchorX * 20 | 0;
                    anchorY = anchorY * 20 | 0;
                    this._graphicsData.curveTo(controlX, controlY, anchorX, anchorY);
                    if (controlX < this._lastX || controlX > anchorX) {
                        this._extendBoundsByX(quadraticBezierExtreme(this._lastX, controlX, anchorX) | 0);
                    }
                    if (controlY < this._lastY || controlY > anchorY) {
                        this._extendBoundsByY(quadraticBezierExtreme(this._lastY, controlY, anchorY) | 0);
                    }
                    this._applyLastCoordinates(anchorX, anchorY);
                    this._invalidate();
                };
                Graphics.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
                    controlX1 = controlX1 * 20 | 0;
                    controlY1 = controlY1 * 20 | 0;
                    controlX2 = controlX2 * 20 | 0;
                    controlY2 = controlY2 * 20 | 0;
                    anchorX = anchorX * 20 | 0;
                    anchorY = anchorY * 20 | 0;
                    this._graphicsData.cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY);
                    var extremes;
                    var i;
                    var fromX = this._lastX;
                    var fromY = this._lastY;
                    if (controlX1 < fromX || controlX2 < fromX || controlX1 > anchorX || controlX2 > anchorX) {
                        extremes = cubicBezierExtremes(fromX, controlX1, controlX2, anchorX);
                        for (i = extremes.length; i--;) {
                            this._extendBoundsByX(extremes[i] | 0);
                        }
                    }
                    if (controlY1 < fromY || controlY2 < fromY || controlY1 > anchorY || controlY2 > anchorY) {
                        extremes = cubicBezierExtremes(fromY, controlY1, controlY2, anchorY);
                        for (i = extremes.length; i--;) {
                            this._extendBoundsByY(extremes[i] | 0);
                        }
                    }
                    this._applyLastCoordinates(anchorX, anchorY);
                    this._invalidate();
                };
                Graphics.prototype.copyFrom = function (sourceGraphics) {
                    this._graphicsData = sourceGraphics._graphicsData.clone();
                    this._fillBounds = sourceGraphics._fillBounds.clone();
                    this._lineBounds = sourceGraphics._lineBounds.clone();
                    this._textures = sourceGraphics._textures.concat();
                    this._lastX = sourceGraphics._lastX;
                    this._lastY = sourceGraphics._lastY;
                    this._boundsIncludeLastCoordinates = sourceGraphics._boundsIncludeLastCoordinates;
                    this._invalidate();
                };
                //    lineShaderStyle(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                //      //shader = shader; matrix = matrix;
                //      release || notImplemented("public flash.display.Graphics::lineShaderStyle"); return;
                //    }
                Graphics.prototype.drawPath = function (commands, data, winding) {
                    if (winding === void 0) { winding = "evenOdd"; }
                    commands = commands;
                    data = data;
                    winding = winding;
                    release || notImplemented("public flash.display.Graphics::drawPath");
                    return;
                };
                Graphics.prototype.drawTriangles = function (vertices, indices, uvtData, culling) {
                    if (indices === void 0) { indices = null; }
                    if (uvtData === void 0) { uvtData = null; }
                    if (culling === void 0) { culling = "none"; }
                    vertices = vertices;
                    indices = indices;
                    uvtData = uvtData;
                    culling = culling;
                    release || notImplemented("public flash.display.Graphics::drawTriangles");
                    return;
                };
                Graphics.prototype.drawGraphicsData = function (graphicsData) {
                    graphicsData = graphicsData;
                    release || notImplemented("public flash.display.Graphics::drawGraphicsData");
                    return;
                };
                /**
                 * Tests if the specified point is within this graphics path.
                 */
                Graphics.prototype._containsPoint = function (x, y, includeLines, ratio) {
                    var hasLines = this._graphicsData.hasLines;
                    if (!ratio && !(includeLines && hasLines ? this._lineBounds : this._fillBounds).contains(x, y)) {
                        return false;
                    }
                    //      enterTimeline("Graphics._containsPoint");
                    var containsPoint = false;
                    // If we have any fills at all, tt's vastly more likely that the point is in a fill,
                    // so test that first.
                    if (this._graphicsData.hasFills) {
                        containsPoint = this._fillContainsPoint(x, y, ratio);
                    }
                    else {
                        release || assert(hasLines, "Can't have non-empty bounds without line or fill set.");
                    }
                    if (!containsPoint && includeLines) {
                        containsPoint = this._linesContainsPoint(x, y, ratio);
                    }
                    //      leaveTimeline();
                    return containsPoint;
                };
                Graphics.prototype._fillContainsPoint = function (x, y, ratio) {
                    //      enterTimeline("Graphics._fillContainsPoint");
                    var data = this._graphicsData;
                    var commands = data.commands;
                    var commandsCount = data.commandsPosition;
                    var coordinates = data.coordinates;
                    var morphCoordinates = data.morphCoordinates;
                    var coordinatesIndex = 0;
                    var fromX = 0;
                    var fromY = 0;
                    var toX = 0;
                    var toY = 0;
                    var cpX;
                    var cpY;
                    var formOpen = false;
                    var fillActive = false;
                    var formOpenX = 0;
                    var formOpenY = 0;
                    var inside = false;
                    // Description of serialization format can be found in ShapeData.
                    // Rough outline of the algorithm's mode of operation:
                    // from x,y an infinite ray to the right is "cast". All operations are then
                    // tested for intersections with this ray, where each intersection means
                    // switching between being outside and inside the shape.
                    var commandIndex;
                    for (commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                        var command = commands[commandIndex];
                        switch (command) {
                            case 9 /* MoveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                if (formOpen && fillActive &&
                                    rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                    inside = !inside;
                                }
                                formOpen = true;
                                fromX = formOpenX = coordinates[coordinatesIndex++];
                                fromY = formOpenY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    fromX = formOpenX += (morphCoordinates[coordinatesIndex - 2] - formOpenX) * ratio;
                                    fromY = formOpenY += (morphCoordinates[coordinatesIndex - 2] - formOpenY) * ratio;
                                }
                                // Continue outer loop.
                                continue;
                            case 10 /* LineTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                if (fillActive && rayIntersectsLine(x, y, fromX, fromY, toX, toY)) {
                                    inside = !inside;
                                }
                                break;
                            case 11 /* CurveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                cpX = coordinates[coordinatesIndex++];
                                cpY = coordinates[coordinatesIndex++];
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    cpX += (morphCoordinates[coordinatesIndex - 4] - cpX) * ratio;
                                    cpY += (morphCoordinates[coordinatesIndex - 3] - cpY) * ratio;
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                if (fillActive && rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY)) {
                                    inside = !inside;
                                }
                                break;
                            case 12 /* CubicCurveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                cpX = coordinates[coordinatesIndex++];
                                cpY = coordinates[coordinatesIndex++];
                                var cp2X = coordinates[coordinatesIndex++];
                                var cp2Y = coordinates[coordinatesIndex++];
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    cpX += (morphCoordinates[coordinatesIndex - 6] - cpX) * ratio;
                                    cpY += (morphCoordinates[coordinatesIndex - 5] - cpY) * ratio;
                                    cp2X += (morphCoordinates[coordinatesIndex - 4] - cp2X) * ratio;
                                    cp2Y += (morphCoordinates[coordinatesIndex - 3] - cp2Y) * ratio;
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                if (fillActive &&
                                    rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY)) {
                                    inside = !inside;
                                }
                                break;
                            case 1 /* BeginSolidFill */:
                            case 2 /* BeginGradientFill */:
                            case 3 /* BeginBitmapFill */:
                            case 4 /* EndFill */:
                                if (formOpen && fillActive &&
                                    rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                    inside = !inside;
                                }
                                // If we close a sub-shape, we can return earlier if our point was inside of its path.
                                if (inside) {
                                    return true;
                                }
                                formOpen = false;
                                fillActive = command !== 4 /* EndFill */;
                                break;
                            case 5 /* LineStyleSolid */:
                                coordinatesIndex++; // Skip thickness
                                break;
                            case 6 /* LineStyleGradient */:
                            case 7 /* LineStyleBitmap */:
                            case 8 /* LineEnd */:
                                break;
                            default:
                                release || assertUnreachable('Invalid command ' + command + ' encountered at index' +
                                    (commandIndex - 1) + ' of ' + commandsCount);
                        }
                        fromX = toX;
                        fromY = toY;
                    }
                    release || assert(commandIndex === commandsCount);
                    release || assert(coordinatesIndex === data.coordinatesPosition);
                    if (formOpen && fillActive &&
                        rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                        inside = !inside;
                    }
                    //      leaveTimeline();
                    return inside;
                };
                Graphics.prototype._linesContainsPoint = function (x, y, ratio) {
                    //      enterTimeline("Graphics._lineContainsPoint");
                    var data = this._graphicsData;
                    var commands = data.commands;
                    var commandsCount = data.commandsPosition;
                    var coordinates = data.coordinates;
                    var morphCoordinates = data.morphCoordinates;
                    var coordinatesIndex = 0;
                    var fromX = 0;
                    var fromY = 0;
                    var toX = 0;
                    var toY = 0;
                    var cpX;
                    var cpY;
                    var curveX;
                    var curveY;
                    var t;
                    var width = 0;
                    var halfWidth = 0;
                    var halfWidthSq = 0;
                    var minX = 0;
                    var maxX = 0;
                    var minY = 0;
                    var maxY = 0;
                    // Description of serialization format can be found in ShapeData.
                    var commandIndex;
                    for (commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                        var command = commands[commandIndex];
                        switch (command) {
                            case 9 /* MoveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                fromX = coordinates[coordinatesIndex++];
                                fromY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                    fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                }
                                // Continue outer loop.
                                continue;
                            case 10 /* LineTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                if (width === 0) {
                                    fromX = coordinates[coordinatesIndex++];
                                    fromY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                        fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                    }
                                    continue;
                                }
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                // Lines with length == 0 aren't rendered.
                                if (fromX === toX && fromY === toY) {
                                    break;
                                }
                                // Eliminate based on bounds.
                                if (maxX < fromX && maxX < toX || minX > fromX && minX > toX ||
                                    maxY < fromY && maxY < toY || minY > fromY && minY > toY) {
                                    break;
                                }
                                // Vertical and horizontal lines are a certain hit at this point
                                if (toX === fromX || toY === fromY) {
                                    return true;
                                }
                                // http://stackoverflow.com/a/1501725/517791
                                t = ((x - fromX) * (toX - fromX) + (y - fromY) * (toY - fromY)) /
                                    distanceSq(fromX, fromY, toX, toY);
                                if (t < 0) {
                                    if (distanceSq(x, y, fromX, fromY) <= halfWidthSq) {
                                        return true;
                                    }
                                    break;
                                }
                                if (t > 1) {
                                    if (distanceSq(x, y, toX, toY) <= halfWidthSq) {
                                        return true;
                                    }
                                    break;
                                }
                                if (distanceSq(x, y, fromX + t * (toX - fromX), fromY + t * (toY - fromY)) <= halfWidthSq) {
                                    return true;
                                }
                                break;
                            case 11 /* CurveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                if (width === 0) {
                                    coordinatesIndex += 2;
                                    fromX = coordinates[coordinatesIndex++];
                                    fromY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                        fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                    }
                                    continue;
                                }
                                cpX = coordinates[coordinatesIndex++];
                                cpY = coordinates[coordinatesIndex++];
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    cpX += (morphCoordinates[coordinatesIndex - 4] - cpX) * ratio;
                                    cpY += (morphCoordinates[coordinatesIndex - 3] - cpY) * ratio;
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                // Eliminate based on bounds
                                var extremeX = quadraticBezierExtreme(fromX, cpX, toX);
                                if (maxX < fromX && maxX < extremeX && maxX < toX ||
                                    minX > fromX && minX > extremeX && minX > toX) {
                                    break;
                                }
                                var extremeY = quadraticBezierExtreme(fromY, cpY, toY);
                                if (maxY < fromY && maxY < extremeY && maxY < toY ||
                                    minY > fromY && minY > extremeY && minY > toY) {
                                    break;
                                }
                                // So, this is very much not ideal, but I'll punt on proper curve
                                // hit-testing for now and just sample an amount of points that seems
                                // sufficient.
                                for (t = 0; t < 1; t += 0.02) {
                                    curveX = quadraticBezier(fromX, cpX, toX, t);
                                    if (curveX < minX || curveX > maxX) {
                                        continue;
                                    }
                                    curveY = quadraticBezier(fromY, cpY, toY, t);
                                    if (curveY < minY || curveY > maxY) {
                                        continue;
                                    }
                                    if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                        return true;
                                    }
                                }
                                break;
                            case 12 /* CubicCurveTo */:
                                release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                if (width === 0) {
                                    coordinatesIndex += 4;
                                    fromX = coordinates[coordinatesIndex++];
                                    fromX = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                        fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                    }
                                    continue;
                                }
                                cpX = coordinates[coordinatesIndex++];
                                cpY = coordinates[coordinatesIndex++];
                                var cp2X = coordinates[coordinatesIndex++];
                                var cp2Y = coordinates[coordinatesIndex++];
                                toX = coordinates[coordinatesIndex++];
                                toY = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    cpX += (morphCoordinates[coordinatesIndex - 6] - cpX) * ratio;
                                    cpY += (morphCoordinates[coordinatesIndex - 5] - cpY) * ratio;
                                    cp2X += (morphCoordinates[coordinatesIndex - 4] - cp2X) * ratio;
                                    cp2Y += (morphCoordinates[coordinatesIndex - 3] - cp2Y) * ratio;
                                    toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                    toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                }
                                // Eliminate based on bounds
                                var extremesX = cubicBezierExtremes(fromX, cpX, cp2X, toX);
                                while (extremesX.length < 2) {
                                    extremesX.push(toX);
                                }
                                if (maxX < fromX && maxX < toX && maxX < extremesX[0] &&
                                    maxX < extremesX[1] ||
                                    minX > fromX && minX > toX && minX > extremesX[0] &&
                                        minX > extremesX[1]) {
                                    break;
                                }
                                var extremesY = cubicBezierExtremes(fromY, cpY, cp2Y, toY);
                                while (extremesY.length < 2) {
                                    extremesY.push(toY);
                                }
                                if (maxY < fromY && maxY < toY && maxY < extremesY[0] &&
                                    maxY < extremesY[1] ||
                                    minY > fromY && minY > toY && minY > extremesY[0] &&
                                        minY > extremesY[1]) {
                                    break;
                                }
                                // So, this is very much not ideal, but I'll punt on proper curve
                                // hit-testing for now and just sample an amount of points that seems
                                // sufficient.
                                for (t = 0; t < 1; t += 0.02) {
                                    curveX = cubicBezier(fromX, cpX, cp2X, toX, t);
                                    if (curveX < minX || curveX > maxX) {
                                        continue;
                                    }
                                    curveY = cubicBezier(fromY, cpY, cp2Y, toY, t);
                                    if (curveY < minY || curveY > maxY) {
                                        continue;
                                    }
                                    if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                        return true;
                                    }
                                }
                                break;
                            case 5 /* LineStyleSolid */:
                                width = coordinates[coordinatesIndex++];
                                if (ratio) {
                                    width += (morphCoordinates[coordinatesIndex - 1] - width) * ratio;
                                }
                                halfWidth = width >> 2;
                                halfWidthSq = halfWidth * halfWidth;
                                minX = x - halfWidth;
                                maxX = x + halfWidth;
                                minY = y - halfWidth;
                                maxY = y + halfWidth;
                                break;
                            case 1 /* BeginSolidFill */:
                            case 2 /* BeginGradientFill */:
                            case 3 /* BeginBitmapFill */:
                            case 4 /* EndFill */:
                            case 6 /* LineStyleGradient */:
                            case 7 /* LineStyleBitmap */:
                            case 8 /* LineEnd */:
                                break;
                            default:
                                release || assertUnreachable('Invalid command ' + command + ' encountered at index' +
                                    (commandIndex - 1) + ' of ' + commandsCount);
                        }
                        fromX = toX;
                        fromY = toY;
                    }
                    release || assert(commandIndex === commandsCount);
                    release || assert(coordinatesIndex === data.coordinatesPosition);
                    //      leaveTimeline();
                    return false;
                };
                /**
                 * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
                 * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                 * be one of PathCommand.BeginBitmapFill and PathCommand.LineStyleBitmap.
                 *
                 * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                 * case, it only does arguments checks so the right exceptions are thrown.
                 */
                Graphics.prototype._writeBitmapStyle = function (pathCommand, bitmap, matrix, repeat, smooth, skipWrite) {
                    if (Shumway.isNullOrUndefined(bitmap)) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'bitmap');
                    }
                    if (!(this._sec.display.BitmapData.axIsType(bitmap))) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'bitmap', 'flash.display.BitmapData');
                    }
                    if (Shumway.isNullOrUndefined(matrix)) {
                        matrix = this._sec.geom.FROZEN_IDENTITY_MATRIX;
                    }
                    else if (!(this._sec.geom.Matrix.axIsType(matrix))) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                    }
                    repeat = !!repeat;
                    smooth = !!smooth;
                    if (skipWrite) {
                        return;
                    }
                    var index = this._textures.length;
                    this._textures.push(bitmap);
                    this._graphicsData.beginBitmap(pathCommand, index, matrix, repeat, smooth);
                };
                /**
                 * Gradients are specified the same for fills and strokes, so we only need to serialize them
                 * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                 * be one of PathCommand.BeginGradientFill and PathCommand.LineStyleGradient.
                 *
                 * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                 * case, it only does arguments checks so the right exceptions are thrown.
                 */
                Graphics.prototype._writeGradientStyle = function (pathCommand, type, colors_, alphas_, ratios_, matrix, spreadMethod, interpolationMethod, focalPointRatio, skipWrite) {
                    if (Shumway.isNullOrUndefined(type)) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'type');
                    }
                    var gradientType = GradientType.toNumber(type);
                    if (gradientType < 0) {
                        this._sec.throwError("ArgumentError", Shumway.Errors.InvalidEnumError, "type");
                    }
                    if (Shumway.isNullOrUndefined(colors_)) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'colors');
                    }
                    if (!(colors_ instanceof Array)) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'colors', 'Array');
                    }
                    var colors = colors_;
                    if (Shumway.isNullOrUndefined(alphas_)) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'alphas');
                    }
                    if (!(alphas_ instanceof Array)) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'alphas', 'Array');
                    }
                    var alphas = alphas_;
                    if (Shumway.isNullOrUndefined(ratios_)) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'ratios');
                    }
                    if (!(ratios_ instanceof Array)) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'ratios', 'Array');
                    }
                    var ratios = ratios_;
                    var colorsRGBA = [];
                    var coercedRatios = [];
                    var colorStops = colors.length;
                    var recordsValid = colorStops === alphas.length && colorStops === ratios.length;
                    if (recordsValid) {
                        for (var i = 0; i < colorStops; i++) {
                            var ratio = +ratios[i];
                            if (ratio > 0xff || ratio < 0) {
                                recordsValid = false;
                                break;
                            }
                            colorsRGBA[i] = (colors[i] << 8 & 0xffffff00) | clamp(+alphas[i], 0, 1) * 0xff;
                            coercedRatios[i] = ratio;
                        }
                    }
                    // If the colors, alphas and ratios arrays don't all have the same length or if any of the
                    // given ratios falls outside [0,0xff], Flash just ignores the gradient style.
                    if (!recordsValid) {
                        return;
                    }
                    if (Shumway.isNullOrUndefined(matrix)) {
                        matrix = this._sec.geom.FROZEN_IDENTITY_MATRIX;
                    }
                    else if (!(this._sec.geom.Matrix.axIsType(matrix))) {
                        this._sec.throwError('TypeError', Shumway.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                    }
                    if (skipWrite) {
                        return;
                    }
                    // If `spreadMethod` is invalid, "pad" is used.
                    var spread = SpreadMethod.toNumber(spreadMethod);
                    if (spread < 0) {
                        spread = SpreadMethod.toNumber(SpreadMethod.PAD);
                    }
                    // If `interpolationMethod` is invalid, "rgb" is used.
                    var interpolation = InterpolationMethod.toNumber(interpolationMethod);
                    if (interpolation < 0) {
                        interpolation = InterpolationMethod.toNumber(InterpolationMethod.RGB);
                    }
                    // Matrix has to be transformed to ShapeMatrix because the scaling is totally different.
                    var scaledMatrix = {
                        a: matrix.a * 819.2, b: matrix.b * 819.2, c: matrix.c * 819.2,
                        d: matrix.d * 819.2, tx: matrix.tx, ty: matrix.ty
                    };
                    // Focal point is scaled by 0xff, divided by 2, rounded and stored as a signed short.
                    focalPointRatio = clamp(+focalPointRatio, -1, 1) / 2 * 0xff | 0;
                    this._graphicsData.beginGradient(pathCommand, colorsRGBA, coercedRatios, gradientType, scaledMatrix, spread, interpolation, focalPointRatio);
                };
                Graphics.prototype._extendBoundsByPoint = function (x, y) {
                    this._extendBoundsByX(x);
                    this._extendBoundsByY(y);
                };
                Graphics.prototype._extendBoundsByX = function (x) {
                    this._fillBounds.extendByX(x);
                    var bounds = this._lineBounds;
                    if (bounds.xMin === 0x8000000) {
                        bounds.xMin = x - this._topLeftStrokeWidth;
                        bounds.xMax = x + this._bottomRightStrokeWidth;
                    }
                    else {
                        bounds.xMin = Math.min(x - this._topLeftStrokeWidth, bounds.xMin);
                        bounds.xMax = Math.max(x + this._bottomRightStrokeWidth, bounds.xMax);
                    }
                };
                Graphics.prototype._extendBoundsByY = function (y) {
                    this._fillBounds.extendByY(y);
                    var bounds = this._lineBounds;
                    if (bounds.yMin === 0x8000000) {
                        bounds.yMin = y - this._topLeftStrokeWidth;
                        bounds.yMax = y + this._bottomRightStrokeWidth;
                    }
                    else {
                        bounds.yMin = Math.min(y - this._topLeftStrokeWidth, bounds.yMin);
                        bounds.yMax = Math.max(y + this._bottomRightStrokeWidth, bounds.yMax);
                    }
                };
                Graphics.prototype._applyLastCoordinates = function (x, y) {
                    if (!this._boundsIncludeLastCoordinates) {
                        this._extendBoundsByPoint(this._lastX, this._lastY);
                    }
                    this._boundsIncludeLastCoordinates = true;
                    this._lastX = x;
                    this._lastY = y;
                    this._extendBoundsByPoint(x, y);
                };
                return Graphics;
            }(flash.LegacyEntity));
            display.Graphics = Graphics;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Sprite
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var Timeline = Shumway.Timeline;
            var clamp = Shumway.NumberUtilities.clamp;
            var DragMode;
            (function (DragMode) {
                DragMode[DragMode["Inactive"] = 0] = "Inactive";
                // Indicates that the dragged object is locked to the center of the mouse position.
                DragMode[DragMode["LockToPointer"] = 1] = "LockToPointer";
                // Indicates that the dragged object is locked to the point where the dragging process started.
                DragMode[DragMode["PreserveDistance"] = 2] = "PreserveDistance";
            })(DragMode || (DragMode = {}));
            var Sprite = /** @class */ (function (_super) {
                __extends(Sprite, _super);
                function Sprite() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    _this._constructChildren();
                    return _this;
                }
                Sprite.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    this._initializeFields();
                    var symbol = this._symbol;
                    if (symbol.isRoot) {
                        this._root = this;
                    }
                    this._children = [];
                    if (symbol.numFrames && symbol.frames.length > 0) {
                        // For a SWF's root symbol, all frames are added after initialization, with
                        // _initializeChildren called after the first frame is added.
                        this._initializeChildren(symbol.frames[0]);
                    }
                };
                Sprite.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                Sprite.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._graphics = null;
                    this._buttonMode = false;
                    this._dropTarget = null;
                    this._hitArea = null;
                    this._useHandCursor = true;
                    this._dragMode = DragMode.Inactive;
                    this._dragDeltaX = 0;
                    this._dragDeltaY = 0;
                    this._dragBounds = null;
                    this._hitTarget = null;
                };
                Sprite.prototype._addFrame = function (frame) {
                    var frames = this._symbol.frames;
                    frames.push(frame);
                    if (frames.length === 1) {
                        this._initializeChildren(frame);
                    }
                };
                Sprite.prototype._initializeChildren = function (frame) {
                    if (frame.controlTags) {
                        this._processControlTags(frame.controlTags, false);
                    }
                };
                Sprite.prototype._processControlTags = function (tags, backwards) {
                    // When seeking backwards all timeline objects will be removed unless they are placed again.
                    if (backwards) {
                        var children = this._children.concat();
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            if (child._depth < 0) {
                                continue;
                            }
                            // For AVM1 objects, children with depth 16384 (0 from API point of view)
                            // are not removed.
                            if ('_as2Object' in child && child._depth >= 16384) {
                                continue;
                            }
                            var tag = null;
                            // Look for a control tag tag that places an object at the same depth as the current
                            // child.
                            for (var j = 0; j < tags.length; j++) {
                                if (tags[j].depth === child._depth) {
                                    tag = tags[j];
                                    break;
                                }
                            }
                            // If no such tag was found or a different object is placed, remove the current child.
                            if (!tag || child._symbol.id !== tag.symbolId || child._ratio !== (tag.ratio | 0)) {
                                this._removeAnimatedChild(child);
                            }
                        }
                    }
                    var loaderInfo = this._symbol.loaderInfo;
                    for (var i = 0; i < tags.length; i++) {
                        // We may have a mix of the parsed and unparsed tags.
                        var parsedOrUnparsedTag = tags[i];
                        var tag = parsedOrUnparsedTag.tagCode === undefined ?
                            parsedOrUnparsedTag : loaderInfo._file.getParsedTag(parsedOrUnparsedTag);
                        switch (tag.code) {
                            case 5 /* CODE_REMOVE_OBJECT */:
                            case 28 /* CODE_REMOVE_OBJECT2 */:
                                var child = this.getTimelineObjectAtDepth(tag.depth | 0);
                                if (child) {
                                    this._removeAnimatedChild(child);
                                }
                                break;
                            case 4 /* CODE_PLACE_OBJECT */:
                            case 26 /* CODE_PLACE_OBJECT2 */:
                            case 70 /* CODE_PLACE_OBJECT3 */:
                                var placeObjectTag = tag;
                                var depth = placeObjectTag.depth;
                                child = this.getTimelineObjectAtDepth(depth);
                                var hasCharacter = placeObjectTag.symbolId > -1;
                                // Check for invalid flag constellations.
                                if (placeObjectTag.flags & 1 /* Move */) {
                                    // Invalid case 1: Move flag set but no child found at given depth.
                                    if (!child) {
                                        //  Ignore the current tag.
                                        break;
                                    }
                                }
                                else if (!hasCharacter || (child && !(backwards && hasCharacter))) {
                                    // Invalid case 2: Neither Move nor HasCharacter flag set.
                                    // Invalid case 3: HasCharacter flag set but given depth is already occupied by a
                                    // another object (only if seeking forward).
                                    Shumway.Debug.warning("Warning: Failed to place object at depth " + depth + ".");
                                    break;
                                }
                                var symbol = null;
                                if (hasCharacter) {
                                    symbol = loaderInfo.getSymbolById(placeObjectTag.symbolId);
                                    // The Flash Player ignores references to undefined symbols here. So should we.
                                    if (!symbol) {
                                        break;
                                    }
                                }
                                if (child) {
                                    if (symbol && !symbol.dynamic) {
                                        // If the current object is of a simple type (for now Shapes, MorphShapes and
                                        // StaticText) only its static content is updated instead of replacing it with a
                                        // new instance. TODO: Handle
                                        // http://wahlers.com.br/claus/blog/hacking-swf-2-placeobject-and-ratio/.
                                        child._setStaticContentFromSymbol(symbol);
                                    }
                                    // We animate the object only if a user script didn't touch any of the properties
                                    // this would affect.
                                    if (child._hasFlags(4096 /* AnimatedByTimeline */)) {
                                        child._animate(tag);
                                    }
                                }
                                else {
                                    // Place a new instance of the symbol.
                                    child = this.createAnimatedDisplayObject(symbol, placeObjectTag, false);
                                    this.addTimelineObjectAtDepth(child, depth);
                                    if (symbol.isAVM1Object) {
                                        child._placeObjectTag = placeObjectTag;
                                        child._setFlags(131072 /* HasPlaceObjectInitPending */);
                                    }
                                }
                                break;
                        }
                    }
                };
                Sprite.prototype._removeAnimatedChild = function (child) {
                    this.removeChild(child);
                    if (child._name) {
                        if (this.axGetPublicProperty(child._name) === child) {
                            this.axSetPublicProperty(child._name, null);
                        }
                        // TODO: Implement proper reference counting.
                        // child._removeReference();
                    }
                    if (child._maskedObject) {
                        child._maskedObject.mask = null;
                    }
                };
                Sprite.prototype._canHaveGraphics = function () {
                    return true;
                };
                Sprite.prototype._getGraphics = function () {
                    return this._graphics;
                };
                Object.defineProperty(Sprite.prototype, "graphics", {
                    get: function () {
                        return this._ensureGraphics();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sprite.prototype, "buttonMode", {
                    get: function () {
                        return this._buttonMode;
                    },
                    set: function (value) {
                        this._buttonMode = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sprite.prototype, "dropTarget", {
                    get: function () {
                        return this._dropTarget;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sprite.prototype, "hitArea", {
                    get: function () {
                        return this._hitArea;
                    },
                    set: function (value) {
                        value = value;
                        if (this._hitArea === value) {
                            return;
                        }
                        if (value && value._hitTarget) {
                            value._hitTarget._hitArea = null;
                        }
                        this._hitArea = value;
                        if (value) {
                            value._hitTarget = this;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sprite.prototype, "useHandCursor", {
                    get: function () {
                        return this._useHandCursor;
                    },
                    set: function (value) {
                        this._useHandCursor = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sprite.prototype, "soundTransform", {
                    get: function () {
                        release || notImplemented("public flash.display.Sprite::get soundTransform");
                        return null;
                        // return this._soundTransform;
                    },
                    set: function (sndTransform) {
                        sndTransform = sndTransform;
                        release || notImplemented("public flash.display.Sprite::set soundTransform");
                        return;
                        // this._soundTransform = sndTransform;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Returns the current mouse position relative to this object.
                 */
                Sprite.prototype._getDragMousePosition = function () {
                    var position = this._sec.ui.Mouse._currentPosition;
                    if (this._parent) {
                        position = this._parent.globalToLocal(position);
                    }
                    return position;
                };
                Sprite.prototype.startDrag = function (lockCenter, bounds) {
                    if (lockCenter === void 0) { lockCenter = false; }
                    if (bounds === void 0) { bounds = null; }
                    lockCenter = !!lockCenter;
                    if (lockCenter) {
                        this._dragMode = DragMode.LockToPointer;
                    }
                    else {
                        this._dragMode = DragMode.PreserveDistance;
                        var mousePosition = this._getDragMousePosition();
                        this._dragDeltaX = this.x - mousePosition.x;
                        this._dragDeltaY = this.y - mousePosition.y;
                    }
                    this._dragBounds = bounds;
                    // TODO: Our mouse handling logic looks up draggableObject on stage.sec.flash.ui.Mouse.axClass
                    // to update its position. Could there be a case where stage.sec !== this.sec?
                    this._sec.ui.Mouse.draggableObject = this;
                };
                Sprite.prototype.stopDrag = function () {
                    var mouse = this._sec.ui.Mouse;
                    if (mouse.draggableObject === this) {
                        mouse.draggableObject = null;
                        this._dragMode = DragMode.Inactive;
                        this._dragDeltaX = 0;
                        this._dragDeltaY = 0;
                        this._dragBounds = null;
                    }
                };
                Sprite.prototype._updateDragState = function (dropTarget) {
                    if (dropTarget === void 0) { dropTarget = null; }
                    var mousePosition = this._getDragMousePosition();
                    var newX = mousePosition.x;
                    var newY = mousePosition.y;
                    if (this._dragMode === DragMode.PreserveDistance) {
                        // Preserve the distance to the point where the dragging process started.
                        newX += this._dragDeltaX;
                        newY += this._dragDeltaY;
                    }
                    if (this._dragBounds) {
                        // Clamp new position to constraint bounds.
                        var bounds = this._dragBounds;
                        newX = clamp(newX, bounds.left, bounds.right);
                        newY = clamp(newY, bounds.top, bounds.bottom);
                    }
                    this.x = newX;
                    this.y = newY;
                    this._dropTarget = dropTarget;
                };
                Sprite.prototype.startTouchDrag = function (touchPointID /*int*/, lockCenter, bounds) {
                    if (lockCenter === void 0) { lockCenter = false; }
                    if (bounds === void 0) { bounds = null; }
                    touchPointID = touchPointID | 0;
                    lockCenter = !!lockCenter;
                    bounds = bounds;
                    release || notImplemented("public flash.display.Sprite::startTouchDrag");
                    return;
                };
                Sprite.prototype.stopTouchDrag = function (touchPointID /*int*/) {
                    touchPointID = touchPointID | 0;
                    release || notImplemented("public flash.display.Sprite::stopTouchDrag");
                    return;
                };
                Sprite.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                    // If looking for a drop target, ignore this object if it is the one being dragged.
                    if (testingType === 5 /* Drop */ && this._dragMode > DragMode.Inactive) {
                        // AMBIGUOUS
                        return 0 /* None */;
                    }
                    var result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                    if (!result && testingType === 3 /* Mouse */ && this._hitArea && this._mouseEnabled) {
                        var matrix = this._hitArea._getInvertedConcatenatedMatrix();
                        var hitAreaLocalX = matrix.transformX(globalX, globalY);
                        var hitAreaLocalY = matrix.transformY(globalX, globalY);
                        result = this._hitArea._boundsAndMaskContainPoint(globalX, globalY, hitAreaLocalX, hitAreaLocalY, testingType);
                    }
                    if (result === 0 /* None */ || testingType < 2 /* HitTestShape */) {
                        return result;
                    }
                    return this._containsPointImpl(globalX, globalY, localX, localY, testingType, objects, true);
                };
                Sprite.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    if (this._hitArea) {
                        return !!this._hitArea._containsGlobalPoint(globalX, globalY, 2 /* HitTestShape */, null);
                    }
                    var graphics = this._getGraphics();
                    return !!graphics && graphics._containsPoint(localX, localY, true, 0);
                };
                Sprite.classInitializer = null;
                // List of static symbols to link.
                Sprite.classSymbols = null; // [];
                // List of instance symbols to link.
                Sprite.instanceSymbols = null; // [];
                return Sprite;
            }(flash.display.DisplayObjectContainer));
            display.Sprite = Sprite;
            var SpriteSymbol = /** @class */ (function (_super) {
                __extends(SpriteSymbol, _super);
                function SpriteSymbol(data, loaderInfo) {
                    var _this = _super.call(this, data, loaderInfo.app._sec.display.MovieClip, true) || this;
                    _this.numFrames = 1;
                    _this.frames = [];
                    _this.labels = [];
                    _this.loaderInfo = loaderInfo;
                    return _this;
                }
                SpriteSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new SpriteSymbol(data, loaderInfo);
                    symbol.numFrames = data.frameCount;
                    if (loaderInfo.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                        symbol.isAVM1Object = true;
                        symbol.avm1Context = loaderInfo._avm1Context;
                    }
                    var frames = data.frames;
                    var frameLabelCtor = loaderInfo.app._sec.display.FrameLabel;
                    for (var i = 0; i < frames.length; i++) {
                        var frame = loaderInfo.getFrame(data, i);
                        if (frame.labelName) {
                            symbol.labels.push(frameLabelCtor.create([frame.labelName, i + 1]));
                        }
                        symbol.frames.push(frame);
                    }
                    return symbol;
                };
                return SpriteSymbol;
            }(Timeline.DisplaySymbol));
            display.SpriteSymbol = SpriteSymbol;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MovieClip
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display_1) {
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var Telemetry = Shumway.Telemetry;
            var events = flash.events;
            //@ivanpopelyshev: AVM1
            var AVM1 = null;
            /**
             * Controls how to behave on inter-frame navigation.
             */
            var FrameNavigationModel;
            (function (FrameNavigationModel) {
                FrameNavigationModel[FrameNavigationModel["SWF1"] = 1] = "SWF1";
                FrameNavigationModel[FrameNavigationModel["SWF9"] = 9] = "SWF9";
                FrameNavigationModel[FrameNavigationModel["SWF10"] = 10] = "SWF10";
            })(FrameNavigationModel = display_1.FrameNavigationModel || (display_1.FrameNavigationModel = {}));
            var MovieClipSoundsManager = /** @class */ (function () {
                function MovieClipSoundsManager(mc) {
                    this._mc = mc;
                    this._startSoundRegistrations = null;
                    this._soundStream = null;
                }
                MovieClipSoundsManager.prototype.registerStartSounds = function (frameNum, soundStartInfo) {
                    if (this._startSoundRegistrations === null) {
                        this._startSoundRegistrations = {};
                    }
                    this._startSoundRegistrations[frameNum] = soundStartInfo;
                };
                MovieClipSoundsManager.prototype.initSoundStream = function (streamInfo) {
                    this._soundStream = new display_1.MovieClipSoundStream(streamInfo, this._mc);
                };
                MovieClipSoundsManager.prototype.addSoundStreamBlock = function (frameNum, streamBlock) {
                    if (this._soundStream) {
                        this._soundStream.appendBlock(frameNum, streamBlock);
                    }
                };
                MovieClipSoundsManager.prototype._startSounds = function (frameNum) {
                    var starts = this._startSoundRegistrations[frameNum];
                    if (starts) {
                        var sounds = this._soundClips || (this._soundClips = {});
                        var loaderInfo = this._mc.loaderInfo;
                        for (var i = 0; i < starts.length; i++) {
                            var start = starts[i];
                            var symbolId = start.soundId;
                            var info = start.soundInfo;
                            var sound = sounds[symbolId];
                            if (!sound) {
                                var symbolInfo = loaderInfo.getSymbolById(symbolId);
                                if (!symbolInfo) {
                                    continue;
                                }
                                var symbolClass = symbolInfo.symbolClass;
                                var soundObj = flash.system.constructClassFromSymbol(symbolInfo, symbolClass);
                                sounds[symbolId] = sound = { object: soundObj };
                            }
                            var stop_2 = info.flags & 32 /* Stop */;
                            if (sound.channel && stop_2) {
                                sound.channel.stop();
                                sound.channel = null;
                            }
                            if (!stop_2 && (!sound.channel || !sound.channel.playing)) {
                                // TODO envelope, in/out point
                                var loops = (info.flags & 4 /* HasLoops */) !== 0 ? info.loopCount : 0;
                                sound.channel = sound.object.play(0, loops);
                            }
                        }
                    }
                };
                MovieClipSoundsManager.prototype.syncSounds = function (frameNum) {
                    if (this._startSoundRegistrations !== null) {
                        this._startSounds(frameNum);
                    }
                    if (this._soundStream) {
                        this._soundStream.playFrame(frameNum);
                    }
                };
                return MovieClipSoundsManager;
            }());
            var MovieClip = /** @class */ (function (_super) {
                __extends(MovieClip, _super);
                function MovieClip() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    return _this;
                }
                MovieClip.prototype.applySymbol = function () {
                    _super.prototype.applySymbol.call(this);
                    this._sec.display._advancableInstances.push(this);
                    var symbol = this._symbol;
                    this._totalFrames = symbol.numFrames;
                    this._currentFrame = 1;
                    if (!symbol.isRoot) {
                        this.addScene('', symbol.labels, 0, symbol.numFrames);
                    }
                    this._frames = symbol.frames;
                    if (symbol.isAVM1Object) {
                        if (symbol.avm1Name) {
                            this.name = symbol.avm1Name;
                        }
                    }
                };
                // This method is called when children are being constructed and AVM1 scripts
                // is about to be run.
                MovieClip.prototype._initAvm1Data = function () {
                    var symbol = this._symbol;
                    var frames = symbol.frames;
                    if (frames) {
                        for (var i = 0; i < frames.length; i++) {
                            var frameInfo = frames[i];
                            this._initAvm1FrameData(i, frameInfo);
                        }
                    }
                };
                // Adds missing AVM1 scripts data to the AS3 object frameScripts and events.
                MovieClip.prototype._initAvm1FrameData = function (frameIndex, frameInfo) {
                    var symbol = this._symbol;
                    var avm1Context = symbol.avm1Context;
                    if (frameInfo.exports) {
                        var exports = frameInfo.exports;
                        for (var i = 0; i < exports.length; i++) {
                            var asset = exports[i];
                            avm1Context.addAsset(asset.className, asset.symbolId, null);
                        }
                    }
                    var initActionBlocks = frameInfo.initActionBlocks;
                    if (initActionBlocks) {
                        this._addAvm1InitActionBlocks(frameIndex, initActionBlocks);
                    }
                    var actionBlocks = frameInfo.actionBlocks;
                    if (actionBlocks) {
                        this._addAvm1FrameScripts(frameIndex, actionBlocks);
                    }
                };
                MovieClip.prototype._addAvm1FrameScripts = function (frameIndex, actionsBlocks) {
                    var _loop_2 = function (i) {
                        var actionsBlock = actionsBlocks[i];
                        var symbol = this_2._symbol;
                        var avm1Context = symbol.avm1Context;
                        var actionsData = avm1Context.actionsDataFactory.createActionsData(actionsBlock.actionsData, 's' + symbol.id + 'f' + frameIndex + 'i' + i);
                        var script = function (actionsData) {
                            var as2MovieClip = AVM1.Lib.getAVM1Object(this, avm1Context);
                            avm1Context.executeActions(actionsData, as2MovieClip);
                        }.bind(this_2, actionsData);
                        script.precedence = this_2._getScriptPrecedence().concat(actionsBlock.precedence);
                        this_2.addFrameScript(frameIndex, script);
                    };
                    var this_2 = this;
                    for (var i = 0; i < actionsBlocks.length; i++) {
                        _loop_2(i);
                    }
                };
                /**
                 * AVM1 InitActionBlocks are executed once, before the children are initialized for a frame.
                 * That matches AS3's enterFrame event, so we can add an event listener that just bails
                 * as long as the target frame isn't reached, and executes the InitActionBlock once it is.
                 *
                 * After that, the listener removes itself.
                 */
                MovieClip.prototype._addAvm1InitActionBlocks = function (frameIndex, actionsBlocks) {
                    function executeInitActions() {
                        var symbol = self._symbol;
                        var avm1Context = symbol.avm1Context;
                        var as2MovieClip = AVM1.Lib.getAVM1Object(self, avm1Context);
                        for (var i = 0; i < actionsBlocks.length; i++) {
                            var actionsData = avm1Context.actionsDataFactory.createActionsData(actionsBlocks[i].actionsData, 's' + symbol.id + 'f' + frameIndex + 'i' + i);
                            avm1Context.executeActions(actionsData, as2MovieClip);
                        }
                    }
                    var self = this;
                    if (this.currentFrame === frameIndex + 1) {
                        executeInitActions();
                        return;
                    }
                    var enterFrameListener = function () {
                        if (self.currentFrame !== frameIndex + 1) {
                            return;
                        }
                        self.removeEventListener('enterFrame', enterFrameListener);
                        executeInitActions();
                    };
                    this.addEventListener('enterFrame', enterFrameListener);
                };
                MovieClip.prototype.removeChildAt = function (index) {
                    var child = _super.prototype.removeChildAt.call(this, index);
                    if (this._as2Object && child._name) {
                        var avm1Child = AVM1.Lib.getAVM1Object(child, this._as2Object.context);
                        // Not all display objects are reflected in AVM1, so not all need to be removed.
                        avm1Child && this._as2Object._removeChildName(avm1Child, child._name);
                    }
                    return child;
                };
                MovieClip.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._currentFrame = 0;
                    this._totalFrames = 1;
                    this._trackAsMenu = false;
                    this._scenes = [];
                    if (!this._symbol) {
                        this.addScene('', [], 0, 1);
                    }
                    this._enabled = true;
                    this._isPlaying = false;
                    this._frames = [];
                    this._frameScripts = [];
                    this._nextFrame = 1;
                    this._stopped = false;
                    this._allowFrameNavigation = true;
                    this._sounds = null;
                    this._buttonFrames = Object.create(null);
                    this._currentButtonState = null;
                };
                MovieClip.prototype._addFrame = function (frameInfo) {
                    var spriteSymbol = this._symbol;
                    var frames = spriteSymbol.frames;
                    frames.push(frameInfo);
                    if (frameInfo.labelName) {
                        // Frame indices are 1-based, so use frames.length after pushing the frame.
                        this.addFrameLabel(frameInfo.labelName, frames.length);
                    }
                    if (frameInfo.soundStreamHead) {
                        this._initSoundStream(frameInfo.soundStreamHead);
                    }
                    if (frameInfo.soundStreamBlock) {
                        // Frame indices are 1-based, so use frames.length after pushing the frame.
                        this._addSoundStreamBlock(frames.length, frameInfo.soundStreamBlock);
                    }
                    if (spriteSymbol.isAVM1Object && this._hasFlags(256 /* Constructed */)) {
                        var avm1Context = spriteSymbol.avm1Context;
                        this._initAvm1FrameData(frames.length - 1, frameInfo);
                    }
                    if (frames.length === 1) {
                        this._initializeChildren(frames[0]);
                    }
                };
                MovieClip.prototype._initFrame = function (advance) {
                    if (advance) {
                        if (this.buttonMode) {
                            var state = null;
                            if (this._mouseOver) {
                                state = this._mouseDown ? '_down' : '_over';
                            }
                            else if (this._currentButtonState !== null) {
                                state = '_up';
                            }
                            if (state !== this._currentButtonState && this._buttonFrames[state]) {
                                this.stop();
                                this._gotoFrame(state, null);
                                this._currentButtonState = state;
                                this._advanceFrame();
                                return;
                            }
                        }
                        if (this._totalFrames > 1 && !this._stopped &&
                            this._hasFlags(256 /* Constructed */)) {
                            this._nextFrame++;
                        }
                    }
                    this._advanceFrame();
                    if (this._symbol && this._symbol.isAVM1Object &&
                        !this._hasFlags(256 /* Constructed */)) {
                        this._initAvm1Data();
                    }
                };
                MovieClip.prototype._constructFrame = function () {
                    this._constructChildren();
                };
                MovieClip.prototype._enqueueFrameScripts = function () {
                    var addToCallQueue = false;
                    if (this._hasFlags(1024 /* NeedsLoadEvent */)) {
                        addToCallQueue = true;
                    }
                    if (this._hasFlags(8192 /* HasFrameScriptPending */)) {
                        this._removeFlags(8192 /* HasFrameScriptPending */);
                        addToCallQueue = true;
                    }
                    if (addToCallQueue) {
                        this._sec.display._callQueue.push(this);
                    }
                    _super.prototype._enqueueFrameScripts.call(this);
                };
                Object.defineProperty(MovieClip.prototype, "currentFrame", {
                    get: function () {
                        var frame = this._currentFrame;
                        if (!this._allowFrameNavigation &&
                            this._sec.display.frameNavigationModel === 1 /* SWF1 */) {
                            // AVM1 needs to return a frame we already navigated during scripts execution.
                            frame = this._nextFrame;
                        }
                        return frame - this._sceneForFrameIndex(frame).offset;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "framesLoaded", {
                    get: function () {
                        return this._frames.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "totalFrames", {
                    get: function () {
                        return this._totalFrames;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "trackAsMenu", {
                    get: function () {
                        return this._trackAsMenu;
                    },
                    set: function (value) {
                        this._trackAsMenu = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "scenes", {
                    get: function () {
                        var scenes = this._scenes ? this._scenes.map(function (x) {
                            return x.clone();
                        }) : [];
                        return scenes;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "currentScene", {
                    get: function () {
                        var scene = this._sceneForFrameIndex(this._currentFrame);
                        return scene.clone();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "currentLabel", {
                    get: function () {
                        var label = this._labelForFrame(this._currentFrame);
                        return label ? label.name : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "currentLabels", {
                    get: function () {
                        return this._sceneForFrameIndex(this._currentFrame).labels;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "currentFrameLabel", {
                    get: function () {
                        var scene = this._sceneForFrameIndex(this._currentFrame);
                        var label = scene.getLabelByFrame(this._currentFrame - scene.offset);
                        return label && label.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "enabled", {
                    get: function () {
                        return this._enabled;
                    },
                    set: function (value) {
                        this._enabled = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MovieClip.prototype, "isPlaying", {
                    get: function () {
                        return this._isPlaying;
                    },
                    enumerable: true,
                    configurable: true
                });
                MovieClip.prototype.play = function () {
                    if (this._totalFrames > 1) {
                        this._isPlaying = true;
                    }
                    this._stopped = false;
                };
                MovieClip.prototype.stop = function () {
                    this._isPlaying = false;
                    this._stopped = true;
                };
                /**
                 * Resolves frame and scene into absolute frame number. If scene is not specified,
                 * the current scene is used. In legacy mode, it might return `undefined` if frame/scene
                 * was not found.
                 */
                MovieClip.prototype._getAbsFrameNumber = function (frame, sceneName) {
                    var navigationModel = this._sec.display.frameNavigationModel;
                    var legacyMode = navigationModel !== 10 /* SWF10 */;
                    var scene;
                    if (sceneName !== null) {
                        var scenes = this._scenes;
                        release || assert(scenes.length, "There should be at least one scene defined.");
                        var i = void 0;
                        for (i = 0; i < scenes.length; i++) {
                            scene = scenes[i];
                            if (scene.name === sceneName) {
                                break;
                            }
                        }
                        if (i === scenes.length) {
                            if (legacyMode) {
                                return undefined; // noop for SWF9 and below
                            }
                            this._sec.throwError('ArgumentError', Shumway.Errors.SceneNotFoundError, sceneName);
                        }
                    }
                    else {
                        scene = this._sceneForFrameIndex(this._currentFrame);
                    }
                    // Amazingly, the `frame` argument, while first coerced to string, is then interpreted as a
                    // frame index even if a label with the same name exists.
                    /* tslint:disable */
                    var frameNum = parseInt(frame, 10);
                    if (frameNum != frame) {
                        var label = scene.getLabelByName(frame, legacyMode);
                        if (!label) {
                            if (legacyMode) {
                                return undefined; // noop for SWF9 and below
                            }
                            this._sec.throwError('ArgumentError', Shumway.Errors.FrameLabelNotFoundError, frame, sceneName);
                        }
                        frameNum = label.frame;
                    }
                    /* tslint:enable */
                    return scene.offset + frameNum;
                };
                /**
                 * Implementation for both gotoAndPlay and gotoAndStop.
                 *
                 * Technically, we should throw all errors from those functions directly so the stack is
                 * correct.
                 * We might at some point do that by explicitly inlining this function using some build step.
                 */
                MovieClip.prototype._gotoFrame = function (frame, sceneName) {
                    var frameNum = this._getAbsFrameNumber(frame, sceneName);
                    if (frameNum === undefined) {
                        return;
                    }
                    this._gotoFrameAbs(frameNum);
                };
                MovieClip.prototype._gotoFrameAbs = function (frame) {
                    if (frame < 1) {
                        frame = 1;
                    }
                    else if (frame > this._totalFrames) {
                        frame = this._totalFrames;
                    }
                    if (frame === this._nextFrame) {
                        return;
                    }
                    this._nextFrame = frame;
                    // Frame navigation only happens immediately if not triggered from under a frame script.
                    if (this._allowFrameNavigation) {
                        var display_2 = this._sec.display;
                        if (display_2.frameNavigationModel === 9 /* SWF9 */) {
                            // In FP 9, the only thing that happens on inter-frame navigation is advancing the frame
                            // and constructing new timeline objects.
                            this._advanceFrame();
                            this._constructFrame();
                        }
                        else {
                            // Frame navigation in an individual timeline triggers an iteration of the whole
                            // frame navigation cycle in FP 10+. This includes broadcasting frame events to *all*
                            // display objects.
                            display_2.performFrameNavigation(false, true);
                        }
                    }
                };
                MovieClip.prototype._advanceFrame = function () {
                    var currentFrame = this._currentFrame;
                    var nextFrame = this._nextFrame;
                    if (nextFrame > this._totalFrames) {
                        nextFrame = 1;
                    }
                    if (currentFrame === nextFrame) {
                        // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                        // just be incremented ever further.
                        this._nextFrame = nextFrame;
                        return;
                    }
                    if (nextFrame > this.framesLoaded) {
                        // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                        // just be incremented ever further.
                        this._nextFrame = nextFrame;
                        // TODO
                        return;
                    }
                    var currentSwfFrame = this._frames[currentFrame - 1];
                    var nextSwfFrame = this._frames[nextFrame - 1];
                    if (nextSwfFrame !== currentSwfFrame) {
                        this._seekToFrame(nextFrame);
                        if (nextSwfFrame.controlTags) {
                            var tags = nextSwfFrame.controlTags;
                            var soundStarts = void 0;
                            for (var i = 0; i < tags.length; i++) {
                                var tag = tags[i];
                                // controlTags might contain parsed and unparsed tags.
                                if (tag.tagCode === 15 /* CODE_START_SOUND */ ||
                                    tag.tagCode === 61 /* CODE_VIDEO_FRAME */) {
                                    var loaderInfo = this._symbol.loaderInfo;
                                    tag = loaderInfo._file.getParsedTag(tag);
                                }
                                if (tag.code === 15 /* CODE_START_SOUND */) {
                                    if (!soundStarts) {
                                        soundStarts = [];
                                    }
                                    soundStarts.push(new Shumway.Timeline.SoundStart(tag.soundId, tag.soundInfo));
                                }
                                else if (tag.tagCode === 61 /* CODE_VIDEO_FRAME */) {
                                    // tag.videoData contains a video frame for the video stream symbol with id == tag.streamId.
                                    // TODO: Do something useful with that information :).
                                }
                            }
                            if (soundStarts) {
                                this._registerStartSounds(nextFrame, soundStarts);
                            }
                        }
                    }
                    if (this._frameScripts[nextFrame]) {
                        this._setFlags(8192 /* HasFrameScriptPending */);
                        this._parent && this._propagateFlagsUp(16384 /* ContainsFrameScriptPendingChildren */);
                    }
                    this._currentFrame = this._nextFrame = nextFrame;
                    this._syncSounds(nextFrame);
                };
                MovieClip.prototype._seekToFrame = function (frame) {
                    var currentFrame = this._currentFrame;
                    var frames = this._frames;
                    if (frame === currentFrame + 1) {
                        var nextSwfFrame = frames[frame - 1];
                        if (nextSwfFrame.controlTags) {
                            this._processControlTags(nextSwfFrame.controlTags, false);
                        }
                        return;
                    }
                    var currentSwfFrame = frames[currentFrame - 1];
                    var loaderInfo = this._symbol.loaderInfo;
                    var backwards = frame < currentFrame;
                    var controlTags = [];
                    var removedObjects;
                    // We scan all control tags in reverse order and make sure we only apply those related to
                    // objects that exist in the new frame.
                    var i = frame;
                    var n = backwards ? 0 : currentFrame;
                    while (i-- > n) {
                        var swfFrame = frames[i];
                        if (swfFrame === currentSwfFrame) {
                            continue;
                        }
                        currentSwfFrame = swfFrame;
                        var tags = swfFrame.controlTags;
                        if (!tags) {
                            continue;
                        }
                        var j = tags.length;
                        while (j--) {
                            // We may have a mix of the parsed and unparsed tags.
                            var parsedOrUnparsedTag = tags[j];
                            var tag = parsedOrUnparsedTag.tagCode === undefined ?
                                parsedOrUnparsedTag : loaderInfo._file.getParsedTag(parsedOrUnparsedTag);
                            switch (tag.code) {
                                case 5 /* CODE_REMOVE_OBJECT */:
                                case 28 /* CODE_REMOVE_OBJECT2 */:
                                    if (!removedObjects) {
                                        removedObjects = Object.create(null);
                                    }
                                    removedObjects[tag.depth] = true;
                                    if (!backwards) {
                                        controlTags.push(tag);
                                    }
                                    break;
                                case 4 /* CODE_PLACE_OBJECT */:
                                case 26 /* CODE_PLACE_OBJECT2 */:
                                case 70 /* CODE_PLACE_OBJECT3 */:
                                    if (!(removedObjects && removedObjects[tag.depth])) {
                                        controlTags.push(tag);
                                    }
                                    break;
                                default:
                                    controlTags.push(tag);
                            }
                        }
                    }
                    // Bring the order back to normal.
                    controlTags.reverse();
                    this._processControlTags(controlTags, backwards);
                };
                /**
                 * Because that's how it's mostly used, the current frame is stored as an offset into the
                 * entire timeline. Sometimes, we need to know which scene it falls into. This utility
                 * function answers that.
                 */
                MovieClip.prototype._sceneForFrameIndex = function (frameIndex) {
                    var scenes = this._scenes;
                    // A gotoAnd* might be invoked by script before the first advanceFrame call. In that case,
                    // _currentFrame is 0, which means this function is called with frameIndex being 0.
                    // We just return the first scene in that case.
                    if (frameIndex === 0) {
                        return scenes[0];
                    }
                    for (var i = 0; i < scenes.length; i++) {
                        var scene = scenes[i];
                        if (scene.offset < frameIndex && scene.offset + scene.numFrames >= frameIndex) {
                            return scene;
                        }
                    }
                    release || assertUnreachable("Must have at least one scene covering all frames.");
                    return null;
                };
                /**
                 * Frame indices are stored as offsets into the entire timline, whereas labels are stored
                 * in their scenes. This utility function iterates over scenes and their labels to find
                 * the label clostest to, but not after the target frame.
                 */
                MovieClip.prototype._labelForFrame = function (frame) {
                    var scenes = this._scenes;
                    var label = null;
                    for (var i = 0; i < scenes.length; i++) {
                        var scene = scenes[i];
                        if (scene.offset > frame) {
                            return label;
                        }
                        var labels = scene.labels;
                        for (var j = 0; j < labels.length; j++) {
                            var currentLabel = labels[j];
                            if (currentLabel.frame > frame - scene.offset) {
                                return label;
                            }
                            label = currentLabel;
                        }
                    }
                    return label;
                };
                MovieClip.prototype.callFrame = function (frame) {
                    frame = frame | 0;
                    var frameScripts = this._frameScripts[frame];
                    if (!frameScripts) {
                        return;
                    }
                    for (var i = 0; i < frameScripts.length; i++) {
                        var script = frameScripts[i];
                        try {
                            script.call(this); // REDUX ? why it was frameScript.$Bgcall(thisArg);
                        }
                        catch (e) {
                            Telemetry.instance.reportTelemetry({ topic: 'error', error: 2 /* AVM2_ERROR */ });
                            //if ($DEBUG) {
                            //  console.error('error ' + e + ', stack: \n' + e.stack);
                            //}
                            this.stop();
                            throw e;
                        }
                    }
                };
                MovieClip.prototype.queueAvm1FrameScripts = function (frame, queue) {
                    // AVM1 action blocks must be executed exactly in the same order they appear in the SWF
                    // file. We keep track of the position for each action block at parsing time and carry that
                    // information on to their wrapping functions (via the precedence property). Here we queue
                    // up all such functions so we can sort and execute them after this loop.
                    if (this._hasFlags(1024 /* NeedsLoadEvent */)) {
                        this._removeFlags(1024 /* NeedsLoadEvent */);
                        release || assert(this._symbol);
                        var handler = function () {
                            var eventClass = this._sec.events;
                            this.dispatchEvent(eventClass.getInstance(events.Event.AVM1_LOAD));
                        }.bind(this);
                        handler.precedence = this._getScriptPrecedence();
                        handler.context = this;
                        queue.push(handler);
                    }
                    var frameScripts = this._frameScripts[frame];
                    if (frameScripts) {
                        for (var j = 0; j < frameScripts.length; j++) {
                            var script = frameScripts[j];
                            script.context = this;
                            queue.push(script);
                        }
                    }
                };
                MovieClip.prototype.nextFrame = function () {
                    this.gotoAndStop(this._currentFrame + 1);
                };
                MovieClip.prototype.prevFrame = function () {
                    this.gotoAndStop(this._currentFrame - 1);
                };
                MovieClip.prototype.gotoAndPlay = function (frame, scene) {
                    if (scene === void 0) { scene = null; }
                    // Argument handling for gotoAnd* is a bit peculiar:
                    // - too many arguments throw just as too few do
                    // - the `sceneName` argument is coerced first
                    // - the `frame` argument is coerced to string, but `undefined` results in `"null"`
                    if (arguments.length === 0 || arguments.length > 2) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                    }
                    frame = frame + '';
                    this.play();
                    this._gotoFrame(frame, scene);
                };
                MovieClip.prototype.gotoAndStop = function (frame, scene) {
                    if (scene === void 0) { scene = null; }
                    // See comment in gotoAndPlay for an explanation of the arguments handling stuff.
                    if (arguments.length === 0 || arguments.length > 2) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                    }
                    frame = frame + ''; // The axCoerceString returns `null` for `undefined`.
                    this.stop();
                    this._gotoFrame(frame, scene);
                };
                /**
                 * Takes pairs of `frameIndex`, `script` arguments and adds the `script`s to the `_frameScripts`
                 * Array.
                 *
                 * Undocumented method used to implement the old timeline concept in AS3.
                 */
                MovieClip.prototype.addFrameScript = function (frameIndex, script /*, ...*/) {
                    if (!this._currentFrame) {
                        return;
                    }
                    // arguments are pairs of frameIndex and script/function
                    // frameIndex is in range 0..totalFrames-1
                    var numArgs = arguments.length;
                    if (numArgs & 1) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.TooFewArgumentsError, numArgs, numArgs + 1);
                    }
                    var frameScripts = this._frameScripts;
                    var totalFrames = this._totalFrames;
                    for (var i = 0; i < numArgs; i += 2) {
                        var frameNum = (arguments[i] | 0) + 1;
                        if (frameNum < 1 || frameNum > totalFrames) {
                            continue;
                        }
                        var fn = arguments[i + 1];
                        var list = frameScripts[frameNum];
                        if (list) {
                            if (fn.precedence) {
                                list.push(fn);
                            }
                            else {
                                list[0] = fn;
                            }
                        }
                        else {
                            frameScripts[frameNum] = [fn];
                        }
                        if (frameNum === this._currentFrame) {
                            this._setFlags(8192 /* HasFrameScriptPending */);
                            this._parent && this._propagateFlagsUp(16384 /* ContainsFrameScriptPendingChildren */);
                        }
                    }
                };
                Object.defineProperty(MovieClip.prototype, "_isFullyLoaded", {
                    get: function () {
                        return this.framesLoaded >= this.totalFrames;
                    },
                    enumerable: true,
                    configurable: true
                });
                MovieClip.prototype._registerStartSounds = function (frameNum, soundStartInfo) {
                    if (this._sounds === null) {
                        this._sounds = new MovieClipSoundsManager(this);
                    }
                    this._sounds.registerStartSounds(frameNum, soundStartInfo);
                };
                MovieClip.prototype._initSoundStream = function (streamInfo) {
                    if (this._sounds === null) {
                        this._sounds = new MovieClipSoundsManager(this);
                    }
                    this._sounds.initSoundStream(streamInfo);
                };
                MovieClip.prototype._addSoundStreamBlock = function (frameNum, streamBlock) {
                    if (this._sounds === null) {
                        this._sounds = new MovieClipSoundsManager(this);
                    }
                    this._sounds.addSoundStreamBlock(frameNum, streamBlock);
                };
                MovieClip.prototype._syncSounds = function (frameNum) {
                    if (this._sounds !== null) {
                        this._sounds.syncSounds(frameNum);
                    }
                };
                MovieClip.prototype.addScene = function (name, labels_, offset, numFrames) {
                    var labels = labels_;
                    this._scenes.push(this._sec.display.Scene.create([name, labels, offset, numFrames]));
                };
                MovieClip.prototype.addFrameLabel = function (name, frame) {
                    var scene = this._sceneForFrameIndex(frame);
                    if (!scene.getLabelByName(name, false)) {
                        scene.labels.push(this._sec.display.FrameLabel.create([name, frame - scene.offset]));
                    }
                };
                MovieClip.prototype.prevScene = function () {
                    var currentScene = this._sceneForFrameIndex(this._currentFrame);
                    if (currentScene.offset === 0) {
                        return;
                    }
                    // Since scene offsets are 0-based, the current scene's offset, treated as a frame index,
                    // is the previous scene's last frame.
                    this._gotoFrameAbs(this._sceneForFrameIndex(currentScene.offset).offset + 1);
                };
                MovieClip.prototype.nextScene = function () {
                    var currentScene = this._sceneForFrameIndex(this._currentFrame);
                    if (currentScene.offset + currentScene.numFrames === this._totalFrames) {
                        return;
                    }
                    this._gotoFrameAbs(currentScene.offset + currentScene.numFrames + 1);
                };
                MovieClip.prototype._containsPointImpl = function (globalX, globalY, localX, localY, testingType, objects, skipBoundsCheck) {
                    var result = _super.prototype._containsPointImpl.call(this, globalX, globalY, localX, localY, testingType, objects, true);
                    // In AVM1 SWFs, MovieClips are transparent to the mouse as long as they don't have a handler
                    // attached to them for any of the button-related events.
                    if (result === 2 /* Shape */ && testingType === 3 /* Mouse */ &&
                        '_as2Object' in this && !this.buttonMode && objects[0] === this) {
                        objects.length = 0;
                    }
                    return result;
                };
                MovieClip.classInitializer = null;
                // List of static symbols to link.
                MovieClip.classSymbols = null; // [];
                // List of instance symbols to link.
                MovieClip.instanceSymbols = null; // ["currentLabels"];
                return MovieClip;
            }(flash.display.Sprite));
            display_1.MovieClip = MovieClip;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MovieClip
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var MP3DecoderSession = Shumway.SWF.MP3DecoderSession;
            var MP3_MIME_TYPE = 'audio/mpeg';
            var HTMLAudioElementAdapter = /** @class */ (function () {
                function HTMLAudioElementAdapter(sec, element) {
                    this._sec = sec;
                    this._element = element;
                }
                Object.defineProperty(HTMLAudioElementAdapter.prototype, "isReady", {
                    get: function () {
                        return !!this._channel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(HTMLAudioElementAdapter.prototype, "element", {
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(HTMLAudioElementAdapter.prototype, "currentTime", {
                    get: function () {
                        return this._element.currentTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                HTMLAudioElementAdapter.prototype.playFrom = function (time) {
                    var element = this._element;
                    if (element.paused) {
                        element.play();
                        element.addEventListener('playing', function setTime(e) {
                            element.removeEventListener('playing', setTime);
                            element.currentTime = time;
                        });
                    }
                    else {
                        element.currentTime = time;
                    }
                };
                Object.defineProperty(HTMLAudioElementAdapter.prototype, "paused", {
                    get: function () {
                        return this._element.paused;
                    },
                    set: function (value) {
                        var element = this._element;
                        if (value) {
                            if (!element.paused) {
                                element.pause();
                            }
                        }
                        else {
                            if (element.paused) {
                                element.play();
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                HTMLAudioElementAdapter.prototype.createChannel = function () {
                    this._channel = flash.media.SoundChannel.initializeFromAudioElement(this._sec, this._element);
                };
                HTMLAudioElementAdapter.prototype.queueData = function (frame) {
                    Shumway.Debug.abstractMethod('HTMLAudioElementAdapter::queueData');
                };
                HTMLAudioElementAdapter.prototype.finish = function () {
                    Shumway.Debug.abstractMethod('HTMLAudioElementAdapter::finish');
                };
                return HTMLAudioElementAdapter;
            }());
            var MediaSourceStreamAdapter = /** @class */ (function (_super) {
                __extends(MediaSourceStreamAdapter, _super);
                function MediaSourceStreamAdapter(sec, element) {
                    var _this = _super.call(this, sec, element) || this;
                    _this._mediaSource = new MediaSource();
                    _this._sourceBuffer = null;
                    _this._updating = false;
                    _this._loading = true;
                    _this._rawFrames = [];
                    _this._isReady = false;
                    _this._mediaSource.addEventListener('sourceopen', _this._openMediaSource.bind(_this));
                    _this.element.src = URL.createObjectURL(_this._mediaSource);
                    return _this;
                }
                MediaSourceStreamAdapter.prototype._appendSoundData = function () {
                    if (this._rawFrames.length === 0 || this._updating || !this._sourceBuffer) {
                        return;
                    }
                    if (!this._loading) {
                        this._mediaSource.endOfStream();
                        return;
                    }
                    this._updating = true;
                    // There is an issue when multiple appendBuffers are added in a sequence,
                    // pushing frames one-by-one.
                    this._sourceBuffer.appendBuffer(this._rawFrames.shift());
                    // Making MediaSourceStreamAdapter be ready on first packet.
                    if (!this._isReady) {
                        this._isReady = true;
                        this.createChannel();
                    }
                };
                MediaSourceStreamAdapter.prototype._openMediaSource = function () {
                    var sourceBuffer = this._mediaSource.addSourceBuffer(MP3_MIME_TYPE);
                    sourceBuffer.addEventListener('update', function () {
                        this._updating = false;
                        this._appendSoundData();
                    }.bind(this));
                    this._sourceBuffer = sourceBuffer;
                    this._appendSoundData();
                };
                MediaSourceStreamAdapter.prototype.queueData = function (frame) {
                    this._rawFrames.push(frame.data);
                    this._appendSoundData();
                };
                MediaSourceStreamAdapter.prototype.finish = function () {
                    this._loading = false;
                    this._appendSoundData();
                };
                return MediaSourceStreamAdapter;
            }(HTMLAudioElementAdapter));
            var BlobStreamAdapter = /** @class */ (function (_super) {
                __extends(BlobStreamAdapter, _super);
                function BlobStreamAdapter(sec, element) {
                    var _this = _super.call(this, sec, element) || this;
                    _this._rawFrames = [];
                    return _this;
                }
                BlobStreamAdapter.prototype.queueData = function (frame) {
                    this._rawFrames.push(frame.data);
                };
                BlobStreamAdapter.prototype.finish = function () {
                    var blob = new Blob(this._rawFrames);
                    this.element.src = URL.createObjectURL(blob);
                    this.createChannel();
                };
                return BlobStreamAdapter;
            }(HTMLAudioElementAdapter));
            function syncTime(element, movieClip) {
                var initialized = false;
                var startMediaTime, startRealTime;
                element.addEventListener('timeupdate', function (e) {
                    if (!initialized) {
                        startMediaTime = element.currentTime;
                        startRealTime = performance.now();
                        initialized = true;
                        //movieClip._stage._frameScheduler.startTrackDelta();
                        return;
                    }
                    var mediaDelta = element.currentTime - startMediaTime;
                    var realDelta = performance.now() - startRealTime;
                    //movieClip._stage._frameScheduler.setDelta(realDelta - mediaDelta * 1000);
                });
                element.addEventListener('pause', function (e) {
                    //movieClip._stage._frameScheduler.endTrackDelta();
                    initialized = false;
                });
                element.addEventListener('seeking', function (e) {
                    //movieClip._stage._frameScheduler.endTrackDelta();
                    initialized = false;
                });
            }
            var WebAudioAdapter = /** @class */ (function () {
                function WebAudioAdapter(sec, data) {
                    this._sec = sec;
                    this._channel = null;
                    this._sound = null;
                    this._data = data;
                    this._position = 0;
                }
                Object.defineProperty(WebAudioAdapter.prototype, "currentTime", {
                    get: function () {
                        return NaN;
                    },
                    enumerable: true,
                    configurable: true
                });
                WebAudioAdapter.prototype.playFrom = function (time) {
                    // tslint, noop
                };
                Object.defineProperty(WebAudioAdapter.prototype, "paused", {
                    get: function () {
                        return false;
                    },
                    set: function (value) {
                        // tslint, noop
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(WebAudioAdapter.prototype, "isReady", {
                    get: function () {
                        return !!this._channel;
                    },
                    enumerable: true,
                    configurable: true
                });
                WebAudioAdapter.prototype.queueData = function (frame) {
                    this._data.pcm.set(frame.pcm, this._position);
                    this._position += frame.pcm.length;
                };
                WebAudioAdapter.prototype.finish = function () {
                    // TODO Start from some seek offset, stopping
                    var sound = flash.media.Sound.initializeFromPCMData(this._sec, this._data);
                    var channel = sound.play();
                    this._sound = sound;
                    this._channel = channel;
                };
                return WebAudioAdapter;
            }());
            var WebAudioMP3Adapter = /** @class */ (function (_super) {
                __extends(WebAudioMP3Adapter, _super);
                function WebAudioMP3Adapter(sec, data) {
                    var _this = _super.call(this, sec, data) || this;
                    _this._decoderPosition = 0;
                    _this._decoderSession = new MP3DecoderSession();
                    _this._decoderSession.onframedata = function (frameData) {
                        var position = this._decoderPosition;
                        data.pcm.set(frameData, position);
                        this._decoderPosition = position + frameData.length;
                    }.bind(_this);
                    _this._decoderSession.onclosed = function () {
                        WebAudioAdapter.prototype.finish.call(this);
                    }.bind(_this);
                    _this._decoderSession.onerror = function (error) {
                        Shumway.Debug.warning('MP3DecoderSession error: ' + error);
                    };
                    return _this;
                }
                WebAudioMP3Adapter.prototype.queueData = function (frame) {
                    this._decoderSession.pushAsync(frame.data);
                };
                WebAudioMP3Adapter.prototype.finish = function () {
                    this._decoderSession.close();
                };
                return WebAudioMP3Adapter;
            }(WebAudioAdapter));
            var MovieClipSoundStream = /** @class */ (function () {
                function MovieClipSoundStream(streamInfo, movieClip) {
                    this.movieClip = movieClip;
                    this.decode = streamInfo.decode.bind(streamInfo);
                    this.data = {
                        sampleRate: streamInfo.sampleRate,
                        channels: streamInfo.channels
                    };
                    this.seekIndex = [];
                    this.position = 0;
                    this.wasFullyLoaded = false;
                    this.expectedFrame = 0;
                    this.waitFor = 0;
                    var sec = movieClip._sec;
                    var isMP3 = streamInfo.format === 'mp3';
                    if (isMP3 && !Shumway.webAudioMP3Option.value) {
                        var element = document.createElement('audio');
                        element.preload = 'metadata'; // for mobile devices
                        element.loop = false;
                        syncTime(element, movieClip);
                        if (element.canPlayType(MP3_MIME_TYPE)) {
                            this.element = element;
                            if (!Shumway.mediaSourceMP3Option.value) {
                                this.soundStreamAdapter = new BlobStreamAdapter(sec, element);
                            }
                            else if (typeof MediaSource !== 'undefined' &&
                                MediaSource.isTypeSupported(MP3_MIME_TYPE)) {
                                this.soundStreamAdapter = new MediaSourceStreamAdapter(sec, element);
                            }
                            else {
                                // Falls back to blob playback.
                                Shumway.Debug.warning('MediaSource is not supported');
                                this.soundStreamAdapter = new BlobStreamAdapter(sec, element);
                            }
                            return;
                        }
                        // Falls through to WebAudio if element cannot play MP3.
                    }
                    // TODO fix streamInfo.samplesCount name -- its actually average value
                    var totalSamples = (streamInfo.samplesCount + 1) * this.movieClip.totalFrames * streamInfo.channels;
                    this.data.pcm = new Float32Array(totalSamples);
                    this.soundStreamAdapter = !isMP3 ? new WebAudioAdapter(sec, this.data) :
                        new WebAudioMP3Adapter(sec, this.data);
                }
                MovieClipSoundStream.prototype.appendBlock = function (frameNum, streamBlock) {
                    var decodedBlock = this.decode(streamBlock);
                    var streamPosition = this.position;
                    this.seekIndex[frameNum] = streamPosition + decodedBlock.seek * this.data.channels;
                    this.position = streamPosition + decodedBlock.samplesCount * this.data.channels;
                    this.soundStreamAdapter.queueData(decodedBlock);
                };
                MovieClipSoundStream.prototype.playFrame = function (frameNum) {
                    if (isNaN(this.seekIndex[frameNum])) {
                        return;
                    }
                    var PAUSE_WHEN_OF_SYNC_GREATER = 1.0;
                    var PLAYBACK_ADJUSTMENT = 0.25;
                    if (!this.wasFullyLoaded && this.movieClip._isFullyLoaded) {
                        this.wasFullyLoaded = true;
                        this.soundStreamAdapter.finish();
                    }
                    if (this.soundStreamAdapter.isReady &&
                        !isNaN(this.soundStreamAdapter.currentTime)) {
                        var soundStreamData = this.data;
                        var time = this.seekIndex[frameNum] /
                            soundStreamData.sampleRate / soundStreamData.channels;
                        var elementTime = this.soundStreamAdapter.currentTime;
                        if (this.expectedFrame !== frameNum) {
                            this.soundStreamAdapter.playFrom(time);
                        }
                        else if (this.waitFor > 0) {
                            if (this.waitFor <= time) {
                                this.soundStreamAdapter.paused = false;
                                this.waitFor = 0;
                            }
                        }
                        else if (elementTime - time > PAUSE_WHEN_OF_SYNC_GREATER) {
                            Shumway.Debug.warning('Sound is faster than frames by ' + (elementTime - time));
                            this.waitFor = elementTime - PLAYBACK_ADJUSTMENT;
                            this.soundStreamAdapter.paused = true;
                        }
                        else if (time - elementTime > PAUSE_WHEN_OF_SYNC_GREATER) {
                            Shumway.Debug.warning('Sound is slower than frames by ' + (time - elementTime));
                            this.soundStreamAdapter.playFrom(time + PLAYBACK_ADJUSTMENT);
                        }
                        this.expectedFrame = frameNum + 1;
                    }
                };
                return MovieClipSoundStream;
            }());
            display.MovieClipSoundStream = MovieClipSoundStream;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Stage
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Stage = /** @class */ (function (_super) {
                __extends(Stage, _super);
                function Stage() {
                    var _this = _super.call(this) || this;
                    _this._root = _this;
                    _this._stage = _this;
                    _this._frameRate = 24;
                    _this._scaleMode = display.StageScaleMode.SHOW_ALL;
                    _this._align = "";
                    _this._stageWidth = 0;
                    _this._stageHeight = 0;
                    _this._showDefaultContextMenu = true;
                    _this._focus = null;
                    _this._colorCorrection = display.ColorCorrection.DEFAULT;
                    _this._colorCorrectionSupport = display.ColorCorrectionSupport.DEFAULT_OFF;
                    _this._stageFocusRect = true;
                    _this._quality = display.StageQuality.HIGH;
                    _this._displayState = null;
                    _this._fullScreenSourceRect = null;
                    _this._mouseLock = false;
                    _this._stageVideos = [];
                    _this._stage3Ds = [];
                    _this._colorARGB = 0xFFFFFFFF;
                    _this._fullScreenWidth = 0;
                    _this._fullScreenHeight = 0;
                    _this._wmodeGPU = false;
                    _this._softKeyboardRect = _this._sec.geom.Rectangle.create();
                    _this._allowsFullScreen = false;
                    _this._allowsFullScreenInteractive = false;
                    _this._contentsScaleFactor = 1;
                    _this._displayContextInfo = null;
                    _this._timeout = -1;
                    _this._stageContainerWidth = -1;
                    _this._stageContainerHeight = -1;
                    _this._setFlags(262144 /* HasPerspectiveProjection */);
                    /**
                     * Indicates if a Render event was requested by calling the |invalid| function.
                     */
                    _this._invalidated = false;
                    return _this;
                }
                Stage.prototype.setRoot = function (root) {
                    this.addTimelineObjectAtDepth(root, 0);
                };
                Object.defineProperty(Stage.prototype, "frameRate", {
                    get: function () {
                        return this._frameRate;
                    },
                    set: function (value) {
                        this._frameRate = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scaleMode", {
                    get: function () {
                        return this._scaleMode;
                    },
                    set: function (value) {
                        if (flash.display.StageScaleMode.toNumber(value) < 0) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.InvalidEnumError, "scaleMode");
                        }
                        if (this._scaleMode !== value) {
                            this._isDirty = true;
                            this._scaleMode = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "align", {
                    get: function () {
                        return this._align;
                    },
                    set: function (value) {
                        var n = flash.display.StageAlign.toNumber(value);
                        release || assert(n >= 0);
                        var newValue = flash.display.StageAlign.fromNumber(n);
                        if (this._align !== newValue) {
                            this._isDirty = true;
                            this._align = newValue;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "stageWidth", {
                    get: function () {
                        if (this.scaleMode !== display.StageScaleMode.NO_SCALE) {
                            return this._stageWidth / 20 | 0;
                        }
                        release || assert(this._stageContainerWidth >= 0);
                        return this._stageContainerWidth;
                    },
                    set: function (value /*int*/) {
                        // While the setter doesn't change the stored value, it still coerces the `value` parameter.
                        // This is script-visible if the value is something like `{valueOf: function(){throw 1}}`.
                        value = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Stage.prototype._setInitialName = function () {
                    this._name = null;
                };
                /**
                 * Non-AS3-available setter. In AS3, the `stageWidth` setter is silently ignored.
                 */
                Stage.prototype.setStageWidth = function (value) {
                    release || assert((value | 0) === value);
                    var newValue = (value * 20) | 0;
                    if (this._stageWidth !== newValue) {
                        this._isDirty = true;
                        this._stageWidth = newValue;
                    }
                };
                Object.defineProperty(Stage.prototype, "stageHeight", {
                    get: function () {
                        if (this.scaleMode !== display.StageScaleMode.NO_SCALE) {
                            return this._stageHeight / 20 | 0;
                        }
                        release || assert(this._stageContainerHeight >= 0);
                        return this._stageContainerHeight;
                    },
                    set: function (value /*int*/) {
                        // While the setter doesn't change the stored value, it still coerces the `value` parameter.
                        // This is script-visible if the value is something like `{valueOf: function(){throw 1}}`.
                        value = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Non-AS3-available setter. In AS3, the `stageHeight` setter is silently ignored.
                 */
                Stage.prototype.setStageHeight = function (value) {
                    release || assert((value | 0) === value);
                    var newValue = (value * 20) | 0;
                    if (this._stageHeight !== newValue) {
                        this._isDirty = true;
                        this._stageHeight = newValue;
                    }
                };
                /**
                 * Almost the same as color setter, except it preserves alpha channel.
                 * @param value
                 */
                Stage.prototype.setStageColor = function (value) {
                    if (this._colorARGB !== value) {
                        this._isDirty = true;
                        this._colorARGB = value;
                    }
                };
                /**
                 * Non-AS3-available setter. Notifies the stage that the dimensions of the stage container have changed.
                 */
                Stage.prototype.setStageContainerSize = function (width, height, pixelRatio) {
                    // Flash doesn't fire a resize event if the pixel ratio has changed, but it needs to be set if
                    // a resize event gets dispatched as a result of a size change.
                    this._contentsScaleFactor = pixelRatio;
                    var sizeHasChanged = this._stageContainerWidth !== width || this._stageContainerHeight !== height;
                    if (sizeHasChanged) {
                        this._stageContainerWidth = width;
                        this._stageContainerHeight = height;
                        if (this.scaleMode === display.StageScaleMode.NO_SCALE) {
                            this.dispatchEvent(this._sec.events.getInstance(flash.events.Event.RESIZE));
                        }
                    }
                };
                Object.defineProperty(Stage.prototype, "showDefaultContextMenu", {
                    get: function () {
                        return this._showDefaultContextMenu;
                    },
                    set: function (value) {
                        this._showDefaultContextMenu = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "focus", {
                    get: function () {
                        return this._focus;
                    },
                    set: function (newFocus) {
                        this._focus = newFocus;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "colorCorrection", {
                    get: function () {
                        return this._colorCorrection;
                    },
                    set: function (value) {
                        //this._colorCorrection = axCoerceString(value);
                        release || notImplemented("public flash.display.Stage::set colorCorrection");
                        return;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "colorCorrectionSupport", {
                    get: function () {
                        return this._colorCorrectionSupport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "stageFocusRect", {
                    get: function () {
                        return this._stageFocusRect;
                    },
                    set: function (on) {
                        this._stageFocusRect = !!on;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "quality", {
                    get: function () {
                        return this._quality.toUpperCase(); // Return value is always uppercase
                    },
                    set: function (value) {
                        // TODO: The *linear versions return just *, stripping the "linear" part
                        // Value is compared case-insensitively, and has default handling, so '' is ok.
                        value = (value || '').toLowerCase();
                        if (flash.display.StageQuality.toNumber(value) < 0) {
                            value = flash.display.StageQuality.HIGH;
                        }
                        this._quality = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "displayState", {
                    get: function () {
                        return this._displayState;
                    },
                    set: function (value) {
                        // TODO: This should only be allowed if the embedding page allows full screen mode.
                        if (flash.display.StageDisplayState.toNumber(value) < 0) {
                            value = flash.display.StageDisplayState.NORMAL;
                        }
                        if (this._displayState !== value) {
                            this._isDirty = true;
                            this._displayState = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "fullScreenSourceRect", {
                    get: function () {
                        return this._fullScreenSourceRect;
                    },
                    set: function (value) {
                        //this._fullScreenSourceRect = value;
                        release || notImplemented("public flash.display.Stage::set fullScreenSourceRect");
                        return;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "mouseLock", {
                    get: function () {
                        return this._mouseLock;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.display.Stage::set mouseLock");
                        this._mouseLock = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "stageVideos", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.Stage::get stageVideos");
                        return this._stageVideos;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "stage3Ds", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.Stage::get stage3Ds");
                        return this._stage3Ds;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "color", {
                    get: function () {
                        return this._colorARGB;
                    },
                    set: function (rgb /*uint*/) {
                        var newValue = rgb | 0xff000000;
                        // Flash player forces the alpha channel to 0xff.
                        if (this._colorARGB !== newValue) {
                            this._isDirty = true;
                            this._colorARGB = newValue;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "alpha", {
                    get: function () {
                        return this._colorTransform.alphaMultiplier;
                    },
                    set: function (alpha) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "fullScreenWidth", {
                    get: function () {
                        return this._fullScreenWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "fullScreenHeight", {
                    get: function () {
                        return this._fullScreenHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "wmodeGPU", {
                    get: function () {
                        return this._wmodeGPU;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "softKeyboardRect", {
                    get: function () {
                        return this._softKeyboardRect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "allowsFullScreen", {
                    get: function () {
                        return this._allowsFullScreen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "allowsFullScreenInteractive", {
                    get: function () {
                        return this._allowsFullScreenInteractive;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "contentsScaleFactor", {
                    get: function () {
                        return this._contentsScaleFactor;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "displayContextInfo", {
                    get: function () {
                        return this._displayContextInfo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Stage.prototype.removeChildAt = function (index) {
                    this.requireOwnerPermissions();
                    return _super.prototype.removeChildAt.call(this, index);
                };
                Stage.prototype.swapChildrenAt = function (index1 /*int*/, index2 /*int*/) {
                    this.requireOwnerPermissions();
                    _super.prototype.swapChildrenAt.call(this, index1, index2);
                };
                Object.defineProperty(Stage.prototype, "width", {
                    get: function () {
                        this.requireOwnerPermissions();
                        return this._getWidth();
                    },
                    set: function (value) {
                        this.requireOwnerPermissions();
                        this._setWidth(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "height", {
                    get: function () {
                        this.requireOwnerPermissions();
                        return this._getHeight();
                    },
                    set: function (value) {
                        this.requireOwnerPermissions();
                        this._setHeight(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "mouseChildren", {
                    get: function () {
                        this.requireOwnerPermissions();
                        return this._getMouseChildren();
                    },
                    set: function (value) {
                        this.requireOwnerPermissions();
                        this._setMouseChildren(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "numChildren", {
                    get: function () {
                        this.requireOwnerPermissions();
                        return this._getNumChildren();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "tabChildren", {
                    get: function () {
                        this.requireOwnerPermissions();
                        return this._getTabChildren();
                    },
                    set: function (value) {
                        this.requireOwnerPermissions();
                        this._setTabChildren(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Stage.prototype.addChild = function (child) {
                    this.requireOwnerPermissions();
                    return _super.prototype.addChild.call(this, child);
                };
                Stage.prototype.addChildAt = function (child, index) {
                    this.requireOwnerPermissions();
                    return _super.prototype.addChildAt.call(this, child, index);
                };
                Stage.prototype.setChildIndex = function (child, index) {
                    this.requireOwnerPermissions();
                    _super.prototype.setChildIndex.call(this, child, index);
                };
                Stage.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                    if (priority === void 0) { priority = 0; }
                    if (useWeakReference === void 0) { useWeakReference = false; }
                    this.requireOwnerPermissions();
                    _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
                };
                Stage.prototype.hasEventListener = function (type) {
                    this.requireOwnerPermissions();
                    return _super.prototype.hasEventListener.call(this, type);
                };
                Stage.prototype.willTrigger = function (type) {
                    this.requireOwnerPermissions();
                    return _super.prototype.willTrigger.call(this, type);
                };
                Stage.prototype.dispatchEvent = function (event) {
                    this.requireOwnerPermissions();
                    return _super.prototype.dispatchEvent.call(this, event);
                };
                Stage.prototype.invalidate = function () {
                    this._invalidated = true;
                };
                Stage.prototype.isFocusInaccessible = function () {
                    release || notImplemented("public flash.display.Stage::isFocusInaccessible");
                    return false;
                };
                Stage.prototype.requireOwnerPermissions = function () {
                    // TODO: implement requireOwnerPermissions
                };
                Stage.prototype.render = function () {
                    if (!this._invalidated) {
                        return;
                    }
                    this._sec.display._broadcastFrameEvent(flash.events.Event.RENDER);
                    this._invalidated = false;
                };
                Object.defineProperty(Stage.prototype, "name", {
                    get: function () {
                        return this._name;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "mask", {
                    get: function () {
                        return this._mask;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "visible", {
                    get: function () {
                        return this._hasFlags(1 /* Visible */);
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "x", {
                    get: function () {
                        return this._getX();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "y", {
                    get: function () {
                        return this._getY();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "z", {
                    get: function () {
                        return this._z;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scaleX", {
                    get: function () {
                        return Math.abs(this._scaleX);
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scaleY", {
                    get: function () {
                        return this._scaleY;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scaleZ", {
                    get: function () {
                        return this._scaleZ;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "rotation", {
                    get: function () {
                        return this._rotation;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "rotationX", {
                    get: function () {
                        return this._rotationX;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "rotationY", {
                    get: function () {
                        return this._rotationX;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "rotationZ", {
                    get: function () {
                        return this._rotationX;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "cacheAsBitmap", {
                    get: function () {
                        return this._getCacheAsBitmap();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "opaqueBackground", {
                    get: function () {
                        return this._opaqueBackground;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scrollRect", {
                    get: function () {
                        return this._getScrollRect();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "filters", {
                    get: function () {
                        return this._getFilters();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "blendMode", {
                    get: function () {
                        return this._blendMode;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "transform", {
                    get: function () {
                        return this._getTransform();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "accessibilityProperties", {
                    get: function () {
                        return this._accessibilityProperties;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "scale9Grid", {
                    get: function () {
                        return this._getScale9Grid();
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "tabEnabled", {
                    get: function () {
                        return this._tabEnabled;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "tabIndex", {
                    get: function () {
                        return this._tabIndex;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "focusRect", {
                    get: function () {
                        return this._focusRect;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "mouseEnabled", {
                    get: function () {
                        return this._mouseEnabled;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "accessibilityImplementation", {
                    get: function () {
                        return this._accessibilityImplementation;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "textSnapshot", {
                    get: function () {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Stage.prototype, "contextMenu", {
                    get: function () {
                        return this._contextMenu;
                    },
                    set: function (value) {
                        this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidStageMethodError);
                    },
                    enumerable: true,
                    configurable: true
                });
                Stage.classInitializer = null;
                Stage.classSymbols = null; // [];
                Stage.instanceSymbols = null;
                return Stage;
            }(flash.display.DisplayObjectContainer));
            display.Stage = Stage;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ActionScriptVersion
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var ActionScriptVersion;
            (function (ActionScriptVersion) {
                ActionScriptVersion[ActionScriptVersion["ACTIONSCRIPT2"] = 2] = "ACTIONSCRIPT2";
                ActionScriptVersion[ActionScriptVersion["ACTIONSCRIPT3"] = 3] = "ACTIONSCRIPT3";
            })(ActionScriptVersion = display.ActionScriptVersion || (display.ActionScriptVersion = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BlendMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var BlendMode;
            (function (BlendMode) {
                // JS -> AS Bindings
                BlendMode["NORMAL"] = "normal";
                BlendMode["LAYER"] = "layer";
                BlendMode["MULTIPLY"] = "multiply";
                BlendMode["SCREEN"] = "screen";
                BlendMode["LIGHTEN"] = "lighten";
                BlendMode["DARKEN"] = "darken";
                BlendMode["ADD"] = "add";
                BlendMode["SUBTRACT"] = "subtract";
                BlendMode["DIFFERENCE"] = "difference";
                BlendMode["INVERT"] = "invert";
                BlendMode["OVERLAY"] = "overlay";
                BlendMode["HARDLIGHT"] = "hardlight";
                BlendMode["ALPHA"] = "alpha";
                BlendMode["ERASE"] = "erase";
                BlendMode["SHADER"] = "shader";
            })(BlendMode = display.BlendMode || (display.BlendMode = {}));
            (function (BlendMode) {
                /**
                 * Returns the blend mode string from the numeric value that appears in the
                 * swf file.
                 */
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                        case 1:
                            return BlendMode.NORMAL;
                        case 2:
                            return BlendMode.LAYER;
                        case 3:
                            return BlendMode.MULTIPLY;
                        case 4:
                            return BlendMode.SCREEN;
                        case 5:
                            return BlendMode.LIGHTEN;
                        case 6:
                            return BlendMode.DARKEN;
                        case 7:
                            return BlendMode.DIFFERENCE;
                        case 8:
                            return BlendMode.ADD;
                        case 9:
                            return BlendMode.SUBTRACT;
                        case 10:
                            return BlendMode.INVERT;
                        case 11:
                            return BlendMode.ALPHA;
                        case 12:
                            return BlendMode.ERASE;
                        case 13:
                            return BlendMode.OVERLAY;
                        case 14:
                            return BlendMode.HARDLIGHT;
                        default:
                            return null;
                    }
                }
                BlendMode.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case BlendMode.NORMAL:
                            return 1;
                        case BlendMode.LAYER:
                            return 2;
                        case BlendMode.MULTIPLY:
                            return 3;
                        case BlendMode.SCREEN:
                            return 4;
                        case BlendMode.LIGHTEN:
                            return 5;
                        case BlendMode.DARKEN:
                            return 6;
                        case BlendMode.DIFFERENCE:
                            return 7;
                        case BlendMode.ADD:
                            return 8;
                        case BlendMode.SUBTRACT:
                            return 9;
                        case BlendMode.INVERT:
                            return 10;
                        case BlendMode.ALPHA:
                            return 11;
                        case BlendMode.ERASE:
                            return 12;
                        case BlendMode.OVERLAY:
                            return 13;
                        case BlendMode.HARDLIGHT:
                            return 14;
                        default:
                            return -1;
                    }
                }
                BlendMode.toNumber = toNumber;
            })(BlendMode = display.BlendMode || (display.BlendMode = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ColorCorrection
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var ColorCorrection;
            (function (ColorCorrection) {
                // JS -> AS Bindings
                ColorCorrection["DEFAULT"] = "default";
                ColorCorrection["ON"] = "on";
                ColorCorrection["OFF"] = "off";
            })(ColorCorrection = display.ColorCorrection || (display.ColorCorrection = {}));
            (function (ColorCorrection) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return ColorCorrection.DEFAULT;
                        case 1:
                            return ColorCorrection.ON;
                        case 2:
                            return ColorCorrection.OFF;
                        default:
                            return null;
                    }
                }
                ColorCorrection.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case ColorCorrection.DEFAULT:
                            return 0;
                        case ColorCorrection.ON:
                            return 1;
                        case ColorCorrection.OFF:
                            return 2;
                        default:
                            return -1;
                    }
                }
                ColorCorrection.toNumber = toNumber;
            })(ColorCorrection = display.ColorCorrection || (display.ColorCorrection = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ColorCorrectionSupport
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var ColorCorrectionSupport;
            (function (ColorCorrectionSupport) {
                ColorCorrectionSupport["UNSUPPORTED"] = "unsupported";
                ColorCorrectionSupport["DEFAULT_ON"] = "defaultOn";
                ColorCorrectionSupport["DEFAULT_OFF"] = "defaultOff";
            })(ColorCorrectionSupport = display.ColorCorrectionSupport || (display.ColorCorrectionSupport = {}));
            (function (ColorCorrectionSupport) {
                // AS -> JS Bindings
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return ColorCorrectionSupport.UNSUPPORTED;
                        case 1:
                            return ColorCorrectionSupport.DEFAULT_ON;
                        case 2:
                            return ColorCorrectionSupport.DEFAULT_OFF;
                        default:
                            return null;
                    }
                }
                ColorCorrectionSupport.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case ColorCorrectionSupport.UNSUPPORTED:
                            return 0;
                        case ColorCorrectionSupport.DEFAULT_ON:
                            return 1;
                        case ColorCorrectionSupport.DEFAULT_OFF:
                            return 2;
                        default:
                            return -1;
                    }
                }
                ColorCorrectionSupport.toNumber = toNumber;
            })(ColorCorrectionSupport = display.ColorCorrectionSupport || (display.ColorCorrectionSupport = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FocusDirection
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var FocusDirection;
            (function (FocusDirection) {
                FocusDirection["TOP"] = "top";
                FocusDirection["BOTTOM"] = "bottom";
                FocusDirection["NONE"] = "none";
            })(FocusDirection = display.FocusDirection || (display.FocusDirection = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FrameLabel
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var FrameLabel = /** @class */ (function (_super) {
                __extends(FrameLabel, _super);
                function FrameLabel(name, frame /*int*/) {
                    var _this = _super.call(this) || this;
                    _this._name = name;
                    _this._frame = frame | 0;
                    return _this;
                }
                Object.defineProperty(FrameLabel.prototype, "name", {
                    get: function () {
                        return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FrameLabel.prototype, "frame", {
                    get: function () {
                        return this._frame;
                    },
                    enumerable: true,
                    configurable: true
                });
                FrameLabel.prototype.clone = function () {
                    return this._sec.display.FrameLabel.create([this._name, this._frame]);
                };
                return FrameLabel;
            }(flash.events.EventDispatcher));
            display.FrameLabel = FrameLabel;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapData
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var swap32 = Shumway.IntegerUtilities.swap32;
            var premultiplyARGB = Shumway.ColorUtilities.premultiplyARGB;
            var unpremultiplyARGB = Shumway.ColorUtilities.unpremultiplyARGB;
            var RGBAToARGB = Shumway.ColorUtilities.RGBAToARGB;
            var indexOf = Shumway.ArrayUtilities.indexOf;
            /**
             * Holds blobs of bitmap data in various formats and lets you do basic pixel operations. When
             * data is unpacked, it is stored as premultiplied ARGB since it's what the SWF encodes bitmaps
             * as.  This way we don't have to do unecessary byte conversions.
             */
            var BitmapData = /** @class */ (function (_super) {
                __extends(BitmapData, _super);
                function BitmapData(width /*int*/, height /*int*/, transparent, fillColorARGB) {
                    if (transparent === void 0) { transparent = true; }
                    if (fillColorARGB === void 0) { fillColorARGB = 4294967295; }
                    var _this = this;
                    width = width | 0;
                    height = height | 0;
                    transparent = !!transparent;
                    fillColorARGB = fillColorARGB | 0;
                    _this = _super.call(this) || this;
                    if (_this._symbol) {
                        _this.applySymbol();
                        return;
                    }
                    if (width > BitmapData.MAXIMUM_WIDTH || width <= 0 ||
                        height > BitmapData.MAXIMUM_HEIGHT || height <= 0 ||
                        width * height > BitmapData.MAXIMUM_DIMENSION) {
                        _this._sec.throwError('ArgumentError', Shumway.Errors.InvalidBitmapData);
                    }
                    _this._rect = _this._sec.geom.Rectangle.create([0, 0, width, height]);
                    _this._transparent = transparent;
                    _this._id = flash.display.DisplayObject.getNextSyncID();
                    _this._setData(new Uint8Array(width * height * 4), Shumway.ImageType.PremultipliedAlphaARGB);
                    var alpha = fillColorARGB >> 24;
                    if (alpha === 0 && transparent) {
                        // No need to do an initial fill since this would all be zeros anyway.
                        _this._solidFillColorPBGRA = 0;
                    }
                    else {
                        _this.fillRect(_this._rect, fillColorARGB);
                    }
                    _this._bitmapReferrers = [];
                    release || assert(_this._isDirty === !!_this._data);
                    release || assert(_this._isRemoteDirty === !_this._data);
                    return _this;
                }
                BitmapData.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    var symbol = this._symbol;
                    release || assert(symbol.syncId);
                    this._rect = this._sec.geom.Rectangle.create([0, 0, symbol.width, symbol.height]);
                    this._transparent = true;
                    this._id = symbol.syncId;
                    if (symbol.type === Shumway.ImageType.PremultipliedAlphaARGB ||
                        symbol.type === Shumway.ImageType.StraightAlphaARGB ||
                        symbol.type === Shumway.ImageType.StraightAlphaRGBA) {
                        release || assert(symbol.data);
                        this._setData(symbol.data, symbol.type);
                    }
                    else {
                        this._isDirty = false;
                        this._isRemoteDirty = true;
                    }
                    this._solidFillColorPBGRA = null;
                    this._bitmapReferrers = [];
                };
                BitmapData.prototype._setData = function (data, type) {
                    // Alpha images are parsed to Uint8Clamped array. Easiest to just handle here.
                    if (data instanceof Uint8ClampedArray) {
                        data = new Uint8Array(data.buffer);
                    }
                    release || assert(data instanceof Uint8Array);
                    this._data = data;
                    this._type = type;
                    this._view = new Int32Array(data.buffer);
                    this._dataBuffer = DataBuffer.FromArrayBuffer(data.buffer);
                    this._isDirty = true;
                    this._isRemoteDirty = false;
                };
                BitmapData.prototype._addBitmapReferrer = function (bitmap) {
                    var index = indexOf(this._bitmapReferrers, bitmap);
                    release || assert(index < 0);
                    this._bitmapReferrers.push(bitmap);
                };
                BitmapData.prototype._removeBitmapReferrer = function (bitmap) {
                    var index = indexOf(this._bitmapReferrers, bitmap);
                    release || assert(index >= 0);
                    this._bitmapReferrers[index] = null;
                };
                /**
                 * Called whenever the contents of this bitmap data changes.
                 */
                BitmapData.prototype._invalidate = function () {
                    if (this._isDirty) {
                        return;
                    }
                    this._isDirty = true;
                    this._isRemoteDirty = false;
                    // TODO: We probably don't need to propagate any flags if |_locked| is true.
                    for (var i = 0; i < this._bitmapReferrers.length; i++) {
                        var bitmap = this._bitmapReferrers[i];
                        if (bitmap) {
                            bitmap._setDirtyFlags(16 /* DirtyBitmapData */);
                        }
                    }
                };
                BitmapData.prototype._getTemporaryRectangleFrom = function (rect) {
                    var r = this._sec.geom._temporaryRectangle;
                    r.copyFrom(rect);
                    return r;
                };
                BitmapData.prototype.getDataBuffer = function () {
                    return this._dataBuffer;
                };
                BitmapData.prototype._getContentBounds = function () {
                    return Shumway.Bounds.FromRectangle(this._rect);
                };
                /**
                 * TODO: Not tested.
                 */
                BitmapData.prototype._getPixelData = function (rect) {
                    var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                    if (r.isEmpty()) {
                        return null;
                    }
                    var xMin = r.x;
                    var xMax = r.x + r.width;
                    var yMin = r.y;
                    var yMax = r.y + r.height;
                    this._ensureBitmapData();
                    var view = this._view;
                    var width = this._rect.width;
                    var output = new Int32Array(r.area);
                    var p = 0;
                    for (var y = yMin; y < yMax; y++) {
                        var offset = y * width;
                        for (var x = xMin; x < xMax; x++) {
                            var colorBGRA = view[offset + x];
                            var alpha = colorBGRA & 0xff;
                            var colorBGR = colorBGRA >>> 8;
                            colorBGRA = ((255 * colorBGR) / alpha) << 8 | alpha;
                            output[p++] = colorBGRA;
                        }
                    }
                    return output;
                };
                /**
                 * TODO: Not tested.
                 */
                BitmapData.prototype._putPixelData = function (rect, input) {
                    var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                    if (r.isEmpty()) {
                        return;
                    }
                    var xMin = r.x;
                    var xMax = r.x + r.width;
                    var yMin = r.y;
                    var yMax = r.y + r.height;
                    this._ensureBitmapData();
                    var view = this._view;
                    var width = this._rect.width;
                    var p = (rect.width * rect.height - r.height) + (xMin - rect.x);
                    var padding = rect.width - r.width;
                    var alphaMask = this._transparent ? 0x00 : 0xff;
                    for (var y = yMin; y < yMax; y++) {
                        var offset = y * width;
                        for (var x = xMin; x < xMax; x++) {
                            var colorBGRA = input[p++];
                            var alpha = colorBGRA & alphaMask;
                            var colorBGR = colorBGRA >>> 8;
                            view[offset + x] = (((colorBGR * alpha + 254) / 255) & 0x00ffffff) << 8 | alpha;
                        }
                        p += padding;
                    }
                    this._invalidate();
                };
                Object.defineProperty(BitmapData.prototype, "width", {
                    get: function () {
                        return this._rect.width;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BitmapData.prototype, "height", {
                    get: function () {
                        return this._rect.height;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BitmapData.prototype, "rect", {
                    get: function () {
                        return this._rect.clone();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BitmapData.prototype, "transparent", {
                    get: function () {
                        return this._transparent;
                    },
                    enumerable: true,
                    configurable: true
                });
                BitmapData.prototype.clone = function () {
                    var bd = this._sec.display.BitmapData.createObject();
                    bd._rect = this._rect.clone();
                    bd._transparent = this._transparent;
                    bd._solidFillColorPBGRA = this._solidFillColorPBGRA;
                    bd._bitmapReferrers = [];
                    // TODO: clone without reading back bitmapdata. There's no need for that.
                    this._ensureBitmapData();
                    bd._id = flash.display.DisplayObject.getNextSyncID();
                    bd._setData(new Uint8Array(this._data), this._type);
                    return bd;
                };
                /**
                 * Returns an straight alpha RGB pixel value 0x00RRGGBB.
                 */
                BitmapData.prototype.getPixel = function (x /*int*/, y /*int*/) {
                    x = x | 0;
                    y = y | 0;
                    return this.getPixel32(x, y) & 0x00ffffff;
                };
                /**
                 * Returns an straight alpha ARGB pixel value 0xAARRGGBB.
                 */
                BitmapData.prototype.getPixel32 = function (x /*int*/, y /*int*/) {
                    x = x | 0;
                    y = y | 0;
                    if (!this._rect.contains(x, y)) {
                        return 0;
                    }
                    this._ensureBitmapData();
                    var value = this._view[y * this._rect.width + x];
                    switch (this._type) {
                        case Shumway.ImageType.PremultipliedAlphaARGB:
                            var pARGB = swap32(value);
                            var uARGB = unpremultiplyARGB(pARGB);
                            return uARGB >>> 0;
                        case Shumway.ImageType.StraightAlphaRGBA:
                            return RGBAToARGB(swap32(value));
                        default:
                            Shumway.Debug.notImplemented(Shumway.ImageType[this._type]);
                            return 0;
                    }
                };
                BitmapData.prototype.setPixel = function (x /*int*/, y /*int*/, uARGB /*uint*/) {
                    // TODO: implement this as a wrapper for setPixel32.
                    x = x | 0;
                    y = y | 0;
                    uARGB = uARGB | 0;
                    if (!this._rect.contains(x, y)) {
                        return;
                    }
                    this._ensureBitmapData();
                    var i = y * this._rect.width + x;
                    var a = this._view[i] & 0xff;
                    uARGB = uARGB & 0x00ffffff | a << 24;
                    var pARGB = premultiplyARGB(uARGB);
                    this._view[i] = swap32(pARGB);
                    this._invalidate();
                    this._solidFillColorPBGRA = null;
                };
                BitmapData.prototype.setPixel32 = function (x /*int*/, y /*int*/, uARGB /*uint*/) {
                    x = x | 0;
                    y = y | 0;
                    if (!this._rect.contains(x, y)) {
                        return;
                    }
                    this._ensureBitmapData();
                    var a = uARGB >>> 24;
                    var uRGB = uARGB & 0x00ffffff;
                    var pARGB;
                    if (this._transparent) {
                        var uARGB_1 = uRGB | a << 24;
                        pARGB = premultiplyARGB(uARGB_1);
                    }
                    else {
                        pARGB = uRGB | 0xff000000;
                    }
                    this._view[y * this._rect.width + x] = swap32(pARGB);
                    this._invalidate();
                    this._solidFillColorPBGRA = null;
                };
                BitmapData.prototype.applyFilter = function (sourceBitmapData, sourceRect, destPoint, filter) {
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    filter = filter;
                    release || somewhatImplemented("public flash.display.BitmapData::applyFilter " + filter);
                    return;
                };
                BitmapData.prototype.colorTransform = function (rect, colorTransform) {
                    rect = rect;
                    colorTransform = colorTransform;
                    release || somewhatImplemented("public flash.display.BitmapData::colorTransform");
                    return;
                };
                BitmapData.prototype.compare = function (otherBitmapData) {
                    otherBitmapData = otherBitmapData;
                    release || notImplemented("public flash.display.BitmapData::compare");
                    return null;
                };
                BitmapData.prototype.copyChannel = function (sourceBitmapData, sourceRect, destPoint, sourceChannel /*uint*/, destChannel
                /*uint*/ ) {
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    sourceChannel = sourceChannel >>> 0;
                    destChannel = destChannel >>> 0;
                    release || somewhatImplemented("public flash.display.BitmapData::copyChannel");
                    return;
                };
                /**
                 * Copies a rectangular region of pixels into the current bitmap data.
                 */
                BitmapData.prototype.copyPixels = function (sourceBitmapData, sourceRect, destPoint, alphaBitmapData, alphaPoint, mergeAlpha) {
                    if (alphaBitmapData === void 0) { alphaBitmapData = null; }
                    if (alphaPoint === void 0) { alphaPoint = null; }
                    mergeAlpha = !!mergeAlpha;
                    if (alphaBitmapData || alphaPoint) {
                        release || somewhatImplemented("public flash.display.BitmapData::copyPixels - Alpha");
                        return;
                    }
                    // Deal with fractional pixel coordinates, looks like Flash "rounds" the corners of
                    // the source rect, however a width of |0.5| rounds down rather than up so we're not
                    // quite correct here.
                    var sRect;
                    if (sourceRect) {
                        sRect = this._getTemporaryRectangleFrom(sourceRect).roundInPlace();
                    }
                    else {
                        sRect = this._sec.geom._temporaryRectangle.setEmpty();
                    }
                    var tBRect = this._rect;
                    var sBRect = sourceBitmapData._rect;
                    // Clip sRect against SBRect.
                    var sL = Math.max(sRect.x, 0);
                    var sT = Math.max(sRect.y, 0);
                    var sR = Math.min(sRect.x + sRect.width, sBRect.width);
                    var sB = Math.min(sRect.y + sRect.height, sBRect.height);
                    // Compute source rect offsets (in case the source rect had negative x, y coordinates).
                    var oX = sL - sRect.x;
                    var oY = sT - sRect.y;
                    var tL = (destPoint.x | 0) + oX;
                    var tT = (destPoint.y | 0) + oY;
                    if (tL < 0) {
                        sL -= tL;
                        tL = 0;
                    }
                    if (tT < 0) {
                        sT -= tT;
                        tT = 0;
                    }
                    var tW = Math.min(sR - sL, tBRect.width - tL);
                    var tH = Math.min(sB - sT, tBRect.height - tT);
                    if (tW <= 0 || tH <= 0) {
                        return;
                    }
                    var sX = sL;
                    var sY = sT;
                    var tX = tL;
                    var tY = tT;
                    var sStride = sourceBitmapData._rect.width;
                    var tStride = this._rect.width;
                    this._ensureBitmapData();
                    sourceBitmapData._ensureBitmapData();
                    var s = sourceBitmapData._view;
                    var t = this._view;
                    if (sourceBitmapData._type !== this._type) {
                        release || somewhatImplemented("public flash.display.BitmapData::copyPixels - Color Format Conversion");
                    }
                    if (mergeAlpha && this._type !== Shumway.ImageType.PremultipliedAlphaARGB) {
                        release || somewhatImplemented("public flash.display.BitmapData::copyPixels - Merge Alpha");
                        return;
                    }
                    // No reason to copy pixels since since both source and target are the same solid fill,
                    // regardless of alpha blending. (TODO: I think the math works out for mergeAlpha also.)
                    if (this._solidFillColorPBGRA !== null &&
                        this._solidFillColorPBGRA === sourceBitmapData._solidFillColorPBGRA) {
                        return;
                    }
                    // Source has a solid fill but is fully opaque, we can get away without alpha blending here.
                    if (sourceBitmapData._solidFillColorPBGRA !== null &&
                        (sourceBitmapData._solidFillColorPBGRA & 0xFF) === 0xFF) {
                        mergeAlpha = false;
                    }
                    // Finally do the copy. All the math above is needed just so we don't do any branches inside
                    // this hot loop.
                    if (mergeAlpha) {
                        this._copyPixelsAndMergeAlpha(s, sX, sY, sStride, t, tX, tY, tStride, tW, tH);
                    }
                    else {
                        var sP = (sY * sStride + sX) | 0;
                        var tP = (tY * tStride + tX) | 0;
                        if ((tW & 3) === 0) {
                            for (var y = 0; y < tH; y = y + 1 | 0) {
                                for (var x = 0; x < tW; x = x + 4 | 0) {
                                    t[(tP + x + 0) | 0] = s[(sP + x + 0) | 0];
                                    t[(tP + x + 1) | 0] = s[(sP + x + 1) | 0];
                                    t[(tP + x + 2) | 0] = s[(sP + x + 2) | 0];
                                    t[(tP + x + 3) | 0] = s[(sP + x + 3) | 0];
                                }
                                sP = sP + sStride | 0;
                                tP = tP + tStride | 0;
                            }
                        }
                        else {
                            for (var y = 0; y < tH; y = y + 1 | 0) {
                                for (var x = 0; x < tW; x = x + 1 | 0) {
                                    t[tP + x | 0] = s[sP + x | 0];
                                }
                                sP = sP + sStride | 0;
                                tP = tP + tStride | 0;
                            }
                        }
                    }
                    this._solidFillColorPBGRA = null;
                    this._invalidate();
                };
                BitmapData.prototype._copyPixelsAndMergeAlpha = function (s, sX, sY, sStride, t, tX, tY, tStride, tW, tH) {
                    var sP = (sY * sStride + sX) | 0;
                    var tP = (tY * tStride + tX) | 0;
                    for (var y = 0; y < tH; y = y + 1 | 0) {
                        for (var x = 0; x < tW; x = x + 1 | 0) {
                            var spBGRA = s[sP + x | 0];
                            var sA = spBGRA & 0xff;
                            // Optimize for the case where the source pixel is fully opaque or transparent. This
                            // pays off if the source image has many such pixels but slows down the normal case.
                            if (sA === 0xff) {
                                t[tP + x | 0] = spBGRA; // Opaque, just copy value over.
                            }
                            else if (sA === 0) {
                                // Transparent, don't do anything.
                            }
                            else {
                                // Compute the blending equation: src.rgb + (dst.rgb * (1 - src.a)). The trick here
                                // is to compute GA and BR at the same time without pulling apart each channel.
                                // We use the "double blend trick" (http://stereopsis.com/doubleblend.html) to
                                // compute GA and BR without unpacking them.
                                var sGA = spBGRA & 0x00ff00ff;
                                var sBR = spBGRA >> 8 & 0x00ff00ff;
                                var tpBGRA = t[tP + x | 0];
                                var tGA = tpBGRA & 0x00ff00ff;
                                var tBR = tpBGRA >> 8 & 0x00ff00ff;
                                var A = 256 - sA;
                                tGA = Math.imul(tGA, A) >> 8;
                                tBR = Math.imul(tBR, A) >> 8;
                                // TODO: Not sure if target alpha is computed correctly.
                                t[tP + x | 0] = ((sBR + tBR & 0x00ff00ff) << 8) | (sGA + tGA & 0x00ff00ff);
                            }
                        }
                        sP = sP + sStride | 0;
                        tP = tP + tStride | 0;
                    }
                };
                BitmapData.prototype.dispose = function () {
                    this._rect.setEmpty();
                    this._view = null;
                    this._invalidate();
                };
                BitmapData.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                    if (matrix === void 0) { matrix = null; }
                    if (colorTransform === void 0) { colorTransform = null; }
                    if (blendMode === void 0) { blendMode = null; }
                    if (clipRect === void 0) { clipRect = null; }
                    if (smoothing === void 0) { smoothing = false; }
                    smoothing = !!smoothing;
                    release || somewhatImplemented("public flash.display.BitmapData::draw");
                    var serializer = this._sec.player;
                    if (matrix) {
                        matrix = matrix.clone().toTwipsInPlace();
                    }
                    serializer.drawToBitmap(this, source, matrix, colorTransform, blendMode, clipRect, smoothing);
                    this._isRemoteDirty = true;
                };
                BitmapData.prototype.drawWithQuality = function (source, matrix, colorTransform, blendMode, clipRect, smoothing, quality) {
                    if (matrix === void 0) { matrix = null; }
                    if (colorTransform === void 0) { colorTransform = null; }
                    if (blendMode === void 0) { blendMode = null; }
                    if (clipRect === void 0) { clipRect = null; }
                    if (smoothing === void 0) { smoothing = false; }
                    if (quality === void 0) { quality = null; }
                    release || somewhatImplemented("public flash.display.BitmapData::drawWithQuality");
                    this.draw(source, matrix, colorTransform, blendMode, clipRect, smoothing);
                };
                BitmapData.prototype.fillRect = function (rect, uARGB /*uint*/) {
                    this._ensureBitmapData();
                    // TODO: what guarantees this, and why do we even need it?
                    release || assert(this._type === Shumway.ImageType.PremultipliedAlphaARGB);
                    var pARGB;
                    if (this._transparent) {
                        pARGB = premultiplyARGB(uARGB);
                    }
                    else {
                        pARGB = uARGB | 0xff000000;
                    }
                    var pBGRA = swap32(pARGB);
                    var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                    if (r.isEmpty()) {
                        return;
                    }
                    // Filling with the same color?
                    if (this._solidFillColorPBGRA === pBGRA) {
                        return;
                    }
                    var view = this._view;
                    // If we are filling the entire buffer, we can do a little better ~ 25% faster.
                    if (r.equals(this._rect)) {
                        var length_7 = view.length | 0;
                        // Unroll 4 iterations, ~ 5% faster.
                        if ((length_7 & 0x3) === 0) {
                            for (var i = 0; i < length_7; i += 4) {
                                view[i] = pBGRA;
                                view[i + 1] = pBGRA;
                                view[i + 2] = pBGRA;
                                view[i + 3] = pBGRA;
                            }
                        }
                        else {
                            for (var i = 0; i < length_7; i++) {
                                view[i] = pBGRA;
                            }
                        }
                        this._solidFillColorPBGRA = pBGRA;
                    }
                    else {
                        var xMin = r.x | 0;
                        var xMax = r.x + r.width | 0;
                        var yMin = r.y | 0;
                        var yMax = r.y + r.height | 0;
                        var width = this._rect.width | 0;
                        for (var y = yMin; y < yMax; y++) {
                            var offset = y * width | 0;
                            for (var x = xMin; x < xMax; x++) {
                                view[offset + x] = pBGRA;
                            }
                        }
                        this._solidFillColorPBGRA = null;
                    }
                    this._invalidate();
                };
                BitmapData.prototype.floodFill = function (x /*int*/, y /*int*/, color /*uint*/) {
                    x = x | 0;
                    y = y | 0;
                    color = color >>> 0;
                    release || somewhatImplemented("public flash.display.BitmapData::floodFill");
                    return;
                };
                BitmapData.prototype.generateFilterRect = function (sourceRect, filter) {
                    sourceRect = sourceRect;
                    filter = filter;
                    release || somewhatImplemented("public flash.display.BitmapData::generateFilterRect");
                    return null;
                };
                BitmapData.prototype.getColorBoundsRect = function (mask /*uint*/, color /*uint*/, findColor) {
                    if (findColor === void 0) { findColor = true; }
                    mask = mask >>> 0;
                    color = color >>> 0;
                    findColor = !!findColor;
                    release || somewhatImplemented("public flash.display.BitmapData::getColorBoundsRect");
                    return this._sec.geom.Rectangle.create();
                };
                BitmapData.prototype.getPixels = function (rect) {
                    var outputByteArray = this._sec.utils.ByteArray.create();
                    this.copyPixelsToByteArray(rect, outputByteArray);
                    return outputByteArray;
                };
                BitmapData.prototype.copyPixelsToByteArray = function (rect, data) {
                    var pixelData = this._getPixelData(rect);
                    if (!pixelData) {
                        return;
                    }
                    data.writeRawBytes(new Uint8Array(pixelData));
                };
                BitmapData.prototype.getVector = function (rect) {
                    var pixelData = this._getPixelData(rect);
                    if (!pixelData) {
                        return new Uint32Array(0);
                    }
                    var outputVector = new Uint32Array(pixelData.length);
                    outputVector.set(pixelData);
                    return outputVector;
                };
                BitmapData.prototype.hitTest = function (firstPoint, firstAlphaThreshold /*uint*/, secondObject, secondBitmapDataPoint, secondAlphaThreshold) {
                    if (secondBitmapDataPoint === void 0) { secondBitmapDataPoint = null; }
                    if (secondAlphaThreshold === void 0) { secondAlphaThreshold = 1; }
                    firstPoint = firstPoint;
                    firstAlphaThreshold = firstAlphaThreshold >>> 0;
                    secondObject = secondObject;
                    secondBitmapDataPoint = secondBitmapDataPoint;
                    secondAlphaThreshold = secondAlphaThreshold >>> 0;
                    release || somewhatImplemented("public flash.display.BitmapData::hitTest");
                    return true;
                };
                BitmapData.prototype.merge = function (sourceBitmapData, sourceRect, destPoint, redMultiplier /*uint*/, greenMultiplier
                /*uint*/ , blueMultiplier /*uint*/, alphaMultiplier /*uint*/) {
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    redMultiplier = redMultiplier >>> 0;
                    greenMultiplier = greenMultiplier >>> 0;
                    blueMultiplier = blueMultiplier >>> 0;
                    alphaMultiplier = alphaMultiplier >>> 0;
                    release || somewhatImplemented("public flash.display.BitmapData::merge");
                };
                BitmapData.prototype.noise = function (randomSeed /*int*/, low, high, channelOptions, grayScale) {
                    if (low === void 0) { low = 0; }
                    if (high === void 0) { high = 255; }
                    if (channelOptions === void 0) { channelOptions = 7; }
                    if (grayScale === void 0) { grayScale = false; }
                    randomSeed = randomSeed | 0;
                    low = low >>> 0;
                    high = high >>> 0;
                    channelOptions = channelOptions >>> 0;
                    grayScale = !!grayScale;
                    release || somewhatImplemented("public flash.display.BitmapData::noise");
                };
                BitmapData.prototype.paletteMap = function (sourceBitmapData, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray) {
                    if (redArray === void 0) { redArray = null; }
                    if (greenArray === void 0) { greenArray = null; }
                    if (blueArray === void 0) { blueArray = null; }
                    if (alphaArray === void 0) { alphaArray = null; }
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    redArray = redArray;
                    greenArray = greenArray;
                    blueArray = blueArray;
                    alphaArray = alphaArray;
                    release || somewhatImplemented("public flash.display.BitmapData::paletteMap");
                };
                BitmapData.prototype.perlinNoise = function (baseX, baseY, numOctaves /*uint*/, randomSeed
                /*int*/ , stitch, fractalNoise, channelOptions, grayScale, offsets) {
                    if (channelOptions === void 0) { channelOptions = 7; }
                    if (grayScale === void 0) { grayScale = false; }
                    if (offsets === void 0) { offsets = null; }
                    baseX = +baseX;
                    baseY = +baseY;
                    numOctaves = numOctaves >>> 0;
                    randomSeed = randomSeed | 0;
                    stitch = !!stitch;
                    fractalNoise = !!fractalNoise;
                    channelOptions = channelOptions >>> 0;
                    grayScale = !!grayScale;
                    offsets = offsets;
                    release || somewhatImplemented("public flash.display.BitmapData::perlinNoise");
                };
                BitmapData.prototype.pixelDissolve = function (sourceBitmapData, sourceRect, destPoint, randomSeed, numPixels, fillColor) {
                    if (randomSeed === void 0) { randomSeed = 0; }
                    if (numPixels === void 0) { numPixels = 0; }
                    if (fillColor === void 0) { fillColor = 0; }
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    randomSeed = randomSeed | 0;
                    numPixels = numPixels | 0;
                    fillColor = fillColor >>> 0;
                    release || somewhatImplemented("public flash.display.BitmapData::pixelDissolve");
                    return 0;
                };
                BitmapData.prototype.scroll = function (x /*int*/, y /*int*/) {
                    x = x | 0;
                    y = y | 0;
                    release || somewhatImplemented("public flash.display.BitmapData::scroll");
                    return;
                };
                BitmapData.prototype.setPixels = function (rect, inputByteArray) {
                    this._putPixelData(rect, new Int32Array(inputByteArray.readRawBytes()));
                };
                BitmapData.prototype.setVector = function (rect, inputVector) {
                    this._putPixelData(rect, inputVector);
                };
                BitmapData.prototype.threshold = function (sourceBitmapData, sourceRect, destPoint, operation, threshold /*uint*/, color, mask, copySource) {
                    if (color === void 0) { color = 0; }
                    if (mask === void 0) { mask = 4294967295; }
                    if (copySource === void 0) { copySource = false; }
                    sourceBitmapData = sourceBitmapData;
                    sourceRect = sourceRect;
                    destPoint = destPoint;
                    operation = operation;
                    threshold = threshold >>> 0;
                    color = color >>> 0;
                    mask = mask >>> 0;
                    copySource = !!copySource;
                    release || somewhatImplemented("public flash.display.BitmapData::threshold");
                    return 0;
                };
                BitmapData.prototype.lock = function () {
                    this._locked = true;
                };
                BitmapData.prototype.unlock = function (changeRect) {
                    if (changeRect === void 0) { changeRect = null; }
                    //changeRect = changeRect;
                    this._locked = false;
                };
                BitmapData.prototype.histogram = function (hRect) {
                    if (hRect === void 0) { hRect = null; }
                    hRect = hRect;
                    release || notImplemented("public flash.display.BitmapData::histogram");
                    return null;
                };
                BitmapData.prototype.encode = function (rect, compressor, byteArray) {
                    if (byteArray === void 0) { byteArray = null; }
                    rect = rect;
                    compressor = compressor;
                    byteArray = byteArray;
                    release || notImplemented("public flash.display.BitmapData::encode");
                    return null;
                };
                /**
                 * Ensures that we have the most up-to-date version of the bitmap data. If a call to
                 * |BitmpaData.draw| was made since the last time this method was called, then we need to send
                 * a synchronous message to the GFX remote requesting the latest image data.
                 *
                 * Here we also normalize the image format to |ImageType.StraightAlphaRGBA|. We only need the
                 * normalized pixel data for pixel operations, so we defer image decoding as late as possible.
                 */
                BitmapData.prototype._ensureBitmapData = function () {
                    if (this._isRemoteDirty) {
                        var data = this._sec.player.requestBitmapData(this);
                        this._setData(data.getBytes(), Shumway.ImageType.StraightAlphaRGBA);
                        this._isRemoteDirty = false;
                        this._isDirty = false;
                        this._solidFillColorPBGRA = null;
                    }
                    release || assert(!(this._type === Shumway.ImageType.JPEG || this._type === Shumway.ImageType.PNG ||
                        this._type === Shumway.ImageType.GIF));
                    if (this._type !== Shumway.ImageType.PremultipliedAlphaARGB) {
                        Shumway.ColorUtilities.convertImage(this._type, Shumway.ImageType.PremultipliedAlphaARGB, this._view, this._view);
                        this._type = Shumway.ImageType.PremultipliedAlphaARGB;
                        this._solidFillColorPBGRA = null;
                    }
                    release || assert(this._data);
                    release || assert(this._dataBuffer);
                    release || assert(this._view);
                };
                BitmapData.classInitializer = null;
                BitmapData.MAXIMUM_WIDTH = 8191;
                BitmapData.MAXIMUM_HEIGHT = 8191;
                BitmapData.MAXIMUM_DIMENSION = 16777215;
                return BitmapData;
            }(flash.LegacyEntity));
            display.BitmapData = BitmapData;
            var BitmapSymbol = /** @class */ (function (_super) {
                __extends(BitmapSymbol, _super);
                function BitmapSymbol(data, _sec) {
                    var _this = _super.call(this, data, _sec.display.BitmapData, false) || this;
                    _this.ready = false;
                    return _this;
                }
                BitmapSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new BitmapSymbol(data, loaderInfo._sec);
                    // For non-decoded images, we don't yet have dimensions.
                    symbol.width = data.width || -1;
                    symbol.height = data.height || -1;
                    symbol.syncId = flash.display.DisplayObject.getNextSyncID();
                    symbol.data = data.data;
                    switch (data.mimeType) {
                        case "application/octet-stream":
                            symbol.type = data.dataType;
                            symbol.ready = true;
                            break;
                        case "image/jpeg":
                            symbol.type = Shumway.ImageType.JPEG;
                            break;
                        case "image/png":
                            symbol.type = Shumway.ImageType.PNG;
                            break;
                        case "image/gif":
                            symbol.type = Shumway.ImageType.GIF;
                            break;
                        default:
                            notImplemented(data.mimeType);
                    }
                    return symbol;
                };
                BitmapSymbol.prototype.getSharedInstance = function () {
                    return this.sharedInstance || this.createSharedInstance();
                };
                BitmapSymbol.prototype.createSharedInstance = function () {
                    release || assert(this.ready);
                    return this.sharedInstance = flash.system.constructClassFromSymbol(this, this.symbolClass);
                };
                Object.defineProperty(BitmapSymbol.prototype, "resolveAssetCallback", {
                    get: function () {
                        return this._unboundResolveAssetCallback.bind(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                BitmapSymbol.prototype._unboundResolveAssetCallback = function (data) {
                    release || assert(!this.ready);
                    this.ready = true;
                    if (!data) {
                        release || Shumway.Debug.error("Error while decoding image");
                        return;
                    }
                    release || assert(data.width);
                    release || assert(data.height);
                    this.width = data.width;
                    this.height = data.height;
                };
                return BitmapSymbol;
            }(Shumway.Timeline.DisplaySymbol));
            display.BitmapSymbol = BitmapSymbol;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapDataChannel
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var BitmapDataChannel;
            (function (BitmapDataChannel) {
                BitmapDataChannel[BitmapDataChannel["RED"] = 1] = "RED";
                BitmapDataChannel[BitmapDataChannel["GREEN"] = 2] = "GREEN";
                BitmapDataChannel[BitmapDataChannel["BLUE"] = 4] = "BLUE";
                BitmapDataChannel[BitmapDataChannel["ALPHA"] = 8] = "ALPHA";
            })(BitmapDataChannel = display.BitmapDataChannel || (display.BitmapDataChannel = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapEncodingColorSpace
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var BitmapEncodingColorSpace;
            (function (BitmapEncodingColorSpace) {
                BitmapEncodingColorSpace["COLORSPACE_AUTO"] = "auto";
                BitmapEncodingColorSpace["COLORSPACE_4_4_4"] = "4:4:4";
                BitmapEncodingColorSpace["COLORSPACE_4_2_2"] = "4:2:2";
                BitmapEncodingColorSpace["COLORSPACE_4_2_0"] = "4:2:0";
            })(BitmapEncodingColorSpace = display.BitmapEncodingColorSpace || (display.BitmapEncodingColorSpace = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: JPEGEncoderOptions
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var JPEGEncoderOptions = /** @class */ (function (_super) {
                __extends(JPEGEncoderOptions, _super);
                function JPEGEncoderOptions(quality) {
                    if (quality === void 0) { quality = 80; }
                    var _this = _super.call(this) || this;
                    _this.quality = quality >>> 0;
                    return _this;
                }
                return JPEGEncoderOptions;
            }(flash.LegacyEntity));
            display.JPEGEncoderOptions = JPEGEncoderOptions;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var events = flash.events;
            var FileLoader = Shumway.FileLoader;
            var SWFFile = Shumway.SWF.SWFFile;
            var ABCFile = flash.lang.ABCFile;
            var Multiname = flash.lang.Multiname;
            var LoadStatus;
            (function (LoadStatus) {
                LoadStatus[LoadStatus["Unloaded"] = 0] = "Unloaded";
                LoadStatus[LoadStatus["Opened"] = 1] = "Opened";
                LoadStatus[LoadStatus["Initialized"] = 2] = "Initialized";
                LoadStatus[LoadStatus["Complete"] = 3] = "Complete";
            })(LoadStatus = display.LoadStatus || (display.LoadStatus = {}));
            var LoadingType;
            (function (LoadingType) {
                LoadingType[LoadingType["External"] = 0] = "External";
                LoadingType[LoadingType["Bytes"] = 1] = "Bytes";
            })(LoadingType = display.LoadingType || (display.LoadingType = {}));
            var Loader = /** @class */ (function (_super) {
                __extends(Loader, _super);
                function Loader() {
                    var _this = _super.call(this) || this;
                    var displayObjectClass = _this._sec.display;
                    displayObjectClass._advancableInstances.push(_this);
                    _this._content = null;
                    if (displayObjectClass.Loader._rootLoader) {
                        // Loader reserves the next instance ID to use for the loaded content.
                        // This isn't needed for the first, root, loader, because that uses "root1" as the name.
                        _this._contentID = displayObjectClass._instanceID++;
                    }
                    else {
                        // The root loader gets a default name, but it's not visible and hence
                        // the instance id must not be used up.
                        displayObjectClass._instanceID--;
                    }
                    _this._contentLoaderInfo = _this._sec.display.LoaderInfo.create([displayObjectClass.Loader.CtorToken]);
                    _this._contentLoaderInfo._loader = _this;
                    // @ivanpopelyshev: That's bad. No cirrentABC for us.
                    _this._contentLoaderInfo._loaderUrl = _this._sec.system._currentDomain.url;
                    // let currentAbc = AVMX.getCurrentABC();
                    // if (currentAbc) {
                    // 	this._contentLoaderInfo._loaderUrl = currentAbc.env.url;
                    // }
                    _this._fileLoader = null;
                    _this._loadStatus = LoadStatus.Unloaded;
                    return _this;
                }
                Loader.prototype._setStage = function (stage) {
                    release || assert(this === this._sec.display.Loader.getRootLoader());
                    this._stage = stage;
                };
                Loader.prototype._initFrame = function (advance) {
                    // ...
                };
                Loader.prototype._constructFrame = function () {
                    var context = this._sec;
                    if (this === context.display.Loader.getRootLoader() && this._content) {
                        context.display._advancableInstances.remove(this);
                        this._children[0] = this._content;
                        this._constructChildren();
                        this._children.length = 0;
                        return;
                    }
                    this._constructChildren();
                };
                Loader.prototype.addChild = function (child) {
                    this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidLoaderMethodError);
                    return null;
                };
                Loader.prototype.addChildAt = function (child, index) {
                    this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidLoaderMethodError);
                    return null;
                };
                Loader.prototype.removeChild = function (child) {
                    this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidLoaderMethodError);
                    return null;
                };
                Loader.prototype.removeChildAt = function (index) {
                    this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidLoaderMethodError);
                    return null;
                };
                Loader.prototype.setChildIndex = function (child, index) {
                    this._sec.throwError('IllegalOperationError', Shumway.Errors.InvalidLoaderMethodError);
                };
                /**
                 * No way of knowing what's in |data|, so do a best effort to print out some meaninfgul debug
                 * info.
                 */
                Loader.prototype._describeData = function (data) {
                    var keyValueParis = [];
                    for (var k in data) {
                        keyValueParis.push(k + ":" + Shumway.StringUtilities.toSafeString(data[k]));
                    }
                    return "{" + keyValueParis.join(", ") + "}";
                };
                Object.defineProperty(Loader.prototype, "content", {
                    get: function () {
                        if (this._loadStatus === LoadStatus.Unloaded) {
                            return null;
                        }
                        return this._content;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Loader.prototype, "contentLoaderInfo", {
                    get: function () {
                        return this._contentLoaderInfo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Loader.prototype._getJPEGLoaderContextdeblockingfilter = function (context) {
                    if (this._sec.system.JPEGLoaderContext.axIsType(context)) {
                        return context.deblockingFilter;
                    }
                    return 0.0;
                };
                Object.defineProperty(Loader.prototype, "uncaughtErrorEvents", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.Loader::uncaughtErrorEvents");
                        if (!this._uncaughtErrorEvents) {
                            this._uncaughtErrorEvents = new events.UncaughtErrorEvents();
                        }
                        return this._uncaughtErrorEvents;
                    },
                    enumerable: true,
                    configurable: true
                });
                Loader.prototype._canLoadSWFFromDomain = function (url) {
                    url = Shumway.FileLoadingService.instance.resolveUrl(url);
                    var whitelist = this._sec.player;
                    return whitelist.checkDomainForSWFLoading(url);
                };
                Loader.prototype.load = function (request, context) {
                    this.close();
                    // TODO: clean up contentloaderInfo.
                    var resolvedURL = Shumway.FileLoadingService.instance.resolveUrl(request.url);
                    this._contentLoaderInfo._url = resolvedURL;
                    this._applyLoaderContext(context);
                    this._loadingType = LoadingType.External;
                    var fileLoader = this._fileLoader = new FileLoader(this, this._contentLoaderInfo);
                    if (!release && Shumway.traceLoaderOption.value) {
                        console.log("Loading url " + request.url);
                    }
                    fileLoader.loadFile(request._toFileRequest());
                    this._queuedLoadUpdate = null;
                    var loaderClass = this._sec.display.Loader;
                    release || assert(loaderClass._loadQueue.indexOf(this) === -1);
                    loaderClass._loadQueue.push(this);
                };
                Loader.prototype.loadBytes = function (data, context) {
                    this.close();
                    // TODO: properly coerce object arguments to their types.
                    var loaderClass = this._sec.display.Loader;
                    // In case this is the initial root loader, we won't have a loaderInfo object. That should
                    // only happen in the inspector when a file is loaded from a Blob, though.
                    this._contentLoaderInfo._url = (this.loaderInfo ? this.loaderInfo._url : '') +
                        '/[[DYNAMIC]]/' + (++loaderClass._embeddedContentLoadCount);
                    this._applyLoaderContext(context);
                    this._loadingType = LoadingType.Bytes;
                    this._fileLoader = new FileLoader(this, this._contentLoaderInfo);
                    this._queuedLoadUpdate = null;
                    if (!release && Shumway.traceLoaderOption.value) {
                        console.log("Loading embedded symbol " + this._contentLoaderInfo._url);
                    }
                    // Just passing in the bytes won't do, because the buffer can contain slop at the end.
                    this._fileLoader.loadBytes(new Uint8Array(data.bytes, 0, data.length));
                    release || assert(loaderClass._loadQueue.indexOf(this) === -1);
                    loaderClass._loadQueue.push(this);
                };
                Loader.prototype.close = function () {
                    var loaderClass = this._sec.display.Loader;
                    var queueIndex = loaderClass._loadQueue.indexOf(this);
                    if (queueIndex > -1) {
                        loaderClass._loadQueue.splice(queueIndex, 1);
                    }
                    this._contentLoaderInfo.reset();
                    if (!this._fileLoader) {
                        return;
                    }
                    this._fileLoader.abortLoad();
                    this._fileLoader = null;
                };
                Loader.prototype._unload = function (stopExecution, gc) {
                    if (this._loadStatus < LoadStatus.Initialized) {
                        this._loadStatus = LoadStatus.Unloaded;
                        return;
                    }
                    this.close();
                    this._content = null;
                    this._contentLoaderInfo._loader = null;
                    this._loadStatus = LoadStatus.Unloaded;
                    this.dispatchEvent(this._sec.events.getInstance(events.Event.UNLOAD));
                };
                Loader.prototype.unload = function () {
                    this._unload(false, false);
                };
                Loader.prototype.unloadAndStop = function (gc) {
                    // TODO: remove all DisplayObjects originating from the unloaded SWF from all lists and stop
                    // them.
                    this._unload(true, !!gc);
                };
                Loader.prototype._applyLoaderContext = function (context) {
                    var parameters = context && context.parameters ?
                        context.parameters :
                        {};
                    if (context && context.applicationDomain) {
                        this._contentLoaderInfo._applicationDomain = context.applicationDomain;
                    }
                    else if (this._loaderInfo && this._loaderInfo._applicationDomain) {
                        this._contentLoaderInfo._applicationDomain = this._loaderInfo._applicationDomain;
                    }
                    else {
                        this._contentLoaderInfo._applicationDomain = this._sec.system.ApplicationDomain.create();
                        this._contentLoaderInfo._applicationDomain.url = this._contentLoaderInfo.url;
                    }
                    this._contentLoaderInfo._parameters = parameters;
                    this._contentLoaderInfo._allowCodeImport = context ? context.allowCodeImport : true;
                    this._contentLoaderInfo._checkPolicyFile = context ? context.checkPolicyFile : false;
                    this._contentLoaderInfo._avm1Context = context ? context._avm1Context : null;
                };
                Loader.prototype.onLoadOpen = function (file) {
                    if (!file) {
                        this._contentLoaderInfo.dispatchEvent(this._sec.events.IOErrorEvent.create([events.IOErrorEvent.IO_ERROR, false, false,
                            Shumway.Errors.UnknownFileTypeError.message,
                            Shumway.Errors.UnknownFileTypeError.code
                        ]));
                        return;
                    }
                    // For child SWF files, only continue loading and interpreting the loaded data if the
                    // either
                    // - it is loaded from the same origin as the parent, or
                    // - the parent has called `system.Security.allowDomain` with the loadees origin whitelisted
                    // This is a mitigation against the loadee breaking our SecurityDomain sandbox and
                    // reaching into the parent's SecurityDomain, reading data it's not supposed to have
                    // access to.
                    //
                    // We perform this check only once loading has started for two reasons: one is that only
                    // at that point do we know that we're loading a SWF instead of an image (or some invalid
                    // file, in which case none of this matters). The other is that the parent might call
                    // `allowDomain` only after the load has started, in which case we still want to allow the
                    // operation to continue.
                    //
                    // Additionally, all the normal cross-domain checks apply as per usual.
                    if (file._file instanceof SWFFile) {
                        var whitelistResult = this._canLoadSWFFromDomain(this._fileLoader._url);
                        var resultType = void 0;
                        switch (whitelistResult) {
                            case 0 /* OwnDomain */:
                                resultType = 0 /* LoadSource */;
                                break;
                            case 1 /* Remote */:
                                resultType = 1 /* LoadWhitelistAllowed */;
                                break;
                            case 2 /* Failed */:
                                resultType = 2 /* LoadWhitelistDenied */;
                                break;
                            default:
                                assertUnreachable("Invalid whitelistResult");
                        }
                        Shumway.Telemetry.instance.reportTelemetry({ topic: 'loadResource', resultType: resultType });
                        if (whitelistResult === 2 /* Failed */) {
                            console.error('Loading of SWF file from ' + this._fileLoader._url +
                                ' was rejected based on allowDomain heuristic.');
                            this._fileLoader.abortLoad();
                            var message = "Security sandbox violation: SWF " + this._loaderInfo._url +
                                " cannot load SWF " + this._fileLoader._url + ". This may be worked" +
                                " around by calling Security.allowDomain.";
                            try {
                                this._contentLoaderInfo.dispatchEvent(this._sec.events.IOErrorEvent.create([events.SecurityErrorEvent.SECURITY_ERROR,
                                    false, false, message,
                                    Shumway.Errors.SecuritySwfNotAllowedError.code
                                ]));
                            }
                            catch (_) {
                                // Ignore error during event handling.
                            }
                            return;
                        }
                        if (!this._contentLoaderInfo._allowCodeImport) {
                            this._fileLoader.abortLoad();
                            try {
                                this._contentLoaderInfo.dispatchEvent(this._sec.events.IOErrorEvent.create([events.SecurityErrorEvent.SECURITY_ERROR,
                                    false, false,
                                    Shumway.Errors.AllowCodeImportError.message,
                                    Shumway.Errors.AllowCodeImportError.code
                                ]));
                            }
                            catch (_) {
                                // Ignore error during event handling.
                            }
                            return;
                        }
                    }
                    this._contentLoaderInfo.setFile(file);
                };
                Loader.prototype.onLoadProgress = function (update) {
                    release || assert(update);
                    this._queuedLoadUpdate = update;
                };
                Loader.prototype.onNewEagerlyParsedSymbols = function (dictionaryEntries, delta) {
                    var promises = [];
                    for (var i = dictionaryEntries.length - delta; i < dictionaryEntries.length; i++) {
                        var dictionaryEntry = dictionaryEntries[i];
                        var symbol = this._contentLoaderInfo.getSymbolById(dictionaryEntry.id);
                        // JPEGs with alpha channel are parsed with our JS parser for now. They're ready
                        // immediately, so don't need any more work here. We'll change them to using the system
                        // parser, but for now, just skip further processing here.
                        if (symbol.ready) {
                            continue;
                        }
                        release || assert(symbol.resolveAssetPromise);
                        release || assert(symbol.ready === false);
                        promises.push(symbol.resolveAssetPromise.promise);
                    }
                    return Promise.all(promises);
                };
                Loader.prototype.onImageBytesLoaded = function () {
                    var file = this._contentLoaderInfo._file;
                    release || assert(file instanceof Shumway.ImageFile);
                    var data = {
                        id: -1,
                        data: file.data,
                        mimeType: file.mimeType,
                        dataType: file.type,
                        type: 'image'
                    };
                    var symbol = display.BitmapSymbol.FromData(data, this._contentLoaderInfo);
                    this._imageSymbol = symbol;
                    this._sec.player.registerImage(symbol, file.type, file.data, null);
                    release || assert(symbol.resolveAssetPromise);
                };
                Loader.prototype._applyDecodedImage = function (symbol) {
                    var bitmapData = symbol.createSharedInstance();
                    this._content = this._sec.display.Bitmap.create([bitmapData]);
                    this._contentLoaderInfo._width = this._content.width * 20;
                    this._contentLoaderInfo._height = this._content.height * 20;
                    this.addTimelineObjectAtDepth(this._content, 0);
                };
                Loader.prototype._applyLoadUpdate = function (update) {
                    var loaderInfo = this._contentLoaderInfo;
                    loaderInfo._bytesLoaded = update.bytesLoaded;
                    var file = loaderInfo._file;
                    if (!(file instanceof SWFFile)) {
                        return;
                    }
                    if (file.framesLoaded === 0) {
                        return;
                    }
                    if (loaderInfo._allowCodeExecution) {
                        var app = loaderInfo.app;
                        var abcBlocksLoaded = file.abcBlocks.length;
                        var abcBlocksLoadedDelta = abcBlocksLoaded - loaderInfo._abcBlocksLoaded;
                        if (abcBlocksLoadedDelta > 0) {
                            for (var i = loaderInfo._abcBlocksLoaded; i < abcBlocksLoaded; i++) {
                                var abcBlock = file.abcBlocks[i];
                                var abc = new ABCFile(loaderInfo, abcBlock.data);
                                if (abcBlock.flags) {
                                    // kDoAbcLazyInitializeFlag = 1 Indicates that the ABC block should not be executed
                                    // immediately.
                                    app.loadABC(abc);
                                }
                                else {
                                    // TODO: probably delay execution until playhead reaches the frame.
                                    app.loadAndExecuteABC(abc);
                                }
                            }
                            loaderInfo._abcBlocksLoaded = abcBlocksLoaded;
                        }
                        var mappedSymbolsLoaded = file.symbolClassesList.length;
                        var mappedSymbolsLoadedDelta = mappedSymbolsLoaded - loaderInfo._mappedSymbolsLoaded;
                        if (mappedSymbolsLoadedDelta > 0) {
                            //@ivanpopelyshev: sorry, hack
                            loaderInfo.getRootSymbol();
                            for (var i = loaderInfo._mappedSymbolsLoaded; i < mappedSymbolsLoaded; i++) {
                                var symbolMapping = file.symbolClassesList[i];
                                //@ivanpopelyshev: here we add symbol directly and right now
                                var name_5 = Multiname.FromFQNString(symbolMapping.className, 0 /* Public */);
                                var symbol = loaderInfo.getSymbolById(symbolMapping.id);
                                var symbolClass = flash.lang.createLegacyClass(name_5, symbol.symbolClass);
                                symbol.symbolClass = symbolClass;
                                symbolClass.setSymbol(symbol);
                                loaderInfo._applicationDomain.addClass({ name: name_5, value: symbolClass });
                                // old code:
                                // let symbolClass = app.getClass(Multiname.FromFQNString(symbolMapping.className,
                                // 	NamespaceType.Public));
                                // symbolClass.setSymbolResolver(loaderInfo.getSymbolResolver(symbolClass, symbolMapping.id));
                            }
                            loaderInfo._mappedSymbolsLoaded = mappedSymbolsLoaded;
                        }
                    }
                    // In browsers that can't synchronously decode fonts, we have already registered all
                    // embedded fonts at this point.
                    if (inFirefox) {
                        var fontsLoaded = file.fonts.length;
                        var fontsLoadedDelta = fontsLoaded - loaderInfo._fontsLoaded;
                        if (fontsLoadedDelta > 0) {
                            for (var i = loaderInfo._fontsLoaded; i < fontsLoaded; i++) {
                                this._sec.text.registerFontSymbol(file.fonts[i], loaderInfo);
                            }
                            loaderInfo._fontsLoaded = fontsLoaded;
                        }
                    }
                    var rootSymbol = loaderInfo.getRootSymbol();
                    var framesLoadedDelta = file.framesLoaded - rootSymbol.frames.length;
                    if (framesLoadedDelta === 0) {
                        return;
                    }
                    var root = this._content;
                    if (!root) {
                        root = this.createContentRoot(rootSymbol, file.sceneAndFrameLabelData);
                    }
                    var rootSprite = root;
                    for (var i = 0; i < framesLoadedDelta; i++) {
                        var frameInfo = loaderInfo.getFrame(null, rootSymbol.frames.length);
                        rootSprite._addFrame(frameInfo);
                    }
                };
                Loader.prototype.onLoadComplete = function () {
                    // Go away, tslint.
                };
                Loader.prototype.onLoadError = function () {
                    release || Shumway.Debug.warning('Not implemented: flash.display.Loader loading-error handling');
                };
                Loader.prototype._addScenesToMovieClip = function (mc, sceneData, numFrames) {
                    // Creating scenes so we will always have frames assigned to some scene.
                    if (!sceneData) {
                        mc.addScene('Scene 1', [], 0, numFrames);
                        return;
                    }
                    // Sorting scenes by offset
                    var sceneInfos = [];
                    var scenes = sceneData.scenes;
                    for (var i = 0; i < scenes.length; i++) {
                        sceneInfos.push({ offset: scenes[i].offset, name: scenes[i].name });
                    }
                    sceneInfos.sort(function (a, b) { return a.offset - b.offset; });
                    var n = sceneInfos.length;
                    var offset, endFrame;
                    if (n > 0 && sceneInfos[0].offset > 0) {
                        // Starting from non-zero frame, we need to create a fake scene.
                        offset = sceneInfos[0].offset;
                        endFrame = Math.min(offset, numFrames);
                        mc.addScene('Scene 0', [], 0, endFrame);
                    }
                    for (var i = 0, n_1 = sceneInfos.length; i < n_1; i++) {
                        var sceneInfo = sceneInfos[i];
                        offset = sceneInfo.offset;
                        if (offset >= numFrames) {
                            break; // out of the movie clip timeline range
                        }
                        endFrame = i < n_1 - 1 ? Math.min(scenes[i + 1].offset, numFrames) : numFrames;
                        mc.addScene(sceneInfo.name, [], offset, endFrame - offset);
                    }
                    var labels = sceneData.labels;
                    for (var i = 0; i < labels.length; i++) {
                        var labelInfo = labels[i];
                        mc.addFrameLabel(labelInfo.name, labelInfo.frame + 1);
                    }
                };
                Loader.prototype.createContentRoot = function (symbol, sceneData) {
                    var isAS2LoadedFromAS3 = false;
                    if (symbol.isAVM1Object && !this._contentLoaderInfo._avm1Context) {
                        // For outermost AVM1 SWF we need to create AVM1Context.
                        isAS2LoadedFromAS3 = true;
                        this._createAVM1Context();
                        // Re-sync the AVM1Context for the symbol.
                        symbol.avm1Context = this._contentLoaderInfo._avm1Context;
                    }
                    var root = flash.system.constructClassFromSymbol(symbol, symbol.symbolClass);
                    var context = this._sec;
                    // The initial SWF's root object gets a default of 'root1', which doesn't use up a
                    // DisplayObject instance ID. For the others, we have reserved one in `_contentID`.
                    context.display._instanceID--;
                    var loaderClass = context.display.Loader;
                    if (this === loaderClass._rootLoader) {
                        root._name = 'root1';
                    }
                    else {
                        root._name = 'instance' + this._contentID;
                    }
                    if (context.display.MovieClip.axIsType(root)) {
                        this._addScenesToMovieClip(root, sceneData, symbol.numFrames);
                    }
                    var loaderInfo = this._contentLoaderInfo;
                    root._loaderInfo = loaderInfo;
                    var rootTimeline = root;
                    var isTopLevelMovie = this === loaderClass.getRootLoader();
                    if (isAS2LoadedFromAS3) {
                        root = this._createAVM1Movie(root);
                    }
                    else if (isTopLevelMovie) {
                        var movieClipClass = this._sec.display;
                        movieClipClass.frameNavigationModel = loaderInfo.swfVersion < 10 ?
                            9 /* SWF9 */ :
                            10 /* SWF10 */;
                        root._perspectiveProjectionCenterX = this._stage.stageWidth / 2;
                        root._perspectiveProjectionCenterY = this._stage.stageHeight / 2;
                        root._setFlags(262144 /* HasPerspectiveProjection */);
                    }
                    this._content = root;
                    if (isTopLevelMovie) {
                        loaderClass.runtimeStartTime = Date.now();
                        this._stage.setRoot(root);
                    }
                    else {
                        this.addTimelineObjectAtDepth(root, 0);
                    }
                    // Always return the non-wrapped MovieClip instead of AVM1Movie for AVM1 SWFs.
                    return rootTimeline;
                };
                Loader.prototype._createAVM1Context = function () {
                    var contentLoaderInfo = this._contentLoaderInfo;
                    //@ivanpopelyshev: AVM1
                    var avm1Context = Shumway.AVM1.AVM1Context.create(contentLoaderInfo);
                    var context = this._sec;
                    var rootLoader = context.display.Loader.getRootLoader();
                    avm1Context.setStage(rootLoader._stage);
                    // FIXME make frameNavigationModel non-global
                    if (this === rootLoader) {
                        context.display.frameNavigationModel = 1 /* SWF1 */;
                    }
                    contentLoaderInfo._avm1Context = avm1Context;
                };
                /**
                 * Create an AVM1Movie container and wrap the root timeline into it.
                 * This associates the AVM1Context with this AVM1 MovieClip tree,
                 * including potential nested SWFs.
                 */
                Loader.prototype._createAVM1Movie = function (root) {
                    var contentLoaderInfo = this._contentLoaderInfo;
                    release || Shumway.Debug.assert(contentLoaderInfo);
                    var avm1Context = this._contentLoaderInfo._avm1Context;
                    //@ivanpopelyshev: AVM1
                    var avm1MovieClip = {};
                    //let avm1MovieClip = <AVM1.Lib.AVM1MovieClip>AVM1.Lib.getAVM1Object(root, avm1Context);
                    var parameters = contentLoaderInfo._parameters;
                    avm1MovieClip.setParameters(parameters);
                    var avm1Movie = this._sec.display.AVM1Movie.create([root]);
                    release || Shumway.Debug.assert(!avm1Context.levelsContainer, "One levels container per context");
                    avm1Context.levelsContainer = avm1Movie;
                    return avm1Movie;
                };
                return Loader;
            }(flash.display.DisplayObjectContainer));
            display.Loader = Loader;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: LoaderInfo
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var SWFFile = Shumway.SWF.SWFFile;
            var LoaderInfo = /** @class */ (function (_super) {
                __extends(LoaderInfo, _super);
                function LoaderInfo(token) {
                    var _this = _super.call(this) || this;
                    if (token !== _this._sec.display.Loader.CtorToken) {
                        _this._sec.throwError('ArgumentError', Shumway.Errors.CantInstantiateError, 'LoaderInfo$');
                    }
                    _this._loader = null;
                    _this._loaderUrl = '';
                    _this.reset();
                    return _this;
                }
                LoaderInfo.prototype.reset = function () {
                    this._url = '';
                    this._file = null;
                    this._bytesLoaded = 0;
                    this._bytesTotal = 0;
                    this._applicationDomain = null;
                    this._parameters = null;
                    this._allowCodeImport = true;
                    this._checkPolicyFile = false;
                    this._width = 0;
                    this._height = 0;
                    this._sharedEvents = null;
                    this._parentSandboxBridge = null;
                    this._childSandboxBridge = null;
                    this._content = null;
                    this._bytes = null;
                    this._uncaughtErrorEvents = null;
                    this._allowCodeExecution = true;
                    this._dictionary = [];
                    this._abcBlocksLoaded = 0;
                    this._mappedSymbolsLoaded = 0;
                    this._fontsLoaded = 0;
                    this._avm1Context = null;
                };
                LoaderInfo.prototype.setFile = function (file /* SWFFile | ImageFile */) {
                    release || assert(!this._file);
                    this._file = file;
                    this._bytesTotal = file.bytesTotal;
                    if (file instanceof SWFFile) {
                        // TODO: remove these duplicated fields from LoaderInfo.
                        var bbox = file.bounds;
                        this._width = bbox.xMax - bbox.xMin;
                        this._height = bbox.yMax - bbox.yMin;
                    }
                    else {
                        release || assert(file instanceof Shumway.ImageFile);
                    }
                };
                LoaderInfo.getLoaderInfoByDefinition = function (object) {
                    object = object;
                    release || notImplemented("public flash.display.LoaderInfo::static getLoaderInfoByDefinition");
                    return null;
                };
                Object.defineProperty(LoaderInfo.prototype, "loaderURL", {
                    get: function () {
                        if (!this._loader) {
                            // For the instance of the main class of the SWF file, this URL is the
                            // same as the SWF file's own URL.
                            // The loaderURL value can be changed by player settings.
                            var service = this._sec.player;
                            return (this._url === service.swfUrl && service.loaderUrl) || this._url;
                        }
                        return this._loaderUrl;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "url", {
                    get: function () {
                        if (!this._file) {
                            return null;
                        }
                        return this._url;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "isURLInaccessible", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get isURLInaccessible");
                        return this._file ? false : true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "bytesLoaded", {
                    get: function () {
                        return this._bytesLoaded;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "bytesTotal", {
                    get: function () {
                        return this._bytesTotal;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "applicationDomain", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get applicationDomain");
                        return this._file ? this._applicationDomain : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "app", {
                    get: function () {
                        return this._applicationDomain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "swfVersion", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        if (!(this._file instanceof SWFFile)) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotSWFError);
                        }
                        return this._file.swfVersion;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "actionScriptVersion", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        if (!(this._file instanceof SWFFile)) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotSWFError);
                        }
                        return this._file.useAVM1 ?
                            display.ActionScriptVersion.ACTIONSCRIPT2 :
                            display.ActionScriptVersion.ACTIONSCRIPT3;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "frameRate", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        if (!(this._file instanceof SWFFile)) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotSWFError);
                        }
                        return this._file.frameRate;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "width", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        return (this._width / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "height", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        return (this._height / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "contentType", {
                    get: function () {
                        if (!this._file) {
                            return null;
                        }
                        return this._file instanceof Shumway.ImageFile ?
                            this._file.mimeType :
                            'application/x-shockwave-flash';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "sharedEvents", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get sharedEvents");
                        if (!this._sharedEvents) {
                            this._sharedEvents = this._sec.events.EventDispatcher.create();
                        }
                        return this._sharedEvents;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "parentSandboxBridge", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get parentSandboxBridge");
                        return this._parentSandboxBridge;
                    },
                    set: function (door) {
                        release || somewhatImplemented("public flash.display.LoaderInfo::set parentSandboxBridge");
                        this._parentSandboxBridge = door;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "childSandboxBridge", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get childSandboxBridge");
                        return this._childSandboxBridge;
                    },
                    set: function (door) {
                        release || somewhatImplemented("public flash.display.LoaderInfo::set childSandboxBridge");
                        this._childSandboxBridge = door;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "sameDomain", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        release || somewhatImplemented("public flash.display.LoaderInfo::get sameDomain");
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "childAllowsParent", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        release || somewhatImplemented("public flash.display.LoaderInfo::get childAllowsParent");
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "parentAllowsChild", {
                    get: function () {
                        if (!this._file) {
                            this._sec.throwError('Error', Shumway.Errors.LoadingObjectNotInitializedError);
                        }
                        release || somewhatImplemented("public flash.display.LoaderInfo::get parentAllowsChild");
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "loader", {
                    get: function () {
                        return this._loader;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "content", {
                    get: function () {
                        return this._loader && this._loader.content;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "bytes", {
                    get: function () {
                        if (!this._file) {
                            return this._sec.utils.ByteArray.create();
                        }
                        // @ivanpopelyshev : both SWFFile and ImageFile has `data` Uint8Array
                        // that can be used for ByteArray constructor
                        //if SWF was compressed, it'll return uncompressed version with patched header
                        return this._sec.utils.ByteArray.create([this._file.data]);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "parameters", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::get parameters");
                        if (this._parameters) {
                            return this._parameters;
                        }
                        return {};
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderInfo.prototype, "uncaughtErrorEvents", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.LoaderInfo::_getUncaughtErrorEvents");
                        if (!this._uncaughtErrorEvents) {
                            this._uncaughtErrorEvents = this._sec.events.UncaughtErrorEvents.create();
                        }
                        return this._uncaughtErrorEvents;
                    },
                    enumerable: true,
                    configurable: true
                });
                // TODO: activate this override while keeping the ability to dispatch events from TS.
                //dispatchEvent(event: events.Event): boolean {
                //  // TODO: this should be `IllegalOperationError`, but we don't include that class.
                //  this._sec.throwError('Error', Errors.InvalidLoaderInfoMethodError);
                //  return false;
                //}
                LoaderInfo.prototype.getSymbolResolver = function (classDefinition, symbolId) {
                    return this.resolveClassSymbol.bind(this, classDefinition, symbolId);
                };
                LoaderInfo.prototype.getSymbolById = function (id) {
                    var symbol = this._dictionary[id];
                    if (symbol) {
                        if (symbol.ready === false) {
                            // We cannot assert this, as content might invalidly access symbols that aren't available
                            // yet.
                            release || Shumway.Debug.warning("Accessing symbol that's not yet ready.");
                            return null;
                        }
                        return symbol;
                    }
                    release || assert(this._file instanceof SWFFile);
                    var data = this._file.getSymbol(id);
                    if (!data) {
                        if (id !== 65535) {
                            // Id 65535 is somehow used invalidly in lots of embedded shapes created by the authoring
                            // tool.
                            Shumway.Debug.warning("Unknown symbol requested: " + id);
                        }
                        // It's entirely valid not to have symbols defined, but might be a sign of us doing
                        // something wrong in parsing.
                        return null;
                    }
                    // TODO: replace this switch with a table lookup.
                    switch (data.type) {
                        case 'shape':
                            symbol = flash.display.ShapeSymbol.FromData(data, this);
                            break;
                        case 'morphshape':
                            symbol = flash.display.MorphShapeSymbol.FromData(data, this);
                            break;
                        case 'image':
                            if (data.definition) {
                                data = data.definition;
                            }
                            symbol = flash.display.BitmapSymbol.FromData(data, this);
                            if (symbol.ready === false) {
                                this._sec.player.registerImage(symbol, data.dataType, data.data, data.alphaData);
                            }
                            break;
                        case 'label':
                            symbol = flash.text.TextSymbol.FromLabelData(data, this);
                            break;
                        case 'text':
                            symbol = flash.text.TextSymbol.FromTextData(data, this);
                            this._syncAVM1Attributes(symbol);
                            break;
                        case 'button':
                            symbol = flash.display.ButtonSymbol.FromData(data, this);
                            this._syncAVM1Attributes(symbol);
                            break;
                        case 'sprite':
                            symbol = flash.display.SpriteSymbol.FromData(data, this);
                            break;
                        case 'font':
                            // Fonts are eagerly parsed and have their data in `definition`.
                            if (data.definition) {
                                data = data.definition;
                            }
                            symbol = flash.text.FontSymbol.FromData(data, this);
                            var font = flash.system.constructClassFromSymbol(symbol, symbol.symbolClass);
                            if (symbol.ready === false) {
                                this._sec.player.registerFont(symbol, data.data);
                            }
                            break;
                        case 'sound':
                            symbol = flash.media.SoundSymbol.FromData(data, this);
                            break;
                        case 'video':
                            symbol = flash.media.VideoSymbol.FromData(data, this);
                            break;
                        case 'binary':
                            symbol = Shumway.Timeline.BinarySymbol.FromData(data, this);
                            break;
                    }
                    release || assert(symbol, "Unknown symbol type " + data.type);
                    this._dictionary[id] = symbol;
                    return symbol;
                };
                LoaderInfo.prototype.getRootSymbol = function () {
                    release || assert(this._file instanceof SWFFile);
                    release || assert(this._file.framesLoaded > 0);
                    var symbol = this._dictionary[0];
                    if (!symbol) {
                        var data = {
                            id: 0,
                            className: this._file.symbolClassesMap[0],
                            env: this
                        };
                        symbol = new flash.display.SpriteSymbol(data, this);
                        symbol.isRoot = true;
                        symbol.numFrames = this._file.frameCount;
                        this._syncAVM1Attributes(symbol);
                        this._dictionary[0] = symbol;
                    }
                    return symbol;
                };
                LoaderInfo.prototype._syncAVM1Attributes = function (symbol) {
                    if (this.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                        symbol.isAVM1Object = true;
                        symbol.avm1Context = this._avm1Context;
                    }
                };
                // TODO: Frames should be parsed lazily when they're first needed, and this removed.
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1114656
                LoaderInfo.prototype.getFrame = function (sprite, index) {
                    var file = this._file;
                    release || assert(file instanceof SWFFile);
                    if (!sprite) {
                        sprite = file;
                    }
                    return sprite.frames[index];
                };
                // TODO: To prevent leaking LoaderInfo instances, those instances should be stored weakly,
                // with support for retrieving the instances based on a numeric id, which would be passed here.
                LoaderInfo.prototype.resolveClassSymbol = function (classDefinition, symbolId) {
                    var symbol = this.getSymbolById(symbolId);
                    if (!symbol) {
                        Shumway.Debug.warning("Attempt to resolve symbol for AVM2 class failed: Symbol " +
                            symbolId + " not found.");
                        return null;
                    }
                    else {
                        classDefinition.setSymbol(symbol);
                        return symbol;
                    }
                };
                return LoaderInfo;
            }(flash.events.EventDispatcher));
            display.LoaderInfo = LoaderInfo;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MorphShape
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var assert = Shumway.Debug.assert;
            var MorphShape = /** @class */ (function (_super) {
                __extends(MorphShape, _super);
                function MorphShape() {
                    var _this = _super.call(this) || this;
                    release || assert(!_this._symbol);
                    return _this;
                }
                MorphShape.prototype.applySymbol = function () {
                    this._initializeFields();
                    release || assert(this._symbol);
                    this._setStaticContentFromSymbol(this._symbol);
                    // TODO: Check what do do if the computed bounds of the graphics object don't
                    // match those given by the symbol.
                    this._setFlags(32768 /* ContainsMorph */);
                };
                MorphShape.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                MorphShape.prototype._canHaveGraphics = function () {
                    return true;
                };
                MorphShape.prototype._getGraphics = function () {
                    return this._graphics;
                };
                Object.defineProperty(MorphShape.prototype, "graphics", {
                    get: function () {
                        return this._ensureGraphics();
                    },
                    enumerable: true,
                    configurable: true
                });
                MorphShape.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    var graphics = this._getGraphics();
                    return graphics && graphics._containsPoint(localX, localY, true, this._ratio / 0xffff);
                };
                return MorphShape;
            }(flash.display.DisplayObject));
            display.MorphShape = MorphShape;
            var MorphShapeSymbol = /** @class */ (function (_super) {
                __extends(MorphShapeSymbol, _super);
                function MorphShapeSymbol(data, sec) {
                    return _super.call(this, data, sec.display.MorphShape) || this;
                }
                MorphShapeSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new MorphShapeSymbol(data, loaderInfo._sec);
                    symbol._setBoundsFromData(data);
                    symbol.graphics = flash.display.Graphics.FromData(data, loaderInfo);
                    symbol.processRequires(data.require, loaderInfo);
                    symbol.morphFillBounds = data.morphFillBounds;
                    symbol.morphLineBounds = data.morphLineBounds;
                    return symbol;
                };
                return MorphShapeSymbol;
            }(flash.display.ShapeSymbol));
            display.MorphShapeSymbol = MorphShapeSymbol;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NativeMenu
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var NativeMenu = /** @class */ (function (_super) {
                __extends(NativeMenu, _super);
                function NativeMenu() {
                    return _super.call(this) || this;
                }
                NativeMenu.classInitializer = null;
                NativeMenu.classSymbols = null; // [];
                NativeMenu.instanceSymbols = null; // [];
                return NativeMenu;
            }(flash.events.EventDispatcher));
            display.NativeMenu = NativeMenu;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NativeMenuItem
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var NativeMenuItem = /** @class */ (function (_super) {
                __extends(NativeMenuItem, _super);
                function NativeMenuItem() {
                    var _this = _super.call(this) || this;
                    _this._enabled = true;
                    return _this;
                }
                Object.defineProperty(NativeMenuItem.prototype, "enabled", {
                    get: function () {
                        release || somewhatImplemented("public flash.display.NativeMenuItem::get enabled");
                        return this._enabled;
                    },
                    set: function (isSeparator) {
                        isSeparator = !!isSeparator;
                        release || somewhatImplemented("public flash.display.NativeMenuItem::set enabled");
                        this._enabled = isSeparator;
                    },
                    enumerable: true,
                    configurable: true
                });
                return NativeMenuItem;
            }(flash.events.EventDispatcher));
            display.NativeMenuItem = NativeMenuItem;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: PNGEncoderOptions
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var PNGEncoderOptions = /** @class */ (function (_super) {
                __extends(PNGEncoderOptions, _super);
                function PNGEncoderOptions(fastCompression) {
                    if (fastCompression === void 0) { fastCompression = false; }
                    var _this = _super.call(this) || this;
                    _this.fastCompression = !!fastCompression;
                    return _this;
                }
                return PNGEncoderOptions;
            }(flash.LegacyEntity));
            display.PNGEncoderOptions = PNGEncoderOptions;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: PixelSnapping
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var PixelSnapping;
            (function (PixelSnapping) {
                PixelSnapping["NEVER"] = "never";
                PixelSnapping["ALWAYS"] = "always";
                PixelSnapping["AUTO"] = "auto";
            })(PixelSnapping = display.PixelSnapping || (display.PixelSnapping = {}));
            (function (PixelSnapping) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return PixelSnapping.NEVER;
                        case 1:
                            return PixelSnapping.ALWAYS;
                        case 2:
                            return PixelSnapping.AUTO;
                        default:
                            return null;
                    }
                }
                PixelSnapping.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case PixelSnapping.NEVER:
                            return 0;
                        case PixelSnapping.ALWAYS:
                            return 1;
                        case PixelSnapping.AUTO:
                            return 2;
                        default:
                            return -1;
                    }
                }
                PixelSnapping.toNumber = toNumber;
            })(PixelSnapping = display.PixelSnapping || (display.PixelSnapping = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SWFVersion
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var SWFVersion;
            (function (SWFVersion) {
                SWFVersion[SWFVersion["FLASH1"] = 1] = "FLASH1";
                SWFVersion[SWFVersion["FLASH2"] = 2] = "FLASH2";
                SWFVersion[SWFVersion["FLASH3"] = 3] = "FLASH3";
                SWFVersion[SWFVersion["FLASH4"] = 4] = "FLASH4";
                SWFVersion[SWFVersion["FLASH5"] = 5] = "FLASH5";
                SWFVersion[SWFVersion["FLASH6"] = 6] = "FLASH6";
                SWFVersion[SWFVersion["FLASH7"] = 7] = "FLASH7";
                SWFVersion[SWFVersion["FLASH8"] = 8] = "FLASH8";
                SWFVersion[SWFVersion["FLASH9"] = 9] = "FLASH9";
                SWFVersion[SWFVersion["FLASH10"] = 10] = "FLASH10";
                SWFVersion[SWFVersion["FLASH11"] = 11] = "FLASH11";
                SWFVersion[SWFVersion["FLASH12"] = 12] = "FLASH12";
            })(SWFVersion = display.SWFVersion || (display.SWFVersion = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Scene
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var Scene = /** @class */ (function (_super) {
                __extends(Scene, _super);
                function Scene(name, labels, offset, numFrames /*int*/) {
                    var _this = _super.call(this) || this;
                    _this._name = name;
                    // Note: creating Scene objects in ActionScript, while possible, is undocumented and entirely
                    // useless. Luckily, that also means that they're not very carefully implemented.
                    // Specifically, the `labels` array isn't cloned during construction or when returned from
                    // the getter. I.e., it can be modified freely.
                    _this._labels = labels;
                    _this.offset = offset;
                    _this._numFrames = numFrames | 0;
                    return _this;
                }
                Object.defineProperty(Scene.prototype, "name", {
                    get: function () {
                        return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scene.prototype, "labels", {
                    get: function () {
                        return this._labels;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scene.prototype, "numFrames", {
                    get: function () {
                        return this._numFrames;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scene.prototype.clone = function () {
                    var labels_ = this._labels.map(function (label) {
                        return label.clone();
                    });
                    return this._sec.display.Scene.create([this._name, labels_,
                        this.offset, this._numFrames]);
                };
                Scene.prototype.getLabelByName = function (name, ignoreCase) {
                    if (ignoreCase) {
                        name = name.toLowerCase();
                    }
                    var labels = this._labels;
                    for (var i = 0; i < labels.length; i++) {
                        var label = labels[i];
                        if (ignoreCase ? label.name.toLowerCase() === name : label.name === name) {
                            return label;
                        }
                    }
                    return null;
                };
                Scene.prototype.getLabelByFrame = function (frame) {
                    var labels = this._labels;
                    for (var i = 0; i < labels.length; i++) {
                        var label = labels[i];
                        if (label.frame === frame) {
                            return label;
                        }
                    }
                    return null;
                };
                return Scene;
            }(flash.LegacyEntity));
            display.Scene = Scene;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageAlign
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var StageAlign;
            (function (StageAlign) {
                // JS -> AS Bindings
                StageAlign["TOP"] = "T";
                StageAlign["LEFT"] = "L";
                StageAlign["BOTTOM"] = "B";
                StageAlign["RIGHT"] = "R";
                StageAlign["TOP_LEFT"] = "TL";
                StageAlign["TOP_RIGHT"] = "TR";
                StageAlign["BOTTOM_LEFT"] = "BL";
                StageAlign["BOTTOM_RIGHT"] = "BR";
            })(StageAlign = display.StageAlign || (display.StageAlign = {}));
            (function (StageAlign) {
                function fromNumber(n) {
                    if (n === 0) {
                        return "";
                    }
                    var s = "";
                    if ((n & 1 /* Top */) !== 0) {
                        s += "T";
                    }
                    if ((n & 2 /* Bottom */) !== 0) {
                        s += "B";
                    }
                    if ((n & 4 /* Left */) !== 0) {
                        s += "L";
                    }
                    if ((n & 8 /* Right */) !== 0) {
                        s += "R";
                    }
                    return s;
                }
                StageAlign.fromNumber = fromNumber;
                /**
                 * Looks like the Flash player just searches for the "T", "B", "L", "R" characters and
                 * maintains an internal bit field for alignment, for instance it's possible to set the
                 * alignment value "TBLR" even though there is no enum for it.
                 */
                function toNumber(value) {
                    var n = 0;
                    value = value.toUpperCase();
                    if (value.indexOf("T") >= 0) {
                        n |= 1 /* Top */;
                    }
                    if (value.indexOf("B") >= 0) {
                        n |= 2 /* Bottom */;
                    }
                    if (value.indexOf("L") >= 0) {
                        n |= 4 /* Left */;
                    }
                    if (value.indexOf("R") >= 0) {
                        n |= 8 /* Right */;
                    }
                    return n;
                }
                StageAlign.toNumber = toNumber;
            })(StageAlign = display.StageAlign || (display.StageAlign = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageDisplayState
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var StageDisplayState;
            (function (StageDisplayState) {
                StageDisplayState["FULL_SCREEN"] = "fullScreen";
                StageDisplayState["FULL_SCREEN_INTERACTIVE"] = "fullScreenInteractive";
                StageDisplayState["NORMAL"] = "normal";
            })(StageDisplayState = display.StageDisplayState || (display.StageDisplayState = {}));
            (function (StageDisplayState) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return StageDisplayState.FULL_SCREEN;
                        case 1:
                            return StageDisplayState.FULL_SCREEN_INTERACTIVE;
                        case 2:
                            return StageDisplayState.NORMAL;
                        default:
                            return null;
                    }
                }
                StageDisplayState.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case StageDisplayState.FULL_SCREEN:
                            return 0;
                        case StageDisplayState.FULL_SCREEN_INTERACTIVE:
                            return 1;
                        case StageDisplayState.NORMAL:
                            return 2;
                        default:
                            return -1;
                    }
                }
                StageDisplayState.toNumber = toNumber;
            })(StageDisplayState = display.StageDisplayState || (display.StageDisplayState = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageQuality
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var StageQuality;
            (function (StageQuality) {
                StageQuality["LOW"] = "low";
                StageQuality["MEDIUM"] = "medium";
                StageQuality["HIGH"] = "high";
                StageQuality["BEST"] = "best";
                StageQuality["HIGH_8X8"] = "8x8";
                StageQuality["HIGH_8X8_LINEAR"] = "8x8linear";
                StageQuality["HIGH_16X16"] = "16x16";
                StageQuality["HIGH_16X16_LINEAR"] = "16x16linear";
            })(StageQuality = display.StageQuality || (display.StageQuality = {}));
            (function (StageQuality) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return StageQuality.LOW;
                        case 1:
                            return StageQuality.MEDIUM;
                        case 2:
                            return StageQuality.HIGH;
                        case 3:
                            return StageQuality.BEST;
                        case 4:
                            return StageQuality.HIGH_8X8;
                        case 5:
                            return StageQuality.HIGH_8X8_LINEAR;
                        case 6:
                            return StageQuality.HIGH_16X16;
                        case 7:
                            return StageQuality.HIGH_16X16_LINEAR;
                        default:
                            return null;
                    }
                }
                StageQuality.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case StageQuality.LOW:
                            return 0;
                        case StageQuality.MEDIUM:
                            return 1;
                        case StageQuality.HIGH:
                            return 2;
                        case StageQuality.BEST:
                            return 3;
                        case StageQuality.HIGH_8X8:
                            return 4;
                        case StageQuality.HIGH_8X8_LINEAR:
                            return 5;
                        case StageQuality.HIGH_16X16:
                            return 6;
                        case StageQuality.HIGH_16X16_LINEAR:
                            return 7;
                        default:
                            return -1;
                    }
                }
                StageQuality.toNumber = toNumber;
            })(StageQuality = display.StageQuality || (display.StageQuality = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageScaleMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var StageScaleMode;
            (function (StageScaleMode) {
                function fromNumber(n) {
                    switch (n) {
                        case 0 /* ShowAll */:
                            return StageScaleMode.SHOW_ALL;
                        case 1 /* ExactFit */:
                            return StageScaleMode.EXACT_FIT;
                        case 2 /* NoBorder */:
                            return StageScaleMode.NO_BORDER;
                        case 4 /* NoScale */:
                            return StageScaleMode.NO_SCALE;
                        default:
                            return null;
                    }
                }
                StageScaleMode.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value.toLowerCase()) {
                        case StageScaleMode.SHOW_ALL_LOWERCASE:
                            return 0 /* ShowAll */;
                        case StageScaleMode.EXACT_FIT_LOWERCASE:
                            return 1 /* ExactFit */;
                        case StageScaleMode.NO_BORDER_LOWERCASE:
                            return 2 /* NoBorder */;
                        case StageScaleMode.NO_SCALE_LOWERCASE:
                            return 4 /* NoScale */;
                        default:
                            return -1;
                    }
                }
                StageScaleMode.toNumber = toNumber;
            })(StageScaleMode = display.StageScaleMode || (display.StageScaleMode = {}));
            (function (StageScaleMode) {
                StageScaleMode["SHOW_ALL"] = "showAll";
                StageScaleMode["EXACT_FIT"] = "exactFit";
                StageScaleMode["NO_BORDER"] = "noBorder";
                StageScaleMode["NO_SCALE"] = "noScale";
                StageScaleMode["SHOW_ALL_LOWERCASE"] = "showall";
                StageScaleMode["EXACT_FIT_LOWERCASE"] = "exactfit";
                StageScaleMode["NO_BORDER_LOWERCASE"] = "noborder";
                StageScaleMode["NO_SCALE_LOWERCASE"] = "noscale";
            })(StageScaleMode = display.StageScaleMode || (display.StageScaleMode = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TriangleCulling
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var TriangleCulling;
            (function (TriangleCulling) {
                TriangleCulling["NONE"] = "none";
                TriangleCulling["POSITIVE"] = "positive";
                TriangleCulling["NEGATIVE"] = "negative";
            })(TriangleCulling = display.TriangleCulling || (display.TriangleCulling = {}));
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * AVM1Movie is the reflection of AVM1 SWFs loaded into AVM2 content. Since AVM1 content is
 * completely opaque to AVM2 content, it's not a DisplayObjectContainer, even though it contains
 * nested children. This is because the two worlds are completely separated from each other[1], and
 * each AVM1 SWF is entirely isolated from everything else.
 *
 * This causes a few headaches because we implement the AVM1 display list in terms of the AVM2
 * display list: each AVM1 MovieClip is a wrapper around an AVM2 MovieClip instance, which is
 * what's actually on stage. Theoretically, the top-most AVM2 MovieClip for an AVM1 SWF isn't
 * supposed to have a parent. However, we need it to be part of the stage's display tree in order
 * to take part in rendering.
 *
 * Therefore, the AVM2 MovieClip wrapped by an AVM1Movie gets the latter set as its parent, even
 * though AVM1Movie isn't a DisplayObjectContainer. We borrow methods from that and generally
 * pretend that AVM1Movie is a container in some places to pull that off.
 *
 * [1]: If you ignore the undocumented `call` and `addCallback` methods for a moment.
 */
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var display;
        (function (display) {
            var notImplemented = Shumway.Debug.notImplemented;
            var AVM1Movie = /** @class */ (function (_super) {
                __extends(AVM1Movie, _super);
                function AVM1Movie(level0) {
                    var _this = _super.call(this) || this;
                    _this._content = _this._sec.display.Sprite.create();
                    _this._children = [];
                    _this._children[0] = _this._content;
                    // Pretend we're a DisplayObjectContainer and can have children. See comment at the top.
                    _this._content._setParent(_this, 0);
                    _this._setDirtyFlags(2 /* DirtyChildren */);
                    _this._invalidateFillAndLineBounds(true, true);
                    _this._sec.display._advancableInstances.push(_this);
                    _this._constructed = false;
                    // Setting _level0 root.
                    _this._content.addTimelineObjectAtDepth(level0, 0);
                    return _this;
                }
                AVM1Movie.prototype.call = function (functionName) {
                    notImplemented('AVM1Movie#call');
                };
                AVM1Movie.prototype.addCallback = function (functionName, closure) {
                    notImplemented('AVM1Movie#call');
                };
                AVM1Movie.prototype._addFrame = function (frame) {
                    this._content._children[0]._addFrame(frame);
                };
                AVM1Movie.prototype._initFrame = function (advance) {
                    // Empty implementation: AVM1Movie doesn't have frames, and the contained MovieClip
                    // adds itself to the IAdvancables list.
                };
                AVM1Movie.prototype._constructFrame = function () {
                    // On custructFrame we need to fully construct the roots container.
                    // Once constructed, its children (which are IAdvancable type) will be
                    // receiving their own _constructFrame events.
                    if (!this._constructed) {
                        this._constructed = true;
                        this._content._constructChildren();
                    }
                };
                AVM1Movie.prototype._enqueueFrameScripts = function () {
                    this._removeFlags(16384 /* ContainsFrameScriptPendingChildren */);
                    this._content._enqueueFrameScripts();
                };
                AVM1Movie.prototype._propagateFlagsDown = function (flags) {
                    if (this._hasFlags(flags)) {
                        return;
                    }
                    this._setFlags(flags);
                    this._content._propagateFlagsDown(flags);
                };
                /**
                 * AVM1Movie only takes the AVM1 content into consideration when testing points against
                 * bounding boxes, not otherwise.
                 */
                AVM1Movie.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                    if (testingType === 3 /* Mouse */) {
                        return this._content._containsPoint(globalX, globalY, localX, localY, testingType, objects);
                    }
                    if (testingType !== 0 /* HitTestBounds */ ||
                        !this._getContentBounds().contains(localX, localY)) {
                        return 0 /* None */;
                    }
                    return 1 /* Bounds */;
                };
                /**
                 * Override of DisplayObject#_getChildBounds that retrieves the AVM1 content's bounds.
                 */
                AVM1Movie.prototype._getChildBounds = function (bounds, includeStrokes) {
                    var childBounds = this._content._getContentBounds(includeStrokes).clone();
                    // Always apply the SimpleButton's matrix.
                    this._getConcatenatedMatrix().transformBounds(childBounds);
                    bounds.unionInPlace(childBounds);
                };
                AVM1Movie.prototype._getLevelForRoot = function (root) {
                    release || Shumway.Debug.assert(root.parent === this._content);
                    return root._depth;
                };
                AVM1Movie.prototype._getRootForLevel = function (level) {
                    return this._content.getTimelineObjectAtDepth(level);
                };
                AVM1Movie.prototype._addRoot = function (level, root) {
                    release || Shumway.Debug.assert(this._sec.display.MovieClip.axIsType(root));
                    this._removeRoot(level);
                    release || Shumway.Debug.assert(!this._content.getTimelineObjectAtDepth(level));
                    this._content.addTimelineObjectAtDepth(root, level);
                };
                AVM1Movie.prototype._removeRoot = function (level) {
                    var root = this._content.getTimelineObjectAtDepth(level);
                    if (!root) {
                        return false;
                    }
                    this._content.removeChild(root);
                    return true;
                };
                AVM1Movie.classInitializer = null;
                AVM1Movie.classSymbols = null;
                AVM1Movie.instanceSymbols = null;
                return AVM1Movie;
            }(flash.display.DisplayObject));
            display.AVM1Movie = AVM1Movie;
        })(display = flash.display || (flash.display = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ExternalInterface
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var external;
        (function (external) {
            var Telemetry = Shumway.Telemetry;
            var ExternalInterfaceService = Shumway.ExternalInterfaceService;
            var Multiname = flash.lang.Multiname;
            var ExternalInterface = /** @class */ (function (_super) {
                __extends(ExternalInterface, _super);
                function ExternalInterface() {
                    return _super.call(this) || this;
                }
                ExternalInterface.ensureInitialized = function () {
                    if (!this.available) {
                        flash.system.currentDomain()._sec.throwError('Error', Shumway.Errors.ExternalInterfaceNotAvailableError);
                    }
                    if (this.initialized) {
                        return;
                    }
                    Telemetry.instance.reportTelemetry({
                        topic: 'feature',
                        feature: 1 /* EXTERNAL_INTERFACE_FEATURE */
                    });
                    this.initialized = true;
                    ExternalInterfaceService.instance.initJS(this._callIn);
                };
                ExternalInterface.call = function (functionName) {
                    this.ensureInitialized();
                    var argsExpr = '';
                    if (arguments.length > 1) {
                        var args = [];
                        for (var i = 1; i < arguments.length; i++) {
                            args.push(this.convertToJSString(arguments[i]));
                        }
                        argsExpr = args.join(',');
                    }
                    var catchExpr = this.$BgmarshallExceptions ?
                        '"<exception>" + e + "</exception>";' :
                        '"<undefined/>";';
                    var evalExpr = 'try {' + '__flash__toXML(' + functionName + '(' + argsExpr + '));' +
                        '} catch (e) {' + catchExpr + '}';
                    var result = this._evalJS(evalExpr);
                    if (result == null) {
                        return null;
                    }
                    return this.convertFromXML(this.convertToXML(result));
                };
                ExternalInterface.addCallback = function (functionName, closure) {
                    this.ensureInitialized();
                    if (!closure) {
                        this._removeCallback(functionName);
                        return;
                    }
                    var self = this;
                    this._addCallback(functionName, function (request, args) {
                        var returnAsJS = true;
                        if (!args) {
                            var xml = this.convertToXML(request);
                            var returnTypeAttr = xml.attribute('returntype');
                            returnAsJS = returnTypeAttr && returnTypeAttr._value == 'javascript';
                            args = [];
                            for (var i = 0; i < xml._children.length; i++) {
                                var x = xml._children[i];
                                args.push(this.convertFromXML(x));
                            }
                        }
                        var result;
                        try {
                            result = closure.apply(null, args);
                        }
                        catch (e) {
                            if (this.$BgmarshallExceptions) {
                                result = e;
                            }
                            else {
                                throw e;
                            }
                        }
                        return returnAsJS ? self.convertToJSString(result) : self.convertToXMLString(result);
                    });
                };
                Object.defineProperty(ExternalInterface, "available", {
                    get: function () {
                        return ExternalInterfaceService.instance.enabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ExternalInterface, "objectID", {
                    get: function () {
                        return ExternalInterfaceService.instance.getId();
                    },
                    enumerable: true,
                    configurable: true
                });
                ExternalInterface._addCallback = function (functionName, closure) {
                    ExternalInterfaceService.instance.registerCallback(functionName);
                    ExternalInterface.registeredCallbacks[functionName] = closure;
                };
                ExternalInterface._removeCallback = function (functionName) {
                    ExternalInterfaceService.instance.unregisterCallback(functionName);
                    delete ExternalInterface.registeredCallbacks[functionName];
                };
                ExternalInterface._evalJS = function (expression) {
                    return ExternalInterfaceService.instance.eval(expression);
                };
                ExternalInterface._callIn = function (functionName, args) {
                    var callback = ExternalInterface.registeredCallbacks[functionName];
                    if (!callback) {
                        return;
                    }
                    return callback(functionName, args);
                };
                ExternalInterface._callOut = function (request) {
                    return ExternalInterfaceService.instance.call(request);
                };
                // @ivanpopelyshev: XML
                ExternalInterface.convertToXML = function (s) {
                    var xmlClass = flash.system.currentDomain().system._systemDomain.getClass(Multiname.FromSimpleName('XML'));
                    var savedIgnoreWhitespace = xmlClass.ignoreWhitespace;
                    xmlClass.ignoreWhitespace = false;
                    var xml = xmlClass.Create(s);
                    xmlClass.ignoreWhitespace = savedIgnoreWhitespace;
                    return xml;
                };
                ExternalInterface.convertToXMLString = function (obj) {
                    switch (typeof obj) {
                        case 'boolean':
                            return obj ? '<true/>' : '<false/>';
                        case 'number':
                            return '<number>' + obj + '</number>';
                        case 'string':
                            return '<string>' + obj.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;') + '</string>';
                        case 'object':
                            if (obj === null) {
                                return '<null/>';
                            }
                            // @ivanpopelyshev : Date here
                            // if (this.sec.AXDate.axIsInstanceOf(obj)) {
                            // 	return '<date>' + obj.time + '</date>';
                            // }
                            // @ivanpopelyshev Marshall exceptions
                            // if (system.currentDomain().AXError.axIsInstanceOf(obj)) {
                            // 	if (this.$BgmarshallExceptions) {
                            // 		return '<exception>' + obj + '</exception>';
                            // 	} else {
                            // 		return '<null/>'; // not sure?
                            // 	}
                            // }
                            var result = [];
                            // Looks like length is used to detect array. (obj is Array) is better?
                            if (obj.hasOwnProperty('$Bglength')) {
                                var len = obj.$Bglength;
                                for (var i = 0; i < len; i++) {
                                    var entry = this.convertToXMLString(obj.axGetNumericProperty(i));
                                    result.push('<property id="' + i + '">' + entry + '</property>');
                                }
                                return '<array>' + result.join('') + '</array>';
                            }
                            var keys = obj.axGetEnumerableKeys();
                            for (var i = 0; i < keys.length; i++) {
                                var key = keys[i];
                                var entry = this.convertToXMLString(obj.axGetPublicProperty(key));
                                result.push('<property id="' + key + '">' + entry + '</property>');
                            }
                            return '<object>' + result.join('') + '</object>';
                        default:
                            return '<undefined/>';
                    }
                };
                ExternalInterface.convertFromXML = function (xml /* ASXML | ASXMLList */) {
                    switch (xml._name.name) {
                        case 'true':
                            return true;
                        case 'false':
                            return false;
                        case 'number':
                            return Number(String(xml.children()));
                        case 'string':
                            return String(xml.children());
                        case 'null':
                            return null;
                        //@ivanpopelyshev dates and exception
                        // case 'date':
                        // 	return this.sec.AXDate.axConstruct([Number(String(xml.children()))]);
                        // case 'exception':
                        // 	if (this.$BgmarshallExceptions) {
                        // 		throw this.sec.AXError.axConstruct([String(xml.children())]);
                        // 	}
                        // 	return undefined;
                        case 'array':
                        case 'object':
                            var obj = xml._name.name === 'object' ?
                                {} :
                                [];
                            for (var i = 0; i < xml._children.length; i++) {
                                var x = xml._children[i];
                                obj.axSetPublicProperty(extractId(x), this.convertFromXML(x._children[0]));
                            }
                            return obj;
                        case 'class':
                            var className = Multiname.FromFQNString(String(xml.children()), 0 /* Public */);
                            return flash.system.currentDomain().system._applicationDomain.getClass(className);
                        default:
                            return undefined;
                    }
                };
                ExternalInterface.convertToJSString = function (obj) {
                    if (typeof obj == 'string') {
                        return '"' + obj.split('\r').join('\\r').split('\n').join('\\n').split('"').join('\\"') + '"';
                    }
                    if (obj instanceof Array) {
                        var parts = [];
                        var arr = obj;
                        for (var i = 0; i < arr.length; i++) {
                            parts.push(this.convertToJSString(arr[i]));
                        }
                        return '[' + parts.join(',') + ']';
                    }
                    // @ivanpopelyshev DATE?
                    // if (this.sec.AXDate.axIsInstanceOf(obj)) {
                    // 	return 'new Date(' + obj.value + ')';
                    // }
                    // @ivanpopelyshev: error: AXError.axIsInstanceOf(obj)
                    if (this.$BgmarshallExceptions && (obj instanceof flash.system.LegacyError)) {
                        return 'throw "' + obj + '"';
                    }
                    if (typeof obj === 'object' && obj !== null) {
                        var parts = [];
                        var keys = obj.axGetEnumerableKeys();
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            parts.push(key + ':' + this.convertToJSString(obj.axGetPublicProperty(key)));
                        }
                        return '({' + parts.join(',') + '})';
                    }
                    return String(obj);
                };
                ExternalInterface.initialized = false;
                ExternalInterface.registeredCallbacks = Object.create(null);
                return ExternalInterface;
            }(flash.LegacyEntity));
            external.ExternalInterface = ExternalInterface;
            //@ivanpopelyshev: ASXML
            function extractId(node /*ASXML*/) {
                for (var i = 0; i < node._attributes.length; i++) {
                    var attribute = node._attributes[i];
                    if (attribute._name.name === 'id') {
                        return attribute._value;
                    }
                }
                // TODO: throw if no `id` attribute was found.
            }
        })(external = flash.external || (flash.external = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapFilterQuality
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var BitmapFilterQuality;
            (function (BitmapFilterQuality) {
                BitmapFilterQuality[BitmapFilterQuality["LOW"] = 1] = "LOW";
                BitmapFilterQuality[BitmapFilterQuality["MEDIUM"] = 2] = "MEDIUM";
                BitmapFilterQuality[BitmapFilterQuality["HIGH"] = 3] = "HIGH";
            })(BitmapFilterQuality = filters.BitmapFilterQuality || (filters.BitmapFilterQuality = {}));
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapFilterType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var BitmapFilterType;
            (function (BitmapFilterType) {
                BitmapFilterType["INNER"] = "inner";
                BitmapFilterType["OUTER"] = "outer";
                BitmapFilterType["FULL"] = "full";
            })(BitmapFilterType = filters.BitmapFilterType || (filters.BitmapFilterType = {}));
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BitmapFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var BitmapFilter = /** @class */ (function (_super) {
                __extends(BitmapFilter, _super);
                function BitmapFilter() {
                    return _super.call(this) || this;
                }
                BitmapFilter._updateBlurBounds = function (bounds, blurX, blurY, quality /*int*/, isBlurFilter) {
                    if (isBlurFilter === void 0) { isBlurFilter = false; }
                    // Approximation of BitmapData.generateFilterRect()
                    var stepWidth = BitmapFilter.blurFilterStepWidths[quality - 1];
                    if (isBlurFilter) {
                        // BlurFilter behaves slightly different from other blur based filters:
                        // Given ascending blurX/blurY values, generateFilterRect with BlurFilter
                        // expands the source rect later than with i.e. GlowFilter. The difference
                        // appears to be stepWidth / 4 for all quality values.
                        var stepWidth4 = stepWidth / 4;
                        blurX -= stepWidth4;
                        blurY -= stepWidth4;
                    }
                    // Calculate horizontal and vertical borders:
                    // blurX/blurY values <= 1 are always rounded up to 1,
                    // which means that generateFilterRect always expands the source rect,
                    // even when blurX/blurY is 0.
                    var bh = Math.ceil((blurX < 1 ? 1 : blurX) * stepWidth);
                    var bv = Math.ceil((blurY < 1 ? 1 : blurY) * stepWidth);
                    bounds.inflate(bh, bv);
                };
                BitmapFilter.prototype._updateFilterBounds = function (bounds) {
                    // ...
                };
                BitmapFilter.prototype._serialize = function (message) {
                    // Overridden by subclasses
                    // -1: Filter not supported, no further serialization
                    // 0-7: Filter IDs according to SWF spec
                    message.writeInt(-1);
                };
                // JS -> AS Bindings
                // AS -> JS Bindings
                BitmapFilter.prototype.clone = function () {
                    return null;
                };
                BitmapFilter.EPS = 0.000000001;
                // Step widths for blur based filters, for quality values 1..15:
                // If we plot the border width added by generateFilterRect for each
                // blurX (or blurY) value, the step width is the amount of blurX
                // that adds one pixel to the border width. I.e. for quality = 1,
                // the border width increments at blurX = 2, 4, 6, ...
                BitmapFilter.blurFilterStepWidths = [0.5, 1.05, 1.35, 1.55, 1.75, 1.9, 2, 2.1, 2.2, 2.3, 2.5, 3, 3, 3.5, 3.5];
                return BitmapFilter;
            }(flash.LegacyEntity));
            filters.BitmapFilter = BitmapFilter;
            var GradientArrays = /** @class */ (function () {
                function GradientArrays() {
                }
                // colors null or empty - all empty
                // ratios empty - all empty
                // ratios null and alphas null - length: colors, alphas set to 0, ratios set to 0
                // ratios null and alphas != null - length: colors, alphas filled with 1, ratios set to 0
                // ratios not empty and alphas null - length: min(colors,ratios), alphas set to 0
                // ratios not empty and alphas != null - length: min(colors,ratios), alphas filled with 1
                GradientArrays.sanitize = function (colors, alphas, ratios) {
                    if (Shumway.isNullOrUndefined(colors) || colors.length === 0) {
                        this.colors = [];
                        this.alphas = [];
                        this.ratios = [];
                    }
                    else {
                        var len = void 0;
                        if (Shumway.isNullOrUndefined(ratios)) {
                            this.colors = this.sanitizeColors(colors);
                            len = this.colors.length;
                            this.ratios = this.initArray(len);
                            if (Shumway.isNullOrUndefined(alphas)) {
                                this.alphas = this.initArray(len);
                            }
                            else {
                                this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                            }
                        }
                        else {
                            if (ratios.length === 0) {
                                this.colors = [];
                                this.alphas = [];
                                this.ratios = [];
                            }
                            else {
                                len = Math.min(colors.length, ratios.length, 16);
                                this.colors = this.sanitizeColors(colors, len);
                                this.ratios = this.sanitizeRatios(ratios, len);
                                if (Shumway.isNullOrUndefined(alphas)) {
                                    this.alphas = this.initArray(len);
                                }
                                else {
                                    this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                                }
                            }
                        }
                    }
                };
                GradientArrays.sanitizeColors = function (colors, maxLen) {
                    if (maxLen === void 0) { maxLen = 16; }
                    var arr = [];
                    for (var i = 0, n = Math.min(colors.length, maxLen); i < n; i++) {
                        arr[i] = (colors[i] >>> 0) & 0xffffff;
                    }
                    return arr;
                };
                GradientArrays.sanitizeAlphas = function (alphas, maxLen, minLen, value) {
                    if (maxLen === void 0) { maxLen = 16; }
                    if (minLen === void 0) { minLen = 0; }
                    if (value === void 0) { value = 0; }
                    var arr = [];
                    var i, n;
                    for (i = 0, n = Math.min(alphas.length, maxLen); i < n; i++) {
                        arr[i] = Shumway.NumberUtilities.clamp(+alphas[i], 0, 1);
                    }
                    while (i < minLen) {
                        arr[i++] = value;
                    }
                    return arr;
                };
                GradientArrays.sanitizeRatios = function (ratios, maxLen, minLen, value) {
                    if (maxLen === void 0) { maxLen = 16; }
                    if (minLen === void 0) { minLen = 0; }
                    if (value === void 0) { value = 0; }
                    var arr = [];
                    var i, n;
                    for (i = 0, n = Math.min(ratios.length, maxLen); i < n; i++) {
                        arr[i] = Shumway.NumberUtilities.clamp(+ratios[i], 0, 255);
                    }
                    while (i < minLen) {
                        arr[i++] = value;
                    }
                    return arr;
                };
                GradientArrays.initArray = function (len, value) {
                    if (value === void 0) { value = 0; }
                    var arr = Array(len);
                    for (var i = 0; i < len; i++) {
                        arr[i] = value;
                    }
                    return arr;
                };
                return GradientArrays;
            }());
            filters.GradientArrays = GradientArrays;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BevelFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var BevelFilter = /** @class */ (function (_super) {
                __extends(BevelFilter, _super);
                function BevelFilter(distance, angle, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout) {
                    if (distance === void 0) { distance = 4; }
                    if (angle === void 0) { angle = 45; }
                    if (highlightColor === void 0) { highlightColor = 16777215; }
                    if (highlightAlpha === void 0) { highlightAlpha = 1; }
                    if (shadowColor === void 0) { shadowColor = 0; }
                    if (shadowAlpha === void 0) { shadowAlpha = 1; }
                    if (blurX === void 0) { blurX = 4; }
                    if (blurY === void 0) { blurY = 4; }
                    if (strength === void 0) { strength = 1; }
                    if (quality === void 0) { quality = 1; }
                    if (type === void 0) { type = "inner"; }
                    if (knockout === void 0) { knockout = false; }
                    var _this = _super.call(this) || this;
                    _this.distance = distance;
                    _this.angle = angle;
                    _this.highlightColor = highlightColor;
                    _this.highlightAlpha = highlightAlpha;
                    _this.shadowColor = shadowColor;
                    _this.shadowAlpha = shadowAlpha;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.strength = strength;
                    _this.quality = quality;
                    _this.type = type;
                    _this.knockout = knockout;
                    return _this;
                }
                BevelFilter.prototype._updateFilterBounds = function (bounds) {
                    if (this.type !== filters.BitmapFilterType.INNER) {
                        filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        if (this._distance !== 0) {
                            var a = this._angle * Math.PI / 180;
                            bounds.x += Math.floor(Math.cos(a) * this._distance);
                            bounds.y += Math.floor(Math.sin(a) * this._distance);
                            if (bounds.left > 0) {
                                bounds.left = 0;
                            }
                            if (bounds.top > 0) {
                                bounds.top = 0;
                            }
                        }
                    }
                };
                Object.defineProperty(BevelFilter.prototype, "distance", {
                    get: function () {
                        return this._distance;
                    },
                    set: function (value) {
                        this._distance = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "angle", {
                    get: function () {
                        return this._angle;
                    },
                    set: function (value) {
                        this._angle = +value % 360;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "highlightColor", {
                    get: function () {
                        return this._highlightColor;
                    },
                    set: function (value /*uint*/) {
                        this._highlightColor = (value >>> 0) & 0xffffff;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "highlightAlpha", {
                    get: function () {
                        return this._highlightAlpha;
                    },
                    set: function (value) {
                        this._highlightAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "shadowColor", {
                    get: function () {
                        return this._shadowColor;
                    },
                    set: function (value /*uint*/) {
                        this._shadowColor = (value >>> 0) & 0xffffff;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "shadowAlpha", {
                    get: function () {
                        return this._shadowAlpha;
                    },
                    set: function (value) {
                        this._shadowAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "knockout", {
                    get: function () {
                        return this._knockout;
                    },
                    set: function (value) {
                        this._knockout = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "strength", {
                    get: function () {
                        return this._strength;
                    },
                    set: function (value) {
                        this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BevelFilter.prototype, "type", {
                    get: function () {
                        return this._type;
                    },
                    set: function (value) {
                        if (value === null) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                        }
                        else {
                            if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                this._type = value;
                            }
                            else {
                                this._type = filters.BitmapFilterType.FULL;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                BevelFilter.prototype.clone = function () {
                    return this._sec.filters.BevelFilter.create([
                        this._distance,
                        this._angle,
                        this._highlightColor,
                        this._highlightAlpha,
                        this._shadowColor,
                        this._shadowAlpha,
                        this._blurX,
                        this._blurY,
                        this._strength,
                        this._quality,
                        this._type,
                        this._knockout
                    ]);
                };
                return BevelFilter;
            }(filters.BitmapFilter));
            filters.BevelFilter = BevelFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: BlurFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var BlurFilter = /** @class */ (function (_super) {
                __extends(BlurFilter, _super);
                function BlurFilter(blurX, blurY, quality) {
                    if (blurX === void 0) { blurX = 4; }
                    if (blurY === void 0) { blurY = 4; }
                    if (quality === void 0) { quality = 1; }
                    var _this = _super.call(this) || this;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.quality = quality;
                    return _this;
                }
                BlurFilter.prototype._updateFilterBounds = function (bounds) {
                    filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality, true);
                };
                BlurFilter.prototype._serialize = function (message) {
                    message.ensureAdditionalCapacity(16);
                    message.writeIntUnsafe(1);
                    message.writeFloatUnsafe(this._blurX);
                    message.writeFloatUnsafe(this._blurY);
                    message.writeIntUnsafe(this._quality);
                };
                Object.defineProperty(BlurFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BlurFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BlurFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                BlurFilter.prototype.clone = function () {
                    return this._sec.filters.BlurFilter.create([this._blurX, this._blurY,
                        this._quality]);
                };
                return BlurFilter;
            }(flash.filters.BitmapFilter));
            filters.BlurFilter = BlurFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ColorMatrixFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var ColorMatrixFilter = /** @class */ (function (_super) {
                __extends(ColorMatrixFilter, _super);
                function ColorMatrixFilter(matrix) {
                    if (matrix === void 0) { matrix = null; }
                    var _this = _super.call(this) || this;
                    if (matrix) {
                        _this.matrix = matrix;
                    }
                    else {
                        _this._matrix = [
                            1, 0, 0, 0, 0,
                            0, 1, 0, 0, 0,
                            0, 0, 1, 0, 0,
                            0, 0, 0, 1, 0
                        ];
                    }
                    return _this;
                }
                ColorMatrixFilter.prototype._serialize = function (message) {
                    var matrix = this._matrix;
                    message.ensureAdditionalCapacity((matrix.length + 1) * 4);
                    message.writeIntUnsafe(6);
                    for (var i = 0; i < matrix.length; i++) {
                        message.writeFloatUnsafe(matrix[i]);
                    }
                };
                Object.defineProperty(ColorMatrixFilter.prototype, "matrix", {
                    get: function () {
                        return this._matrix.concat();
                    },
                    set: function (value_) {
                        if (Shumway.isNullOrUndefined(value_)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "matrix");
                        }
                        var matrix = [
                            0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0
                        ];
                        var value = value_;
                        for (var i = 0, n = Math.min(value.length, 20); i < n; i++) {
                            matrix[i] = Shumway.toNumber(value[i]);
                        }
                        this._matrix = matrix;
                    },
                    enumerable: true,
                    configurable: true
                });
                ColorMatrixFilter.prototype.clone = function () {
                    return this._sec.filters.ColorMatrixFilter.create([this.matrix]);
                };
                return ColorMatrixFilter;
            }(flash.filters.BitmapFilter));
            filters.ColorMatrixFilter = ColorMatrixFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ConvolutionFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var ConvolutionFilter = /** @class */ (function (_super) {
                __extends(ConvolutionFilter, _super);
                function ConvolutionFilter(matrixX, matrixY, matrix, divisor, bias, preserveAlpha, clamp, color, alpha) {
                    if (matrixX === void 0) { matrixX = 0; }
                    if (matrixY === void 0) { matrixY = 0; }
                    if (matrix === void 0) { matrix = null; }
                    if (divisor === void 0) { divisor = 1; }
                    if (bias === void 0) { bias = 0; }
                    if (preserveAlpha === void 0) { preserveAlpha = true; }
                    if (clamp === void 0) { clamp = true; }
                    if (color === void 0) { color = 0; }
                    if (alpha === void 0) { alpha = 0; }
                    var _this = _super.call(this) || this;
                    _this.matrixX = matrixX;
                    _this.matrixY = matrixY;
                    if (matrix) {
                        _this.matrix = matrix;
                    }
                    else {
                        _this._matrix = _this._expandArray([], _this._matrixX * _this._matrixY);
                    }
                    _this.divisor = divisor;
                    _this.bias = bias;
                    _this.preserveAlpha = preserveAlpha;
                    _this.clamp = clamp;
                    _this.color = color;
                    _this.alpha = alpha;
                    return _this;
                }
                ConvolutionFilter.prototype._expandArray = function (a, newLen /*uint*/, value) {
                    if (value === void 0) { value = 0; }
                    if (a) {
                        var i = a.length;
                        while (i < newLen) {
                            a[i++] = 0;
                        }
                    }
                    return a;
                };
                Object.defineProperty(ConvolutionFilter.prototype, "matrix", {
                    get: function () {
                        return this._matrix.slice(0, this._matrixX * this._matrixY);
                    },
                    set: function (value_) {
                        if (Shumway.isNullOrUndefined(value_)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "matrix");
                        }
                        var value = value_;
                        var actualLen = this._matrixX * this._matrixY;
                        var minLen = Math.min(value.length, actualLen);
                        var matrix = Array(minLen);
                        for (var i = 0; i < minLen; i++) {
                            matrix[i] = Shumway.toNumber(value[i]);
                        }
                        this._expandArray(matrix, actualLen);
                        this._matrix = matrix;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "matrixX", {
                    get: function () {
                        return this._matrixX;
                    },
                    set: function (value) {
                        var mx = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                        if (this._matrixX !== mx) {
                            this._matrixX = mx;
                            this._expandArray(this._matrix, mx * this._matrixY);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "matrixY", {
                    get: function () {
                        return this._matrixY;
                    },
                    set: function (value) {
                        var my = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                        if (this._matrixY !== my) {
                            this._matrixY = my;
                            this._expandArray(this._matrix, my * this._matrixX);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "divisor", {
                    get: function () {
                        return this._divisor;
                    },
                    set: function (value) {
                        this._divisor = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "bias", {
                    get: function () {
                        return this._bias;
                    },
                    set: function (value) {
                        this._bias = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "preserveAlpha", {
                    get: function () {
                        return this._preserveAlpha;
                    },
                    set: function (value) {
                        this._preserveAlpha = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "clamp", {
                    get: function () {
                        return this._clamp;
                    },
                    set: function (value) {
                        this._clamp = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "color", {
                    get: function () {
                        return this._color;
                    },
                    set: function (value /*uint*/) {
                        this._color = value >>> 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConvolutionFilter.prototype, "alpha", {
                    get: function () {
                        return this._alpha;
                    },
                    set: function (value) {
                        this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                ConvolutionFilter.prototype.clone = function () {
                    return this._sec.filters.ConvolutionFilter.create([
                        this._matrixX,
                        this._matrixY,
                        this.matrix,
                        this._divisor,
                        this._bias,
                        this._preserveAlpha,
                        this._clamp,
                        this._color,
                        this._alpha
                    ]);
                };
                ConvolutionFilter.classInitializer = null;
                return ConvolutionFilter;
            }(flash.filters.BitmapFilter));
            filters.ConvolutionFilter = ConvolutionFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: DisplacementMapFilterMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var DisplacementMapFilterMode;
            (function (DisplacementMapFilterMode) {
                DisplacementMapFilterMode["WRAP"] = "wrap";
                DisplacementMapFilterMode["CLAMP"] = "clamp";
                DisplacementMapFilterMode["IGNORE"] = "ignore";
                DisplacementMapFilterMode["COLOR"] = "color";
            })(DisplacementMapFilterMode = filters.DisplacementMapFilterMode || (filters.DisplacementMapFilterMode = {}));
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: DisplacementMapFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var DisplacementMapFilter = /** @class */ (function (_super) {
                __extends(DisplacementMapFilter, _super);
                function DisplacementMapFilter(mapBitmap, mapPoint, componentX, componentY, scaleX, scaleY, mode, color, alpha) {
                    if (mapBitmap === void 0) { mapBitmap = null; }
                    if (mapPoint === void 0) { mapPoint = null; }
                    if (componentX === void 0) { componentX = 0; }
                    if (componentY === void 0) { componentY = 0; }
                    if (scaleX === void 0) { scaleX = 0; }
                    if (scaleY === void 0) { scaleY = 0; }
                    if (mode === void 0) { mode = "wrap"; }
                    if (color === void 0) { color = 0; }
                    if (alpha === void 0) { alpha = 0; }
                    var _this = _super.call(this) || this;
                    _this.mapBitmap = mapBitmap;
                    _this.mapPoint = mapPoint;
                    _this.componentX = componentX;
                    _this.componentY = componentY;
                    _this.scaleX = scaleX;
                    _this.scaleY = scaleY;
                    _this.mode = mode;
                    _this.color = color;
                    _this.alpha = alpha;
                    return _this;
                }
                DisplacementMapFilter.FromUntyped = function (obj) {
                    return flash.system.currentDomain().filters.DisplacementMapFilter.create([
                        obj.mapBitmap,
                        obj.mapPoint,
                        obj.componentX,
                        obj.componentY,
                        obj.scaleX,
                        obj.scaleY,
                        obj.mode,
                        obj.color,
                        obj.alpha
                    ]);
                };
                Object.defineProperty(DisplacementMapFilter.prototype, "mapBitmap", {
                    get: function () {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::get mapBitmap");
                        return this._mapBitmap;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set mapBitmap");
                        this._mapBitmap = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "mapPoint", {
                    get: function () {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::get mapPoint");
                        return this._mapPoint;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set mapPoint");
                        this._mapPoint = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "componentX", {
                    get: function () {
                        return this._componentX;
                    },
                    set: function (value /*uint*/) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set componentX");
                        this._componentX = value >>> 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "componentY", {
                    get: function () {
                        return this._componentY;
                    },
                    set: function (value /*uint*/) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set componentY");
                        this._componentY = value >>> 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "scaleX", {
                    get: function () {
                        return this._scaleX;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set scaleX");
                        this._scaleX = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "scaleY", {
                    get: function () {
                        return this._scaleY;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set scaleY");
                        this._scaleY = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "mode", {
                    get: function () {
                        return this._mode;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set mode");
                        this._mode = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "color", {
                    get: function () {
                        return this._color;
                    },
                    set: function (value /*uint*/) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set color");
                        this._color = (value >>> 0) & 0xffffff;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplacementMapFilter.prototype, "alpha", {
                    get: function () {
                        return this._alpha;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.filters.DisplacementMapFilter::set alpha");
                        this._alpha = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplacementMapFilter.prototype.clone = function () {
                    return this._sec.filters.DisplacementMapFilter.create([
                        this._mapBitmap,
                        this._mapPoint,
                        this._componentX,
                        this._componentY,
                        this._scaleX,
                        this._scaleY,
                        this._mode,
                        this._color,
                        this._alpha
                    ]);
                };
                return DisplacementMapFilter;
            }(flash.filters.BitmapFilter));
            filters.DisplacementMapFilter = DisplacementMapFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: DropShadowFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var DropShadowFilter = /** @class */ (function (_super) {
                __extends(DropShadowFilter, _super);
                function DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject) {
                    if (distance === void 0) { distance = 4; }
                    if (angle === void 0) { angle = 45; }
                    if (color === void 0) { color = 0; }
                    if (alpha === void 0) { alpha = 1; }
                    if (blurX === void 0) { blurX = 4; }
                    if (blurY === void 0) { blurY = 4; }
                    if (strength === void 0) { strength = 1; }
                    if (quality === void 0) { quality = 1; }
                    if (inner === void 0) { inner = false; }
                    if (knockout === void 0) { knockout = false; }
                    if (hideObject === void 0) { hideObject = false; }
                    var _this = _super.call(this) || this;
                    _this.distance = distance;
                    _this.angle = angle;
                    _this.color = color;
                    _this.alpha = alpha;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.strength = strength;
                    _this.quality = quality;
                    _this.inner = inner;
                    _this.knockout = knockout;
                    _this.hideObject = hideObject;
                    return _this;
                }
                DropShadowFilter.prototype._updateFilterBounds = function (bounds) {
                    if (!this.inner) {
                        filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        if (this._distance !== 0) {
                            var a = this._angle * Math.PI / 180;
                            bounds.x += Math.floor(Math.cos(a) * this._distance);
                            bounds.y += Math.floor(Math.sin(a) * this._distance);
                            if (bounds.left > 0) {
                                bounds.left = 0;
                            }
                            if (bounds.top > 0) {
                                bounds.top = 0;
                            }
                        }
                    }
                };
                Object.defineProperty(DropShadowFilter.prototype, "distance", {
                    get: function () {
                        return this._distance;
                    },
                    set: function (value) {
                        this._distance = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "angle", {
                    get: function () {
                        return this._angle;
                    },
                    set: function (value) {
                        this._angle = +value % 360;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "color", {
                    get: function () {
                        return this._color;
                    },
                    set: function (value /*uint*/) {
                        this._color = (value >>> 0) & 0xffffff;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "alpha", {
                    get: function () {
                        return this._alpha;
                    },
                    set: function (value) {
                        this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "hideObject", {
                    get: function () {
                        return this._hideObject;
                    },
                    set: function (value) {
                        this._hideObject = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "inner", {
                    get: function () {
                        return this._inner;
                    },
                    set: function (value) {
                        this._inner = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "knockout", {
                    get: function () {
                        return this._knockout;
                    },
                    set: function (value) {
                        this._knockout = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DropShadowFilter.prototype, "strength", {
                    get: function () {
                        return this._strength;
                    },
                    set: function (value) {
                        this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                DropShadowFilter.prototype.clone = function () {
                    return this._sec.filters.DropShadowFilter.create([
                        this._distance,
                        this._angle,
                        this._color,
                        this._alpha,
                        this._blurX,
                        this._blurY,
                        this._strength,
                        this._quality,
                        this._inner,
                        this._knockout,
                        this._hideObject
                    ]);
                };
                return DropShadowFilter;
            }(flash.filters.BitmapFilter));
            filters.DropShadowFilter = DropShadowFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GlowFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var GlowFilter = /** @class */ (function (_super) {
                __extends(GlowFilter, _super);
                function GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout) {
                    if (color === void 0) { color = 16711680; }
                    if (alpha === void 0) { alpha = 1; }
                    if (blurX === void 0) { blurX = 6; }
                    if (blurY === void 0) { blurY = 6; }
                    if (strength === void 0) { strength = 2; }
                    if (quality === void 0) { quality = 1; }
                    if (inner === void 0) { inner = false; }
                    if (knockout === void 0) { knockout = false; }
                    var _this = _super.call(this) || this;
                    _this.color = color;
                    _this.alpha = alpha;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.strength = strength;
                    _this.quality = quality;
                    _this.inner = inner;
                    _this.knockout = knockout;
                    return _this;
                }
                GlowFilter.prototype._updateFilterBounds = function (bounds) {
                    filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                };
                Object.defineProperty(GlowFilter.prototype, "color", {
                    get: function () {
                        return this._color;
                    },
                    set: function (value /*uint*/) {
                        this._color = (value >>> 0) & 0xffffff;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "alpha", {
                    get: function () {
                        return this._alpha;
                    },
                    set: function (value) {
                        this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "inner", {
                    get: function () {
                        return this._inner;
                    },
                    set: function (value) {
                        this._inner = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "knockout", {
                    get: function () {
                        return this._knockout;
                    },
                    set: function (value) {
                        this._knockout = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GlowFilter.prototype, "strength", {
                    get: function () {
                        return this._strength;
                    },
                    set: function (value) {
                        this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                GlowFilter.prototype.clone = function () {
                    return this._sec.filters.GlowFilter.create([
                        this._color,
                        this._alpha,
                        this._blurX,
                        this._blurY,
                        this._strength,
                        this._quality,
                        this._inner,
                        this._knockout
                    ]);
                };
                return GlowFilter;
            }(flash.filters.BitmapFilter));
            filters.GlowFilter = GlowFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GradientBevelFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var GradientBevelFilter = /** @class */ (function (_super) {
                __extends(GradientBevelFilter, _super);
                function GradientBevelFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                    if (distance === void 0) { distance = 4; }
                    if (angle === void 0) { angle = 45; }
                    if (colors === void 0) { colors = null; }
                    if (alphas === void 0) { alphas = null; }
                    if (ratios === void 0) { ratios = null; }
                    if (blurX === void 0) { blurX = 4; }
                    if (blurY === void 0) { blurY = 4; }
                    if (strength === void 0) { strength = 1; }
                    if (quality === void 0) { quality = 1; }
                    if (type === void 0) { type = "inner"; }
                    if (knockout === void 0) { knockout = false; }
                    var _this = _super.call(this) || this;
                    _this.distance = distance;
                    _this.angle = angle;
                    filters.GradientArrays.sanitize(colors ? colors : null, alphas ? alphas : null, ratios ? ratios : null);
                    _this._colors = filters.GradientArrays.colors;
                    _this._alphas = filters.GradientArrays.alphas;
                    _this._ratios = filters.GradientArrays.ratios;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.strength = strength;
                    _this.quality = quality;
                    _this.type = type;
                    _this.knockout = knockout;
                    return _this;
                }
                GradientBevelFilter.prototype._updateFilterBounds = function (bounds) {
                    if (this.type !== filters.BitmapFilterType.INNER) {
                        filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        if (this._distance !== 0) {
                            var a = this._angle * Math.PI / 180;
                            bounds.x += Math.floor(Math.cos(a) * this._distance);
                            bounds.y += Math.floor(Math.sin(a) * this._distance);
                            if (bounds.left > 0) {
                                bounds.left = 0;
                            }
                            if (bounds.top > 0) {
                                bounds.top = 0;
                            }
                        }
                    }
                };
                Object.defineProperty(GradientBevelFilter.prototype, "distance", {
                    get: function () {
                        return this._distance;
                    },
                    set: function (value) {
                        this._distance = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "angle", {
                    get: function () {
                        return this._angle;
                    },
                    set: function (value) {
                        this._angle = +value % 360;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "colors", {
                    get: function () {
                        return this._colors.concat();
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "colors");
                        }
                        this._colors = filters.GradientArrays.sanitizeColors(value);
                        var len = this._colors.length;
                        this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                        this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "alphas", {
                    get: function () {
                        return this._alphas.concat().concat();
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "alphas");
                        }
                        filters.GradientArrays.sanitize(this._colors, value, this._ratios);
                        this._colors = filters.GradientArrays.colors;
                        this._alphas = filters.GradientArrays.alphas;
                        this._ratios = filters.GradientArrays.ratios;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "ratios", {
                    get: function () {
                        return this._ratios.concat();
                    },
                    set: function (value_) {
                        if (Shumway.isNullOrUndefined(value_)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "ratios");
                        }
                        filters.GradientArrays.sanitize(this._colors, this._alphas, value_);
                        this._colors = filters.GradientArrays.colors;
                        this._alphas = filters.GradientArrays.alphas;
                        this._ratios = filters.GradientArrays.ratios;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "knockout", {
                    get: function () {
                        return this._knockout;
                    },
                    set: function (value) {
                        this._knockout = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "strength", {
                    get: function () {
                        return this._strength;
                    },
                    set: function (value) {
                        this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientBevelFilter.prototype, "type", {
                    get: function () {
                        return this._type;
                    },
                    set: function (value) {
                        if (value === null) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                        }
                        else {
                            if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                this._type = value;
                            }
                            else {
                                this._type = filters.BitmapFilterType.FULL;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                GradientBevelFilter.prototype.clone = function () {
                    return this._sec.filters.GradientBevelFilter.create([
                        this._distance,
                        this._angle,
                        this.colors,
                        this.alphas,
                        this.ratios,
                        this._blurX,
                        this._blurY,
                        this._strength,
                        this._quality,
                        this._type,
                        this._knockout
                    ]);
                };
                return GradientBevelFilter;
            }(flash.filters.BitmapFilter));
            filters.GradientBevelFilter = GradientBevelFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GradientGlowFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var filters;
        (function (filters) {
            var GradientGlowFilter = /** @class */ (function (_super) {
                __extends(GradientGlowFilter, _super);
                function GradientGlowFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                    if (distance === void 0) { distance = 4; }
                    if (angle === void 0) { angle = 45; }
                    if (colors === void 0) { colors = null; }
                    if (alphas === void 0) { alphas = null; }
                    if (ratios === void 0) { ratios = null; }
                    if (blurX === void 0) { blurX = 4; }
                    if (blurY === void 0) { blurY = 4; }
                    if (strength === void 0) { strength = 1; }
                    if (quality === void 0) { quality = 1; }
                    if (type === void 0) { type = "inner"; }
                    if (knockout === void 0) { knockout = false; }
                    var _this = _super.call(this) || this;
                    _this.distance = distance;
                    _this.angle = angle;
                    filters.GradientArrays.sanitize(colors ? colors : null, alphas ? alphas : null, ratios ? ratios : null);
                    _this._colors = filters.GradientArrays.colors;
                    _this._alphas = filters.GradientArrays.alphas;
                    _this._ratios = filters.GradientArrays.ratios;
                    _this.blurX = blurX;
                    _this.blurY = blurY;
                    _this.strength = strength;
                    _this.quality = quality;
                    _this.type = type;
                    _this.knockout = knockout;
                    return _this;
                }
                GradientGlowFilter.prototype._updateFilterBounds = function (bounds) {
                    if (this.type !== filters.BitmapFilterType.INNER) {
                        filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        if (this._distance !== 0) {
                            var a = this._angle * Math.PI / 180;
                            bounds.x += Math.floor(Math.cos(a) * this._distance);
                            bounds.y += Math.floor(Math.sin(a) * this._distance);
                            if (bounds.left > 0) {
                                bounds.left = 0;
                            }
                            if (bounds.top > 0) {
                                bounds.top = 0;
                            }
                        }
                    }
                };
                Object.defineProperty(GradientGlowFilter.prototype, "distance", {
                    get: function () {
                        return this._distance;
                    },
                    set: function (value) {
                        this._distance = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "angle", {
                    get: function () {
                        return this._angle;
                    },
                    set: function (value) {
                        this._angle = +value % 360;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "colors", {
                    get: function () {
                        return this._colors.concat();
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "colors");
                        }
                        this._colors = filters.GradientArrays.sanitizeColors(value);
                        var len = this._colors.length;
                        this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                        this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "alphas", {
                    get: function () {
                        return this._alphas.concat();
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "alphas");
                        }
                        filters.GradientArrays.sanitize(this._colors, value, this._ratios);
                        this._colors = filters.GradientArrays.colors;
                        this._alphas = filters.GradientArrays.alphas;
                        this._ratios = filters.GradientArrays.ratios;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "ratios", {
                    get: function () {
                        return this._ratios.concat();
                    },
                    set: function (value_) {
                        if (Shumway.isNullOrUndefined(value_)) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "ratios");
                        }
                        filters.GradientArrays.sanitize(this._colors, this._alphas, value_);
                        this._colors = filters.GradientArrays.colors;
                        this._alphas = filters.GradientArrays.alphas;
                        this._ratios = filters.GradientArrays.ratios;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "blurX", {
                    get: function () {
                        return this._blurX;
                    },
                    set: function (value) {
                        this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "blurY", {
                    get: function () {
                        return this._blurY;
                    },
                    set: function (value) {
                        this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "knockout", {
                    get: function () {
                        return this._knockout;
                    },
                    set: function (value) {
                        this._knockout = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (value /*int*/) {
                        this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "strength", {
                    get: function () {
                        return this._strength;
                    },
                    set: function (value) {
                        this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GradientGlowFilter.prototype, "type", {
                    get: function () {
                        return this._type;
                    },
                    set: function (value) {
                        if (value === null) {
                            this._sec.throwError("TypeError", Shumway.Errors.NullPointerError, "type");
                        }
                        else {
                            if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                this._type = value;
                            }
                            else {
                                this._type = filters.BitmapFilterType.FULL;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                GradientGlowFilter.prototype.clone = function () {
                    return this._sec.filters.GradientGlowFilter.create([
                        this._distance,
                        this._angle,
                        this.colors,
                        this.alphas,
                        this.ratios,
                        this._blurX,
                        this._blurY,
                        this._strength,
                        this._quality,
                        this._type,
                        this._knockout
                    ]);
                };
                return GradientGlowFilter;
            }(flash.filters.BitmapFilter));
            filters.GradientGlowFilter = GradientGlowFilter;
        })(filters = flash.filters || (flash.filters = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ColorTransform
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var geom;
        (function (geom) {
            var toS16 = Shumway.IntegerUtilities.toS16;
            var clampS8U8 = Shumway.IntegerUtilities.clampS8U8;
            var ColorTransform = /** @class */ (function (_super) {
                __extends(ColorTransform, _super);
                // "blueMultiplier", "alphaMultiplier", "redOffset",
                // "greenOffset", "blueOffset", "alphaOffset",
                // "color", "color", "concat", "toString"];
                function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                    if (redMultiplier === void 0) { redMultiplier = 1; }
                    if (greenMultiplier === void 0) { greenMultiplier = 1; }
                    if (blueMultiplier === void 0) { blueMultiplier = 1; }
                    if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
                    if (redOffset === void 0) { redOffset = 0; }
                    if (greenOffset === void 0) { greenOffset = 0; }
                    if (blueOffset === void 0) { blueOffset = 0; }
                    if (alphaOffset === void 0) { alphaOffset = 0; }
                    var _this = _super.call(this) || this;
                    _this.redMultiplier = +redMultiplier;
                    _this.greenMultiplier = +greenMultiplier;
                    _this.blueMultiplier = +blueMultiplier;
                    _this.alphaMultiplier = +alphaMultiplier;
                    _this.redOffset = +redOffset;
                    _this.greenOffset = +greenOffset;
                    _this.blueOffset = +blueOffset;
                    _this.alphaOffset = +alphaOffset;
                    return _this;
                }
                Object.defineProperty(ColorTransform.prototype, "native_redMultiplier", {
                    get: function () {
                        return this.redMultiplier;
                    },
                    set: function (redMultiplier) {
                        this.redMultiplier = +redMultiplier;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_greenMultiplier", {
                    get: function () {
                        return this.greenMultiplier;
                    },
                    set: function (greenMultiplier) {
                        this.greenMultiplier = +greenMultiplier;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_blueMultiplier", {
                    get: function () {
                        return this.blueMultiplier;
                    },
                    set: function (blueMultiplier) {
                        this.blueMultiplier = +blueMultiplier;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_alphaMultiplier", {
                    get: function () {
                        return this.alphaMultiplier;
                    },
                    set: function (alphaMultiplier) {
                        this.alphaMultiplier = +alphaMultiplier;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_redOffset", {
                    get: function () {
                        return this.redOffset;
                    },
                    set: function (redOffset) {
                        this.redOffset = +redOffset;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_greenOffset", {
                    get: function () {
                        return this.greenOffset;
                    },
                    set: function (greenOffset) {
                        this.greenOffset = +greenOffset;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_blueOffset", {
                    get: function () {
                        return this.blueOffset;
                    },
                    set: function (blueOffset) {
                        this.blueOffset = +blueOffset;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ColorTransform.prototype, "native_alphaOffset", {
                    get: function () {
                        return this.alphaOffset;
                    },
                    set: function (alphaOffset) {
                        this.alphaOffset = +alphaOffset;
                    },
                    enumerable: true,
                    configurable: true
                });
                ColorTransform.prototype.ColorTransform = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                    if (redMultiplier === void 0) { redMultiplier = 1; }
                    if (greenMultiplier === void 0) { greenMultiplier = 1; }
                    if (blueMultiplier === void 0) { blueMultiplier = 1; }
                    if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
                    if (redOffset === void 0) { redOffset = 0; }
                    if (greenOffset === void 0) { greenOffset = 0; }
                    if (blueOffset === void 0) { blueOffset = 0; }
                    if (alphaOffset === void 0) { alphaOffset = 0; }
                    this.redMultiplier = redMultiplier;
                    this.greenMultiplier = greenMultiplier;
                    this.blueMultiplier = blueMultiplier;
                    this.alphaMultiplier = alphaMultiplier;
                    this.redOffset = redOffset;
                    this.greenOffset = greenOffset;
                    this.blueOffset = blueOffset;
                    this.alphaOffset = alphaOffset;
                };
                Object.defineProperty(ColorTransform.prototype, "color", {
                    get: function () {
                        return (this.redOffset << 16) | (this.greenOffset << 8) | this.blueOffset;
                    },
                    set: function (newColor) {
                        this.redOffset = (newColor >> 16) & 0xff;
                        this.greenOffset = (newColor >> 8) & 0xff;
                        this.blueOffset = newColor & 0xff;
                        this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                ColorTransform.prototype.concat = function (second) {
                    this.redMultiplier *= second.redMultiplier;
                    this.greenMultiplier *= second.greenMultiplier;
                    this.blueMultiplier *= second.blueMultiplier;
                    this.alphaMultiplier *= second.alphaMultiplier;
                    this.redOffset += second.redOffset;
                    this.greenOffset += second.greenOffset;
                    this.blueOffset += second.blueOffset;
                    this.alphaOffset += second.alphaOffset;
                };
                ColorTransform.prototype.preMultiply = function (second) {
                    this.redOffset += second.redOffset * this.redMultiplier;
                    this.greenOffset += second.greenOffset * this.greenMultiplier;
                    this.blueOffset += second.blueOffset * this.blueMultiplier;
                    this.alphaOffset += second.alphaOffset * this.alphaMultiplier;
                    this.redMultiplier *= second.redMultiplier;
                    this.greenMultiplier *= second.greenMultiplier;
                    this.blueMultiplier *= second.blueMultiplier;
                    this.alphaMultiplier *= second.alphaMultiplier;
                };
                ColorTransform.prototype.copyFrom = function (sourceColorTransform) {
                    this.redMultiplier = sourceColorTransform.redMultiplier;
                    this.greenMultiplier = sourceColorTransform.greenMultiplier;
                    this.blueMultiplier = sourceColorTransform.blueMultiplier;
                    this.alphaMultiplier = sourceColorTransform.alphaMultiplier;
                    this.redOffset = sourceColorTransform.redOffset;
                    this.greenOffset = sourceColorTransform.greenOffset;
                    this.blueOffset = sourceColorTransform.blueOffset;
                    this.alphaOffset = sourceColorTransform.alphaOffset;
                };
                ColorTransform.prototype.copyFromUntyped = function (object) {
                    this.redMultiplier = object.redMultiplier / 256;
                    this.greenMultiplier = object.greenMultiplier / 256;
                    this.blueMultiplier = object.blueMultiplier / 256;
                    this.alphaMultiplier = object.alphaMultiplier / 256;
                    this.redOffset = object.redOffset;
                    this.greenOffset = object.greenOffset;
                    this.blueOffset = object.blueOffset;
                    this.alphaOffset = object.alphaOffset;
                };
                ColorTransform.prototype.setTo = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                    this.redMultiplier = redMultiplier;
                    this.greenMultiplier = greenMultiplier;
                    this.blueMultiplier = blueMultiplier;
                    this.alphaMultiplier = alphaMultiplier;
                    this.redOffset = redOffset;
                    this.greenOffset = greenOffset;
                    this.blueOffset = blueOffset;
                    this.alphaOffset = alphaOffset;
                };
                ColorTransform.prototype.clone = function () {
                    return this._sec.geom.ColorTransform.clone(this);
                };
                ColorTransform.prototype.convertToFixedPoint = function () {
                    this.redMultiplier = clampS8U8(this.redMultiplier);
                    this.greenMultiplier = clampS8U8(this.greenMultiplier);
                    this.blueMultiplier = clampS8U8(this.blueMultiplier);
                    this.alphaMultiplier = clampS8U8(this.alphaMultiplier);
                    this.redOffset = toS16(this.redOffset);
                    this.greenOffset = toS16(this.greenOffset);
                    this.blueOffset = toS16(this.blueOffset);
                    this.alphaOffset = toS16(this.alphaOffset);
                    return this;
                };
                ColorTransform.prototype.equals = function (other) {
                    if (this === other) {
                        return true;
                    }
                    return this.redMultiplier === other.redMultiplier &&
                        this.greenMultiplier === other.greenMultiplier &&
                        this.blueMultiplier === other.blueMultiplier &&
                        this.alphaMultiplier === other.alphaMultiplier &&
                        this.redOffset === other.redOffset &&
                        this.greenOffset === other.greenOffset &&
                        this.blueOffset === other.blueOffset &&
                        this.alphaOffset === other.alphaOffset;
                };
                ColorTransform.prototype.toString = function () {
                    return "(redMultiplier=" + this.redMultiplier +
                        ", greenMultiplier=" + this.greenMultiplier +
                        ", blueMultiplier=" + this.blueMultiplier +
                        ", alphaMultiplier=" + this.alphaMultiplier +
                        ", redOffset=" + this.redOffset +
                        ", greenOffset=" + this.greenOffset +
                        ", blueOffset=" + this.blueOffset +
                        ", alphaOffset=" + this.alphaOffset +
                        ")";
                };
                ColorTransform.classInitializer = null;
                ColorTransform.classSymbols = null; // [];
                ColorTransform.instanceSymbols = null; // ["redMultiplier", "greenMultiplier",
                return ColorTransform;
            }(flash.LegacyEntity));
            geom.ColorTransform = ColorTransform;
        })(geom = flash.geom || (flash.geom = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Camera
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Camera = /** @class */ (function (_super) {
                __extends(Camera, _super);
                function Camera() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Camera, "names", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get names");
                        return [];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera, "isSupported", {
                    get: function () {
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Camera.getCamera = function (name) {
                    if (name === void 0) { name = null; }
                    name = name;
                    release || somewhatImplemented("public flash.media.Camera::static getCamera");
                    return null;
                };
                Camera._scanHardware = function () {
                    release || somewhatImplemented("public flash.media.Camera::static _scanHardware");
                };
                Object.defineProperty(Camera.prototype, "activityLevel", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get activityLevel");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "bandwidth", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get bandwidth");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "currentFPS", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get currentFPS");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "fps", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get fps");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "height", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get height");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "index", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get index");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "keyFrameInterval", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get keyFrameInterval");
                        return 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "loopback", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get loopback");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "motionLevel", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get motionLevel");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "motionTimeout", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get motionTimeout");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "muted", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get muted");
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "name", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get name");
                        return '';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "quality", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get quality");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Camera.prototype, "width", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Camera::get width");
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Camera.prototype.setCursor = function (value) {
                    value = !!value;
                    release || somewhatImplemented("public flash.media.Camera::setCursor");
                };
                Camera.prototype.setKeyFrameInterval = function (keyFrameInterval /*int*/) {
                    keyFrameInterval = keyFrameInterval | 0;
                    release || somewhatImplemented("public flash.media.Camera::setKeyFrameInterval");
                };
                Camera.prototype.setLoopback = function (compress) {
                    if (compress === void 0) { compress = false; }
                    compress = !!compress;
                    release || somewhatImplemented("public flash.media.Camera::setLoopback");
                };
                Camera.prototype.setMode = function (width /*int*/, height /*int*/, fps, favorArea) {
                    if (favorArea === void 0) { favorArea = true; }
                    width = width | 0;
                    height = height | 0;
                    fps = +fps;
                    favorArea = !!favorArea;
                    release || somewhatImplemented("public flash.media.Camera::setMode");
                };
                Camera.prototype.setMotionLevel = function (motionLevel /*int*/, timeout) {
                    if (timeout === void 0) { timeout = 2000; }
                    motionLevel = motionLevel | 0;
                    timeout = timeout | 0;
                    release || somewhatImplemented("public flash.media.Camera::setMotionLevel");
                };
                Camera.prototype.setQuality = function (bandwidth /*int*/, quality /*int*/) {
                    bandwidth = bandwidth | 0;
                    quality = quality | 0;
                    release || somewhatImplemented("public flash.media.Camera::setQuality");
                };
                Camera.prototype.drawToBitmapData = function (destination) {
                    destination = destination;
                    release || somewhatImplemented("public flash.media.Camera::drawToBitmapData");
                };
                Camera.prototype.copyToByteArray = function (rect, destination) {
                    rect = rect;
                    destination = destination;
                    release || somewhatImplemented("public flash.media.Camera::copyToByteArray");
                };
                Camera.prototype.copyToVector = function (rect, destination) {
                    rect = rect;
                    destination = destination;
                    release || somewhatImplemented("public flash.media.Camera::copyToVector");
                };
                return Camera;
            }(flash.events.EventDispatcher));
            media.Camera = Camera;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ID3Info
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var ID3Info = /** @class */ (function (_super) {
                __extends(ID3Info, _super);
                function ID3Info() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return ID3Info;
            }(flash.LegacyEntity));
            media.ID3Info = ID3Info;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Microphone
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Microphone = /** @class */ (function (_super) {
                __extends(Microphone, _super);
                function Microphone() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Microphone, "names", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Microphone::get names");
                        return [];
                        // return this._names;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone, "isSupported", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Microphone::get isSupported");
                        return false;
                        // return this._isSupported;
                    },
                    enumerable: true,
                    configurable: true
                });
                Microphone.getMicrophone = function (index) {
                    if (index === void 0) { index = -1; }
                    index = index | 0;
                    release || notImplemented("public flash.media.Microphone::static getMicrophone");
                    return null;
                };
                Microphone.getEnhancedMicrophone = function (index) {
                    if (index === void 0) { index = -1; }
                    index = index | 0;
                    release || notImplemented("public flash.media.Microphone::static getEnhancedMicrophone");
                    return null;
                };
                Object.defineProperty(Microphone.prototype, "rate", {
                    // _rate: number /*int*/;
                    // _codec: string;
                    // _framesPerPacket: number /*int*/;
                    // _encodeQuality: number /*int*/;
                    // _noiseSuppressionLevel: number /*int*/;
                    // _enableVAD: boolean;
                    // _activityLevel: number;
                    // _gain: number;
                    // _index: number /*int*/;
                    // _muted: boolean;
                    // _name: string;
                    // _silenceLevel: number;
                    // _silenceTimeout: number /*int*/;
                    // _useEchoSuppression: boolean;
                    // _soundTransform: flash.media.SoundTransform;
                    // _enhancedOptions: flash.media.MicrophoneEnhancedOptions;
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get rate");
                        return 0;
                        // return this._rate;
                    },
                    set: function (rate /*int*/) {
                        rate = rate | 0;
                        release || notImplemented("public flash.media.Microphone::set rate");
                        return;
                        // this._rate = rate;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "codec", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get codec");
                        return "";
                        // return this._codec;
                    },
                    set: function (codec) {
                        codec = codec;
                        release || notImplemented("public flash.media.Microphone::set codec");
                        return;
                        // this._codec = codec;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "framesPerPacket", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get framesPerPacket");
                        return 0;
                        // return this._framesPerPacket;
                    },
                    set: function (frames /*int*/) {
                        frames = frames | 0;
                        release || notImplemented("public flash.media.Microphone::set framesPerPacket");
                        return;
                        // this._framesPerPacket = frames;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "encodeQuality", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get encodeQuality");
                        return 0;
                        // return this._encodeQuality;
                    },
                    set: function (quality /*int*/) {
                        quality = quality | 0;
                        release || notImplemented("public flash.media.Microphone::set encodeQuality");
                        return;
                        // this._encodeQuality = quality;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "noiseSuppressionLevel", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get noiseSuppressionLevel");
                        return 0;
                        // return this._noiseSuppressionLevel;
                    },
                    set: function (level /*int*/) {
                        level = level | 0;
                        release || notImplemented("public flash.media.Microphone::set noiseSuppressionLevel");
                        return;
                        // this._noiseSuppressionLevel = level;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "enableVAD", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get enableVAD");
                        return false;
                        // return this._enableVAD;
                    },
                    set: function (enable) {
                        enable = !!enable;
                        release || notImplemented("public flash.media.Microphone::set enableVAD");
                        return;
                        // this._enableVAD = enable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "activityLevel", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get activityLevel");
                        return 0;
                        // return this._activityLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "gain", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get gain");
                        return 0;
                        // return this._gain;
                    },
                    set: function (gain) {
                        gain = +gain;
                        release || notImplemented("public flash.media.Microphone::set gain");
                        return;
                        // this._gain = gain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "index", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get index");
                        return 0;
                        // return this._index;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "muted", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get muted");
                        return false;
                        // return this._muted;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "name", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get name");
                        return "";
                        // return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "silenceLevel", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get silenceLevel");
                        return 0;
                        // return this._silenceLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "silenceTimeout", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get silenceTimeout");
                        return 0;
                        // return this._silenceTimeout;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "useEchoSuppression", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get useEchoSuppression");
                        return false;
                        // return this._useEchoSuppression;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "soundTransform", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get soundTransform");
                        return null;
                        // return this._soundTransform;
                    },
                    set: function (sndTransform) {
                        sndTransform = sndTransform;
                        release || notImplemented("public flash.media.Microphone::set soundTransform");
                        return;
                        // this._soundTransform = sndTransform;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Microphone.prototype, "enhancedOptions", {
                    get: function () {
                        release || notImplemented("public flash.media.Microphone::get enhancedOptions");
                        return;
                        // return this._enhancedOptions;
                    },
                    set: function (options /* flash.media.MicrophoneEnhancedOptions */) {
                        options = options;
                        release || notImplemented("public flash.media.Microphone::set enhancedOptions");
                        return;
                        // this._enhancedOptions = options;
                    },
                    enumerable: true,
                    configurable: true
                });
                Microphone.prototype.setSilenceLevel = function (silenceLevel, timeout) {
                    if (timeout === void 0) { timeout = -1; }
                    silenceLevel = +silenceLevel;
                    timeout = timeout | 0;
                    release || notImplemented("public flash.media.Microphone::setSilenceLevel");
                    return;
                };
                Microphone.prototype.setUseEchoSuppression = function (useEchoSuppression) {
                    useEchoSuppression = !!useEchoSuppression;
                    release || notImplemented("public flash.media.Microphone::setUseEchoSuppression");
                    return;
                };
                Microphone.prototype.setLoopBack = function (state) {
                    if (state === void 0) { state = true; }
                    state = !!state;
                    release || notImplemented("public flash.media.Microphone::setLoopBack");
                    return;
                };
                Microphone.classInitializer = null;
                return Microphone;
            }(flash.events.EventDispatcher));
            media.Microphone = Microphone;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Sound
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var assert = Shumway.Debug.assert;
            var Telemetry = Shumway.Telemetry;
            function getAudioDescription(soundData, onComplete) {
                var audioElement = document.createElement('audio');
                if (!audioElement.canPlayType(soundData.mimeType)) {
                    onComplete({
                        duration: 0
                    });
                    return;
                }
                audioElement.preload = 'metadata'; // for mobile devices
                var blob = new Blob([soundData.data], { type: soundData.mimeType });
                audioElement.src = URL.createObjectURL(blob);
                audioElement.load();
                audioElement.addEventListener("loadedmetadata", function () {
                    onComplete({
                        duration: this.duration * 1000
                    });
                });
            }
            var SoundData = /** @class */ (function () {
                function SoundData() {
                }
                return SoundData;
            }());
            var Sound = /** @class */ (function (_super) {
                __extends(Sound, _super);
                function Sound(stream, context) {
                    var _this = _super.call(this) || this;
                    Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 5 /* SOUND_FEATURE */ });
                    _this._playQueue = [];
                    _this._url = null;
                    _this._length = 0;
                    _this._bytesTotal = 0;
                    _this._bytesLoaded = 0;
                    _this._id3 = _this._sec.media.ID3Info.create();
                    _this._isURLInaccessible = false;
                    _this._isBuffering = false;
                    _this.load(stream, context);
                    return _this;
                }
                Sound.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    this._playQueue = [];
                    this._url = null;
                    this._length = 0;
                    this._bytesTotal = 0;
                    this._bytesLoaded = 0;
                    this._id3 = this._sec.media.ID3Info.create();
                    this._isURLInaccessible = false;
                    this._isBuffering = false;
                    var symbol = this._symbol;
                    if (symbol) {
                        var soundData = new SoundData();
                        soundData.sampleRate = symbol.sampleRate;
                        soundData.channels = symbol.channels;
                        soundData.completed = true;
                        if (symbol.pcm) {
                            soundData.pcm = symbol.pcm;
                            soundData.end = symbol.pcm.length;
                        }
                        if (symbol.packaged) {
                            soundData.data = symbol.packaged.data.buffer;
                            soundData.mimeType = symbol.packaged.mimeType;
                        }
                        var self_7 = this;
                        getAudioDescription(soundData, function (description) {
                            self_7._length = description.duration;
                        });
                        this._soundData = soundData;
                    }
                };
                Sound.initializeFromPCMData = function (sec, data) {
                    var sound = sec.media.Sound.create();
                    sound._symbol = data;
                    sound.applySymbol();
                    return sound;
                };
                Sound.prototype.preInit = function () {
                    if (this._symbol) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                Object.defineProperty(Sound.prototype, "url", {
                    get: function () {
                        return this._url;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "isURLInaccessible", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Sound::get isURLInaccessible");
                        return this._isURLInaccessible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "length", {
                    get: function () {
                        return this._length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "isBuffering", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.Sound::get isBuffering");
                        return this._isBuffering;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "bytesLoaded", {
                    get: function () {
                        return this._bytesLoaded;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "bytesTotal", {
                    get: function () {
                        return this._bytesTotal;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Sound.prototype, "id3", {
                    get: function () {
                        return this._id3;
                    },
                    enumerable: true,
                    configurable: true
                });
                Sound.prototype.loadCompressedDataFromByteArray = function (bytes, bytesLength /*uint*/) {
                    bytes = bytes;
                    bytesLength = bytesLength >>> 0;
                    release || notImplemented("public flash.media.Sound::loadCompressedDataFromByteArray");
                    return;
                };
                Sound.prototype.loadPCMFromByteArray = function (bytes, samples /*uint*/, format, stereo, sampleRate) {
                    if (format === void 0) { format = "float"; }
                    if (stereo === void 0) { stereo = true; }
                    if (sampleRate === void 0) { sampleRate = 44100; }
                    bytes = bytes;
                    samples = samples >>> 0;
                    format = format;
                    stereo = !!stereo;
                    sampleRate = +sampleRate;
                    release || notImplemented("public flash.media.Sound::loadPCMFromByteArray");
                    return;
                };
                Sound.prototype.play = function (startTime, loops, sndTransform) {
                    if (startTime === void 0) { startTime = 0; }
                    if (loops === void 0) { loops = 0; }
                    if (sndTransform === void 0) { sndTransform = null; }
                    startTime = +startTime;
                    loops = loops | 0;
                    var channel = this._sec.media.SoundChannel.create();
                    channel._sound = this;
                    channel._soundTransform = Shumway.isNullOrUndefined(sndTransform) ?
                        this._sec.media.SoundTransform.create() :
                        sndTransform;
                    this._playQueue.push({
                        channel: channel,
                        startTime: startTime
                    });
                    if (Shumway.disableAudioOption.value) {
                        return channel;
                    }
                    if (this._soundData) {
                        if (!Shumway.webAudioOption.value && !Shumway.webAudioMP3Option.value) {
                            channel._playSoundDataViaAudio(this._soundData, startTime, loops);
                        }
                        else if (!this._soundData.pcm) {
                            if (this._soundData.mimeType === 'audio/mpeg' && Shumway.webAudioMP3Option.value) {
                                Shumway.SWF.MP3DecoderSession.processAll(new Uint8Array(this._soundData.data)).then(function (result) {
                                    this._soundData.pcm = result.data;
                                    this._soundData.end = result.data.length;
                                    channel._playSoundDataViaChannel(this._soundData, startTime, loops);
                                }.bind(this), function (reason) {
                                    Shumway.Debug.warning('Unable to decode MP3 data: ' + reason);
                                });
                            }
                            else {
                                Shumway.Debug.warning('Unable to decode packaged sound data of type: ' + this._soundData.mimeType);
                            }
                        }
                        else {
                            channel._playSoundDataViaChannel(this._soundData, startTime, loops);
                        }
                    }
                    return channel;
                };
                Sound.prototype.close = function () {
                    release || somewhatImplemented("public flash.media.Sound::close");
                };
                Sound.prototype.extract = function (target, length, startPosition) {
                    if (startPosition === void 0) { startPosition = -1; }
                    target = target;
                    length = +length;
                    startPosition = +startPosition;
                    release || notImplemented("public flash.media.Sound::extract");
                    return 0;
                };
                Sound.prototype.load = function (request, context) {
                    if (!request) {
                        return;
                    }
                    var checkPolicyFile = context ? context.checkPolicyFile : false;
                    var bufferTime = context ? context.bufferTime : 1000;
                    var self = this;
                    var stream = this._stream = this._sec.net.URLStream.create();
                    var data = this._sec.utils.ByteArray.create();
                    var dataPosition = 0;
                    var playUsingWebAudio = Shumway.webAudioOption.value;
                    var mp3DecodingSession = null;
                    var soundData = new SoundData();
                    soundData.completed = false;
                    stream.addEventListener("progress", function (event) {
                        self._bytesLoaded = event.axGetPublicProperty("bytesLoaded");
                        self._bytesTotal = event.axGetPublicProperty("bytesTotal");
                        if (playUsingWebAudio && !mp3DecodingSession) {
                            // initialize MP3 decoding
                            mp3DecodingSession = decodeMP3(soundData, function (duration, final) {
                                if (self._length === 0) {
                                    // once we have some data, trying to play it
                                    self._soundData = soundData;
                                    self._playQueue.forEach(function (item) {
                                        item.channel._playSoundDataViaChannel(soundData, item.startTime);
                                    });
                                }
                                // estimate duration based on bytesTotal and current loaded data time
                                self._length = final ? duration * 1000 : Math.max(duration, mp3DecodingSession.estimateDuration(self._bytesTotal)) * 1000;
                            });
                        }
                        var bytesAvailable = stream.bytesAvailable;
                        stream.readBytes(data, dataPosition, bytesAvailable);
                        if (mp3DecodingSession) {
                            mp3DecodingSession.pushData(new Uint8Array(data._buffer, dataPosition, bytesAvailable));
                        }
                        dataPosition += bytesAvailable;
                        self.dispatchEvent(event);
                    });
                    stream.addEventListener("complete", function (event) {
                        self.dispatchEvent(event);
                        soundData.data = data._buffer;
                        soundData.mimeType = 'audio/mpeg';
                        soundData.completed = true;
                        if (!playUsingWebAudio) {
                            self._soundData = soundData;
                            getAudioDescription(soundData, function (description) {
                                self._length = description.duration;
                            });
                            self._playQueue.forEach(function (item) {
                                item.channel._playSoundDataViaAudio(soundData, item.startTime);
                            });
                        }
                        if (mp3DecodingSession) {
                            mp3DecodingSession.close();
                        }
                    });
                    stream.load(request);
                };
                // Called whenever the class is initialized.
                Sound.classInitializer = null;
                // List of static symbols to link.
                Sound.classSymbols = null; // [];
                // List of instance symbols to link.
                Sound.instanceSymbols = null; // ["load"];
                return Sound;
            }(flash.events.EventDispatcher));
            media.Sound = Sound;
            var SoundSymbol = /** @class */ (function (_super) {
                __extends(SoundSymbol, _super);
                function SoundSymbol(data, sec) {
                    return _super.call(this, data, sec.media.Sound) || this;
                }
                SoundSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new SoundSymbol(data, loaderInfo._sec);
                    symbol.channels = data.channels;
                    symbol.sampleRate = data.sampleRate;
                    symbol.pcm = data.pcm;
                    symbol.packaged = data.packaged;
                    return symbol;
                };
                return SoundSymbol;
            }(Shumway.Timeline.Symbol));
            media.SoundSymbol = SoundSymbol;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SoundChannel
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var assert = Shumway.Debug.assert;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var error = Shumway.Debug.error;
            function createAudioChannel(sampleRate, channels) {
                if (WebAudioChannel.isSupported) {
                    return new WebAudioChannel(sampleRate, channels);
                }
                else {
                    error('PCM data playback is not supported by the browser');
                    return null;
                }
            }
            var AudioResampler = /** @class */ (function () {
                function AudioResampler(sourceRate, targetRate) {
                    this._sourceRate = sourceRate;
                    this._targetRate = targetRate;
                    this._tail = [];
                    this._sourceOffset = 0;
                }
                AudioResampler.prototype.getData = function (channelsData, count) {
                    var k = this._sourceRate / this._targetRate;
                    var offset = this._sourceOffset;
                    var needed = Math.ceil((count - 1) * k + offset) + 1;
                    var sourceData = [];
                    for (var channel = 0; channel < channelsData.length; channel++) {
                        sourceData.push(new Float32Array(needed));
                    }
                    var e = { data: sourceData, count: needed };
                    this.ondatarequested(e);
                    for (var channel = 0; channel < channelsData.length; channel++) {
                        var data = channelsData[channel];
                        var source = sourceData[channel];
                        for (var j = 0; j < count; j++) {
                            var i = j * k + offset;
                            var i1 = i | 0, i2 = Math.ceil(i) | 0;
                            var source_i1 = i1 < 0 ? this._tail[channel] : source[i1];
                            if (i1 === i2) {
                                data[j] = source_i1;
                            }
                            else {
                                var alpha = i - i1;
                                data[j] = source_i1 * (1 - alpha) + source[i2] * alpha;
                            }
                        }
                        this._tail[channel] = source[needed - 1];
                    }
                    this._sourceOffset = ((count - 1) * k + offset) - (needed - 1);
                };
                return AudioResampler;
            }());
            var WebAudioChannel = /** @class */ (function () {
                function WebAudioChannel(sampleRate, channels) {
                    var context = WebAudioChannel._cachedContext;
                    if (!context) {
                        context = new AudioContext();
                        WebAudioChannel._cachedContext = context;
                    }
                    this._context = context;
                    this._contextSampleRate = context.sampleRate || 44100;
                    this._channels = channels;
                    this._sampleRate = sampleRate;
                    if (this._contextSampleRate !== sampleRate) {
                        this._resampler = new AudioResampler(sampleRate, this._contextSampleRate);
                        this._resampler.ondatarequested = function (e) {
                            this.requestData(e.data, e.count);
                        }.bind(this);
                    }
                }
                WebAudioChannel.prototype.setVolume = function (value) {
                    // TODO set volume on this._source via gain node
                };
                WebAudioChannel.prototype.start = function () {
                    var source = this._context.createScriptProcessor(2048, 0, this._channels);
                    var self = this;
                    source.onaudioprocess = function (e) {
                        var channelsData = [];
                        for (var i = 0; i < self._channels; i++) {
                            channelsData.push(e.outputBuffer.getChannelData(i));
                        }
                        var count = channelsData[0].length;
                        if (self._resampler) {
                            self._resampler.getData(channelsData, count);
                        }
                        else {
                            self.requestData(channelsData, count);
                        }
                    };
                    source.connect(this._context.destination);
                    this._source = source;
                };
                WebAudioChannel.prototype.stop = function () {
                    this._source.disconnect(this._context.destination);
                };
                WebAudioChannel.prototype.requestData = function (channelsData, count) {
                    var channels = this._channels;
                    var buffer = new Float32Array(count * channels);
                    var e = { data: buffer, count: buffer.length };
                    this.ondatarequested(e);
                    for (var j = 0, p = 0; j < count; j++) {
                        for (var i = 0; i < channels; i++) {
                            channelsData[i][j] = buffer[p++];
                        }
                    }
                };
                WebAudioChannel.isSupported = function () {
                    return typeof AudioContext !== 'undefined';
                };
                return WebAudioChannel;
            }());
            var SoundChannel = /** @class */ (function (_super) {
                __extends(SoundChannel, _super);
                function SoundChannel() {
                    var _this = _super.call(this) || this;
                    _this._element = null;
                    _this._position = 0;
                    _this._leftPeak = 0;
                    _this._rightPeak = 0;
                    _this._pcmData = null;
                    _this._soundTransform = _this._sec.media.SoundTransform.create();
                    _this._playing = false;
                    _this._element = null;
                    return _this;
                }
                SoundChannel.initializeFromAudioElement = function (sec, element) {
                    var channel = sec.media.SoundChannel.create();
                    channel._element = element;
                    media.SoundMixer._registerSoundSource(channel);
                    return channel;
                };
                Object.defineProperty(SoundChannel.prototype, "position", {
                    get: function () {
                        return this._position;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundChannel.prototype, "soundTransform", {
                    get: function () {
                        return this._soundTransform;
                    },
                    set: function (sndTransform) {
                        release || somewhatImplemented("public flash.media.SoundChannel::set soundTransform");
                        this._soundTransform = Shumway.isNullOrUndefined(sndTransform) ?
                            this._sec.media.SoundTransform.create() :
                            sndTransform;
                        media.SoundMixer._updateSoundSource(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundChannel.prototype, "leftPeak", {
                    get: function () {
                        return this._leftPeak;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundChannel.prototype, "rightPeak", {
                    get: function () {
                        return this._rightPeak;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundChannel.prototype, "playing", {
                    get: function () {
                        return this._playing;
                    },
                    enumerable: true,
                    configurable: true
                });
                SoundChannel.prototype.stop = function () {
                    if (this._element) {
                        media.SoundMixer._unregisterSoundSource(this);
                        this._element.loop = false;
                        this._element.pause();
                        this._element.removeAttribute('src');
                        this._playing = false;
                    }
                    if (this._audioChannel) {
                        media.SoundMixer._unregisterSoundSource(this);
                        this._audioChannel.stop();
                        this._playing = false;
                    }
                };
                SoundChannel.prototype._playSoundDataViaAudio = function (soundData, startTime, loops) {
                    if (!soundData.mimeType) {
                        return;
                    }
                    media.SoundMixer._registerSoundSource(this);
                    this._position = startTime;
                    var self = this;
                    var lastCurrentTime = 0;
                    var element = document.createElement('audio');
                    if (!element.canPlayType(soundData.mimeType)) {
                        console.error('ERROR: \"' + soundData.mimeType + '\" ' +
                            'type playback is not supported by the browser');
                        return;
                    }
                    element.preload = 'metadata'; // for mobile devices
                    element.loop = loops > 0; // starts loop played if at least one is specified
                    var blob = new Blob([soundData.data], { type: soundData.mimeType });
                    element.src = URL.createObjectURL(blob);
                    element.addEventListener("loadeddata", function loaded() {
                        element.currentTime = startTime / 1000;
                        element.play();
                    });
                    element.addEventListener("timeupdate", function timeupdate() {
                        var currentTime = element.currentTime;
                        if (loops && lastCurrentTime > currentTime) {
                            --loops;
                            if (!loops) {
                                element.loop = false;
                            }
                            if (currentTime < startTime / 1000) {
                                element.currentTime = startTime / 1000;
                            }
                        }
                        self._position = (lastCurrentTime = currentTime) * 1000;
                    });
                    element.addEventListener("ended", function ended() {
                        media.SoundMixer._unregisterSoundSource(self);
                        self._element = null;
                        self._playing = false;
                        self.dispatchEvent(self._sec.events.Event.create(["soundComplete", false,
                            false]));
                    });
                    this._element = element;
                    this._playing = true;
                    media.SoundMixer._updateSoundSource(this);
                };
                SoundChannel.prototype._playSoundDataViaChannel = function (soundData, startTime, loops) {
                    release || assert(soundData.pcm, 'no pcm data found');
                    media.SoundMixer._registerSoundSource(this);
                    var self = this;
                    var startPosition = Math.round(startTime / 1000 * soundData.sampleRate) *
                        soundData.channels;
                    var position = startPosition;
                    this._position = startTime;
                    this._audioChannel = createAudioChannel(soundData.sampleRate, soundData.channels);
                    this._audioChannel.ondatarequested = function (e) {
                        var end = soundData.end;
                        if (position >= end && soundData.completed) {
                            // end of buffer
                            media.SoundMixer._unregisterSoundSource(this);
                            self._audioChannel.stop();
                            self._playing = false;
                            self.dispatchEvent(self._sec.events.Event.create(["soundComplete", false,
                                false]));
                            return;
                        }
                        var left = e.count;
                        var data = e.data;
                        var source = soundData.pcm;
                        do {
                            var count = Math.min(end - position, left);
                            for (var j = 0; j < count; j++) {
                                data[j] = source[position++];
                            }
                            left -= count;
                            if (position >= end) {
                                if (!loops) {
                                    break;
                                }
                                loops--;
                                position = startPosition;
                            }
                        } while (left > 0);
                        self._position = position / soundData.sampleRate / soundData.channels * 1000;
                    };
                    this._audioChannel.start();
                    this._playing = true;
                    media.SoundMixer._updateSoundSource(this);
                };
                SoundChannel.prototype.stopSound = function () {
                    this.stop();
                };
                SoundChannel.prototype.updateSoundLevels = function (volume) {
                    if (this._element) {
                        this._element.volume = volume <= 0 ? 0 : volume >= 1.0 ? 1.0 : volume;
                    }
                    if (this._audioChannel) {
                        this._audioChannel.setVolume(volume);
                    }
                };
                SoundChannel.classInitializer = null;
                return SoundChannel;
            }(flash.events.EventDispatcher));
            media.SoundChannel = SoundChannel;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SoundLoaderContext
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var SoundLoaderContext = /** @class */ (function (_super) {
                __extends(SoundLoaderContext, _super);
                function SoundLoaderContext(bufferTime, checkPolicyFile) {
                    if (bufferTime === void 0) { bufferTime = 1000; }
                    if (checkPolicyFile === void 0) { checkPolicyFile = false; }
                    var _this = _super.call(this) || this;
                    _this.bufferTime = +bufferTime;
                    _this.checkPolicyFile = !!checkPolicyFile;
                    return _this;
                }
                return SoundLoaderContext;
            }(flash.LegacyEntity));
            media.SoundLoaderContext = SoundLoaderContext;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SoundMixer
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var SoundMixer = /** @class */ (function (_super) {
                __extends(SoundMixer, _super);
                function SoundMixer() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(SoundMixer, "bufferTime", {
                    // static _audioPlaybackMode: string;
                    // static _useSpeakerphoneForVoice: boolean;
                    get: function () {
                        release || notImplemented("public flash.media.SoundMixer::get bufferTime");
                        return SoundMixer._bufferTime;
                    },
                    set: function (bufferTime /*int*/) {
                        release || somewhatImplemented("public flash.media.SoundMixer::set bufferTime");
                        SoundMixer._bufferTime = bufferTime | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundMixer, "soundTransform", {
                    get: function () {
                        release || somewhatImplemented("public flash.media.SoundMixer::get soundTransform");
                        return Shumway.isNullOrUndefined(SoundMixer._soundTransform) ?
                            flash.system.currentDomain().media.SoundTransform.create() :
                            flash.system.currentDomain().media.SoundTransform.create([SoundMixer._soundTransform.volume,
                                SoundMixer._soundTransform.pan]);
                    },
                    set: function (sndTransform) {
                        release || somewhatImplemented("public flash.media.SoundMixer::set soundTransform");
                        SoundMixer._soundTransform = Shumway.isNullOrUndefined(sndTransform) ?
                            flash.system.currentDomain().media.SoundTransform.create() :
                            sndTransform;
                        SoundMixer._updateAllSoundSources();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundMixer, "audioPlaybackMode", {
                    get: function () {
                        release || notImplemented("public flash.media.SoundMixer::get audioPlaybackMode");
                        return "";
                        // return SoundMixer._audioPlaybackMode;
                    },
                    set: function (value) {
                        value = value;
                        release || notImplemented("public flash.media.SoundMixer::set audioPlaybackMode");
                        return;
                        // SoundMixer._audioPlaybackMode = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundMixer, "useSpeakerphoneForVoice", {
                    get: function () {
                        release || notImplemented("public flash.media.SoundMixer::get useSpeakerphoneForVoice");
                        return false;
                        // return SoundMixer._useSpeakerphoneForVoice;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.media.SoundMixer::set useSpeakerphoneForVoice");
                        return;
                        // SoundMixer._useSpeakerphoneForVoice = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                SoundMixer.stopAll = function () {
                    SoundMixer._registeredSoundSources.forEach(function (channel) {
                        channel.stopSound();
                    });
                    SoundMixer._registeredSoundSources = [];
                };
                SoundMixer.computeSpectrum = function (outputArray, FFTMode, stretchFactor) {
                    if (FFTMode === void 0) { FFTMode = false; }
                    if (stretchFactor === void 0) { stretchFactor = 0; }
                    FFTMode = !!FFTMode;
                    stretchFactor = stretchFactor | 0;
                    release || somewhatImplemented("public flash.media.SoundMixer::static computeSpectrum");
                    var data = new Float32Array(1024);
                    for (var i = 0; i < 1024; i++) {
                        data[i] = Math.random();
                    }
                    outputArray.writeRawBytes(data);
                    outputArray.position = 0;
                };
                SoundMixer.areSoundsInaccessible = function () {
                    release || notImplemented("public flash.media.SoundMixer::static areSoundsInaccessible");
                    return false;
                };
                SoundMixer._getMasterVolume = function () {
                    return SoundMixer._masterVolume;
                };
                SoundMixer._setMasterVolume = function (volume) {
                    volume = +volume;
                    SoundMixer._masterVolume = volume;
                    SoundMixer._updateAllSoundSources();
                };
                SoundMixer._registerSoundSource = function (source) {
                    SoundMixer._registeredSoundSources.push(source);
                };
                SoundMixer._unregisterSoundSource = function (source) {
                    var index = SoundMixer._registeredSoundSources.indexOf(source);
                    if (index >= 0) {
                        SoundMixer._registeredSoundSources.splice(index, 1);
                    }
                };
                SoundMixer._updateSoundSource = function (source) {
                    var volume = source.soundTransform.volume;
                    if (SoundMixer._soundTransform) {
                        volume *= SoundMixer._soundTransform.volume;
                    }
                    volume *= SoundMixer._getMasterVolume();
                    source.updateSoundLevels(volume);
                };
                SoundMixer._updateAllSoundSources = function () {
                    SoundMixer._registeredSoundSources.forEach(SoundMixer._updateSoundSource);
                };
                SoundMixer._masterVolume = 1;
                SoundMixer._registeredSoundSources = [];
                SoundMixer._bufferTime = 0;
                return SoundMixer;
            }(flash.LegacyEntity));
            media.SoundMixer = SoundMixer;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SoundTransform
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var SoundTransform = /** @class */ (function (_super) {
                __extends(SoundTransform, _super);
                function SoundTransform(vol, panning) {
                    if (vol === void 0) { vol = 1; }
                    if (panning === void 0) { panning = 0; }
                    var _this = _super.call(this) || this;
                    _this.volume = +vol;
                    _this.pan = +panning;
                    return _this;
                }
                Object.defineProperty(SoundTransform.prototype, "volume", {
                    get: function () {
                        return this._volume;
                    },
                    set: function (volume) {
                        volume = +volume;
                        this._volume = volume;
                        this._updateTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundTransform.prototype, "leftToLeft", {
                    get: function () {
                        return this._leftToLeft;
                    },
                    set: function (leftToLeft) {
                        leftToLeft = +leftToLeft;
                        this._leftToLeft = leftToLeft;
                        this._updateTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundTransform.prototype, "leftToRight", {
                    get: function () {
                        return this._leftToRight;
                    },
                    set: function (leftToRight) {
                        leftToRight = +leftToRight;
                        this._leftToRight = leftToRight;
                        this._updateTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundTransform.prototype, "rightToRight", {
                    get: function () {
                        return this._rightToRight;
                    },
                    set: function (rightToRight) {
                        rightToRight = +rightToRight;
                        this._rightToRight = rightToRight;
                        this._updateTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundTransform.prototype, "rightToLeft", {
                    get: function () {
                        return this._rightToLeft;
                    },
                    set: function (rightToLeft) {
                        rightToLeft = +rightToLeft;
                        this._rightToLeft = rightToLeft;
                        this._updateTransform();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SoundTransform.prototype, "pan", {
                    get: function () {
                        if (this._leftToRight === 0 && this._rightToLeft === 0) {
                            return 1 - this._leftToLeft * this._leftToLeft;
                        }
                        return 0;
                    },
                    set: function (panning) {
                        this.leftToLeft = Math.sqrt(1 - panning);
                        this.leftToRight = 0;
                        this.rightToRight = Math.sqrt(1 + panning);
                        this.rightToLeft = 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                SoundTransform.prototype._updateTransform = function () {
                    release || somewhatImplemented("public flash.media.SoundTransform::_updateTransform");
                    // TODO dispatch updates to the current audio destinations?
                };
                return SoundTransform;
            }(flash.LegacyEntity));
            media.SoundTransform = SoundTransform;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageVideo
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var notImplemented = Shumway.Debug.notImplemented;
            var StageVideo = /** @class */ (function (_super) {
                __extends(StageVideo, _super);
                function StageVideo() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(StageVideo.prototype, "viewPort", {
                    // JS -> AS Bindings
                    // AS -> JS Bindings
                    // _viewPort: flash.geom.Rectangle;
                    // _pan: flash.geom.Point;
                    // _zoom: flash.geom.Point;
                    // _depth: number /*int*/;
                    // _videoWidth: number /*int*/;
                    // _videoHeight: number /*int*/;
                    // _colorSpaces: any /*ASVector*/;
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get viewPort");
                        return null;
                        // return this._viewPort;
                    },
                    set: function (rect) {
                        rect = rect;
                        release || notImplemented("public flash.media.StageVideo::set viewPort");
                        return;
                        // this._viewPort = rect;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "pan", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get pan");
                        return null;
                        // return this._pan;
                    },
                    set: function (point) {
                        point = point;
                        release || notImplemented("public flash.media.StageVideo::set pan");
                        return;
                        // this._pan = point;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "zoom", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get zoom");
                        return null;
                        // return this._zoom;
                    },
                    set: function (point) {
                        point = point;
                        release || notImplemented("public flash.media.StageVideo::set zoom");
                        return;
                        // this._zoom = point;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "depth", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get depth");
                        return 0;
                        // return this._depth;
                    },
                    set: function (depth /*int*/) {
                        depth = depth | 0;
                        release || notImplemented("public flash.media.StageVideo::set depth");
                        return;
                        // this._depth = depth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "videoWidth", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get videoWidth");
                        return 0;
                        // return this._videoWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "videoHeight", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get videoHeight");
                        return 0;
                        // return this._videoHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(StageVideo.prototype, "colorSpaces", {
                    get: function () {
                        release || notImplemented("public flash.media.StageVideo::get colorSpaces");
                        return null;
                        // return this._colorSpaces;
                    },
                    enumerable: true,
                    configurable: true
                });
                StageVideo.prototype.attachNetStream = function (netStream) {
                    netStream = netStream;
                    release || notImplemented("public flash.media.StageVideo::attachNetStream");
                    return;
                };
                StageVideo.prototype.attachCamera = function (theCamera) {
                    theCamera = theCamera;
                    release || notImplemented("public flash.media.StageVideo::attachCamera");
                    return;
                };
                return StageVideo;
            }(flash.events.EventDispatcher));
            media.StageVideo = StageVideo;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StageVideoAvailability
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var StageVideoAvailability;
            (function (StageVideoAvailability) {
                StageVideoAvailability["AVAILABLE"] = "available";
                StageVideoAvailability["UNAVAILABLE"] = "unavailable";
            })(StageVideoAvailability = media.StageVideoAvailability || (media.StageVideoAvailability = {}));
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Video
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var assert = Shumway.Debug.assert;
            var Video = /** @class */ (function (_super) {
                __extends(Video, _super);
                function Video(width, height) {
                    if (width === void 0) { width = 320; }
                    if (height === void 0) { height = 240; }
                    var _this = this;
                    width |= 0;
                    height |= 0;
                    _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    if (!_this._symbol) {
                        width = width || 320;
                        height = height || 240;
                        _this._setFillAndLineBoundsFromWidthAndHeight(width * 20, height * 20);
                    }
                    return _this;
                }
                Video.prototype.applySymbol = function () {
                    this._initializeFields();
                    var symbol = this._symbol;
                    this._deblocking = symbol.deblocking;
                    this._smoothing = symbol.smoothing;
                    this._setFillAndLineBoundsFromWidthAndHeight(symbol.width * 20, symbol.height * 20);
                };
                Video.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._deblocking = 0;
                    this._smoothing = false;
                    this._videoWidth = 0;
                    this._videoHeight = 0;
                };
                Video.prototype.preInit = function () {
                    if (this._symbol && !this._fieldsInitialized) {
                        this.applySymbol();
                    }
                    _super.prototype.preInit.call(this);
                };
                Object.defineProperty(Video.prototype, "deblocking", {
                    get: function () {
                        return this._deblocking;
                    },
                    set: function (value /*int*/) {
                        this._deblocking = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Video.prototype, "smoothing", {
                    get: function () {
                        return this._smoothing;
                    },
                    set: function (value) {
                        this._smoothing = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Video.prototype, "videoWidth", {
                    get: function () {
                        return this._videoWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Video.prototype, "videoHeight", {
                    get: function () {
                        return this._videoHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Video.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    // If this override is reached, the content bounds have already been checked, which is all
                    // we need to do.
                    release || assert(this._getContentBounds().contains(localX, localY));
                    return true;
                };
                Video.prototype.clear = function () {
                    release || somewhatImplemented("public flash.media.Video::clear");
                    return;
                };
                Video.prototype.attachNetStream = function (netStream) {
                    if (this._netStream === netStream) {
                        return;
                    }
                    if (this._netStream) {
                        this._netStream._videoReferrer = null;
                    }
                    this._netStream = netStream;
                    if (this._netStream) {
                        netStream._videoReferrer = this;
                    }
                    this._setDirtyFlags(32 /* DirtyNetStream */);
                };
                Video.prototype.attachCamera = function (camera) {
                    release || notImplemented("public flash.media.Video::attachCamera");
                    return;
                };
                Video.classInitializer = null;
                Video.classSymbols = null;
                Video.instanceSymbols = null;
                return Video;
            }(flash.display.DisplayObject));
            media.Video = Video;
            var VideoSymbol = /** @class */ (function (_super) {
                __extends(VideoSymbol, _super);
                function VideoSymbol(data, sec) {
                    return _super.call(this, data, sec.media.Video, true) || this;
                }
                VideoSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new VideoSymbol(data, loaderInfo._sec);
                    symbol.width = data.width;
                    symbol.height = data.height;
                    symbol.deblocking = data.deblocking;
                    symbol.smoothing = data.smoothing;
                    symbol.codec = data.codec;
                    return symbol;
                };
                return VideoSymbol;
            }(Shumway.Timeline.DisplaySymbol));
            media.VideoSymbol = VideoSymbol;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: VideoStreamSettings
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var media;
        (function (media) {
            var VideoStreamSettings = /** @class */ (function (_super) {
                __extends(VideoStreamSettings, _super);
                function VideoStreamSettings() {
                    return _super.call(this) || this;
                }
                return VideoStreamSettings;
            }(flash.LegacyEntity));
            media.VideoStreamSettings = VideoStreamSettings;
        })(media = flash.media || (flash.media = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FileFilter
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var FileFilter = /** @class */ (function (_super) {
                __extends(FileFilter, _super);
                function FileFilter(description, extension, macType) {
                    if (macType === void 0) { macType = null; }
                    return _super.call(this) || this;
                }
                Object.defineProperty(FileFilter.prototype, "description", {
                    get: function () {
                        return this._description;
                    },
                    set: function (value) {
                        this._description = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileFilter.prototype, "extension", {
                    get: function () {
                        return this._extension;
                    },
                    set: function (value) {
                        this._extension = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileFilter.prototype, "macType", {
                    get: function () {
                        return this._macType;
                    },
                    set: function (value) {
                        this._macType = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return FileFilter;
            }(flash.LegacyEntity));
            net.FileFilter = FileFilter;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FileReference
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var notImplemented = Shumway.Debug.notImplemented;
            var FileReference = /** @class */ (function (_super) {
                __extends(FileReference, _super);
                function FileReference() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(FileReference.prototype, "creationDate", {
                    // _creationDate: ASDate;
                    // _creator: string;
                    // _modificationDate: ASDate;
                    // _name: string;
                    // _size: number;
                    // _type: string;
                    // _data: flash.utils.ByteArray;
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get creationDate");
                        return null;
                        // return this._creationDate;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileReference.prototype, "creator", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get creator");
                        return "";
                        // return this._creator;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileReference.prototype, "modificationDate", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get modificationDate");
                        return null;
                        // return this._modificationDate;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileReference.prototype, "name", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get name");
                        return "";
                        // return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileReference.prototype, "size", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get size");
                        return 0;
                        // return this._size;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileReference.prototype, "type", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get type");
                        return "";
                        // return this._type;
                    },
                    enumerable: true,
                    configurable: true
                });
                FileReference.prototype.cancel = function () {
                    release || notImplemented("public flash.net.FileReference::cancel");
                    return;
                };
                FileReference.prototype.download = function (request, defaultFileName) {
                    if (defaultFileName === void 0) { defaultFileName = null; }
                    request = request;
                    defaultFileName = defaultFileName;
                    release || notImplemented("public flash.net.FileReference::download");
                    return;
                };
                FileReference.prototype.upload = function (request, uploadDataFieldName, testUpload) {
                    if (uploadDataFieldName === void 0) { uploadDataFieldName = "Filedata"; }
                    if (testUpload === void 0) { testUpload = false; }
                    request = request;
                    uploadDataFieldName = uploadDataFieldName;
                    testUpload = !!testUpload;
                    release || notImplemented("public flash.net.FileReference::upload");
                    return;
                };
                Object.defineProperty(FileReference.prototype, "data", {
                    get: function () {
                        release || notImplemented("public flash.net.FileReference::get data");
                        return null;
                        // return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });
                FileReference.prototype.browse = function (typeFilter) {
                    if (typeFilter === void 0) { typeFilter = null; }
                    typeFilter = typeFilter;
                    release || notImplemented("public flash.net.FileReference::browse");
                    return false;
                };
                return FileReference;
            }(flash.events.EventDispatcher));
            net.FileReference = FileReference;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FileReferenceList
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var notImplemented = Shumway.Debug.notImplemented;
            var FileReferenceList = /** @class */ (function (_super) {
                __extends(FileReferenceList, _super);
                function FileReferenceList() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(FileReferenceList.prototype, "fileList", {
                    // _fileList: any [];
                    get: function () {
                        release || notImplemented("public flash.net.FileReferenceList::get fileList");
                        return null;
                        // return this._fileList;
                    },
                    enumerable: true,
                    configurable: true
                });
                FileReferenceList.prototype.browse = function (typeFilter) {
                    if (typeFilter === void 0) { typeFilter = null; }
                    typeFilter = typeFilter;
                    release || notImplemented("public flash.net.FileReferenceList::browse");
                    return false;
                };
                FileReferenceList.classInitializer = null;
                return FileReferenceList;
            }(flash.events.EventDispatcher));
            net.FileReferenceList = FileReferenceList;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var assert = Shumway.Debug.assert;
            var forbiddenNames = ['send', 'connect', 'close', 'allowDomain', 'allowInsecureDomain', 'client',
                'domain'];
            Object.freeze(forbiddenNames);
            var LocalConnection = /** @class */ (function (_super) {
                __extends(LocalConnection, _super);
                function LocalConnection() {
                    var _this = _super.call(this) || this;
                    _this._client = _this;
                    _this._connectionName = null;
                    _this._allowedInsecureDomains = [];
                    _this._allowedSecureDomains = [];
                    // tsc contains a definition for URL that's non-constructible.
                    // @ivanpopelyshev: that's a problem, we dont have currentABC in legacy, only currentDomain's
                    // no url in them
                    // let url = new (<any>URL)(Shumway.AVMX.getCurrentABC().env.url);
                    var url = new URL("localhost:8080");
                    _this._domain = url.hostname;
                    _this._secure = url.protocol === 'https:';
                    return _this;
                }
                Object.defineProperty(LocalConnection, "isSupported", {
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                LocalConnection.prototype.close = function () {
                    var connectionName = this._connectionName;
                    if (!connectionName) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.CloseNotConnectedError);
                    }
                    release || assert(typeof connectionName === 'string' && connectionName.length > 0);
                    this._connectionName = null;
                    // TODO: verify that these really are reset. For now, we aim to err on the safe side.
                    this._allowedInsecureDomains = [];
                    this._allowedSecureDomains = [];
                    Shumway.LocalConnectionService.instance.closeConnection(connectionName, this);
                };
                LocalConnection.prototype.connect = function (connectionName) {
                    if (connectionName === null) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'connectionName');
                    }
                    if (connectionName === '') {
                        this._sec.throwError('TypeError', Shumway.Errors.EmptyStringError, 'connectionName');
                    }
                    // The only disallowed character for the connection name is ":".
                    if (connectionName.indexOf(':') > -1) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.InvalidParamError);
                    }
                    if (this._connectionName) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.AlreadyConnectedError);
                    }
                    var result = Shumway.LocalConnectionService.instance.createConnection(connectionName, this);
                    if (result === -2 /* AlreadyTaken */) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.AlreadyConnectedError);
                    }
                    this._connectionName = connectionName;
                    release || assert(result === 0 /* Success */);
                    if (this._allowedInsecureDomains.length) {
                        Shumway.LocalConnectionService.instance.allowDomains(connectionName, this, this._allowedInsecureDomains, false);
                    }
                    if (this._allowedSecureDomains.length) {
                        Shumway.LocalConnectionService.instance.allowDomains(connectionName, this, this._allowedSecureDomains, true);
                    }
                };
                LocalConnection.prototype.send = function (connectionName, methodName) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    if (connectionName === null) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'connectionName');
                    }
                    if (connectionName === '') {
                        this._sec.throwError('TypeError', Shumway.Errors.EmptyStringError, 'connectionName');
                    }
                    if (methodName === null) {
                        this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'methodName');
                    }
                    if (methodName === '') {
                        this._sec.throwError('TypeError', Shumway.Errors.EmptyStringError, 'methodName');
                    }
                    if (forbiddenNames.indexOf(methodName) > -1) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.InvalidParamError);
                    }
                    var serializedArgs = this._sec.utils.ByteArray.create();
                    serializedArgs.writeObject(args);
                    if (serializedArgs.length > 40 * 1024) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.ArgumentSizeError);
                    }
                    var argsBuffer = serializedArgs.getBytes().buffer;
                    try {
                        Shumway.LocalConnectionService.instance.send(connectionName, methodName, argsBuffer, this, this._domain, this._secure);
                    }
                    catch (e) {
                        // Not sure what to do here, this shouldn't happen. We'll just ignore it with a warning.
                        Shumway.Debug.warning('Unknown error occurred in LocalConnection#send', e);
                    }
                };
                Object.defineProperty(LocalConnection.prototype, "client", {
                    get: function () {
                        return this._client;
                    },
                    set: function (client) {
                        if (client._sec !== this._sec) {
                            this._sec.throwError('ArgumentError', Shumway.Errors.InvalidParamError);
                        }
                        this._client = client;
                    },
                    enumerable: true,
                    configurable: true
                });
                LocalConnection.prototype.allowDomain = function () {
                    var domains = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        domains[_i] = arguments[_i];
                    }
                    this._allowDomains(domains, true);
                };
                LocalConnection.prototype.allowInsecureDomain = function () {
                    var domains = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        domains[_i] = arguments[_i];
                    }
                    // allowInsecureDomain also allows secure domains.
                    this._allowDomains(domains, true);
                    this._allowDomains(domains, false);
                };
                LocalConnection.prototype._allowDomains = function (domains, secure) {
                    var result = [];
                    // If no connection has been made yet, store the domains for later retrieval.
                    if (!this._connectionName) {
                        result = secure ? this._allowedSecureDomains : this._allowedInsecureDomains;
                    }
                    for (var i = 0; i < domains.length; i++) {
                        var domain = domains[i];
                        if (typeof domain !== 'string') {
                            this._sec.throwError('ArgumentError', Shumway.Errors.AllowDomainArgumentError);
                        }
                        if (result.indexOf(domain) === -1) {
                            result.push(domain);
                        }
                    }
                    if (this._connectionName) {
                        Shumway.LocalConnectionService.instance.allowDomains(this._connectionName, this, domains, secure);
                    }
                };
                LocalConnection.prototype.handleMessage = function (methodName, argsBuffer) {
                    var client = this._client;
                    var error;
                    if (!client.axHasPublicProperty(methodName) || forbiddenNames.indexOf(methodName) > -1) {
                        // Forbidden names really shouldn't reach this point, but should everything else fail,
                        // we just pretend not to have found them here.
                        error = this._sec.createError('ReferenceError', Shumway.Errors.ReadSealedError, methodName, client.axClass.name.name);
                    }
                    else {
                        var handler = client.axGetPublicProperty(methodName);
                        if (typeof handler !== 'function') {
                            // Non-callable handlers are just ignored.
                            return;
                        }
                        var ba = this._sec.utils.ByteArray.create([argsBuffer]);
                        var args = ba.readObject();
                        if (!(args instanceof Array)) {
                            error =
                                this._sec.createError('TypeError', Shumway.Errors.CheckTypeFailedError, args, 'Array');
                        }
                        else {
                            try {
                                handler.apply(client, args);
                            }
                            catch (e) {
                                error = e;
                            }
                        }
                    }
                    if (!error) {
                        return;
                    }
                    var asyncErrorEventCtor = this._sec.events.AsyncErrorEvent;
                    var errorEvent = asyncErrorEventCtor.create(['asyncError', false, false,
                        'Error #2095: flash.net.LocalConnection was' +
                            ' unable to invoke' +
                            ' callback ' + methodName + '.', error]);
                    if (this.hasEventListener('asyncError')) {
                        try {
                            this.dispatchEvent(errorEvent);
                        }
                        catch (e) {
                            console.warn("Exception encountered during asyncErrorEvent handling in " +
                                "LocalConnection sender.");
                        }
                    }
                    else {
                        // TODO: add the error to the LoaderInfo#uncaughtErrorEvents list.
                        console.warn('No handler for asyncError on LocalConnection sender, not sending event', errorEvent);
                    }
                };
                Object.defineProperty(LocalConnection.prototype, "domain", {
                    get: function () {
                        return this._domain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LocalConnection.prototype, "isPerUser", {
                    get: function () {
                        // We always return true, because everything else would be a lie.
                        return true;
                    },
                    set: function (newValue) {
                        !!newValue;
                        // Ignored. See
                        // https://blogs.adobe.com/simplicity/2009/08/localconnectionisperuser_in_ai.html for an
                        // explanation.
                    },
                    enumerable: true,
                    configurable: true
                });
                return LocalConnection;
            }(flash.events.EventDispatcher));
            net.LocalConnection = LocalConnection;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetConnection
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Telemetry = Shumway.Telemetry;
            var NetConnection = /** @class */ (function (_super) {
                __extends(NetConnection, _super);
                function NetConnection() {
                    var _this = _super.call(this) || this;
                    _this._uri = null;
                    _this._connected = false;
                    _this._client = null;
                    _this._proxyType = 'none';
                    _this._objectEncoding = NetConnection.defaultObjectEncoding;
                    _this._usingTLS = false;
                    _this._protocol = null;
                    Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 6 /* NETCONNECTION_FEATURE */ });
                    return _this;
                }
                // JS -> AS Bindings
                NetConnection.prototype.close = function () {
                    this.invoke(1);
                };
                NetConnection.prototype.addHeader = function (operation, mustUnderstand, param) {
                    if (mustUnderstand === void 0) { mustUnderstand = false; }
                    if (param === void 0) { param = null; }
                    this._invoke(3, [operation, !!mustUnderstand, param]);
                };
                NetConnection.prototype.call = function (command, responder /* more args can be provided */) {
                    arguments[0] = command;
                    this._invoke(2, arguments);
                };
                Object.defineProperty(NetConnection, "defaultObjectEncoding", {
                    get: function () {
                        return NetConnection._defaultObjectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        NetConnection._defaultObjectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "connected", {
                    get: function () {
                        return this._connected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "uri", {
                    get: function () {
                        return this._uri;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetConnection.prototype.connect = function (command) {
                    release || somewhatImplemented("public flash.net.NetConnection::connect");
                    this._uri = command;
                    var netStatusEventCtor = this._sec.events.NetStatusEvent;
                    if (!command) {
                        this._connected = true;
                        this.dispatchEvent(netStatusEventCtor.create([flash.events.NetStatusEvent.NET_STATUS, false, false,
                            { level: 'status', code: 'NetConnection.Connect.Success' }]));
                    }
                    else {
                        var parsedURL = RtmpJs.parseConnectionString(command);
                        if (!parsedURL || !parsedURL.host ||
                            (parsedURL.protocol !== 'rtmp' && parsedURL.protocol !== 'rtmpt' && parsedURL.protocol !== 'rtmps')) {
                            this.dispatchEvent(netStatusEventCtor.create([flash.events.NetStatusEvent.NET_STATUS, false, false,
                                { level: 'status', code: 'NetConnection.Connect.Failed' }]));
                            return;
                        }
                        var service = this._sec.player;
                        var rtmpProps = {
                            app: parsedURL.app,
                            flashver: flash.system.Capabilities.version,
                            swfUrl: service.swfUrl,
                            tcUrl: command,
                            fpad: false,
                            audioCodecs: 0x0FFF,
                            videoCodecs: 0x00FF,
                            videoFunction: 1,
                            pageUrl: service.pageUrl || service.swfUrl,
                            objectEncoding: 0
                        };
                        this._protocol = parsedURL.protocol;
                        var secured = parsedURL.protocol === 'rtmps' ||
                            (parsedURL.protocol === 'rtmpt' && (parsedURL.port === 443 || parsedURL.port === 8443));
                        this._usingTLS = secured;
                        var rtmpConnection = parsedURL.protocol === 'rtmp' || parsedURL.protocol === 'rtmps' ?
                            new RtmpJs.Browser.RtmpTransport({
                                host: parsedURL.host,
                                port: parsedURL.port || 1935,
                                ssl: secured
                            }) :
                            new RtmpJs.Browser.RtmptTransport({ host: parsedURL.host, port: parsedURL.port || 80, ssl: secured });
                        this._rtmpConnection = rtmpConnection;
                        this._rtmpCreateStreamCallbacks = [null, null]; // reserve first two
                        rtmpConnection.onresponse = function (e) {
                            //
                        };
                        rtmpConnection.onevent = function (e) {
                            //
                        };
                        rtmpConnection.onconnected = function (e) {
                            this._connected = true;
                            this.dispatchEvent(new this.sec.flash.events.NetStatusEvent(flash.events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({ level: 'status', code: 'NetConnection.Connect.Success' })));
                        }.bind(this);
                        rtmpConnection.onstreamcreated = function (e) {
                            console.log('#streamcreated: ' + e.streamId);
                            var callback = this._rtmpCreateStreamCallbacks[e.transactionId];
                            delete this._rtmpCreateStreamCallbacks[e.transactionId];
                            callback(e.stream, e.streamId);
                        }.bind(this);
                        rtmpConnection.connect(rtmpProps);
                    }
                };
                NetConnection.prototype._createRtmpStream = function (callback) {
                    var transactionId = this._rtmpCreateStreamCallbacks.length;
                    this._rtmpCreateStreamCallbacks[transactionId] = callback;
                    this._rtmpConnection.createStream(transactionId, null);
                };
                Object.defineProperty(NetConnection.prototype, "client", {
                    get: function () {
                        return this._client;
                    },
                    set: function (object) {
                        this._client = object;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "objectEncoding", {
                    get: function () {
                        return this._objectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        release || somewhatImplemented("public flash.net.NetConnection::set objectEncoding");
                        this._objectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "proxyType", {
                    get: function () {
                        return this._proxyType;
                    },
                    set: function (ptype) {
                        ptype = ptype;
                        release || somewhatImplemented("public flash.net.NetConnection::set proxyType");
                        this._proxyType = ptype;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "connectedProxyType", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get connectedProxyType");
                        return "";
                        // return this._connectedProxyType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "usingTLS", {
                    get: function () {
                        return this._usingTLS;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "protocol", {
                    get: function () {
                        return this._protocol;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "maxPeerConnections", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get maxPeerConnections");
                        return 0;
                        // return this._maxPeerConnections;
                    },
                    set: function (maxPeers /*uint*/) {
                        maxPeers = maxPeers >>> 0;
                        release || notImplemented("public flash.net.NetConnection::set maxPeerConnections");
                        return;
                        // this._maxPeerConnections = maxPeers;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "nearID", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get nearID");
                        return "";
                        // return this._nearID;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "farID", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get farID");
                        return "";
                        // return this._farID;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "nearNonce", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get nearNonce");
                        return "";
                        // return this._nearNonce;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "farNonce", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get farNonce");
                        return "";
                        // return this._farNonce;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetConnection.prototype, "unconnectedPeerStreams", {
                    get: function () {
                        release || notImplemented("public flash.net.NetConnection::get unconnectedPeerStreams");
                        return null;
                        // return this._unconnectedPeerStreams;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetConnection.prototype.invoke = function (index /*uint*/) {
                    index = index >>> 0;
                    return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                };
                NetConnection.prototype._invoke = function (index, args) {
                    var simulated = false;
                    var result;
                    switch (index) {
                        case 1: // close
                        case 2:// call, e.g. with ('createStream', <Responder>)
                            simulated = true;
                            break;
                    }
                    (simulated ? somewhatImplemented : notImplemented)("private flash.net.NetConnection::_invoke (" + index + ")");
                    return result;
                };
                // Called whenever the class is initialized.
                NetConnection.classInitializer = null;
                // AS -> JS Bindings
                NetConnection._defaultObjectEncoding = 3 /* AMF3 */;
                return NetConnection;
            }(flash.events.EventDispatcher));
            net.NetConnection = NetConnection;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetStream
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net_1) {
            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var events = Shumway.flash.events;
            var FileLoadingService = Shumway.FileLoadingService;
            var NetStream = /** @class */ (function (_super) {
                __extends(NetStream, _super);
                function NetStream(connection, peerID) {
                    if (peerID === void 0) { peerID = "connectToFMS"; }
                    var _this = _super.call(this) || this;
                    _this._connection = connection;
                    _this._peerID = peerID;
                    _this._id = flash.display.DisplayObject.getNextSyncID();
                    _this._isDirty = true;
                    _this._soundTransform = _this._sec.media.SoundTransform.create();
                    _this._contentTypeHint = null;
                    _this._checkPolicyFile = true;
                    _this._videoStream = new VideoStream(_this);
                    _this._videoStream._onEnsurePlay = function () {
                        this._notifyVideoControl(9 /* EnsurePlaying */, null);
                    }.bind(_this);
                    _this._resourceName = null;
                    _this._metaData = null;
                    return _this;
                }
                // _multicastPushNeighborLimit: number;
                // _multicastWindowDuration: number;
                // _multicastRelayMarginDuration: number;
                // _multicastAvailabilityUpdatePeriod: number;
                // _multicastFetchPeriod: number;
                // _multicastAvailabilitySendToAll: boolean;
                // _farID: string;
                // _nearNonce: string;
                // _farNonce: string;
                // _peerStreams: any [];
                // _audioReliable: boolean;
                // _videoReliable: boolean;
                // _dataReliable: boolean;
                // _audioSampleAccess: boolean;
                // _videoSampleAccess: boolean;
                // _useHardwareDecoder: boolean;
                // _useJitterBuffer: boolean;
                // _videoStreamSettings: flash.media.VideoStreamSettings;
                NetStream.prototype.dispose = function () {
                    release || notImplemented("public flash.net.NetStream::dispose");
                    return;
                };
                NetStream.prototype._getVideoStreamURL = function () {
                    return this._videoStream.url;
                };
                NetStream.prototype.play = function (url) {
                    flash.media.SoundMixer._registerSoundSource(this);
                    // (void) -> void ???
                    var service = this._sec.player;
                    service.registerEventListener(this._id, this.processVideoEvent.bind(this));
                    if (this._connection && this._connection.uri) {
                        this._videoStream.playInConnection(this._connection, url);
                    }
                    else if (url === null) {
                        this._videoStream.openInDataGenerationMode();
                    }
                    else {
                        this._videoStream.play(url, this.checkPolicyFile);
                    }
                    this._notifyVideoControl(1 /* Init */, {
                        url: this._videoStream.url
                    });
                };
                NetStream.prototype.play2 = function (param) {
                    param = param;
                    release || notImplemented("public flash.net.NetStream::play2");
                    return;
                };
                Object.defineProperty(NetStream.prototype, "info", {
                    get: function () {
                        release || somewhatImplemented("public flash.net.NetStream::get info");
                        var bufferSeconds = 1;
                        var playedSeconds = Math.ceil(this._invoke(304, null));
                        var audioBytesPerSecond = 32;
                        var videoBytesPerSecond = 200;
                        var dataBytesPerSecond = 1;
                        return this._sec.net.NetStreamInfo.create([
                            audioBytesPerSecond + videoBytesPerSecond,
                            (audioBytesPerSecond + videoBytesPerSecond + dataBytesPerSecond) * (bufferSeconds + playedSeconds),
                            audioBytesPerSecond + videoBytesPerSecond,
                            audioBytesPerSecond,
                            audioBytesPerSecond * (bufferSeconds + playedSeconds),
                            videoBytesPerSecond,
                            videoBytesPerSecond * (bufferSeconds + playedSeconds),
                            dataBytesPerSecond,
                            dataBytesPerSecond * (bufferSeconds + playedSeconds),
                            (audioBytesPerSecond + videoBytesPerSecond + dataBytesPerSecond) * playedSeconds,
                            0,
                            audioBytesPerSecond * bufferSeconds,
                            videoBytesPerSecond * bufferSeconds,
                            dataBytesPerSecond * bufferSeconds,
                            bufferSeconds,
                            bufferSeconds,
                            bufferSeconds,
                            0,
                            0,
                            0,
                            this._metaData,
                            null,
                            this._connection.uri,
                            this._resourceName,
                            false
                        ]);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastInfo", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastInfo");
                        return null;
                        // return this._multicastInfo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "soundTransform", {
                    get: function () {
                        return this._soundTransform;
                    },
                    set: function (sndTransform) {
                        this._soundTransform = sndTransform;
                        flash.media.SoundMixer._updateSoundSource(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "checkPolicyFile", {
                    get: function () {
                        return this._checkPolicyFile;
                    },
                    set: function (state) {
                        state = !!state;
                        this._checkPolicyFile = state;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "client", {
                    get: function () {
                        return this._client;
                    },
                    set: function (object) {
                        release || somewhatImplemented("public flash.net.NetStream::set client");
                        this._client = object;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "objectEncoding", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get objectEncoding");
                        return 0;
                        // return this._objectEncoding;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastPushNeighborLimit", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastPushNeighborLimit");
                        return 0;
                        // return this._multicastPushNeighborLimit;
                    },
                    set: function (neighbors) {
                        neighbors = +neighbors;
                        release || notImplemented("public flash.net.NetStream::set multicastPushNeighborLimit");
                        return;
                        // this._multicastPushNeighborLimit = neighbors;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastWindowDuration", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastWindowDuration");
                        return 0;
                        // return this._multicastWindowDuration;
                    },
                    set: function (seconds) {
                        seconds = +seconds;
                        release || notImplemented("public flash.net.NetStream::set multicastWindowDuration");
                        return;
                        // this._multicastWindowDuration = seconds;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastRelayMarginDuration", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastRelayMarginDuration");
                        return 0;
                        // return this._multicastRelayMarginDuration;
                    },
                    set: function (seconds) {
                        seconds = +seconds;
                        release || notImplemented("public flash.net.NetStream::set multicastRelayMarginDuration");
                        return;
                        // this._multicastRelayMarginDuration = seconds;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastAvailabilityUpdatePeriod", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastAvailabilityUpdatePeriod");
                        return 0;
                        // return this._multicastAvailabilityUpdatePeriod;
                    },
                    set: function (seconds) {
                        seconds = +seconds;
                        release || notImplemented("public flash.net.NetStream::set multicastAvailabilityUpdatePeriod");
                        return;
                        // this._multicastAvailabilityUpdatePeriod = seconds;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastFetchPeriod", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastFetchPeriod");
                        return 0;
                        // return this._multicastFetchPeriod;
                    },
                    set: function (seconds) {
                        seconds = +seconds;
                        release || notImplemented("public flash.net.NetStream::set multicastFetchPeriod");
                        return;
                        // this._multicastFetchPeriod = seconds;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "multicastAvailabilitySendToAll", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get multicastAvailabilitySendToAll");
                        return false;
                        // return this._multicastAvailabilitySendToAll;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.net.NetStream::set multicastAvailabilitySendToAll");
                        return;
                        // this._multicastAvailabilitySendToAll = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "farID", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get farID");
                        return "";
                        // return this._farID;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "nearNonce", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get nearNonce");
                        return "";
                        // return this._nearNonce;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "farNonce", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get farNonce");
                        return "";
                        // return this._farNonce;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "peerStreams", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get peerStreams");
                        return null;
                        // return this._peerStreams;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "audioReliable", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get audioReliable");
                        return false;
                        // return this._audioReliable;
                    },
                    set: function (reliable) {
                        reliable = !!reliable;
                        release || notImplemented("public flash.net.NetStream::set audioReliable");
                        return;
                        // this._audioReliable = reliable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "videoReliable", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get videoReliable");
                        return false;
                        // return this._videoReliable;
                    },
                    set: function (reliable) {
                        reliable = !!reliable;
                        release || notImplemented("public flash.net.NetStream::set videoReliable");
                        return;
                        // this._videoReliable = reliable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "dataReliable", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get dataReliable");
                        return false;
                        // return this._dataReliable;
                    },
                    set: function (reliable) {
                        reliable = !!reliable;
                        release || notImplemented("public flash.net.NetStream::set dataReliable");
                        return;
                        // this._dataReliable = reliable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "audioSampleAccess", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get audioSampleAccess");
                        return false;
                        // return this._audioSampleAccess;
                    },
                    set: function (reliable) {
                        reliable = !!reliable;
                        release || notImplemented("public flash.net.NetStream::set audioSampleAccess");
                        return;
                        // this._audioSampleAccess = reliable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "videoSampleAccess", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get videoSampleAccess");
                        return false;
                        // return this._videoSampleAccess;
                    },
                    set: function (reliable) {
                        reliable = !!reliable;
                        release || notImplemented("public flash.net.NetStream::set videoSampleAccess");
                        return;
                        // this._videoSampleAccess = reliable;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetStream.prototype.appendBytes = function (bytes) {
                    var chunk = new Uint8Array(bytes._buffer, 0, bytes.length);
                    // We need to pass cloned data, since the bytes can be reused and
                    // VideoStream.appendBytes can hold data for some time.
                    this._videoStream.appendBytes(chunk);
                };
                NetStream.prototype.appendBytesAction = function (netStreamAppendBytesAction) {
                    this._videoStream.appendBytesAction(netStreamAppendBytesAction);
                };
                Object.defineProperty(NetStream.prototype, "useHardwareDecoder", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get useHardwareDecoder");
                        return false;
                        // return this._useHardwareDecoder;
                    },
                    set: function (v) {
                        v = !!v;
                        release || notImplemented("public flash.net.NetStream::set useHardwareDecoder");
                        return;
                        // this._useHardwareDecoder = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "useJitterBuffer", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get useJitterBuffer");
                        return false;
                        // return this._useJitterBuffer;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.net.NetStream::set useJitterBuffer");
                        return;
                        // this._useJitterBuffer = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NetStream.prototype, "videoStreamSettings", {
                    get: function () {
                        release || notImplemented("public flash.net.NetStream::get videoStreamSettings");
                        return null;
                        // return this._videoStreamSettings;
                    },
                    set: function (settings) {
                        settings = settings;
                        release || notImplemented("public flash.net.NetStream::set videoStreamSettings");
                        return;
                        // this._videoStreamSettings = settings;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetStream.prototype.invoke = function (index /*uint*/) {
                    index = index >>> 0;
                    return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                };
                NetStream.prototype.invokeWithArgsArray = function (index /*uint*/, p_arguments) {
                    index = index >>> 0;
                    p_arguments = p_arguments;
                    return this._invoke.call(this, index, p_arguments);
                };
                Object.defineProperty(NetStream.prototype, "inBufferSeek", {
                    get: function () {
                        return this._inBufferSeek;
                    },
                    set: function (value) {
                        this._inBufferSeek = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                NetStream.prototype._invoke = function (index, args) {
                    var simulated = false, result;
                    switch (index) {
                        case 4:// set bufferTime
                            this._videoStream.bufferTime = args[0];
                            simulated = true;
                            break;
                        case 202:// call, e.g. ('pause', null, paused, time)
                            switch (args[1]) {
                                case 'pause':
                                    simulated = true;
                                    this._notifyVideoControl(2 /* Pause */, {
                                        paused: !!args[3],
                                        time: args[4] / 1000
                                    });
                                    break;
                                case 'seek':
                                    simulated = true;
                                    this._notifyVideoControl(3 /* Seek */, {
                                        time: args[3] / 1000
                                    });
                                    break;
                            }
                            break;
                        case 300:// time
                            result = this._notifyVideoControl(4 /* GetTime */, null);
                            simulated = true;
                            break;
                        case 302:// get bufferTime
                            result = this._videoStream.bufferTime;
                            simulated = true;
                            break;
                        case 303:// get bufferLength
                            result = this._notifyVideoControl(5 /* GetBufferLength */, null);
                            simulated = true;
                            break;
                        case 305:// get bytesLoaded
                            result = this._notifyVideoControl(7 /* GetBytesLoaded */, null);
                            simulated = true;
                            break;
                        case 306:// get bytesTotal
                            result = this._notifyVideoControl(8 /* GetBytesTotal */, null);
                            simulated = true;
                            break;
                    }
                    // (index:uint) -> any
                    (simulated ? somewhatImplemented : notImplemented)("NetStream._invoke (" + index + ")");
                    return result;
                };
                NetStream.prototype._notifyVideoControl = function (eventType, data) {
                    var service = this._sec.player;
                    return service.notifyVideoControl(this._id, eventType, data);
                };
                NetStream.prototype.processVideoEvent = function (eventType, data) {
                    this._videoStream.processVideoPlaybackEvent(eventType, data);
                    var netStatusEventCtor = this._sec.events.NetStatusEvent;
                    switch (eventType) {
                        case 0 /* Initialized */:
                            flash.media.SoundMixer._updateSoundSource(this);
                            break;
                        case 2 /* PlayStart */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Play.Start", level: "status" }]));
                            break;
                        case 3 /* PlayStop */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Buffer.Flush", level: "status" }]));
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Play.Stop", level: "status" }]));
                            flash.media.SoundMixer._unregisterSoundSource(this);
                            break;
                        case 5 /* BufferFull */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Buffer.Full", level: "status" }]));
                            break;
                        case 4 /* BufferEmpty */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Buffer.Empty", level: "status" }]));
                            break;
                        case 11 /* Error */:
                            var code = data.code === 4 ? "NetStream.Play.NoSupportedTrackFound" :
                                data.code === 3 ? "NetStream.Play.FileStructureInvalid" : "NetStream.Play.StreamNotFound";
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: code, level: "error" }]));
                            break;
                        case 6 /* Pause */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Pause.Notify", level: "status" }]));
                            break;
                        case 7 /* Unpause */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, {
                                    code: "NetStream.Unpause.Notify",
                                    level: "status"
                                }]));
                            break;
                        case 8 /* Seeking */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Seek.Notify", level: "status" }]));
                            break;
                        case 9 /* Seeked */:
                            this.dispatchEvent(netStatusEventCtor.create([events.NetStatusEvent.NET_STATUS,
                                false, false, { code: "NetStream.Seek.Complete", level: "status" }]));
                            break;
                        case 1 /* Metadata */:
                            if (this._client) {
                                var metadata = {
                                    width: data.videoWidth,
                                    height: data.videoHeight,
                                    duration: data.duration
                                };
                                this._client.axCallPublicProperty('onMetaData', [metadata]);
                            }
                            break;
                    }
                };
                NetStream.prototype.stopSound = function () {
                    this.pause();
                };
                NetStream.prototype.updateSoundLevels = function (volume) {
                    this._notifyVideoControl(6 /* SetSoundLevels */, {
                        volume: volume
                    });
                };
                // JS -> AS Bindings
                NetStream.DIRECT_CONNECTIONS = "directConnections";
                NetStream.CONNECT_TO_FMS = "connectToFMS";
                return NetStream;
            }(flash.events.EventDispatcher));
            net_1.NetStream = NetStream;
            var FLV_MIME_TYPE = 'video/x-flv';
            var MP4_MIME_TYPE = 'video/mp4';
            var MP3_MIME_TYPE = 'audio/mpeg';
            function buildMimeType(baseType, codecs) {
                var mimeType = baseType;
                if (codecs) {
                    mimeType += ';codecs=\"' + codecs.join(',') + '\"';
                }
                return mimeType;
            }
            var VideoStreamState;
            (function (VideoStreamState) {
                VideoStreamState[VideoStreamState["CLOSED"] = 0] = "CLOSED";
                VideoStreamState[VideoStreamState["OPENED"] = 1] = "OPENED";
                VideoStreamState[VideoStreamState["ENDED"] = 2] = "ENDED";
                VideoStreamState[VideoStreamState["OPENED_DATA_GENERATION"] = 3] = "OPENED_DATA_GENERATION";
                VideoStreamState[VideoStreamState["ERROR"] = 4] = "ERROR";
            })(VideoStreamState || (VideoStreamState = {}));
            /**
             * Helper class that encapsulates VIDEO/MediaSource operations and
             * buffers data before passing to the MSE.
             */
            var VideoStream = /** @class */ (function () {
                function VideoStream(netStream) {
                    this.sec = netStream._sec;
                    this._domReady = new Shumway.PromiseWrapper();
                    this._metadataReady = new Shumway.PromiseWrapper();
                    this._started = false;
                    this._buffer = 'empty';
                    this._bufferTime = 0.1;
                    this._url = null;
                    this._mediaSource = null;
                    this._mediaSourceBuffer = null;
                    this._mediaSourceBufferLock = null;
                    this._contentTypeHint = null;
                    this._state = VideoStreamState.CLOSED;
                    this._head = null;
                    this._netStream = netStream;
                }
                Object.defineProperty(VideoStream.prototype, "state", {
                    get: function () {
                        return this._state;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VideoStream.prototype, "bufferTime", {
                    get: function () {
                        return this._bufferTime;
                    },
                    set: function (value) {
                        this._bufferTime = +value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VideoStream.prototype, "url", {
                    get: function () {
                        return this._url;
                    },
                    enumerable: true,
                    configurable: true
                });
                VideoStream.prototype.play = function (url, checkPolicyFile) {
                    var _this = this;
                    release || assert(this._state === VideoStreamState.CLOSED);
                    var isMediaSourceEnabled = Shumway.mediaSourceOption.value;
                    if (isMediaSourceEnabled && typeof MediaSource === 'undefined') {
                        Shumway.Debug.warning('MediaSource API is not enabled, falling back to regular playback');
                        isMediaSourceEnabled = false;
                    }
                    var forceMediaSource = false;
                    if (/\.flv($|\?)/i.test(url)) {
                        if (Shumway.flvOption.value === 'supported') {
                            forceMediaSource = true;
                        }
                        else if (Shumway.flvOption.value === 'mock') {
                            url = 'resource://shumway/web/noflv.mp4';
                        }
                        else {
                            setTimeout(function () {
                                _this._netStream.dispatchEvent(_this.sec.events.NetStatusEvent.create([events.NetStatusEvent.NET_STATUS,
                                    false, false, {
                                        code: "NetStream.Play.NoSupportedTrackFound",
                                        level: "error"
                                    }]));
                            });
                            return;
                        }
                    }
                    if (!forceMediaSource && !isMediaSourceEnabled) {
                        release || somewhatImplemented("public flash.net.NetStream::play");
                        this._state = VideoStreamState.OPENED;
                        this._url = FileLoadingService.instance.resolveUrl(url);
                        return;
                    }
                    this.openInDataGenerationMode();
                    var request = this.sec.net.URLRequest.create([url]);
                    request._checkPolicyFile = checkPolicyFile;
                    var stream = this.sec.net.URLStream.create();
                    stream.addEventListener('httpStatus', function (e) {
                        var responseHeaders = e.axGetPublicProperty('responseHeaders');
                        var contentTypeHeader = responseHeaders.filter(function (h) {
                            return h.axGetPublicProperty('name') === 'Content-Type';
                        })[0];
                        if (contentTypeHeader) {
                            var hint = contentTypeHeader.axGetPublicProperty('value');
                            if (hint !== 'application/octet-stream') {
                                // this._contentTypeHint = hint;
                            }
                        }
                    }.bind(this));
                    stream.addEventListener('progress', function (e) {
                        var available = stream.bytesAvailable;
                        var bytes = request._sec.utils.ByteArray.create();
                        stream.readBytes(bytes, 0, available);
                        var chunk = new Uint8Array(bytes._buffer, 0, bytes.length);
                        this.appendBytes(chunk);
                    }.bind(this));
                    stream.addEventListener('complete', function (e) {
                        this.appendBytesAction('endSequence'); // NetStreamAppendBytesAction.END_SEQUENCE
                    }.bind(this));
                    stream.load(request);
                };
                VideoStream.prototype.playInConnection = function (connection, streamPath) {
                    this.openInDataGenerationMode();
                    var self = this;
                    var mux;
                    var mp4 = {
                        packets: 0,
                        init: function (metadata) {
                            if (!metadata.axGetPublicProperty('audiocodecid') && !metadata.axGetPublicProperty('videocodecid')) {
                                return; // useless metadata?
                            }
                            var parsedMetadata = RtmpJs.MP4.parseFLVMetadata(metadata);
                            mux = new RtmpJs.MP4.MP4Mux(parsedMetadata);
                            mux.oncodecinfo = function (mediaCodecs) {
                                this._contentTypeHint = buildMimeType(MP4_MIME_TYPE, mediaCodecs);
                            };
                            mux.ondata = function (data) {
                                self.appendBytes(new Uint8Array(data));
                            }.bind(this);
                        },
                        packet: function (type, data, timestamp) {
                            mux.pushPacket(type, new Uint8Array(data), timestamp);
                        },
                        generate: function () {
                            mux.flush();
                        }
                    };
                    connection._createRtmpStream(function (ns, streamId) {
                        ns.ondata = function (message) {
                            console.log('#packet (' + message.typeId + '): @' + message.timestamp);
                            if (message.data.length > 0) {
                                mp4.packet(message.typeId, message.data, message.timestamp);
                            }
                        };
                        ns.oncallback = function () {
                            console.log('#callback');
                        };
                        ns.onscriptdata = function (type, data) {
                            console.log('#object: ' + type);
                            if (type === 'onMetaData') {
                                mp4.init(data);
                            }
                        };
                        ns.play(streamPath);
                    });
                };
                VideoStream.prototype.openInDataGenerationMode = function () {
                    release || assert(this._state === VideoStreamState.CLOSED);
                    this._state = VideoStreamState.OPENED_DATA_GENERATION;
                    var mediaSource = new MediaSource();
                    mediaSource.addEventListener('sourceopen', function (e) {
                        this._ensurePlaying();
                    }.bind(this));
                    mediaSource.addEventListener('sourceend', function (e) {
                        this._mediaSource = null;
                    }.bind(this));
                    this._mediaSource = mediaSource;
                    this._url = URL.createObjectURL(mediaSource);
                };
                VideoStream.prototype.appendBytes = function (bytes) {
                    release || assert(this._state === VideoStreamState.OPENED_DATA_GENERATION ||
                        this._state === VideoStreamState.OPENED);
                    release || assert(this._mediaSource);
                    if (this._decoder) {
                        this._decoder.push(bytes);
                        return;
                    }
                    // First we need to parse some content to find out mime type and codecs
                    // for MediaSource. Caching some data at the beginning until we can tell
                    // the type of the content.
                    var cached;
                    var buffer;
                    if (this._head !== null) {
                        cached = this._head.length;
                        buffer = new Uint8Array(cached + bytes.length);
                        buffer.set(bytes, cached);
                    }
                    else {
                        cached = 0;
                        buffer = bytes;
                    }
                    if (!this._decoder) {
                        // Trying to create a data decoder.
                        var contentType = this._detectContentType(buffer);
                        if (contentType === FLV_MIME_TYPE) {
                            // FLV data needs to be parsed and wrapped with MP4 tags.
                            var flvDecoder = new FlvMp4Decoder(this.sec);
                            flvDecoder.onHeader = function (contentType) {
                                this._mediaSourceBuffer = this._mediaSource.addSourceBuffer(contentType);
                                this._mediaSourceBufferLock = Promise.resolve(undefined);
                            }.bind(this);
                            flvDecoder.onData = this._queueData.bind(this);
                            this._decoder = flvDecoder;
                        }
                        else if (contentType) {
                            // Let's use identity decoder for reset of the types.
                            this._decoder = {
                                onData: this._queueData.bind(this),
                                onError: function (e) {
                                },
                                push: function (bytes) {
                                    this.onData(bytes);
                                },
                                close: function () {
                                }
                            };
                            this._mediaSourceBuffer = this._mediaSource.addSourceBuffer(contentType);
                            this._mediaSourceBufferLock = Promise.resolve(undefined);
                        }
                    }
                    if (this._decoder) {
                        // The decoder exists, doing first data push, see also above.
                        this._decoder.push(buffer);
                        if (cached > 0) {
                            this._head = null;
                        }
                    }
                    else {
                        // Caching header more header data.
                        if (cached === 0) {
                            this._head = new Uint8Array(bytes);
                        }
                        else {
                            this._head = buffer;
                        }
                    }
                };
                VideoStream.prototype._queueData = function (bytes) {
                    // We need to chain all appendBuffer operations using 'update' event.
                    var buffer = this._mediaSourceBuffer;
                    this._mediaSourceBufferLock = this._mediaSourceBufferLock.then(function () {
                        buffer.appendBuffer(bytes);
                        return new Promise(function (resolve) {
                            buffer.addEventListener('update', function updateHandler() {
                                buffer.removeEventListener('update', updateHandler);
                                resolve();
                            });
                        });
                    });
                };
                VideoStream.prototype.appendBytesAction = function (netStreamAppendBytesAction) {
                    release || assert(this._state === VideoStreamState.OPENED_DATA_GENERATION ||
                        this._state === VideoStreamState.OPENED);
                    // TODO Ignoring reset actions for now.
                    if (netStreamAppendBytesAction === 'endSequence') {
                        if (!this._decoder) {
                            // REDUX: throw a proper internal error. Or something.
                            throw new Error('Internal appendBytes error');
                        }
                        this._decoder.close();
                        this._mediaSourceBufferLock.then(function () {
                            if (this._mediaSource) {
                                this._mediaSource.endOfStream();
                            }
                            this.close();
                        }.bind(this));
                    }
                    release || somewhatImplemented("public flash.net.NetStream::appendBytesAction");
                };
                VideoStream.prototype.close = function () {
                    this._state = VideoStreamState.CLOSED;
                };
                VideoStream.prototype._ensurePlaying = function () {
                    if (!this._onEnsurePlay) {
                        return;
                    }
                    this._onEnsurePlay();
                };
                VideoStream.prototype._detectContentType = function (bytes) {
                    if (bytes.length < 16) {
                        return null; // Need more bytes.
                    }
                    if (bytes[0] === 0x46 /* F */ &&
                        bytes[1] === 0x4C /* L */ &&
                        bytes[2] === 0x56 /* V */ &&
                        bytes[3] === 1 /* version 1 */) {
                        // Likely FLV.
                        return FLV_MIME_TYPE;
                    }
                    if (bytes[4] === 0x66 /* f */ &&
                        bytes[5] === 0x74 /* t */ &&
                        bytes[6] === 0x79 /* y */ &&
                        bytes[7] === 0x70 /* p */) {
                        if (this._contentTypeHint &&
                            /^video\/mp4;\s*codecs=/.test(this._contentTypeHint)) {
                            return this._contentTypeHint;
                        }
                        // TODO check bytes for content type
                        return 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
                    }
                    if ((bytes[0] === 0x49 /* I */ &&
                        bytes[1] === 0x44 /* D */ &&
                        bytes[2] === 0x33 /* 3 */) ||
                        (bytes[0] === 0xFF &&
                            (bytes[1] & 0xE0) === 0xE0 &&
                            (bytes[1] & 0x1E) !== 0x08)) {
                        // Maybe MP3.
                        return MP3_MIME_TYPE;
                    }
                    // Just a wild (and wrong) guess
                    return this._contentTypeHint || MP4_MIME_TYPE;
                };
                VideoStream.prototype.processVideoPlaybackEvent = function (eventType, data) {
                    switch (eventType) {
                        case 0 /* Initialized */:
                            this._domReady.resolve(undefined);
                            break;
                        case 2 /* PlayStart */:
                            if (this._started) {
                                break;
                            }
                            this._started = true;
                            break;
                        case 3 /* PlayStop */:
                            this._started = false;
                            break;
                        case 5 /* BufferFull */:
                            this._buffer = 'full';
                            break;
                        case 10 /* Progress */:
                            this._buffer = 'progress';
                            break;
                        case 4 /* BufferEmpty */:
                            this._buffer = 'empty';
                            break;
                        case 1 /* Metadata */:
                            this._metadataReady.resolve({
                                videoWidth: data.videoWidth,
                                videoHeight: data.videoHeight
                            });
                            break;
                    }
                };
                return VideoStream;
            }());
            // FLV-to-MP4 data transformation.
            var FlvMp4Decoder = /** @class */ (function () {
                function FlvMp4Decoder(sec) {
                    this.sec = sec;
                    this._flvParser = new RtmpJs.FLV.FLVParser();
                    this._flvParser.onHeader = this._onFlvHeader.bind(this);
                    this._flvParser.onTag = this._onFlvTag.bind(this);
                    this._flvParser.onClose = this._onFlvClose.bind(this);
                    this._flvParser.onError = this._onFlvError.bind(this);
                    this._mp4Mux = null;
                }
                FlvMp4Decoder.prototype._onFlvHeader = function (header) {
                    //
                };
                FlvMp4Decoder.prototype._onFlvTag = function (tag) {
                    if (tag.type === 18) {
                        var ba = this.sec.utils.ByteArray.create();
                        ba.writeRawBytes(tag.data);
                        ba.position = 0;
                        // @ivanpopelyshev don't know what to do with this dependency
                        var name_6 = AMF0.read(ba);
                        var value = AMF0.read(ba);
                        if (name_6 === 'onMetaData') {
                            var metadata = RtmpJs.MP4.parseFLVMetadata(value);
                            var mp4Mux = new RtmpJs.MP4.MP4Mux(metadata);
                            mp4Mux.oncodecinfo = function (codecs) {
                                this.onHeader(buildMimeType(MP4_MIME_TYPE, codecs));
                            }.bind(this);
                            mp4Mux.ondata = function (data) {
                                this.onData.call(null, data);
                            }.bind(this);
                            this._mp4Mux = mp4Mux;
                        }
                        return;
                    }
                    this._mp4Mux.pushPacket(tag.type, new Uint8Array(tag.data), tag.timestamp);
                };
                FlvMp4Decoder.prototype._onFlvClose = function () {
                    this._mp4Mux.flush();
                };
                FlvMp4Decoder.prototype._onFlvError = function (e) {
                    if (this.onError) {
                        this.onError(e);
                    }
                };
                FlvMp4Decoder.prototype.push = function (bytes) {
                    try {
                        this._flvParser.push(bytes);
                    }
                    catch (e) {
                        if (this.onError) {
                            this.onError(e);
                        }
                    }
                };
                FlvMp4Decoder.prototype.close = function () {
                    try {
                        this._flvParser.close();
                    }
                    catch (e) {
                        if (this.onError) {
                            this.onError(e);
                        }
                    }
                };
                return FlvMp4Decoder;
            }());
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetStreamInfo
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var NetStreamInfo = /** @class */ (function (_super) {
                __extends(NetStreamInfo, _super);
                function NetStreamInfo(curBPS, byteCount, maxBPS, audioBPS, audioByteCount, videoBPS, videoByteCount, dataBPS, dataByteCount, playbackBPS, droppedFrames, audioBufferByteLength, videoBufferByteLength, dataBufferByteLength, audioBufferLength, videoBufferLength, dataBufferLength, srtt, audioLossRate, videoLossRate, metaData, xmpData, uri, resourceName, isLive) {
                    if (metaData === void 0) { metaData = null; }
                    if (xmpData === void 0) { xmpData = null; }
                    if (uri === void 0) { uri = null; }
                    if (resourceName === void 0) { resourceName = null; }
                    if (isLive === void 0) { isLive = true; }
                    var _this = _super.call(this) || this;
                    _this.currentBytesPerSecond = +curBPS;
                    _this.byteCount = +byteCount;
                    _this.maxBytesPerSecond = +maxBPS;
                    _this.audioBytesPerSecond = +audioBPS;
                    _this.audioByteCount = +audioByteCount;
                    _this.videoBytesPerSecond = +videoBPS;
                    _this.videoByteCount = +videoByteCount;
                    _this.dataBytesPerSecond = +dataBPS;
                    _this.dataByteCount = +dataByteCount;
                    _this.playbackBytesPerSecond = +playbackBPS;
                    _this.droppedFrames = +droppedFrames;
                    _this.audioBufferByteLength = +audioBufferByteLength;
                    _this.videoBufferByteLength = +videoBufferByteLength;
                    _this.dataBufferByteLength = +dataBufferByteLength;
                    _this.audioBufferLength = +audioBufferLength;
                    _this.videoBufferLength = +videoBufferLength;
                    _this.dataBufferLength = +dataBufferLength;
                    _this._srtt = +srtt;
                    _this.audioLossRate = +audioLossRate;
                    _this.videoLossRate = +videoLossRate;
                    _this.metaData = metaData;
                    _this.xmpData = xmpData;
                    _this.uri = uri;
                    _this.resourceName = resourceName;
                    _this.isLive = !!isLive;
                    return _this;
                }
                return NetStreamInfo;
            }(flash.LegacyEntity));
            net.NetStreamInfo = NetStreamInfo;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetStreamMulticastInfo
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var NetStreamMulticastInfo = /** @class */ (function (_super) {
                __extends(NetStreamMulticastInfo, _super);
                function NetStreamMulticastInfo(sendDataBytesPerSecond, sendControlBytesPerSecond, receiveDataBytesPerSecond, receiveControlBytesPerSecond, bytesPushedToPeers, fragmentsPushedToPeers, bytesRequestedByPeers, fragmentsRequestedByPeers, bytesPushedFromPeers, fragmentsPushedFromPeers, bytesRequestedFromPeers, fragmentsRequestedFromPeers, sendControlBytesPerSecondToServer, receiveDataBytesPerSecondFromServer, bytesReceivedFromServer, fragmentsReceivedFromServer, receiveDataBytesPerSecondFromIPMulticast, bytesReceivedFromIPMulticast, fragmentsReceivedFromIPMulticast) {
                    var _this = _super.call(this) || this;
                    _this.sendDataBytesPerSecond = +sendDataBytesPerSecond;
                    _this.sendControlBytesPerSecond = +sendControlBytesPerSecond;
                    _this.receiveDataBytesPerSecond = +receiveDataBytesPerSecond;
                    _this.receiveControlBytesPerSecond = +receiveControlBytesPerSecond;
                    _this.bytesPushedToPeers = +bytesPushedToPeers;
                    _this.fragmentsPushedToPeers = +fragmentsPushedToPeers;
                    _this.bytesRequestedByPeers = +bytesRequestedByPeers;
                    _this.fragmentsRequestedByPeers = +fragmentsRequestedByPeers;
                    _this.bytesPushedFromPeers = +bytesPushedFromPeers;
                    _this.fragmentsPushedFromPeers = +fragmentsPushedFromPeers;
                    _this.bytesRequestedFromPeers = +bytesRequestedFromPeers;
                    _this.fragmentsRequestedFromPeers = +fragmentsRequestedFromPeers;
                    _this.sendControlBytesPerSecondToServer = +sendControlBytesPerSecondToServer;
                    _this.receiveDataBytesPerSecondFromServer = +receiveDataBytesPerSecondFromServer;
                    _this.bytesReceivedFromServer = +bytesReceivedFromServer;
                    _this.fragmentsReceivedFromServer = +fragmentsReceivedFromServer;
                    _this.receiveDataBytesPerSecondFromIPMulticast = +receiveDataBytesPerSecondFromIPMulticast;
                    _this.bytesReceivedFromIPMulticast = +bytesReceivedFromIPMulticast;
                    _this.fragmentsReceivedFromIPMulticast = +fragmentsReceivedFromIPMulticast;
                    return _this;
                }
                return NetStreamMulticastInfo;
            }(flash.LegacyEntity));
            net.NetStreamMulticastInfo = NetStreamMulticastInfo;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: NetStreamPlayOptions
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var NetStreamPlayOptions = /** @class */ (function (_super) {
                __extends(NetStreamPlayOptions, _super);
                function NetStreamPlayOptions() {
                    return _super.call(this, undefined) || this;
                }
                // Called whenever the class is initialized.
                NetStreamPlayOptions.classInitializer = null;
                // List of static symbols to link.
                NetStreamPlayOptions.classSymbols = null; // [];
                // List of instance symbols to link.
                NetStreamPlayOptions.instanceSymbols = null; // ["streamName", "oldStreamName", "start", "len", "offset", "transition"];
                return NetStreamPlayOptions;
            }(flash.events.EventDispatcher));
            net.NetStreamPlayOptions = NetStreamPlayOptions;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Responder
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var Responder = /** @class */ (function (_super) {
                __extends(Responder, _super);
                function Responder(result, status) {
                    if (status === void 0) { status = null; }
                    return _super.call(this) || this;
                }
                // JS -> AS Bindings
                // AS -> JS Bindings
                Responder.prototype.ctor = function (result, status) {
                    this._result = result;
                    this._status = status;
                };
                return Responder;
            }(flash.LegacyEntity));
            net.Responder = Responder;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SharedObject
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var _sharedObjectStorage;
            function getSharedObjectStorage() {
                if (!_sharedObjectStorage) {
                    if (typeof ShumwayCom !== 'undefined' && ShumwayCom.createSpecialStorage) {
                        _sharedObjectStorage = ShumwayCom.createSpecialStorage();
                    }
                    else {
                        _sharedObjectStorage = window.sessionStorage;
                    }
                }
                release || assert(_sharedObjectStorage, "SharedObjectStorage is not available.");
                return _sharedObjectStorage;
            }
            var SharedObject = /** @class */ (function (_super) {
                __extends(SharedObject, _super);
                function SharedObject() {
                    var _this = _super.call(this) || this;
                    _this._data = {};
                    return _this;
                }
                SharedObject.deleteAll = function (url) {
                    release || notImplemented("public flash.net.SharedObject::static deleteAll");
                    return 0;
                };
                SharedObject.getDiskUsage = function (url) {
                    release || somewhatImplemented("public flash.net.SharedObject::static getDiskUsage");
                    return 0;
                };
                SharedObject._create = function (path, data, encoding) {
                    var obj = flash.system.currentDomain().net.SharedObject.create();
                    obj._path = path;
                    obj._data = data;
                    obj._objectEncoding = encoding;
                    Shumway.Telemetry.instance.reportTelemetry({ topic: 'feature', feature: 3 /* SHAREDOBJECT_FEATURE */ });
                    return obj;
                };
                SharedObject.getLocal = function (name, localPath, secure) {
                    if (localPath === void 0) { localPath = null; }
                    if (secure === void 0) { secure = false; }
                    secure = !!secure;
                    var path = (localPath || '') + '/' + name;
                    if (this._sharedObjects[path]) {
                        return this._sharedObjects[path];
                    }
                    var encodedData = getSharedObjectStorage().getItem(path);
                    var data;
                    var encoding = this._defaultObjectEncoding;
                    if (encodedData) {
                        try {
                            var bytes = Shumway.StringUtilities.decodeRestrictedBase64ToBytes(encodedData);
                            var serializedData = flash.system.currentDomain().utils.ByteArray.create(bytes);
                            data = serializedData.readObject();
                            encoding = serializedData.objectEncoding;
                        }
                        catch (e) {
                            Shumway.Debug.warning('Error encountered while decoding LocalStorage entry. Resetting data.');
                        }
                        if (!data || typeof data !== 'object') {
                            data = {};
                        }
                    }
                    else {
                        data = {};
                    }
                    var so = this._create(path, data, encoding);
                    so._objectEncoding = encoding;
                    this._sharedObjects[path] = so;
                    return so;
                };
                SharedObject.getRemote = function (name, remotePath, persistence, secure) {
                    if (remotePath === void 0) { remotePath = null; }
                    if (persistence === void 0) { persistence = false; }
                    if (secure === void 0) { secure = false; }
                    secure = !!secure;
                    release || notImplemented("public flash.net.SharedObject::static getRemote");
                    return null;
                };
                Object.defineProperty(SharedObject, "defaultObjectEncoding", {
                    get: function () {
                        return this._defaultObjectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        this._defaultObjectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SharedObject.prototype, "data", {
                    // _client: ASObject;
                    get: function () {
                        // Make sure that any changes made to the object get stored.
                        // This isn't how Flash does it, and not as efficient as it could be, but it'll
                        // do for now.
                        this.queueFlush();
                        return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SharedObject.prototype, "objectEncoding", {
                    get: function () {
                        return this._objectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        this._objectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SharedObject.prototype, "client", {
                    get: function () {
                        release || notImplemented("public flash.net.SharedObject::get client");
                        return null;
                        // return this._client;
                    },
                    set: function (object) {
                        object = object;
                        release || notImplemented("public flash.net.SharedObject::set client");
                        return;
                        // this._client = object;
                    },
                    enumerable: true,
                    configurable: true
                });
                SharedObject.prototype.setDirty = function (propertyName) {
                    // propertyName = axCoerceString(propertyName);
                    this.queueFlush();
                };
                SharedObject.prototype.connect = function (myConnection, params) {
                    if (params === void 0) { params = null; }
                    release || notImplemented("public flash.net.SharedObject::connect");
                };
                SharedObject.prototype.send = function () {
                    release || notImplemented("public flash.net.SharedObject::send");
                };
                SharedObject.prototype.close = function () {
                    release || somewhatImplemented("public flash.net.SharedObject::close");
                };
                SharedObject.prototype.flush = function (minDiskSpace) {
                    minDiskSpace = minDiskSpace | 0;
                    release || somewhatImplemented("public flash.net.SharedObject::flush");
                    if (!this._pendingFlushId) {
                        return 'flushed';
                    }
                    clearTimeout(this._pendingFlushId);
                    this._pendingFlushId = 0;
                    // Check if the object is empty. If it is, don't create a stored object if one doesn't exist.
                    var isEmpty = true;
                    for (var key in this._data) {
                        if (this._data.hasOwnProperty(key)) {
                            isEmpty = false;
                            break;
                        }
                    }
                    if (isEmpty && !getSharedObjectStorage().getItem(this._path)) {
                        return "";
                    }
                    var serializedData = this._sec.utils.ByteArray.create();
                    serializedData.objectEncoding = this._objectEncoding;
                    serializedData.writeObject(this._data);
                    var bytes = serializedData.getBytes();
                    var encodedData = Shumway.StringUtilities.base64EncodeBytes(bytes);
                    if (!release) {
                        var decoded = Shumway.StringUtilities.decodeRestrictedBase64ToBytes(encodedData);
                        Shumway.Debug.assert(decoded.byteLength === bytes.byteLength);
                        for (var i = 0; i < decoded.byteLength; i++) {
                            Shumway.Debug.assert(decoded[i] === bytes[i]);
                        }
                    }
                    getSharedObjectStorage().setItem(this._path, encodedData);
                    return 'flushed';
                };
                SharedObject.prototype.clear = function () {
                    release || somewhatImplemented("public flash.net.SharedObject::clear");
                    this._data = {};
                    getSharedObjectStorage().removeItem(this._path);
                };
                Object.defineProperty(SharedObject.prototype, "size", {
                    get: function () {
                        release || somewhatImplemented("public flash.net.SharedObject::get size");
                        this.flush(0);
                        var storedData = getSharedObjectStorage().getItem(this._path);
                        return storedData ? storedData.length : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SharedObject.prototype, "fps", {
                    set: function (updatesPerSecond) {
                        release || somewhatImplemented("fps");
                        this._fps = updatesPerSecond;
                    },
                    enumerable: true,
                    configurable: true
                });
                SharedObject.prototype.setProperty = function (propertyName, value) {
                    if (value === void 0) { value = null; }
                    propertyName = '' + propertyName;
                    if (value === this._data[propertyName]) {
                        return;
                    }
                    this._data[propertyName] = value;
                    this.queueFlush();
                };
                SharedObject.prototype.queueFlush = function () {
                    if (this._pendingFlushId) {
                        clearTimeout(this._pendingFlushId);
                    }
                    this._pendingFlushId = setTimeout(this.flush.bind(this), 100);
                };
                // Called whenever the class is initialized.
                SharedObject.classInitializer = null;
                SharedObject._sharedObjects = Object.create(null);
                SharedObject._defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;
                return SharedObject;
            }(flash.events.EventDispatcher));
            net.SharedObject = SharedObject;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Socket
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Socket = /** @class */ (function (_super) {
                __extends(Socket, _super);
                function Socket(host, port) {
                    if (host === void 0) { host = null; }
                    if (port === void 0) { port = 0; }
                    var _this = _super.call(this, undefined) || this;
                    host = host;
                    port = port | 0;
                    return _this;
                }
                Object.defineProperty(Socket.prototype, "bytesAvailable", {
                    // AS -> JS Bindings
                    // _timeout: number /*uint*/;
                    // _bytesAvailable: number /*uint*/;
                    // _connected: boolean;
                    // _objectEncoding: number /*uint*/;
                    // _endian: string;
                    // _bytesPending: number /*uint*/;
                    get: function () {
                        release || notImplemented("public flash.net.Socket::get bytesAvailable");
                        return 0;
                        // return this._bytesAvailable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Socket.prototype, "connected", {
                    get: function () {
                        release || notImplemented("public flash.net.Socket::get connected");
                        return false;
                        // return this._connected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Socket.prototype, "objectEncoding", {
                    get: function () {
                        release || notImplemented("public flash.net.Socket::get objectEncoding");
                        return 0;
                        // return this._objectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        release || notImplemented("public flash.net.Socket::set objectEncoding");
                        return;
                        // this._objectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Socket.prototype, "endian", {
                    get: function () {
                        release || notImplemented("public flash.net.Socket::get endian");
                        return "";
                        // return this._endian;
                    },
                    set: function (type) {
                        type = type;
                        release || notImplemented("public flash.net.Socket::set endian");
                        return;
                        // this._endian = type;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Socket.prototype, "bytesPending", {
                    get: function () {
                        release || notImplemented("public flash.net.Socket::get bytesPending");
                        return 0;
                        // return this._bytesPending;
                    },
                    enumerable: true,
                    configurable: true
                });
                Socket.prototype.readBytes = function (bytes, offset, length) {
                    if (offset === void 0) { offset = 0; }
                    if (length === void 0) { length = 0; }
                    bytes = bytes;
                    offset = offset >>> 0;
                    length = length >>> 0;
                    release || notImplemented("public flash.net.Socket::readBytes");
                    return;
                };
                Socket.prototype.writeBytes = function (bytes, offset, length) {
                    if (offset === void 0) { offset = 0; }
                    if (length === void 0) { length = 0; }
                    bytes = bytes;
                    offset = offset >>> 0;
                    length = length >>> 0;
                    release || notImplemented("public flash.net.Socket::writeBytes");
                    return;
                };
                Socket.prototype.writeBoolean = function (value) {
                    value = !!value;
                    release || notImplemented("public flash.net.Socket::writeBoolean");
                    return;
                };
                Socket.prototype.writeByte = function (value /*int*/) {
                    value = value | 0;
                    release || notImplemented("public flash.net.Socket::writeByte");
                    return;
                };
                Socket.prototype.writeShort = function (value /*int*/) {
                    value = value | 0;
                    release || notImplemented("public flash.net.Socket::writeShort");
                    return;
                };
                Socket.prototype.writeInt = function (value /*int*/) {
                    value = value | 0;
                    release || notImplemented("public flash.net.Socket::writeInt");
                    return;
                };
                Socket.prototype.writeUnsignedInt = function (value /*uint*/) {
                    value = value >>> 0;
                    release || notImplemented("public flash.net.Socket::writeUnsignedInt");
                    return;
                };
                Socket.prototype.writeFloat = function (value) {
                    value = +value;
                    release || notImplemented("public flash.net.Socket::writeFloat");
                    return;
                };
                Socket.prototype.writeDouble = function (value) {
                    value = +value;
                    release || notImplemented("public flash.net.Socket::writeDouble");
                    return;
                };
                Socket.prototype.writeMultiByte = function (value, charSet) {
                    value = value;
                    charSet = charSet;
                    release || notImplemented("public flash.net.Socket::writeMultiByte");
                    return;
                };
                Socket.prototype.writeUTF = function (value) {
                    value = value;
                    release || notImplemented("public flash.net.Socket::writeUTF");
                    return;
                };
                Socket.prototype.writeUTFBytes = function (value) {
                    value = value;
                    release || notImplemented("public flash.net.Socket::writeUTFBytes");
                    return;
                };
                Socket.prototype.readBoolean = function () {
                    release || notImplemented("public flash.net.Socket::readBoolean");
                    return false;
                };
                Socket.prototype.readByte = function () {
                    release || notImplemented("public flash.net.Socket::readByte");
                    return 0;
                };
                Socket.prototype.readUnsignedByte = function () {
                    release || notImplemented("public flash.net.Socket::readUnsignedByte");
                    return 0;
                };
                Socket.prototype.readShort = function () {
                    release || notImplemented("public flash.net.Socket::readShort");
                    return 0;
                };
                Socket.prototype.readUnsignedShort = function () {
                    release || notImplemented("public flash.net.Socket::readUnsignedShort");
                    return 0;
                };
                Socket.prototype.readInt = function () {
                    release || notImplemented("public flash.net.Socket::readInt");
                    return 0;
                };
                Socket.prototype.readUnsignedInt = function () {
                    release || notImplemented("public flash.net.Socket::readUnsignedInt");
                    return 0;
                };
                Socket.prototype.readFloat = function () {
                    release || notImplemented("public flash.net.Socket::readFloat");
                    return 0;
                };
                Socket.prototype.readDouble = function () {
                    release || notImplemented("public flash.net.Socket::readDouble");
                    return 0;
                };
                Socket.prototype.readMultiByte = function (length /*uint*/, charSet) {
                    length = length >>> 0;
                    charSet = charSet;
                    release || notImplemented("public flash.net.Socket::readMultiByte");
                    return "";
                };
                Socket.prototype.readUTF = function () {
                    release || notImplemented("public flash.net.Socket::readUTF");
                    return "";
                };
                Socket.prototype.readUTFBytes = function (length /*uint*/) {
                    length = length >>> 0;
                    release || notImplemented("public flash.net.Socket::readUTFBytes");
                    return "";
                };
                Socket.prototype.flush = function () {
                    release || notImplemented("public flash.net.Socket::flush");
                    return;
                };
                Socket.prototype.writeObject = function (object) {
                    release || notImplemented("public flash.net.Socket::writeObject");
                    return;
                };
                Socket.prototype.readObject = function () {
                    release || notImplemented("public flash.net.Socket::readObject");
                    return;
                };
                Socket.prototype.internalGetSecurityErrorMessage = function (host, port) {
                    host = host;
                    port |= 0;
                    release || somewhatImplemented("flash.net.Socket::internalGetSecurityErrorMessage");
                    return 'SecurityErrorEvent';
                };
                Socket.prototype.internalConnect = function (host, port) {
                    host = host;
                    port |= 0;
                    release || somewhatImplemented("flash.net.Socket::internalConnect");
                    this._sec.throwError('SecurityError', Shumway.Errors.SocketConnectError, host, port);
                };
                Socket.prototype.didFailureOccur = function () {
                    release || somewhatImplemented("flash.net.Socket::didFailureOccur");
                    return true;
                };
                return Socket;
            }(flash.events.EventDispatcher));
            net.Socket = Socket;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: URLLoader
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var Event = flash.events.Event;
            var IOErrorEvent = flash.events.IOErrorEvent;
            var ProgressEvent = flash.events.ProgressEvent;
            var HTTPStatusEvent = flash.events.HTTPStatusEvent;
            var SecurityErrorEvent = flash.events.SecurityErrorEvent;
            var URLLoader = /** @class */ (function (_super) {
                __extends(URLLoader, _super);
                function URLLoader(request) {
                    var _this = _super.call(this) || this;
                    var stream = _this._stream = _this._sec.net.URLStream.create();
                    stream.addEventListener(Event.OPEN, _this.onStreamOpen.bind(_this));
                    stream.addEventListener(Event.COMPLETE, _this.onStreamComplete.bind(_this));
                    stream.addEventListener(ProgressEvent.PROGRESS, _this.onStreamProgress.bind(_this));
                    stream.addEventListener(IOErrorEvent.IO_ERROR, _this.onStreamIOError.bind(_this));
                    stream.addEventListener(HTTPStatusEvent.HTTP_STATUS, _this.onStreamHTTPStatus.bind(_this));
                    stream.addEventListener(HTTPStatusEvent.HTTP_RESPONSE_STATUS, _this.onStreamHTTPResponseStatus.bind(_this));
                    stream.addEventListener(SecurityErrorEvent.SECURITY_ERROR, _this.onStreamSecurityError.bind(_this));
                    _this._dataFormat = 'text';
                    if (request) {
                        _this.load(request);
                    }
                    return _this;
                }
                Object.defineProperty(URLLoader.prototype, "data", {
                    get: function () {
                        return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLLoader.prototype, "dataFormat", {
                    get: function () {
                        return this._dataFormat;
                    },
                    set: function (format) {
                        release || Shumway.Debug.assert(typeof format === 'string');
                        this._dataFormat = format;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
                    get: function () {
                        return this._bytesLoaded;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLLoader.prototype, "bytesTotal", {
                    get: function () {
                        return this._bytesTotal;
                    },
                    enumerable: true,
                    configurable: true
                });
                URLLoader.prototype.load = function (request) {
                    this._stream.load(request);
                };
                URLLoader.prototype.close = function () {
                    this._stream.close();
                };
                URLLoader.prototype.complete = function () {
                    var response = this._sec.utils.ByteArray.create();
                    this._stream.readBytes(response);
                    if (this._dataFormat === 'binary') {
                        this._data = response;
                        return;
                    }
                    var data = response.toString();
                    if (response.length > 0 && this._dataFormat === 'variables') {
                        var variable = this._sec.net.URLVariables.create();
                        if (this._ignoreDecodeErrors) {
                            variable._ignoreDecodingErrors = true;
                        }
                        variable.decode(String(data));
                        this._data = variable;
                    }
                    else {
                        this._data = data;
                    }
                };
                URLLoader.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                    _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
                    // Looks like there is some bug related to the HTTP_RESPONSE_STATUS
                    if (type === HTTPStatusEvent.HTTP_RESPONSE_STATUS) {
                        this._httpResponseEventBound = true;
                    }
                };
                URLLoader.prototype.onStreamOpen = function (e) {
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamComplete = function (e) {
                    this.complete();
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamProgress = function (e) {
                    this._bytesLoaded = e.bytesLoaded;
                    this._bytesTotal = e.bytesTotal;
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamIOError = function (e) {
                    this.complete();
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamHTTPStatus = function (e) {
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamHTTPResponseStatus = function (e) {
                    if (!this._httpResponseEventBound) {
                        return;
                    }
                    this.dispatchEvent(e);
                };
                URLLoader.prototype.onStreamSecurityError = function (e) {
                    this.dispatchEvent(e);
                };
                return URLLoader;
            }(flash.events.EventDispatcher));
            net.URLLoader = URLLoader;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: URLRequest
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var URLRequest = /** @class */ (function (_super) {
                __extends(URLRequest, _super);
                function URLRequest(url) {
                    if (url === void 0) { url = null; }
                    var _this = _super.call(this) || this;
                    _this._url = url;
                    _this._method = 'GET';
                    _this._data = null;
                    _this._digest = null;
                    _this._contentType = 'application/x-www-form-urlencoded';
                    _this._requestHeaders = [];
                    _this._checkPolicyFile = true;
                    return _this;
                }
                Object.defineProperty(URLRequest.prototype, "url", {
                    get: function () {
                        return this._url;
                    },
                    set: function (value) {
                        this._url = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLRequest.prototype, "data", {
                    get: function () {
                        return this._data;
                    },
                    set: function (value) {
                        this._data = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLRequest.prototype, "method", {
                    get: function () {
                        return this._method;
                    },
                    set: function (value) {
                        if (value !== 'get' && value !== 'GET' &&
                            value !== 'post' && value !== 'POST') {
                            this._sec.throwError('ArgumentError', Shumway.Errors.InvalidArgumentError);
                        }
                        this._method = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLRequest.prototype, "contentType", {
                    get: function () {
                        return this._contentType;
                    },
                    set: function (value) {
                        this._contentType = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLRequest.prototype, "requestHeaders", {
                    get: function () {
                        return this._requestHeaders;
                    },
                    set: function (value) {
                        if (!(value instanceof Array)) {
                            this._sec.throwError('ArgumentError', Shumway.Errors.InvalidArgumentError, "value");
                        }
                        this._requestHeaders = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLRequest.prototype, "digest", {
                    get: function () {
                        return this._digest;
                    },
                    set: function (value) {
                        this._digest = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                URLRequest.prototype._toFileRequest = function () {
                    var obj = {};
                    obj.url = this._url;
                    obj.method = this._method;
                    obj.checkPolicyFile = this._checkPolicyFile;
                    var data = this._data;
                    if (data) {
                        obj.mimeType = this._contentType;
                        if (this._sec.utils.ByteArray.axIsType(data)) {
                            obj.data = new Uint8Array(data._buffer, 0, data.length);
                        }
                        else {
                            var dataStr = data.toString();
                            if (this._method === 'GET') {
                                var i = obj.url.lastIndexOf('?');
                                obj.url = (i < 0 ? obj.url : obj.url.substring(0, i)) + '?' + dataStr;
                            }
                            else {
                                obj.data = dataStr;
                            }
                        }
                    }
                    return obj;
                };
                return URLRequest;
            }(flash.LegacyEntity));
            net.URLRequest = URLRequest;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: URLRequestHeader
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var URLRequestHeader = /** @class */ (function (_super) {
                __extends(URLRequestHeader, _super);
                function URLRequestHeader(name, value) {
                    if (name === void 0) { name = ""; }
                    if (value === void 0) { value = ""; }
                    var _this = _super.call(this) || this;
                    _this.name = name;
                    _this.value = value;
                    return _this;
                }
                return URLRequestHeader;
            }(flash.LegacyEntity));
            net.URLRequestHeader = URLRequestHeader;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../references.ts'/>
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var notImplemented = Shumway.Debug.notImplemented;
            var FileLoadingService = Shumway.FileLoadingService;
            var URLStream = /** @class */ (function (_super) {
                __extends(URLStream, _super);
                function URLStream() {
                    var _this = _super.call(this) || this;
                    _this._buffer = _this._sec.utils.ByteArray.create();
                    _this._writePosition = 0;
                    _this._connected = false;
                    return _this;
                }
                Object.defineProperty(URLStream.prototype, "connected", {
                    // _diskCacheEnabled: boolean;
                    get: function () {
                        return this._connected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "bytesAvailable", {
                    get: function () {
                        return this._buffer.length - this._buffer.position;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "objectEncoding", {
                    get: function () {
                        return this._buffer.objectEncoding;
                    },
                    set: function (version /*uint*/) {
                        version = version >>> 0;
                        this._buffer.objectEncoding = version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "endian", {
                    get: function () {
                        return this._buffer.endian;
                    },
                    set: function (type) {
                        this._buffer.endian = type;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "diskCacheEnabled", {
                    get: function () {
                        release || notImplemented("public flash.net.URLStream::get diskCacheEnabled");
                        return false;
                        // return this._diskCacheEnabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "position", {
                    get: function () {
                        return this._buffer.position;
                    },
                    set: function (offset) {
                        offset = +offset;
                        this._buffer.position = offset;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(URLStream.prototype, "length", {
                    get: function () {
                        return this._buffer.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                URLStream.prototype.load = function (request) {
                    var Event = flash.events.Event;
                    var IOErrorEvent = flash.events.IOErrorEvent;
                    var ProgressEvent = flash.events.ProgressEvent;
                    var HTTPStatusEvent = flash.events.HTTPStatusEvent;
                    var session = FileLoadingService.instance.createSession();
                    var self = this;
                    var initStream = true;
                    var eventsPackage = this._sec.events;
                    session.onprogress = function (data, progressState) {
                        var readPosition = self._buffer.position;
                        self._buffer.position = self._writePosition;
                        self._buffer.writeRawBytes(data);
                        self._writePosition = self._buffer.position;
                        self._buffer.position = readPosition;
                        self.dispatchEvent(eventsPackage.ProgressEvent.create([ProgressEvent.PROGRESS, false, false,
                            progressState.bytesLoaded,
                            progressState.bytesTotal]));
                    };
                    session.onerror = function (error) {
                        self._connected = false;
                        self.dispatchEvent(eventsPackage.IOErrorEvent.create([IOErrorEvent.IO_ERROR, false, false,
                            error]));
                        var isXDomainError = typeof error === 'string' && error.indexOf('XDOMAIN') >= 0;
                        Shumway.Telemetry.instance.reportTelemetry({
                            topic: 'loadResource',
                            resultType: isXDomainError ? 5 /* StreamCrossdomain */ :
                                4 /* StreamDenied */
                        });
                    };
                    session.onopen = function () {
                        self._connected = true;
                        self.dispatchEvent(eventsPackage.Event.create([Event.OPEN, false, false]));
                        Shumway.Telemetry.instance.reportTelemetry({
                            topic: 'loadResource',
                            resultType: 3 /* StreamAllowed */
                        });
                    };
                    session.onhttpstatus = function (location, httpStatus, httpHeaders) {
                        var httpStatusEvent = eventsPackage.HTTPStatusEvent.create([HTTPStatusEvent.HTTP_STATUS, false,
                            false, httpStatus]);
                        var headers = [];
                        httpHeaders.split(/(?:\n|\r?\n)/g).forEach(function (h) {
                            var m = /^([^:]+): (.*)$/.exec(h);
                            if (m) {
                                headers.push(self._sec.net.URLRequestHeader.create([m[1], m[2]]));
                                if (m[1] === 'Location') {
                                    location = m[2];
                                }
                            }
                        });
                        httpStatusEvent.responseHeaders = headers;
                        httpStatusEvent.responseURL = location;
                        self.dispatchEvent(httpStatusEvent);
                    };
                    session.onclose = function () {
                        self._connected = false;
                        self.dispatchEvent(eventsPackage.Event.create([Event.COMPLETE, false, false]));
                    };
                    session.open(request._toFileRequest());
                    this._session = session;
                };
                URLStream.prototype.readBytes = function (bytes, offset, length) {
                    if (offset === void 0) { offset = 0; }
                    if (length === void 0) { length = 0; }
                    offset = offset >>> 0;
                    length = length >>> 0;
                    if (length < 0) {
                        this._sec.throwError('ArgumentError', Shumway.Errors.InvalidArgumentError, "length");
                    }
                    this._buffer.readBytes(bytes, offset, length);
                };
                URLStream.prototype.readBoolean = function () {
                    release || notImplemented("public flash.net.URLStream::readBoolean");
                    return false;
                };
                URLStream.prototype.readByte = function () {
                    return this._buffer.readByte();
                };
                URLStream.prototype.readUnsignedByte = function () {
                    release || notImplemented("public flash.net.URLStream::readUnsignedByte");
                    return 0;
                };
                URLStream.prototype.readShort = function () {
                    release || notImplemented("public flash.net.URLStream::readShort");
                    return 0;
                };
                URLStream.prototype.readUnsignedShort = function () {
                    return this._buffer.readUnsignedShort();
                };
                URLStream.prototype.readUnsignedInt = function () {
                    release || notImplemented("public flash.net.URLStream::readUnsignedInt");
                    return 0;
                };
                URLStream.prototype.readInt = function () {
                    release || notImplemented("public flash.net.URLStream::readInt");
                    return 0;
                };
                URLStream.prototype.readFloat = function () {
                    release || notImplemented("public flash.net.URLStream::readFloat");
                    return 0;
                };
                URLStream.prototype.readDouble = function () {
                    release || notImplemented("public flash.net.URLStream::readDouble");
                    return 0;
                };
                URLStream.prototype.readMultiByte = function (length /*uint*/, charSet) {
                    length = length >>> 0;
                    charSet = charSet;
                    release || notImplemented("public flash.net.URLStream::readMultiByte");
                    return "";
                };
                URLStream.prototype.readUTF = function () {
                    return this._buffer.readUTF();
                };
                URLStream.prototype.readUTFBytes = function (length /*uint*/) {
                    return this._buffer.readUTFBytes(length);
                };
                URLStream.prototype.close = function () {
                    if (this._session) {
                        this._session.close();
                    }
                };
                URLStream.prototype.readObject = function () {
                    release || notImplemented("public flash.net.URLStream::readObject");
                    return;
                };
                URLStream.prototype.stop = function () {
                    release || notImplemented("public flash.net.URLStream::stop");
                    return;
                };
                return URLStream;
            }(flash.events.EventDispatcher));
            net.URLStream = URLStream;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: URLVariables
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var net;
        (function (net) {
            var URLVariables = /** @class */ (function (_super) {
                __extends(URLVariables, _super);
                function URLVariables(source) {
                    if (source === void 0) { source = null; }
                    var _this = _super.call(this) || this;
                    _this._ignoreDecodingErrors = false;
                    source && _this.decode(source);
                    return _this;
                }
                URLVariables.prototype.decode = function (source) {
                    var variables = source.split('&');
                    for (var i = 0; i < variables.length; i++) {
                        var p = variables[i];
                        var j = p.indexOf('=');
                        if (j < 0) {
                            if (this._ignoreDecodingErrors) {
                                j = p.length;
                            }
                            else {
                                this._sec.throwError('Error', Shumway.Errors.DecodeParamError);
                            }
                        }
                        var name_7 = unescape(p.substring(0, j).split('+').join(' '));
                        var value = unescape(p.substring(j + 1).split('+').join(' '));
                        var currentValue = this.axGetPublicProperty(name_7);
                        if (typeof currentValue === 'undefined') {
                            this.axSetPublicProperty(name_7, value);
                        }
                        else if (Array.isArray(currentValue)) {
                            currentValue.push(value);
                        }
                        else {
                            this.axSetPublicProperty(name_7, [currentValue, value]);
                        }
                    }
                };
                URLVariables.prototype.toString = function () {
                    var pairs = [];
                    var keys = this.axGetEnumerableKeys();
                    for (var i = 0; i < keys.length; i++) {
                        var name_8 = keys[i].split(' ').join('+');
                        var value = this.axGetPublicProperty(name_8);
                        name_8 = escape(name_8).split(' ').join('+');
                        if (Array.isArray(value)) {
                            for (var j = 0; j < value.length; j++) {
                                pairs.push(name_8 + '=' + escape(value[j]));
                            }
                        }
                        else {
                            pairs.push(name_8 + '=' + escape(value));
                        }
                    }
                    return pairs.join('&');
                };
                URLVariables.prototype.axSetPublicProperty = function (name, value) {
                    this._inner[name] = value;
                };
                URLVariables.prototype.axGetPublicProperty = function (name) {
                    return this._inner[name];
                };
                URLVariables.prototype.axGetEnumerableKeys = function () {
                    return Object.keys(this._inner);
                };
                return URLVariables;
            }(flash.LegacyEntity));
            net.URLVariables = URLVariables;
        })(net = flash.net || (flash.net = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ApplicationDomain
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var notImplemented = Shumway.Debug.notImplemented;
            var ApplicationDomain = /** @class */ (function (_super) {
                __extends(ApplicationDomain, _super);
                function ApplicationDomain(parentDomain) {
                    if (parentDomain === void 0) { parentDomain = null; }
                    var _this = _super.call(this) || this;
                    _this._classes = [];
                    // @ivanpopelyshev instead of currentABC
                    _this.url = location.href;
                    release || Shumway.Debug.assert(!(_this instanceof ApplicationDomain));
                    // this.parentDomain = parentDomain || this._sec.;
                    if (parentDomain) {
                        _this._parentDomain = parentDomain;
                    }
                    else if (_this._sec.system) {
                        _this._parentDomain = _this._sec.system._applicationDomain;
                    }
                    else {
                        _this._parentDomain = null;
                    }
                    return _this;
                }
                ApplicationDomain.prototype.loadABC = function (file) {
                    // nothing
                };
                ApplicationDomain.prototype.loadAndExecuteABC = function (file) {
                    // nothing
                };
                ApplicationDomain.prototype.getClass = function (name, namespaceType) {
                    for (var i = 0; i < this._classes.length; i++) {
                        var entry = this._classes[i];
                        if (entry.name.matches(name)) {
                            return entry.value;
                        }
                    }
                    return null;
                };
                ApplicationDomain.prototype.addClass = function (entry) {
                    this._classes.push(entry);
                    return entry;
                };
                Object.defineProperty(ApplicationDomain, "currentDomain", {
                    // This must return a new object each time.
                    get: function () {
                        return system._currentDomain.system._currentDomain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ApplicationDomain, "MIN_DOMAIN_MEMORY_LENGTH", {
                    get: function () {
                        release || notImplemented("public flash.system.ApplicationDomain::get MIN_DOMAIN_MEMORY_LENGTH");
                        return 0;
                        // return this._MIN_DOMAIN_MEMORY_LENGTH;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ApplicationDomain.prototype, "parentDomain", {
                    get: function () {
                        return this._parentDomain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ApplicationDomain.prototype, "domainMemory", {
                    get: function () {
                        release || notImplemented("public flash.system.ApplicationDomain::get domainMemory");
                        return null;
                        // return this._domainMemory;
                    },
                    set: function (mem) {
                        mem = mem;
                        release || notImplemented("public flash.system.ApplicationDomain::set domainMemory");
                        return;
                        // this._domainMemory = mem;
                    },
                    enumerable: true,
                    configurable: true
                });
                ApplicationDomain.prototype.getDefinition = function (name) {
                    var definition = this.getDefinitionImpl(name);
                    if (!definition) {
                        this._sec.throwError('ReferenceError', Shumway.Errors.UndefinedVarError, name);
                    }
                    return definition;
                };
                ApplicationDomain.prototype.hasDefinition = function (name) {
                    return !!this.getDefinitionImpl(name);
                };
                ApplicationDomain.prototype.getDefinitionImpl = function (name) {
                    //TODO: @ivanpopelyshev QNF here from AXApplicationDomain
                    // if (!name) {
                    // 	this.sec.throwError('TypeError', Errors.NullPointerError, 'definitionName');
                    // }
                    // let simpleName = name.replace("::", ".");
                    // let mn = Multiname.FromFQNString(simpleName, NamespaceType.Public);
                    // return this.axDomain.getProperty(mn, false, false);
                };
                ApplicationDomain.prototype.getQualifiedDefinitionNames = function () {
                    release || notImplemented("public flash.system.ApplicationDomain::getQualifiedDefinitionNames");
                    return null;
                };
                return ApplicationDomain;
            }(flash.LegacyEntity));
            system.ApplicationDomain = ApplicationDomain;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Capabilities
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var toKeyValueArray = Shumway.ObjectUtilities.toKeyValueArray;
            var Capabilities = /** @class */ (function (_super) {
                __extends(Capabilities, _super);
                function Capabilities() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Capabilities, "isEmbeddedInAcrobat", {
                    // static _touchscreenType: string;
                    // static _hasIME: boolean;
                    // static _hasTLS: boolean;
                    // static _maxLevelIDC: string;
                    // static _supports32BitProcesses: boolean;
                    // static _supports64BitProcesses: boolean;
                    // static __internal: number /*uint*/;
                    get: function () {
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasEmbeddedVideo", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get hasEmbeddedVideo");
                        return false;
                        // return Capabilities._hasEmbeddedVideo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasAudio", {
                    get: function () {
                        // The documentation says "this property is always true".
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "avHardwareDisable", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get avHardwareDisable");
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasAccessibility", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasAccessibility");
                        return Capabilities._hasAccessibility;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasAudioEncoder", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasAudioEncoder");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasMP3", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get hasMP3");
                        return false;
                        // return Capabilities._hasMP3;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasPrinting", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasPrinting");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasScreenBroadcast", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasScreenBroadcast");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasScreenPlayback", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasScreenPlayback");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasStreamingAudio", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get hasStreamingAudio");
                        return false;
                        // return Capabilities._hasStreamingAudio;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasStreamingVideo", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get hasStreamingVideo");
                        return false;
                        // return Capabilities._hasStreamingVideo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasVideoEncoder", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get hasVideoEncoder");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "isDebugger", {
                    get: function () {
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "localFileReadDisable", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get localFileReadDisable");
                        return false;
                        // return Capabilities._localFileReadDisable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "language", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get language");
                        return Capabilities._language;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "manufacturer", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get manufacturer");
                        return Capabilities._manufacturer;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "os", {
                    get: function () {
                        if (Capabilities._os === null) {
                            var os = void 0;
                            var userAgent = window.navigator.userAgent;
                            if (userAgent.indexOf("Macintosh") > 0) {
                                if (userAgent.indexOf('Mac OS X ') === -1) {
                                    os = 'Mac OS 10.6';
                                }
                                else {
                                    var versionStr = userAgent.split('Mac OS X ')[1];
                                    os = versionStr.substr(0, versionStr.indexOf(';'));
                                }
                            }
                            else if (userAgent.indexOf("Windows") > 0) {
                                os = "Windows XP";
                            }
                            else if (userAgent.indexOf("Linux") > 0) {
                                os = "Linux";
                            }
                            else if (/(iPad|iPhone|iPod|Android)/.test(userAgent)) {
                                os = "iPhone3,1";
                            }
                            else {
                                release || somewhatImplemented("public flash.system.Capabilities::get os");
                                os = "Generic OS";
                            }
                            Capabilities._os = os;
                        }
                        return Capabilities._os;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "cpuArchitecture", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get cpuArchitecture");
                        return 'x86';
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "playerType", {
                    get: function () {
                        return Capabilities._playerType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "serverString", {
                    get: function () {
                        var str = toKeyValueArray({ OS: Capabilities.os }).map(function (pair) {
                            return pair[0] + "=" + encodeURIComponent(pair[1]);
                        }).join("&");
                        release || somewhatImplemented("Capabilities.serverString: " + str);
                        return str;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "version", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get version");
                        return Capabilities._version;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "screenColor", {
                    /**
                     * This can be "color", "gray" or "bw" for black and white. I don't know when you'd have anything
                     * other than "color".
                     */
                    get: function () {
                        return "color";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "pixelAspectRatio", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get pixelAspectRatio");
                        return 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "screenDPI", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get screenDPI");
                        return Capabilities._screenDPI;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "screenResolutionX", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get screenResolutionX");
                        return window.screen.width; // TODO check
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "screenResolutionY", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Capabilities::get screenResolutionY");
                        return window.screen.height; // TODO check
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "touchscreenType", {
                    get: function () {
                        return system.TouchscreenType.NONE;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasIME", {
                    get: function () {
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "hasTLS", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get hasTLS");
                        return false;
                        // return Capabilities._hasTLS;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "maxLevelIDC", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get maxLevelIDC");
                        return "";
                        // return Capabilities._maxLevelIDC;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "supports32BitProcesses", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get supports32BitProcesses");
                        return false;
                        // return Capabilities._supports32BitProcesses;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "supports64BitProcesses", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get supports64BitProcesses");
                        return false;
                        // return Capabilities._supports64BitProcesses;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Capabilities, "_internal", {
                    get: function () {
                        release || notImplemented("public flash.system.Capabilities::get _internal");
                        return 0;
                        // return Capabilities.__internal;
                    },
                    enumerable: true,
                    configurable: true
                });
                Capabilities.hasMultiChannelAudio = function (type) {
                    release || somewhatImplemented("public flash.system.Capabilities::static hasMultiChannelAudio");
                    return false;
                };
                // static _hasEmbeddedVideo: boolean;
                // static _hasAudio: boolean;
                // static _avHardwareDisable: boolean;
                Capabilities._hasAccessibility = false;
                // static _hasAudioEncoder: boolean;
                // static _hasMP3: boolean;
                // static _hasPrinting: boolean;
                // static _hasScreenBroadcast: boolean;
                // static _hasScreenPlayback: boolean;
                // static _hasStreamingAudio: boolean;
                // static _hasStreamingVideo: boolean;
                // static _hasVideoEncoder: boolean;
                // static _localFileReadDisable: boolean;
                Capabilities._language = 'en';
                Capabilities._manufacturer = 'Mozilla Research';
                Capabilities._os = null;
                // static _cpuArchitecture: string;
                Capabilities._playerType = 'PlugIn';
                Capabilities._version = 'SHUMWAY 10,0,0,0';
                // static _screenColor: string;
                // static _pixelAspectRatio: number;
                Capabilities._screenDPI = 96; // Using standard CSS DPI for now.
                return Capabilities;
            }(flash.LegacyEntity));
            system.Capabilities = Capabilities;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FSCommand
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            function fscommand(sec, command, args) {
                console.log('FSCommand: ' + command + '; ' + args);
                command = command.toLowerCase();
                if (command === 'debugger') {
                    /* tslint:disable */
                    debugger;
                    /* tslint:enable */
                    return;
                }
                sec.player.executeFSCommand(command, args);
            }
            system.fscommand = fscommand;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ImageDecodingPolicy
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var ImageDecodingPolicy;
            (function (ImageDecodingPolicy) {
                ImageDecodingPolicy["ON_DEMAND"] = "onDemand";
                ImageDecodingPolicy["ON_LOAD"] = "onLoad";
            })(ImageDecodingPolicy = system.ImageDecodingPolicy || (system.ImageDecodingPolicy = {}));
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: LoaderContext
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var LoaderContext = /** @class */ (function (_super) {
                __extends(LoaderContext, _super);
                function LoaderContext(checkPolicyFile, applicationDomain, securityDomain) {
                    if (checkPolicyFile === void 0) { checkPolicyFile = false; }
                    if (applicationDomain === void 0) { applicationDomain = null; }
                    if (securityDomain === void 0) { securityDomain = null; }
                    var _this = _super.call(this) || this;
                    _this.$BgcheckPolicyFile = !!checkPolicyFile;
                    _this.$BgapplicationDomain = applicationDomain;
                    _this.$BgsecurityDomain = securityDomain;
                    _this.$BgimageDecodingPolicy = flash.system.ImageDecodingPolicy.ON_DEMAND;
                    _this._avm1Context = null;
                    return _this;
                }
                Object.defineProperty(LoaderContext.prototype, "imageDecodingPolicy", {
                    get: function () {
                        return this.$BgimageDecodingPolicy;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "parameters", {
                    get: function () {
                        return this.$Bgparameters;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "requestedContentParent", {
                    get: function () {
                        return this.$BgrequestedContentParent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "allowCodeImport", {
                    get: function () {
                        return this.$BgallowCodeImport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "securityDomain", {
                    get: function () {
                        return this.$BgsecurityDomain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "applicationDomain", {
                    get: function () {
                        return this.$BgapplicationDomain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoaderContext.prototype, "checkPolicyFile", {
                    get: function () {
                        return this.$BgcheckPolicyFile;
                    },
                    enumerable: true,
                    configurable: true
                });
                return LoaderContext;
            }(flash.LegacyEntity));
            system.LoaderContext = LoaderContext;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: JPEGLoaderContext
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var JPEGLoaderContext = /** @class */ (function (_super) {
                __extends(JPEGLoaderContext, _super);
                function JPEGLoaderContext(deblockingFilter, checkPolicyFile, applicationDomain, securityDomain) {
                    if (deblockingFilter === void 0) { deblockingFilter = 0; }
                    if (checkPolicyFile === void 0) { checkPolicyFile = false; }
                    if (applicationDomain === void 0) { applicationDomain = null; }
                    if (securityDomain === void 0) { securityDomain = null; }
                    var _this = _super.call(this, checkPolicyFile, applicationDomain, securityDomain) || this;
                    _this.deblockingFilter = +deblockingFilter;
                    return _this;
                }
                return JPEGLoaderContext;
            }(system.LoaderContext));
            system.JPEGLoaderContext = JPEGLoaderContext;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MessageChannel
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var notImplemented = Shumway.Debug.notImplemented;
            var MessageChannel = /** @class */ (function (_super) {
                __extends(MessageChannel, _super);
                function MessageChannel() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(MessageChannel.prototype, "messageAvailable", {
                    // addEventListener: (type: string, listener: ASFunction, useCapture: boolean = false, priority: number /*int*/ = 0, useWeakReference: boolean = false) => void;
                    // removeEventListener: (type: string, listener: ASFunction, useCapture: boolean = false) => void;
                    // AS -> JS Bindings
                    // _messageAvailable: boolean;
                    // _state: string;
                    get: function () {
                        release || notImplemented("public flash.system.MessageChannel::get messageAvailable");
                        return false;
                        // return this._messageAvailable;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MessageChannel.prototype, "state", {
                    get: function () {
                        release || notImplemented("public flash.system.MessageChannel::get state");
                        return "";
                        // return this._state;
                    },
                    enumerable: true,
                    configurable: true
                });
                MessageChannel.prototype.send = function (arg, queueLimit) {
                    if (queueLimit === void 0) { queueLimit = -1; }
                    queueLimit = queueLimit | 0;
                    release || notImplemented("public flash.system.MessageChannel::send");
                    return;
                };
                MessageChannel.prototype.receive = function (blockUntilReceived) {
                    if (blockUntilReceived === void 0) { blockUntilReceived = false; }
                    blockUntilReceived = !!blockUntilReceived;
                    release || notImplemented("public flash.system.MessageChannel::receive");
                    return;
                };
                MessageChannel.prototype.close = function () {
                    release || notImplemented("public flash.system.MessageChannel::close");
                    return;
                };
                return MessageChannel;
            }(flash.events.EventDispatcher));
            system.MessageChannel = MessageChannel;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MessageChannelState
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var MessageChannelState;
            (function (MessageChannelState) {
                MessageChannelState["OPEN"] = "open";
                MessageChannelState["CLOSING"] = "closing";
                MessageChannelState["CLOSED"] = "closed";
            })(MessageChannelState = system.MessageChannelState || (system.MessageChannelState = {}));
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Security
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var Security = /** @class */ (function (_super) {
                __extends(Security, _super);
                function Security() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Security, "exactSettings", {
                    // static _pageDomain: string;
                    get: function () {
                        return Security._exactSettings;
                    },
                    set: function (value) {
                        value = !!value;
                        Security._exactSettings = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Security, "disableAVM1Loading", {
                    get: function () {
                        release || notImplemented("public flash.system.Security::get disableAVM1Loading");
                        return false;
                        // return Security._disableAVM1Loading;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.system.Security::set disableAVM1Loading");
                        return;
                        // Security._disableAVM1Loading = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Security, "sandboxType", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Security::get sandboxType");
                        return Security._sandboxType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Security, "pageDomain", {
                    get: function () {
                        release || somewhatImplemented("public flash.system.Security::get pageDomain");
                        // TODO: convert this to proper URI parsing.
                        var pageHost = Shumway.FileLoadingService.instance.resolveUrl('/');
                        var parts = pageHost.split('/');
                        parts.pop();
                        return parts.pop();
                    },
                    enumerable: true,
                    configurable: true
                });
                Security.allowDomain = function () {
                    release || somewhatImplemented('public flash.system.Security::static allowDomain ["' +
                        Array.prototype.join.call(arguments, '", "') + '"]');
                    var whitelist = system.currentDomain().player;
                    for (var i = 0; i < arguments.length; i++) {
                        whitelist.addToSWFLoadingWhitelist(arguments[i] || '', false, false);
                    }
                };
                Security.allowInsecureDomain = function () {
                    release || somewhatImplemented("public flash.system.Security::static allowInsecureDomain");
                    var whitelist = system.currentDomain().player;
                    for (var i = 0; i < arguments.length; i++) {
                        whitelist.addToSWFLoadingWhitelist(arguments[i] || '', true, false);
                    }
                };
                Security.loadPolicyFile = function (url) {
                    release || somewhatImplemented("public flash.system.Security::static loadPolicyFile");
                };
                Security.showSettings = function (panel) {
                    if (panel === void 0) { panel = "default"; }
                    release || notImplemented("public flash.system.Security::static showSettings");
                    return;
                };
                Security.duplicateSandboxBridgeInputArguments = function (toplevel, args) {
                    toplevel = toplevel;
                    args = args;
                    release || notImplemented("public flash.system.Security::static duplicateSandboxBridgeInputArguments");
                    return null;
                };
                Security.duplicateSandboxBridgeOutputArgument = function (toplevel, arg) {
                    toplevel = toplevel;
                    release || notImplemented("public flash.system.Security::static duplicateSandboxBridgeOutputArgument");
                    return;
                };
                // JS -> AS Bindings
                Security.REMOTE = "remote";
                Security.LOCAL_WITH_FILE = "localWithFile";
                Security.LOCAL_WITH_NETWORK = "localWithNetwork";
                Security.LOCAL_TRUSTED = "localTrusted";
                Security.APPLICATION = "application";
                // AS -> JS Bindings
                Security._exactSettings = false;
                // static _disableAVM1Loading: boolean;
                Security._sandboxType = 'remote';
                return Security;
            }(flash.LegacyEntity));
            system.Security = Security;
            var CrossDomainSWFLoadingWhitelistResult;
            (function (CrossDomainSWFLoadingWhitelistResult) {
                /**
                 * The requested domain belongs to the same domain as SWF's.
                 */
                CrossDomainSWFLoadingWhitelistResult[CrossDomainSWFLoadingWhitelistResult["OwnDomain"] = 0] = "OwnDomain";
                /**
                 * The requested domain belongs to the other domain than SWF's.
                 */
                CrossDomainSWFLoadingWhitelistResult[CrossDomainSWFLoadingWhitelistResult["Remote"] = 1] = "Remote";
                /**
                 * The requested domain is not whitelisted.
                 */
                CrossDomainSWFLoadingWhitelistResult[CrossDomainSWFLoadingWhitelistResult["Failed"] = 2] = "Failed";
            })(CrossDomainSWFLoadingWhitelistResult = system.CrossDomainSWFLoadingWhitelistResult || (system.CrossDomainSWFLoadingWhitelistResult = {}));
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var LegacyError = /** @class */ (function (_super) {
                __extends(LegacyError, _super);
                function LegacyError(msg, code) {
                    return _super.call(this, msg) || this;
                }
                return LegacyError;
            }(Error));
            system.LegacyError = LegacyError;
            var SecurityDomain = /** @class */ (function () {
                function SecurityDomain() {
                    var oldDomain = system._currentDomain;
                    system._currentDomain = this;
                    this.events = new system.EventsNamespace();
                    this.utils = new system.UtilsNamespace();
                    this.display = new system.DisplayNamespace();
                    this.geom = new system.GeomNamespace();
                    this.text = new system.TextNamespace();
                    this.system = new system.SystemNamespace();
                    this.filters = new system.FiltersNamespace();
                    this.media = new system.MediaNamespace();
                    this.net = new system.NetNamespace();
                    this.ui = new system.UINamespace();
                    if (oldDomain) {
                        system._currentDomain = oldDomain;
                    }
                }
                SecurityDomain.prototype.throwError = function (className, error, replacement1, replacement2, replacement3, replacement4) {
                    throw this.createError.apply(this, arguments);
                };
                SecurityDomain.prototype.createError = function (className, error, replacement1, replacement2, replacement3, replacement4) {
                    var message = Shumway.formatErrorMessage.apply(null, Shumway.sliceArguments(arguments, 1));
                    return new LegacyError(message, error.code);
                    // let mn = Multiname.FromFQNString(className, NamespaceType.Public);
                    // let axClass: AXClass = <any>this.system.getProperty(mn, true, true);
                    // return axClass.axConstruct([message, error.code]);
                };
                return SecurityDomain;
            }());
            system.SecurityDomain = SecurityDomain;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SecurityPanel
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var SecurityPanel;
            (function (SecurityPanel) {
                SecurityPanel["DEFAULT"] = "default";
                SecurityPanel["PRIVACY"] = "privacy";
                SecurityPanel["LOCAL_STORAGE"] = "localStorage";
                SecurityPanel["MICROPHONE"] = "microphone";
                SecurityPanel["CAMERA"] = "camera";
                SecurityPanel["DISPLAY"] = "display";
                SecurityPanel["SETTINGS_MANAGER"] = "settingsManager";
            })(SecurityPanel = system.SecurityPanel || (system.SecurityPanel = {}));
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TouchscreenType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var TouchscreenType;
            (function (TouchscreenType) {
                TouchscreenType["FINGER"] = "finger";
                TouchscreenType["STYLUS"] = "stylus";
                TouchscreenType["NONE"] = "none";
            })(TouchscreenType = system.TouchscreenType || (system.TouchscreenType = {}));
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: AntiAliasType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var AntiAliasType;
            (function (AntiAliasType) {
                AntiAliasType["NORMAL"] = "normal";
                AntiAliasType["ADVANCED"] = "advanced";
            })(AntiAliasType = text.AntiAliasType || (text.AntiAliasType = {}));
            (function (AntiAliasType) {
                function fromNumber(n) {
                    switch (n) {
                        case 1:
                            return AntiAliasType.NORMAL;
                        case 2:
                            return AntiAliasType.ADVANCED;
                        default:
                            return null;
                    }
                }
                AntiAliasType.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case AntiAliasType.NORMAL:
                            return 1;
                        case AntiAliasType.ADVANCED:
                            return 2;
                        default:
                            return -1;
                    }
                }
                AntiAliasType.toNumber = toNumber;
            })(AntiAliasType = text.AntiAliasType || (text.AntiAliasType = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FontStyle
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var FontStyle;
            (function (FontStyle) {
                FontStyle["REGULAR"] = "regular";
                FontStyle["BOLD"] = "bold";
                FontStyle["ITALIC"] = "italic";
                FontStyle["BOLD_ITALIC"] = "boldItalic";
            })(FontStyle = text.FontStyle || (text.FontStyle = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: FontType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var FontType;
            (function (FontType) {
                FontType["EMBEDDED"] = "embedded";
                FontType["EMBEDDED_CFF"] = "embeddedCFF";
                FontType["DEVICE"] = "device";
            })(FontType = text.FontType || (text.FontType = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Font
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var FontStyle = flash.text.FontStyle;
            var FontType = flash.text.FontType;
            var Font = /** @class */ (function (_super) {
                __extends(Font, _super);
                function Font() {
                    var _this = _super.call(this) || this;
                    if (!_this._symbol) {
                        _this._initializeFields();
                    }
                    return _this;
                }
                Font.prototype._initializeFields = function () {
                    this._fontName = null;
                    this._fontFamily = null;
                    this._fontStyle = null;
                    this._fontType = null;
                    this.ascent = 0;
                    this.descent = 0;
                    this.leading = 0;
                    this.advances = null;
                    this._id = flash.display.DisplayObject.getNextSyncID();
                };
                Font.prototype.applySymbol = function () {
                    release || Shumway.Debug.assert(this._symbol);
                    var symbol = this._symbol;
                    release || Shumway.Debug.assert(symbol.syncId);
                    this._initializeFields();
                    this._id = symbol.syncId;
                    this._fontName = symbol.name;
                    var fontClass = this._sec.text;
                    this._fontFamily = fontClass.resolveFontName(symbol.name);
                    if (symbol.bold) {
                        if (symbol.italic) {
                            this._fontStyle = FontStyle.BOLD_ITALIC;
                        }
                        else {
                            this._fontStyle = FontStyle.BOLD;
                        }
                    }
                    else if (symbol.italic) {
                        this._fontStyle = FontStyle.ITALIC;
                    }
                    else {
                        this._fontStyle = FontStyle.REGULAR;
                    }
                    var metrics = symbol.metrics;
                    if (metrics) {
                        this.ascent = metrics.ascent;
                        this.descent = metrics.descent;
                        this.leading = metrics.leading;
                        this.advances = metrics.advances;
                    }
                    // Font symbols without any glyphs describe device fonts.
                    this._fontType = metrics ? FontType.EMBEDDED : FontType.DEVICE;
                    // Keeping fontProp.configurable === true, some old movies have fonts with non-unique
                    // names.
                    var fontProp = {
                        value: this,
                        configurable: true
                    };
                    Object.defineProperty(fontClass._fontsBySymbolId, symbol.id + '', fontProp);
                    Object.defineProperty(fontClass._fontsByName, symbol.name.toLowerCase() + this._fontStyle, fontProp);
                    if (this._fontType === FontType.EMBEDDED) {
                        Object.defineProperty(fontClass._fontsByName, 'swffont' + symbol.syncId + this._fontStyle, fontProp);
                    }
                };
                Object.defineProperty(Font.prototype, "fontName", {
                    get: function () {
                        return this._fontName;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Font.prototype, "fontStyle", {
                    get: function () {
                        return this._fontStyle;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Font.prototype, "fontType", {
                    get: function () {
                        return this._fontType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Font.prototype.hasGlyphs = function (str) {
                    somewhatImplemented('Font#hasGlyphs');
                    return true;
                };
                return Font;
            }(flash.LegacyEntity));
            text.Font = Font;
            var FontSymbol = /** @class */ (function (_super) {
                __extends(FontSymbol, _super);
                function FontSymbol(data, sec) {
                    return _super.call(this, data, sec.text.Font) || this;
                }
                FontSymbol.FromData = function (data, loaderInfo) {
                    var symbol = new FontSymbol(data, loaderInfo._sec);
                    // Immediately mark glyph-less fonts as ready.
                    symbol.ready = !data.metrics;
                    symbol.name = data.name;
                    // No need to keep the original data baggage around.
                    symbol.data = { id: data.id };
                    symbol.bold = data.bold;
                    symbol.italic = data.italic;
                    symbol.originalSize = data.originalSize;
                    symbol.codes = data.codes;
                    symbol.metrics = data.metrics;
                    symbol.syncId = flash.display.DisplayObject.getNextSyncID();
                    return symbol;
                };
                Object.defineProperty(FontSymbol.prototype, "resolveAssetCallback", {
                    get: function () {
                        return this._unboundResolveAssetCallback.bind(this);
                    },
                    enumerable: true,
                    configurable: true
                });
                FontSymbol.prototype._unboundResolveAssetCallback = function (data) {
                    release || Shumway.Debug.assert(!this.ready);
                    this.ready = true;
                };
                return FontSymbol;
            }(Shumway.Timeline.Symbol));
            text.FontSymbol = FontSymbol;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GridFitType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var GridFitType;
            (function (GridFitType) {
                GridFitType["NONE"] = "none";
                GridFitType["PIXEL"] = "pixel";
                GridFitType["SUBPIXEL"] = "subpixel";
            })(GridFitType = text.GridFitType || (text.GridFitType = {}));
            (function (GridFitType) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return GridFitType.NONE;
                        case 1:
                            return GridFitType.PIXEL;
                        case 2:
                            return GridFitType.SUBPIXEL;
                        default:
                            return null;
                    }
                }
                GridFitType.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case GridFitType.NONE:
                            return 0;
                        case GridFitType.PIXEL:
                            return 1;
                        case GridFitType.SUBPIXEL:
                            return 2;
                        default:
                            return -1;
                    }
                }
                GridFitType.toNumber = toNumber;
            })(GridFitType = text.GridFitType || (text.GridFitType = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StaticText
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var assert = Shumway.Debug.assert;
            var StaticText = /** @class */ (function (_super) {
                __extends(StaticText, _super);
                function StaticText() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    return _this;
                }
                StaticText.prototype.applySymbol = function () {
                    release || assert(this._symbol);
                    this._initializeFields();
                    this._setStaticContentFromSymbol(this._symbol);
                };
                StaticText.prototype._canHaveTextContent = function () {
                    return true;
                };
                StaticText.prototype._getTextContent = function () {
                    return this._textContent;
                };
                Object.defineProperty(StaticText.prototype, "text", {
                    get: function () {
                        return this._textContent.plainText;
                    },
                    enumerable: true,
                    configurable: true
                });
                StaticText.classInitializer = null;
                StaticText.classSymbols = null;
                StaticText.instanceSymbols = null;
                return StaticText;
            }(flash.display.DisplayObject));
            text.StaticText = StaticText;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: StyleSheet
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var assert = Shumway.Debug.assert;
            var StyleSheet = /** @class */ (function (_super) {
                __extends(StyleSheet, _super);
                function StyleSheet() {
                    var _this = _super.call(this) || this;
                    _this.clear();
                    return _this;
                }
                Object.defineProperty(StyleSheet.prototype, "styleNames", {
                    get: function () {
                        var styles = this._rules;
                        var names = [];
                        for (var name_9 in styles) {
                            if (styles[name_9]) {
                                names.push(name_9);
                            }
                        }
                        return names;
                    },
                    enumerable: true,
                    configurable: true
                });
                StyleSheet.prototype.getStyle = function (styleName) {
                    var style = this._rules[styleName.toLowerCase()];
                    if (!style) {
                        return {}; // note that documentation is lying about `null`;
                    }
                    return style;
                };
                StyleSheet.prototype.applyStyle = function (textFormat, styleName) {
                    var style = this._rules[styleName.toLowerCase()];
                    if (style) {
                        return textFormat.transform(style);
                    }
                    return textFormat;
                };
                StyleSheet.prototype.setStyle = function (styleName, styleObject) {
                    if (typeof styleObject !== 'object') {
                        return;
                    }
                    this._rules[styleName.toLowerCase()] = styleObject;
                };
                StyleSheet.prototype.hasStyle = function (styleName) {
                    return !!this._rules[styleName.toLowerCase()];
                };
                StyleSheet.prototype.clear = function () {
                    this._rules = Object.create(null);
                };
                StyleSheet.prototype.transform = function (formatObject) {
                    if (typeof formatObject !== 'object') {
                        return null;
                    }
                    var jsObject = formatObject;
                    var textFormat = this._sec.text.TextFormat.create();
                    textFormat.transform(jsObject);
                    return textFormat;
                };
                StyleSheet.prototype.parseCSS = function (css) {
                    css = css + '';
                    var length = css.length;
                    var index = skipWhitespace(css, 0, length);
                    // Styles are only added once parsing completed successfully. Invalid syntax anywhere discards all new styles.
                    var newStyles = {};
                    var currentNames = [];
                    var sawWhitespace = false;
                    var name = '';
                    while (index < length) {
                        var char = css[index++];
                        // Everything except whitespace, command, and '{' is valid in names.
                        // Note: if no name is given, the empty string is used.
                        switch (char) {
                            case '{':
                                sawWhitespace = false;
                                currentNames.push(name);
                                // parse style.
                                index = parseStyle(css, index, length, currentNames, newStyles);
                                if (index === -1) {
                                    // Syntax error encountered in style parsing.
                                    return;
                                }
                                else if (!release) {
                                    assert(css[index - 1] === '}');
                                }
                                currentNames = [];
                                name = '';
                                index = skipWhitespace(css, index, length);
                                break;
                            case ',':
                                sawWhitespace = false;
                                currentNames.push(name);
                                name = '';
                                index = skipWhitespace(css, index, length);
                                break;
                            case ' ':
                            case '\n':
                            case '\r':
                            case '\t':
                                sawWhitespace = true;
                                index = skipWhitespace(css, index, length);
                                break;
                            default:
                                if (sawWhitespace) {
                                    return;
                                }
                                name += char;
                        }
                    }
                    var styles = this._rules;
                    for (name in newStyles) {
                        styles[name.toLowerCase()] = newStyles[name];
                    }
                };
                StyleSheet.classInitializer = null;
                StyleSheet.classSymbols = null;
                StyleSheet.instanceSymbols = null;
                return StyleSheet;
            }(flash.events.EventDispatcher));
            text.StyleSheet = StyleSheet;
            function parseStyle(css, index, length, names, newStyles) {
                release || assert(index > 0);
                release || assert(css[index - 1] === '{');
                var style = {};
                var name = '';
                var sawWhitespace = false;
                var upperCase = false;
                index = skipWhitespace(css, index, length);
                // Outer loop parsing property names.
                nameLoop: while (index < length) {
                    var char = css[index++];
                    switch (char) {
                        case '}':
                            if (name.length > 0) {
                                return -1;
                            }
                            break nameLoop;
                        case ':':
                            var value = '';
                            var propertyName = name;
                            // Reset outer-loop state.
                            name = '';
                            sawWhitespace = false;
                            upperCase = false;
                            // Inner loop parsing property values.
                            /*valueLoop:*/
                            while (index < length) {
                                char = css[index];
                                switch (char) {
                                    case ';':
                                    case '\r':
                                    case '\n':
                                        index++;
                                        index = skipWhitespace(css, index, length);
                                    // Fallthrough.
                                    case '}':
                                        style[propertyName] = value;
                                        continue nameLoop;
                                    default:
                                        index++;
                                        value += char;
                                }
                            }
                            // If we got here, the inner loop ended by exhausting the string, so the definition
                            // wasn't properly closed.
                            return -1;
                        case '-':
                            if (css[index] === ':') {
                                name += char;
                            }
                            else {
                                upperCase = true;
                            }
                            break;
                        case ' ':
                        case '\n':
                        case '\r':
                        case '\t':
                            sawWhitespace = true;
                            name += char;
                            upperCase = false;
                            break;
                        default:
                            // Names that're interrupted by whitespace are invalid.
                            if (sawWhitespace) {
                                return -1;
                            }
                            if (upperCase) {
                                char = char.toUpperCase();
                                upperCase = false;
                            }
                            name += char;
                    }
                }
                if (css[index - 1] !== '}') {
                    return -1;
                }
                for (var i = 0; i < names.length; i++) {
                    newStyles[names[i]] = style;
                }
                return index;
            }
            function skipWhitespace(css, index, length) {
                while (index < length) {
                    var char = css[index];
                    switch (char) {
                        case ' ':
                        case '\n':
                        case '\r':
                        case '\t':
                            index++;
                            break;
                        default:
                            return index;
                    }
                }
                release || assert(index === length);
                return length;
            }
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextDisplayMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextDisplayMode;
            (function (TextDisplayMode) {
                TextDisplayMode["LCD"] = "lcd";
                TextDisplayMode["CRT"] = "crt";
                TextDisplayMode["DEFAULT"] = "default";
            })(TextDisplayMode = text.TextDisplayMode || (text.TextDisplayMode = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextField
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text_1) {
            var notImplemented = Shumway.Debug.notImplemented;
            var assert = Shumway.Debug.assert;
            var warning = Shumway.Debug.warning;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var clamp = Shumway.NumberUtilities.clamp;
            var TextField = /** @class */ (function (_super) {
                __extends(TextField, _super);
                function TextField() {
                    var _this = _super.call(this) || this;
                    if (!_this._fieldsInitialized) {
                        _this._initializeFields();
                    }
                    if (!_this._symbol) {
                        _this._setFillAndLineBoundsFromWidthAndHeight(100 * 20, 100 * 20);
                    }
                    return _this;
                }
                TextField.prototype.applySymbol = function () {
                    this._initializeFields();
                    release || assert(this._symbol);
                    var symbol = this._symbol;
                    this._setFillAndLineBoundsFromSymbol(symbol);
                    var defaultTextFormat = this._textContent.defaultTextFormat;
                    defaultTextFormat.color = symbol.color;
                    defaultTextFormat.size = (symbol.size / 20) | 0;
                    defaultTextFormat.font = symbol.face;
                    defaultTextFormat.bold = symbol.bold;
                    defaultTextFormat.italic = symbol.italic;
                    defaultTextFormat.align = symbol.align;
                    defaultTextFormat.leftMargin = (symbol.leftMargin / 20) | 0;
                    defaultTextFormat.rightMargin = (symbol.rightMargin / 20) | 0;
                    defaultTextFormat.indent = (symbol.indent / 20) | 0;
                    defaultTextFormat.leading = (symbol.leading / 20) | 0;
                    this._multiline = symbol.multiline;
                    this._embedFonts = symbol.embedFonts;
                    this._selectable = symbol.selectable;
                    this._displayAsPassword = symbol.displayAsPassword;
                    this._type = symbol.type;
                    this._maxChars = symbol.maxChars;
                    if (symbol.border) {
                        this.background = true;
                        this.border = true;
                    }
                    if (symbol.html) {
                        this.htmlText = symbol.initialText;
                    }
                    else {
                        this.text = symbol.initialText;
                    }
                    this.wordWrap = symbol.wordWrap;
                    this.autoSize = symbol.autoSize;
                };
                TextField.prototype._initializeFields = function () {
                    _super.prototype._initializeFields.call(this);
                    this._alwaysShowSelection = false;
                    this._antiAliasType = text_1.AntiAliasType.NORMAL;
                    this._autoSize = text_1.TextFieldAutoSize.NONE;
                    this._background = false;
                    this._backgroundColor = 0xffffffff;
                    this._border = false;
                    this._borderColor = 0x000000ff;
                    this._bottomScrollV = 1;
                    this._caretIndex = 0;
                    this._condenseWhite = false;
                    this._embedFonts = false;
                    this._gridFitType = text_1.GridFitType.PIXEL;
                    this._htmlText = '';
                    this._length = 0;
                    this._textInteractionMode = text_1.TextInteractionMode.NORMAL;
                    this._maxChars = 0;
                    this._maxScrollH = 0;
                    this._maxScrollV = 1;
                    this._mouseWheelEnabled = false;
                    this._multiline = false;
                    this._numLines = 1;
                    this._displayAsPassword = false;
                    this._restrict = null;
                    this._selectable = true;
                    this._selectedText = '';
                    this._selectionBeginIndex = 0;
                    this._selectionEndIndex = 0;
                    this._sharpness = 0;
                    this._styleSheet = null;
                    this._textColor = null;
                    this._textHeight = 0;
                    this._textWidth = 0;
                    this._thickness = 0;
                    this._type = text_1.TextFieldType.DYNAMIC;
                    this._useRichTextClipboard = false;
                    this._lineMetricsData = null;
                    var defaultTextFormat = this._sec.text.TextFormat.create([
                        this._sec.text.DEFAULT_FONT_SERIF,
                        12,
                        0,
                        false,
                        false,
                        false,
                        '',
                        '',
                        text_1.TextFormatAlign.LEFT
                    ]);
                    defaultTextFormat.letterSpacing = 0;
                    defaultTextFormat.kerning = 0;
                    this._textContent = new Shumway.TextContent(this._sec, defaultTextFormat);
                };
                TextField.prototype._setFillAndLineBoundsFromSymbol = function (symbol) {
                    _super.prototype._setFillAndLineBoundsFromSymbol.call(this, symbol);
                    this._textContent.bounds = this._lineBounds;
                    this._invalidateContent();
                };
                TextField.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                    _super.prototype._setFillAndLineBoundsFromWidthAndHeight.call(this, width, height);
                    this._textContent.bounds = this._lineBounds;
                    this._invalidateContent();
                };
                TextField.prototype._canHaveTextContent = function () {
                    return true;
                };
                TextField.prototype._getTextContent = function () {
                    return this._textContent;
                };
                TextField.prototype._getContentBounds = function (includeStrokes) {
                    if (includeStrokes === void 0) { includeStrokes = true; }
                    this._ensureLineMetrics();
                    return _super.prototype._getContentBounds.call(this, includeStrokes);
                };
                TextField.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                    // If this override is reached, the content bounds have already been checked, which is all
                    // we need to do.
                    release || assert(this._getContentBounds().contains(localX, localY));
                    return true;
                };
                TextField.prototype._invalidateContent = function () {
                    if (this._textContent.flags & 15 /* Dirty */) {
                        this._setDirtyFlags(8 /* DirtyTextContent */);
                    }
                };
                // JS -> AS Bindings
                //selectedText: string;
                //appendText: (newText: string) => void;
                //getXMLText: (beginIndex: number /*int*/ = 0, endIndex: number /*int*/ = 2147483647) =>
                // string;
                //insertXMLText: (beginIndex: number /*int*/, endIndex: number /*int*/, richText: string,
                // pasting: boolean = false) => void; copyRichText: () => string; pasteRichText: (richText:
                // string) => boolean;
                // AS -> JS Bindings
                TextField.isFontCompatible = function (fontName, fontStyle) {
                    var font = flash.system.currentDomain().text.getByNameAndStyle(fontName, fontStyle);
                    if (!font) {
                        return false;
                    }
                    return font.fontStyle === fontStyle;
                };
                Object.defineProperty(TextField.prototype, "alwaysShowSelection", {
                    get: function () {
                        return this._alwaysShowSelection;
                    },
                    set: function (value) {
                        this._alwaysShowSelection = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "antiAliasType", {
                    get: function () {
                        return this._antiAliasType;
                    },
                    set: function (antiAliasType) {
                        if (Shumway.isNullOrUndefined(antiAliasType)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'antiAliasType');
                        }
                        if (text_1.AntiAliasType.toNumber(antiAliasType) < 0) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.InvalidParamError, "antiAliasType");
                        }
                        this._antiAliasType = antiAliasType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "autoSize", {
                    get: function () {
                        return this._autoSize;
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'autoSize');
                        }
                        if (value === this._autoSize) {
                            return;
                        }
                        if (text_1.TextFieldAutoSize.toNumber(value) < 0) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.InvalidParamError, "autoSize");
                        }
                        this._autoSize = value;
                        this._textContent.autoSize = text_1.TextFieldAutoSize.toNumber(value);
                        this._invalidateContent();
                        this._ensureLineMetrics();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "background", {
                    get: function () {
                        return this._background;
                    },
                    set: function (value) {
                        value = !!value;
                        if (value === this._background) {
                            return;
                        }
                        this._background = value;
                        this._textContent.backgroundColor = value ? this._backgroundColor : 0;
                        this._setDirtyFlags(8 /* DirtyTextContent */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "backgroundColor", {
                    get: function () {
                        return this._backgroundColor >> 8;
                    },
                    set: function (value /*uint*/) {
                        value = ((value << 8) | 0xff) >>> 0;
                        if (value === this._backgroundColor) {
                            return;
                        }
                        this._backgroundColor = value;
                        if (this._background) {
                            this._textContent.backgroundColor = value;
                            this._setDirtyFlags(8 /* DirtyTextContent */);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "border", {
                    get: function () {
                        return this._border;
                    },
                    set: function (value) {
                        value = !!value;
                        if (value === this._border) {
                            return;
                        }
                        this._border = value;
                        this._textContent.borderColor = value ? this._borderColor : 0;
                        this._setDirtyFlags(8 /* DirtyTextContent */);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "borderColor", {
                    get: function () {
                        return this._borderColor >> 8;
                    },
                    set: function (value /*uint*/) {
                        value = ((value << 8) | 0xff) >>> 0;
                        if (value === this._borderColor) {
                            return;
                        }
                        this._borderColor = value;
                        if (this._border) {
                            this._textContent.borderColor = value;
                            this._setDirtyFlags(8 /* DirtyTextContent */);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "bottomScrollV", {
                    // Returns bottommost line that is currently visible.
                    get: function () {
                        return this._bottomScrollV;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "caretIndex", {
                    get: function () {
                        release || notImplemented("public flash.text.TextField::get caretIndex");
                        return 0;
                        // return this._caretIndex;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "condenseWhite", {
                    get: function () {
                        return this._condenseWhite;
                    },
                    set: function (value) {
                        this._condenseWhite = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "defaultTextFormat", {
                    get: function () {
                        return this._textContent.defaultTextFormat.clone();
                    },
                    set: function (format) {
                        if (Shumway.isNullOrUndefined(format)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'format');
                        }
                        var defaultTextFormat = this._textContent.defaultTextFormat;
                        defaultTextFormat.merge(format);
                        if (defaultTextFormat.color === null) {
                            defaultTextFormat.color = this._textColor;
                        }
                        else {
                            this._textColor = +defaultTextFormat.color;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "embedFonts", {
                    get: function () {
                        return this._embedFonts;
                    },
                    set: function (value) {
                        this._embedFonts = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "gridFitType", {
                    get: function () {
                        return this._gridFitType;
                    },
                    set: function (gridFitType) {
                        if (Shumway.isNullOrUndefined(gridFitType)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'gridFitType');
                        }
                        release || assert(flash.text.GridFitType.toNumber(gridFitType) >= 0);
                        this._gridFitType = gridFitType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "htmlText", {
                    get: function () {
                        return this._htmlText;
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'value');
                        }
                        // Flash resets the bold and italic flags when an html value is set on a text field created
                        // from a symbol.
                        if (this._symbol) {
                            this._textContent.defaultTextFormat.bold = false;
                            this._textContent.defaultTextFormat.italic = false;
                        }
                        this._textContent.parseHtml(value, this._styleSheet, this._multiline);
                        this._htmlText = value;
                        this._invalidateContent();
                        this._ensureLineMetrics();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "length", {
                    get: function () {
                        return this._length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "textInteractionMode", {
                    get: function () {
                        release || notImplemented("public flash.text.TextField::get textInteractionMode");
                        return "";
                        // return this._textInteractionMode;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "maxChars", {
                    get: function () {
                        return this._maxChars;
                    },
                    set: function (value /*int*/) {
                        this._maxChars = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "maxScrollH", {
                    get: function () {
                        this._ensureLineMetrics();
                        return this._maxScrollH;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "maxScrollV", {
                    get: function () {
                        this._ensureLineMetrics();
                        return this._maxScrollV;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "mouseWheelEnabled", {
                    get: function () {
                        return this._mouseWheelEnabled;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.text.TextField::set mouseWheelEnabled");
                        this._mouseWheelEnabled = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "multiline", {
                    get: function () {
                        return this._multiline;
                    },
                    set: function (value) {
                        this._multiline = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "numLines", {
                    get: function () {
                        return this._numLines;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "displayAsPassword", {
                    get: function () {
                        return this._displayAsPassword;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.text.TextField::set displayAsPassword");
                        this._displayAsPassword = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "restrict", {
                    get: function () {
                        return this._restrict;
                    },
                    set: function (value) {
                        release || somewhatImplemented("public flash.text.TextField::set restrict");
                        this._restrict = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "scrollH", {
                    // Returns the current vertical scrolling position in lines.
                    get: function () {
                        return this._textContent.scrollH;
                    },
                    set: function (value /*int*/) {
                        value = value | 0;
                        this._ensureLineMetrics();
                        this._textContent.scrollH = clamp(Math.abs(value), 0, this._maxScrollH);
                        this._invalidateContent();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "scrollV", {
                    // Returns the current horizontal scrolling position in pixels.
                    get: function () {
                        return this._textContent.scrollV;
                    },
                    set: function (value /*int*/) {
                        value = value | 0;
                        this._ensureLineMetrics();
                        this._textContent.scrollV = clamp(value, 1, this._maxScrollV);
                        this._invalidateContent();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "selectable", {
                    get: function () {
                        return this._selectable;
                    },
                    set: function (value) {
                        this._selectable = !!value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "selectedText", {
                    get: function () {
                        return this._textContent.plainText.substring(this._selectionBeginIndex, this._selectionEndIndex);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "selectionBeginIndex", {
                    get: function () {
                        return this._selectionBeginIndex;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "selectionEndIndex", {
                    get: function () {
                        return this._selectionEndIndex;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "sharpness", {
                    get: function () {
                        return this._sharpness;
                    },
                    set: function (value) {
                        this._sharpness = clamp(+value, -400, 400);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "styleSheet", {
                    get: function () {
                        return this._styleSheet;
                    },
                    set: function (value) {
                        this._styleSheet = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "text", {
                    get: function () {
                        return this._textContent.plainText;
                    },
                    set: function (value) {
                        if (Shumway.isNullOrUndefined(value)) {
                            this._sec.throwError('TypeError', Shumway.Errors.NullPointerError, 'value');
                        }
                        value = value || '';
                        if (value === this._textContent.plainText) {
                            return;
                        }
                        this._textContent.plainText = value;
                        this._invalidateContent();
                        this._ensureLineMetrics();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "textColor", {
                    get: function () {
                        return this._textColor === null ? +this._textContent.defaultTextFormat.color : this._textColor;
                    },
                    set: function (value /*uint*/) {
                        this._textColor = this._textContent.defaultTextFormat.color = value >>> 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "textHeight", {
                    get: function () {
                        this._ensureLineMetrics();
                        return (this._textHeight / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "textWidth", {
                    get: function () {
                        this._ensureLineMetrics();
                        return (this._textWidth / 20) | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "thickness", {
                    get: function () {
                        return this._thickness;
                    },
                    set: function (value) {
                        this._thickness = clamp(+value, -200, 200);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "type", {
                    get: function () {
                        return this._type;
                    },
                    set: function (value) {
                        this._type = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "wordWrap", {
                    get: function () {
                        return this._textContent.wordWrap;
                    },
                    set: function (value) {
                        value = !!value;
                        if (value === this._textContent.wordWrap) {
                            return;
                        }
                        this._textContent.wordWrap = !!value;
                        this._invalidateContent();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "useRichTextClipboard", {
                    get: function () {
                        release || notImplemented("public flash.text.TextField::get useRichTextClipboard");
                        return false;
                        // return this._useRichTextClipboard;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.text.TextField::set useRichTextClipboard");
                        return;
                        // this._useRichTextClipboard = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                TextField.prototype.copyRichText = function () {
                    release || notImplemented("public flash.text.TextField::copyRichText");
                };
                TextField.prototype.pasteRichText = function (richText) {
                    release || notImplemented("public flash.text.TextField::pasteRichText");
                };
                TextField.prototype.getXMLText = function (beginIndex, endIndex) {
                    if (endIndex === void 0) { endIndex = 2147483647; }
                    beginIndex = +beginIndex;
                    endIndex = +endIndex;
                    release || notImplemented("public flash.text.TextField::getXMLText");
                    return "";
                };
                TextField.prototype.insertXMLText = function (beginIndex, endIndex, richText, pasting) {
                    beginIndex = +beginIndex;
                    endIndex = +endIndex;
                    pasting = !!pasting;
                    release || notImplemented("public flash.text.TextField::insertXMLText");
                };
                TextField.prototype._ensureLineMetrics = function () {
                    if (!this._hasDirtyFlags(8 /* DirtyTextContent */)) {
                        return;
                    }
                    var serializer = this._sec.player;
                    var lineMetricsData = serializer.syncDisplayObject(this, false);
                    var textWidth = lineMetricsData.readInt();
                    var textHeight = lineMetricsData.readInt();
                    var offsetX = lineMetricsData.readInt();
                    var bounds = this._lineBounds;
                    if (this._autoSize !== text_1.TextFieldAutoSize.NONE) {
                        bounds.xMin = offsetX;
                        bounds.xMax = offsetX + textWidth + 80;
                        bounds.yMax = bounds.yMin + textHeight + 80;
                    }
                    this._textWidth = textWidth;
                    this._textHeight = textHeight;
                    this._numLines = lineMetricsData.readInt();
                    this._lineMetricsData = lineMetricsData;
                    if (this._textHeight > bounds.height) {
                        var maxScrollV = 1;
                        var bottomScrollV = 1;
                        lineMetricsData.position = 16;
                        var y = 0;
                        for (var i = 0; i < this._numLines; i++) {
                            lineMetricsData.position += 8;
                            var ascent = lineMetricsData.readInt();
                            var descent = lineMetricsData.readInt();
                            var leading = lineMetricsData.readInt();
                            var height = ascent + descent + leading;
                            if (y > bounds.height / 20) {
                                maxScrollV++;
                            }
                            else {
                                bottomScrollV++;
                            }
                            y += height;
                        }
                        this._maxScrollV = maxScrollV;
                        this._bottomScrollV = bottomScrollV;
                    }
                    if (this._textWidth > bounds.width) {
                        this._maxScrollH = (((this._textWidth + 80) - bounds.width) / 20) | 0;
                    }
                    else {
                        this._maxScrollH = 0;
                    }
                };
                TextField.prototype.appendText = function (newText) {
                    this._textContent.appendText(newText);
                };
                TextField.prototype.getCharBoundaries = function (charIndex /*int*/) {
                    charIndex = charIndex | 0;
                    release || somewhatImplemented("public flash.text.TextField::getCharBoundaries");
                    var fakeCharHeight = this.textHeight, fakeCharWidth = fakeCharHeight * 0.75;
                    return this._sec.geom.Rectangle.create([charIndex * fakeCharWidth, 0,
                        fakeCharWidth, fakeCharHeight]);
                };
                TextField.prototype.getCharIndexAtPoint = function (x, y) {
                    x = +x;
                    y = +y;
                    release || notImplemented("public flash.text.TextField::getCharIndexAtPoint");
                    return 0;
                };
                TextField.prototype.getFirstCharInParagraph = function (charIndex /*int*/) {
                    charIndex = charIndex | 0;
                    release || notImplemented("public flash.text.TextField::getFirstCharInParagraph");
                    return 0;
                };
                TextField.prototype.getLineIndexAtPoint = function (x, y) {
                    x = +x;
                    y = +y;
                    release || notImplemented("public flash.text.TextField::getLineIndexAtPoint");
                    return 0;
                };
                TextField.prototype.getLineIndexOfChar = function (charIndex /*int*/) {
                    charIndex = charIndex | 0;
                    release || notImplemented("public flash.text.TextField::getLineIndexOfChar");
                    return 0;
                };
                TextField.prototype.getLineLength = function (lineIndex /*int*/) {
                    lineIndex = lineIndex | 0;
                    release || notImplemented("public flash.text.TextField::getLineLength");
                    return 0;
                };
                TextField.prototype.getLineMetrics = function (lineIndex /*int*/) {
                    lineIndex = lineIndex | 0;
                    if (lineIndex < 0 || lineIndex > this._numLines - 1) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    this._ensureLineMetrics();
                    var lineMetricsData = this._lineMetricsData;
                    lineMetricsData.position = 16 + lineIndex * 20;
                    // The lines left position includes the gutter widths (it should also include the the margin
                    // and indent, which we don't support yet).
                    var x = lineMetricsData.readInt() + this._lineBounds.xMin + 2;
                    var width = lineMetricsData.readInt();
                    var ascent = lineMetricsData.readInt();
                    var descent = lineMetricsData.readInt();
                    var leading = lineMetricsData.readInt();
                    var height = ascent + descent + leading;
                    return this._sec.text.TextLineMetrics.create([x, width, height, ascent, descent,
                        leading]);
                };
                TextField.prototype.getLineOffset = function (lineIndex /*int*/) {
                    lineIndex = lineIndex | 0;
                    var lines = this._textContent.plainText.split('\r');
                    if (lineIndex < 0 || lineIndex >= lines.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    var offset = 0;
                    for (var i = 0; i < lineIndex; i++) {
                        offset += lines[i].length + 1; // Length + `\r`
                    }
                    // TODO:  I've tried modifying the width of the text field so that lines wrap, but this doesn't seem
                    // to have any effect on how line offsets are computed. I'm leaving in the |somewhatImplemented| call
                    // since this is not fully tested.
                    release || release || somewhatImplemented("public flash.text.TextField::getLineOffset");
                    return offset;
                };
                TextField.prototype.getLineText = function (lineIndex /*int*/) {
                    lineIndex = lineIndex | 0;
                    var lines = this._textContent.plainText.split('\r');
                    if (lineIndex < 0 || lineIndex >= lines.length) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    return lines[lineIndex];
                };
                TextField.prototype.getParagraphLength = function (charIndex /*int*/) {
                    charIndex = charIndex | 0;
                    release || notImplemented("public flash.text.TextField::getParagraphLength");
                    return 0;
                };
                /**
                 * Returns a TextFormat object that contains the intersection of formatting information for the
                 * range of text between |beginIndex| and |endIndex|.
                 */
                TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
                    if (beginIndex === void 0) { beginIndex = -1; }
                    if (endIndex === void 0) { endIndex = -1; }
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    var plainText = this._textContent.plainText;
                    var maxIndex = plainText.length;
                    if (beginIndex < 0) {
                        beginIndex = 0;
                        if (endIndex < 0) {
                            endIndex = maxIndex;
                        }
                    }
                    else {
                        if (endIndex < 0) {
                            endIndex = beginIndex + 1;
                        }
                    }
                    if (endIndex <= beginIndex || endIndex > maxIndex) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    var format;
                    var textRuns = this._textContent.textRuns;
                    for (var i = 0; i < textRuns.length; i++) {
                        var run = textRuns[i];
                        if (run.intersects(beginIndex, endIndex)) {
                            if (format) {
                                format.intersect(run.textFormat);
                            }
                            else {
                                format = run.textFormat.clone();
                            }
                        }
                    }
                    return format;
                };
                TextField.prototype.getTextRuns = function (beginIndex, endIndex) {
                    if (beginIndex === void 0) { beginIndex = 0; }
                    if (endIndex === void 0) { endIndex = 2147483647; }
                    var textRuns = this._textContent.textRuns;
                    var result = [];
                    for (var i = 0; i < textRuns.length; i++) {
                        var textRun = textRuns[i];
                        if (textRun.beginIndex >= beginIndex && textRun.endIndex <= endIndex) {
                            result.push(textRun.clone());
                        }
                    }
                    return result;
                };
                TextField.prototype.getRawText = function () {
                    release || notImplemented("public flash.text.TextField::getRawText");
                    return "";
                };
                TextField.prototype.replaceSelectedText = function (value) {
                    value = "" + value;
                    this.replaceText(this._selectionBeginIndex, this._selectionEndIndex, value);
                };
                TextField.prototype.replaceText = function (beginIndex /*int*/, endIndex /*int*/, newText) {
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    newText = "" + newText;
                    if (beginIndex < 0 || endIndex < 0) {
                        return;
                    }
                    this._textContent.replaceText(beginIndex, endIndex, newText);
                    this._invalidateContent();
                    this._ensureLineMetrics();
                };
                TextField.prototype.setSelection = function (beginIndex /*int*/, endIndex /*int*/) {
                    this._selectionBeginIndex = beginIndex | 0;
                    this._selectionEndIndex = endIndex | 0;
                };
                TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
                    if (beginIndex === void 0) { beginIndex = -1; }
                    if (endIndex === void 0) { endIndex = -1; }
                    format = format;
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    var plainText = this._textContent.plainText;
                    var maxIndex = plainText.length;
                    if (beginIndex < 0) {
                        beginIndex = 0;
                        if (endIndex < 0) {
                            endIndex = maxIndex;
                        }
                    }
                    else {
                        if (endIndex < 0) {
                            endIndex = beginIndex + 1;
                        }
                    }
                    if (beginIndex > maxIndex || endIndex > maxIndex) {
                        this._sec.throwError('RangeError', Shumway.Errors.ParamRangeError);
                    }
                    if (endIndex <= beginIndex) {
                        return;
                    }
                    var subText = plainText.substring(beginIndex, endIndex);
                    this._textContent.replaceText(beginIndex, endIndex, subText, format);
                    this._invalidateContent();
                    this._ensureLineMetrics();
                };
                TextField.prototype.getImageReference = function (id) {
                    //id = "" + id;
                    release || notImplemented("public flash.text.TextField::getImageReference");
                    return null;
                };
                return TextField;
            }(flash.display.InteractiveObject));
            text_1.TextField = TextField;
            var TextSymbol = /** @class */ (function (_super) {
                __extends(TextSymbol, _super);
                function TextSymbol(data, _sec) {
                    var _this = _super.call(this, data, _sec.text.TextField, true) || this;
                    _this.color = 0;
                    _this.size = 0;
                    _this.face = "";
                    _this.bold = false;
                    _this.italic = false;
                    _this.align = flash.text.TextFormatAlign.LEFT;
                    _this.leftMargin = 0;
                    _this.rightMargin = 0;
                    _this.indent = 0;
                    _this.leading = 0;
                    _this.multiline = false;
                    _this.wordWrap = false;
                    _this.embedFonts = false;
                    _this.selectable = true;
                    _this.border = false;
                    _this.initialText = "";
                    _this.html = false;
                    _this.displayAsPassword = false;
                    _this.type = flash.text.TextFieldType.DYNAMIC;
                    _this.maxChars = 0;
                    _this.autoSize = flash.text.TextFieldAutoSize.NONE;
                    _this.variableName = null;
                    _this.textContent = null;
                    return _this;
                }
                TextSymbol.FromTextData = function (data, loaderInfo) {
                    var _sec = loaderInfo._sec;
                    var symbol = new TextSymbol(data, _sec);
                    symbol._setBoundsFromData(data);
                    var tag = data.tag;
                    if (data.static) {
                        symbol.dynamic = false;
                        symbol.symbolClass = _sec.text.StaticText;
                        if (tag.initialText) {
                            var textContent = new Shumway.TextContent(_sec);
                            textContent.bounds = symbol.lineBounds;
                            textContent.parseHtml(tag.initialText, null, false);
                            textContent.matrix = _sec.geom.Matrix.create();
                            textContent.matrix.copyFromUntyped(data.matrix);
                            textContent.coords = data.coords;
                            symbol.textContent = textContent;
                        }
                    }
                    if (tag.flags & 4 /* HasColor */) {
                        symbol.color = tag.color >>> 8;
                    }
                    if (tag.flags & 1 /* HasFont */) {
                        symbol.size = tag.fontHeight;
                        // Requesting the font symbol guarantees that it's loaded and initialized.
                        var fontSymbol = loaderInfo.getSymbolById(tag.fontId);
                        if (fontSymbol) {
                            symbol.face = tag.flags & 256 /* UseOutlines */ ?
                                fontSymbol.name :
                                'swffont' + fontSymbol.syncId;
                            symbol.bold = fontSymbol.bold;
                            symbol.italic = fontSymbol.italic;
                        }
                        else {
                            warning("Font " + tag.fontId + " is not defined.");
                        }
                    }
                    if (tag.flags & 8192 /* HasLayout */) {
                        symbol.align = flash.text.TextFormatAlign.fromNumber(tag.align);
                        symbol.leftMargin = tag.leftMargin;
                        symbol.rightMargin = tag.rightMargin;
                        symbol.indent = tag.indent;
                        symbol.leading = tag.leading;
                    }
                    symbol.multiline = !!(tag.flags & 32 /* Multiline */);
                    symbol.wordWrap = !!(tag.flags & 64 /* WordWrap */);
                    symbol.embedFonts = !!(tag.flags & 256 /* UseOutlines */);
                    symbol.selectable = !(tag.flags & 4096 /* NoSelect */);
                    symbol.border = !!(tag.flags & 2048 /* Border */);
                    if (tag.flags & 128 /* HasText */) {
                        symbol.initialText = tag.initialText;
                    }
                    symbol.html = !!(tag.flags & 512 /* Html */);
                    symbol.displayAsPassword = !!(tag.flags & 16 /* Password */);
                    symbol.type = tag.flags & 8 /* ReadOnly */ ?
                        flash.text.TextFieldType.DYNAMIC :
                        flash.text.TextFieldType.INPUT;
                    if (tag.flags & 2 /* HasMaxLength */) {
                        symbol.maxChars = tag.maxLength;
                    }
                    symbol.autoSize = tag.flags & 16384 /* AutoSize */ ?
                        flash.text.TextFieldAutoSize.LEFT :
                        flash.text.TextFieldAutoSize.NONE;
                    symbol.variableName = tag.variableName;
                    return symbol;
                };
                /**
                 * Turns raw DefineLabel tag data into an object that's consumable as a text symbol and then
                 * passes that into `FromTextData`, returning the resulting TextSymbol.
                 *
                 * This has to be done outside the SWF parser because it relies on any used fonts being
                 * available as symbols, which isn't the case in the SWF parser.
                 */
                TextSymbol.FromLabelData = function (data, loaderInfo) {
                    var bounds = data.fillBounds;
                    var records = data.records;
                    var coords = data.coords = [];
                    var htmlText = '';
                    var size = 12;
                    var face = 'Times Roman';
                    var bold = false;
                    var italic = false;
                    var color = 0;
                    var x = 0;
                    var y = 0;
                    var codes;
                    for (var i = 0; i < records.length; i++) {
                        var record = records[i];
                        if (record.flags & 8 /* HasFont */) {
                            var fontSymbol = loaderInfo.getSymbolById(record.fontId);
                            if (fontSymbol) {
                                codes = fontSymbol.codes;
                                size = record.fontHeight;
                                if (!fontSymbol.originalSize) {
                                    size /= 20;
                                }
                                face = fontSymbol.metrics ? 'swffont' + fontSymbol.syncId : fontSymbol.name;
                                bold = fontSymbol.bold;
                                italic = fontSymbol.italic;
                            }
                            else {
                                Shumway.Debug.warning('Label ' + data.id + 'refers to undefined font symbol ' + record.fontId);
                            }
                        }
                        if (record.flags & 4 /* HasColor */) {
                            color = record.color >>> 8;
                        }
                        if (record.flags & 1 /* HasMoveX */) {
                            x = record.moveX;
                        }
                        if (record.flags & 2 /* HasMoveY */) {
                            y = record.moveY;
                        }
                        var text_2 = '';
                        var entries = record.entries;
                        var j = 0;
                        var entry = void 0;
                        while ((entry = entries[j++])) {
                            var code = codes[entry.glyphIndex];
                            release || assert(code, 'undefined label glyph');
                            var char = String.fromCharCode(code);
                            text_2 += charEscapeMap[char] || char;
                            coords.push(x, y);
                            x += entry.advance;
                        }
                        if (italic) {
                            text_2 = '<i>' + text_2 + '</i>';
                        }
                        if (bold) {
                            text_2 = '<b>' + text_2 + '</b>';
                        }
                        htmlText += '<font size="' + size + '" face="' + face + '"' + ' color="#' +
                            ('000000' + color.toString(16)).slice(-6) + '">' + text_2 + '</font>';
                    }
                    data.tag.initialText = htmlText;
                    return TextSymbol.FromTextData(data, loaderInfo);
                };
                return TextSymbol;
            }(Shumway.Timeline.DisplaySymbol));
            text_1.TextSymbol = TextSymbol;
            var charEscapeMap = { '<': '&lt;', '>': '&gt;', '&': '&amp;' };
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextFieldAutoSize
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextFieldAutoSize;
            (function (TextFieldAutoSize) {
                TextFieldAutoSize["NONE"] = "none";
                TextFieldAutoSize["LEFT"] = "left";
                TextFieldAutoSize["CENTER"] = "center";
                TextFieldAutoSize["RIGHT"] = "right";
            })(TextFieldAutoSize = text.TextFieldAutoSize || (text.TextFieldAutoSize = {}));
            (function (TextFieldAutoSize) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return TextFieldAutoSize.NONE;
                        case 1:
                            return TextFieldAutoSize.CENTER;
                        case 2:
                            return TextFieldAutoSize.LEFT;
                        case 3:
                            return TextFieldAutoSize.RIGHT;
                        default:
                            return null;
                    }
                }
                TextFieldAutoSize.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case TextFieldAutoSize.NONE:
                            return 0;
                        case TextFieldAutoSize.CENTER:
                            return 1;
                        case TextFieldAutoSize.LEFT:
                            return 2;
                        case TextFieldAutoSize.RIGHT:
                            return 3;
                        default:
                            return -1;
                    }
                }
                TextFieldAutoSize.toNumber = toNumber;
            })(TextFieldAutoSize = text.TextFieldAutoSize || (text.TextFieldAutoSize = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextFieldType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextFieldType;
            (function (TextFieldType) {
                TextFieldType["INPUT"] = "input";
                TextFieldType["DYNAMIC"] = "dynamic";
            })(TextFieldType = text.TextFieldType || (text.TextFieldType = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextFormat
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var roundHalfEven = Shumway.NumberUtilities.roundHalfEven;
            var TextFormat = /** @class */ (function (_super) {
                __extends(TextFormat, _super);
                function TextFormat(font, size, color, bold, italic, underline, url, target, align, leftMargin, rightMargin, indent, leading) {
                    if (font === void 0) { font = null; }
                    if (size === void 0) { size = null; }
                    if (color === void 0) { color = null; }
                    if (bold === void 0) { bold = null; }
                    if (italic === void 0) { italic = null; }
                    if (underline === void 0) { underline = null; }
                    if (url === void 0) { url = null; }
                    if (target === void 0) { target = null; }
                    if (align === void 0) { align = null; }
                    if (leftMargin === void 0) { leftMargin = null; }
                    if (rightMargin === void 0) { rightMargin = null; }
                    if (indent === void 0) { indent = null; }
                    if (leading === void 0) { leading = null; }
                    var _this = _super.call(this) || this;
                    _this.font = font;
                    _this.size = size;
                    _this.color = color;
                    _this.bold = bold;
                    _this.italic = italic;
                    _this.underline = underline;
                    _this.url = url;
                    _this.target = target;
                    _this.align = align;
                    _this.leftMargin = leftMargin;
                    _this.rightMargin = rightMargin;
                    _this.indent = indent;
                    _this.leading = leading;
                    _this._blockIndent = null;
                    _this._bullet = null;
                    _this._display = text.TextFormatDisplay.BLOCK;
                    _this._kerning = null;
                    _this._letterSpacing = null;
                    _this._tabStops = null;
                    return _this;
                }
                Object.defineProperty(TextFormat.prototype, "align", {
                    // AS -> JS Bindings
                    get: function () {
                        return this._align;
                    },
                    set: function (value) {
                        //if (TextFormatAlign.toNumber(value) < 0) {
                        //  this.sec.throwError("ArgumentError", Errors.InvalidEnumError, "align");
                        //}
                        this._align = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "blockIndent", {
                    get: function () {
                        return this._blockIndent;
                    },
                    set: function (value) {
                        this._blockIndent = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "bold", {
                    get: function () {
                        return this._bold;
                    },
                    set: function (value) {
                        this._bold = TextFormat.coerceBoolean(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "bullet", {
                    get: function () {
                        return this._bullet;
                    },
                    set: function (value) {
                        this._bullet = TextFormat.coerceBoolean(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "color", {
                    get: function () {
                        return this._color;
                    },
                    set: function (value) {
                        this._color = value != null ? +value | 0 : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "display", {
                    get: function () {
                        return this._display;
                    },
                    set: function (value) {
                        this._display = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "font", {
                    get: function () {
                        return this._font;
                    },
                    set: function (value) {
                        this._font = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "style", {
                    get: function () {
                        if (this._bold && this._italic) {
                            return text.FontStyle.BOLD_ITALIC;
                        }
                        else if (this._bold) {
                            return text.FontStyle.BOLD;
                        }
                        else if (this._italic) {
                            return text.FontStyle.ITALIC;
                        }
                        else {
                            return text.FontStyle.REGULAR;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "indent", {
                    get: function () {
                        return this._indent;
                    },
                    set: function (value) {
                        this._indent = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "italic", {
                    get: function () {
                        return this._italic;
                    },
                    set: function (value) {
                        this._italic = TextFormat.coerceBoolean(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "kerning", {
                    get: function () {
                        return this._kerning;
                    },
                    set: function (value) {
                        this._kerning = TextFormat.coerceBoolean(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "leading", {
                    get: function () {
                        return this._leading;
                    },
                    set: function (value) {
                        this._leading = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "leftMargin", {
                    get: function () {
                        return this._leftMargin;
                    },
                    set: function (value) {
                        this._leftMargin = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "letterSpacing", {
                    get: function () {
                        return this._letterSpacing;
                    },
                    set: function (value) {
                        this._letterSpacing = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "rightMargin", {
                    get: function () {
                        return this._rightMargin;
                    },
                    set: function (value) {
                        this._rightMargin = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "size", {
                    get: function () {
                        return this._size;
                    },
                    set: function (value) {
                        this._size = TextFormat.coerceNumber(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "tabStops", {
                    get: function () {
                        return this._tabStops;
                    },
                    set: function (value) {
                        if (value == null) {
                            this._tabStops = null;
                            return;
                        }
                        if (!(value instanceof Array)) {
                            this._sec.throwError("ArgumentError", Shumway.Errors.CheckTypeFailedError, value, 'Array');
                        }
                        this._tabStops = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "target", {
                    get: function () {
                        return this._target;
                    },
                    set: function (value) {
                        this._target = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "underline", {
                    get: function () {
                        return this._underline;
                    },
                    set: function (value) {
                        this._underline = TextFormat.coerceBoolean(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextFormat.prototype, "url", {
                    get: function () {
                        return this._url;
                    },
                    set: function (value) {
                        this._url = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * All integer values on TextFormat are typed as Object and coerced to ints using the following
                 * "algorithm":
                 * - if the supplied value is null or undefined, the field is set to null
                 * - else if coercing to number results in NaN or the value is greater than MAX_INT, set to
                 *   -0x80000000
                 * - else, round the coerced value using half-even rounding
                 */
                TextFormat.coerceNumber = function (value) {
                    /* tslint:disable */
                    if (value == undefined) {
                        return null;
                    }
                    /* tslint:enable */
                    if (isNaN(value) || value > 0xfffffff) {
                        return -0x80000000;
                    }
                    return roundHalfEven(value);
                };
                /**
                 * Boolean values are only stored as bools if they're not undefined or null. In that case,
                 * they're stored as null.
                 */
                TextFormat.coerceBoolean = function (value) {
                    /* tslint:disable */
                    return value == undefined ? null : !!value;
                    /* tslint:enable */
                };
                TextFormat.prototype.clone = function () {
                    var tf = this._sec.text.TextFormat.create([
                        this._font,
                        this._size,
                        this._color,
                        this._bold,
                        this._italic,
                        this._underline,
                        this._url,
                        this._target,
                        this._align,
                        this._leftMargin,
                        this._rightMargin,
                        this._indent,
                        this._leading
                    ]);
                    tf._blockIndent = this._blockIndent;
                    tf._bullet = this._bullet;
                    tf._display = this._display;
                    tf._kerning = this._kerning;
                    tf._letterSpacing = this._letterSpacing;
                    tf._tabStops = this._tabStops;
                    return tf;
                };
                TextFormat.prototype.equals = function (other) {
                    return this._align === other._align &&
                        this._blockIndent === other._blockIndent &&
                        this._bold === other._bold &&
                        this._bullet === other._bullet &&
                        this._color === other._color &&
                        this._display === other._display &&
                        this._font === other._font &&
                        this._indent === other._indent &&
                        this._italic === other._italic &&
                        this._kerning === other._kerning &&
                        this._leading === other._leading &&
                        this._leftMargin === other._leftMargin &&
                        this._letterSpacing === other._letterSpacing &&
                        this._rightMargin === other._rightMargin &&
                        this._size === other._size &&
                        this._tabStops === other._tabStops &&
                        this._target === other._target &&
                        this._underline === other._underline &&
                        this._url === other._url;
                };
                TextFormat.prototype.merge = function (other) {
                    if (other._align !== null) {
                        this._align = other._align;
                    }
                    if (other._blockIndent !== null) {
                        this._blockIndent = other._blockIndent;
                    }
                    if (other._bold !== null) {
                        this._bold = other._bold;
                    }
                    if (other._bullet !== null) {
                        this._bullet = other._bullet;
                    }
                    if (other._color !== null) {
                        this._color = other._color;
                    }
                    if (other._display !== null) {
                        this._display = other._display;
                    }
                    if (other._font) {
                        this._font = other._font;
                    }
                    if (other._indent !== null) {
                        this._indent = other._indent;
                    }
                    if (other._italic !== null) {
                        this._italic = other._italic;
                    }
                    if (other._kerning !== null) {
                        this._kerning = other._kerning;
                    }
                    if (other._leading !== null) {
                        this._leading = other._leading;
                    }
                    if (other._leftMargin !== null) {
                        this._leftMargin = other._leftMargin;
                    }
                    if (other._letterSpacing !== null) {
                        this._letterSpacing = other._letterSpacing;
                    }
                    if (other._rightMargin !== null) {
                        this._rightMargin = other._rightMargin;
                    }
                    if (other._size !== null) {
                        this._size = other._size;
                    }
                    if (other._tabStops !== null) {
                        this._tabStops = other._tabStops;
                    }
                    if (other._target) {
                        this._target = other._target;
                    }
                    if (other._underline !== null) {
                        this._underline = other._underline;
                    }
                    if (other._url) {
                        this._url = other._url;
                    }
                };
                TextFormat.prototype.intersect = function (other) {
                    if (other._align !== this._align) {
                        this._align = null;
                    }
                    if (other._blockIndent !== this._blockIndent) {
                        this._blockIndent = null;
                    }
                    if (other._bold !== this._bold) {
                        this._bold = null;
                    }
                    if (other._bullet !== this._bullet) {
                        this._bullet = null;
                    }
                    if (other._color !== this._color) {
                        this._color = null;
                    }
                    if (other._display !== this._display) {
                        this._display = null;
                    }
                    if (other._font !== this._font) {
                        this._font = null;
                    }
                    if (other._indent !== this._indent) {
                        this._indent = null;
                    }
                    if (other._italic !== this._italic) {
                        this._italic = null;
                    }
                    if (other._kerning !== this._kerning) {
                        this._kerning = null;
                    }
                    if (other._leading !== this._leading) {
                        this._leading = null;
                    }
                    if (other._leftMargin !== this._leftMargin) {
                        this._leftMargin = null;
                    }
                    if (other._letterSpacing !== this._letterSpacing) {
                        this._letterSpacing = null;
                    }
                    if (other._rightMargin !== this._rightMargin) {
                        this._rightMargin = null;
                    }
                    if (other._size !== this._size) {
                        this._size = null;
                    }
                    if (other._tabStops !== this._tabStops) {
                        this._tabStops = null;
                    }
                    if (other._target !== this._target) {
                        this._target = null;
                    }
                    if (other._underline !== this._underline) {
                        this._underline = null;
                    }
                    if (other._url !== this._url) {
                        this._url = null;
                    }
                };
                TextFormat.prototype.transform = function (formatObject) {
                    var v = formatObject.textAlign;
                    if (v) {
                        this.align = v;
                    }
                    v = formatObject.fontWeight;
                    if (v === "bold") {
                        this.bold = true;
                    }
                    else if (v === "normal") {
                        this.bold = false;
                    }
                    v = formatObject.color;
                    if (v) {
                        // When parsing colors, whitespace is trimmed away, and all numbers are accepted, as long
                        // as they make up the full string after the "#", without any non-numeric pre- or suffix.
                        // This implementation is somewhat atrocious, but it should be reasonably fast and works.
                        var colorStr = v.trim().toLowerCase();
                        if (colorStr[0] === '#') {
                            var numericPart = colorStr.substr(1);
                            while (numericPart[0] === '0') {
                                numericPart = numericPart.substr(1);
                            }
                            var colorVal = parseInt(numericPart, 16);
                            if (colorVal.toString(16) === numericPart) {
                                this.color = colorVal;
                            }
                        }
                    }
                    v = formatObject.display;
                    if (v) {
                        this.display = v;
                    }
                    v = formatObject.fontFamily;
                    if (v) {
                        // TODO: Sanitize fontFamily string.
                        this.font = v.replace('sans-serif', '_sans').replace('serif', '_serif');
                    }
                    v = formatObject.textIndent;
                    if (v) {
                        this.indent = parseInt(v);
                    }
                    v = formatObject.fontStyle;
                    if (v === "italic") {
                        this.italic = true;
                    }
                    else if (v === "normal") {
                        this.italic = false;
                    }
                    v = formatObject.kerning;
                    if (v === "true") {
                        this.kerning = 1;
                    }
                    else if (v === "false") {
                        this.kerning = 0;
                    }
                    else {
                        this.kerning = parseInt(v);
                    }
                    v = formatObject.leading;
                    if (v) {
                        this.leading = parseInt(v);
                    }
                    v = formatObject.marginLeft;
                    if (v) {
                        this.leftMargin = parseInt(v);
                    }
                    v = formatObject.letterSpacing;
                    if (v) {
                        this.letterSpacing = parseFloat(v);
                    }
                    v = formatObject.marginRight;
                    if (v) {
                        this.rightMargin = parseInt(v);
                    }
                    v = formatObject.fontSize;
                    if (v) {
                        var size = parseInt(v);
                        if (size > 0) {
                            this.size = size;
                        }
                    }
                    v = formatObject.textDecoration;
                    if (v === "none") {
                        this.underline = false;
                    }
                    else if (v === "underline") {
                        this.underline = true;
                    }
                    return this;
                };
                return TextFormat;
            }(flash.LegacyEntity));
            text.TextFormat = TextFormat;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextFormatAlign
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextFormatAlign;
            (function (TextFormatAlign) {
                TextFormatAlign["LEFT"] = "left";
                TextFormatAlign["CENTER"] = "center";
                TextFormatAlign["RIGHT"] = "right";
                TextFormatAlign["JUSTIFY"] = "justify";
                TextFormatAlign["START"] = "start";
                TextFormatAlign["END"] = "end";
            })(TextFormatAlign = text.TextFormatAlign || (text.TextFormatAlign = {}));
            (function (TextFormatAlign) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return TextFormatAlign.LEFT;
                        case 1:
                            return TextFormatAlign.RIGHT;
                        case 2:
                            return TextFormatAlign.CENTER;
                        case 3:
                            return TextFormatAlign.JUSTIFY;
                        case 4:
                            return TextFormatAlign.START;
                        case 5:
                            return TextFormatAlign.END;
                        default:
                            return null;
                    }
                }
                TextFormatAlign.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case TextFormatAlign.LEFT:
                            return 0;
                        case TextFormatAlign.RIGHT:
                            return 1;
                        case TextFormatAlign.CENTER:
                            return 2;
                        case TextFormatAlign.JUSTIFY:
                            return 3;
                        case TextFormatAlign.START:
                            return 4;
                        case TextFormatAlign.END:
                            return 5;
                        default:
                            return -1;
                    }
                }
                TextFormatAlign.toNumber = toNumber;
            })(TextFormatAlign = text.TextFormatAlign || (text.TextFormatAlign = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextFormatDisplay
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextFormatDisplay;
            (function (TextFormatDisplay) {
                TextFormatDisplay["INLINE"] = "inline";
                TextFormatDisplay["BLOCK"] = "block";
            })(TextFormatDisplay = text.TextFormatDisplay || (text.TextFormatDisplay = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextInteractionMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextInteractionMode;
            (function (TextInteractionMode) {
                TextInteractionMode["NORMAL"] = "normal";
                TextInteractionMode["SELECTION"] = "selection";
            })(TextInteractionMode = text.TextInteractionMode || (text.TextInteractionMode = {}));
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextLineMetrics
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextLineMetrics = /** @class */ (function (_super) {
                __extends(TextLineMetrics, _super);
                function TextLineMetrics(x, width, height, ascent, descent, leading) {
                    var _this = _super.call(this) || this;
                    _this.x = +x;
                    _this.width = +width;
                    _this.height = +height;
                    _this.ascent = +ascent;
                    _this.descent = +descent;
                    _this.leading = +leading;
                    return _this;
                }
                return TextLineMetrics;
            }(flash.LegacyEntity));
            text.TextLineMetrics = TextLineMetrics;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextRun
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var TextRun = /** @class */ (function (_super) {
                __extends(TextRun, _super);
                function TextRun(beginIndex /*int*/, endIndex /*int*/, textFormat) {
                    var _this = _super.call(this) || this;
                    _this._beginIndex = beginIndex | 0;
                    _this._endIndex = endIndex | 0;
                    _this._textFormat = textFormat;
                    return _this;
                }
                Object.defineProperty(TextRun.prototype, "beginIndex", {
                    get: function () {
                        return this._beginIndex;
                    },
                    set: function (value) {
                        this._beginIndex = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextRun.prototype, "endIndex", {
                    get: function () {
                        return this._endIndex;
                    },
                    set: function (value) {
                        this._endIndex = value | 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextRun.prototype, "textFormat", {
                    get: function () {
                        return this._textFormat;
                    },
                    set: function (value) {
                        this._textFormat = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                TextRun.prototype.clone = function () {
                    return this._sec.text.TextRun.create([this.beginIndex, this.endIndex,
                        this.textFormat.clone()]);
                };
                TextRun.prototype.containsIndex = function (index) {
                    return index >= this._beginIndex && index < this._endIndex;
                };
                TextRun.prototype.intersects = function (beginIndex, endIndex) {
                    return Math.max(this._beginIndex, beginIndex) < Math.min(this._endIndex, endIndex);
                };
                return TextRun;
            }(flash.LegacyEntity));
            text.TextRun = TextRun;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: TextSnapshot
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var text;
        (function (text) {
            var notImplemented = Shumway.Debug.notImplemented;
            var TextSnapshot = /** @class */ (function (_super) {
                __extends(TextSnapshot, _super);
                function TextSnapshot() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(TextSnapshot.prototype, "charCount", {
                    // _charCount: number /*int*/;
                    get: function () {
                        release || notImplemented("public flash.text.TextSnapshot::get charCount");
                        return 0;
                        // return this._charCount;
                    },
                    enumerable: true,
                    configurable: true
                });
                TextSnapshot.prototype.findText = function (beginIndex /*int*/, textToFind, caseSensitive) {
                    beginIndex = beginIndex | 0;
                    caseSensitive = !!caseSensitive;
                    release || notImplemented("public flash.text.TextSnapshot::findText");
                    return 0;
                };
                TextSnapshot.prototype.getSelected = function (beginIndex /*int*/, endIndex /*int*/) {
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    release || notImplemented("public flash.text.TextSnapshot::getSelected");
                    return false;
                };
                TextSnapshot.prototype.getSelectedText = function (includeLineEndings) {
                    if (includeLineEndings === void 0) { includeLineEndings = false; }
                    includeLineEndings = !!includeLineEndings;
                    release || notImplemented("public flash.text.TextSnapshot::getSelectedText");
                    return "";
                };
                TextSnapshot.prototype.getText = function (beginIndex /*int*/, endIndex /*int*/, includeLineEndings) {
                    if (includeLineEndings === void 0) { includeLineEndings = false; }
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    includeLineEndings = !!includeLineEndings;
                    release || notImplemented("public flash.text.TextSnapshot::getText");
                    return "";
                };
                TextSnapshot.prototype.getTextRunInfo = function (beginIndex /*int*/, endIndex /*int*/) {
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    release || notImplemented("public flash.text.TextSnapshot::getTextRunInfo");
                    return null;
                };
                TextSnapshot.prototype.hitTestTextNearPos = function (x, y, maxDistance) {
                    if (maxDistance === void 0) { maxDistance = 0; }
                    x = +x;
                    y = +y;
                    maxDistance = +maxDistance;
                    release || notImplemented("public flash.text.TextSnapshot::hitTestTextNearPos");
                    return 0;
                };
                TextSnapshot.prototype.setSelectColor = function (hexColor) {
                    if (hexColor === void 0) { hexColor = 16776960; }
                    hexColor = hexColor >>> 0;
                    release || notImplemented("public flash.text.TextSnapshot::setSelectColor");
                    return;
                };
                TextSnapshot.prototype.setSelected = function (beginIndex /*int*/, endIndex /*int*/, select) {
                    beginIndex = beginIndex | 0;
                    endIndex = endIndex | 0;
                    select = !!select;
                    release || notImplemented("public flash.text.TextSnapshot::setSelected");
                    return;
                };
                return TextSnapshot;
            }(flash.LegacyEntity));
            text.TextSnapshot = TextSnapshot;
        })(text = flash.text || (flash.text = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Trace
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var trace;
        (function (trace) {
            var notImplemented = Shumway.Debug.notImplemented;
            var Trace = /** @class */ (function (_super) {
                __extends(Trace, _super);
                function Trace() {
                    return _super.call(this) || this;
                }
                // AS -> JS Bindings
                Trace.setLevel = function (l /*int*/, target) {
                    if (target === void 0) { target = 2; }
                    l = l | 0;
                    target = target | 0;
                    release || notImplemented("public flash.trace.Trace::static setLevel");
                    return;
                };
                Trace.getLevel = function (target) {
                    if (target === void 0) { target = 2; }
                    target = target | 0;
                    release || notImplemented("public flash.trace.Trace::static getLevel");
                    return 0;
                };
                Trace.setListener = function (f) {
                    f = f;
                    release || notImplemented("public flash.trace.Trace::static setListener");
                    return;
                };
                Trace.getListener = function () {
                    release || notImplemented("public flash.trace.Trace::static getListener");
                    return null;
                };
                // JS -> AS Bindings
                Trace.OFF = undefined;
                Trace.METHODS = 1;
                Trace.METHODS_WITH_ARGS = 2;
                Trace.METHODS_AND_LINES = 3;
                Trace.METHODS_AND_LINES_WITH_ARGS = 4;
                Trace.FILE = 1;
                Trace.LISTENER = 2;
                return Trace;
            }(flash.LegacyEntity));
            trace.Trace = Trace;
        })(trace = flash.trace || (flash.trace = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ContextMenu
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var ContextMenu = /** @class */ (function (_super) {
                __extends(ContextMenu, _super);
                function ContextMenu() {
                    var _this = _super.call(this) || this;
                    _this._builtInItems = _this._sec.ui.ContextMenuBuiltInItems.create();
                    _this._customItems = [];
                    return _this;
                }
                Object.defineProperty(ContextMenu, "isSupported", {
                    get: function () {
                        somewhatImplemented('ContextMenu::isSupported');
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenu.prototype, "builtInItems", {
                    get: function () {
                        // TODO: Should clone here probably.
                        release || somewhatImplemented("public flash.ui.ContextMenu::get builtInItems");
                        return this._builtInItems;
                    },
                    set: function (value) {
                        // TODO: Should clone here probably.
                        value = value;
                        release || somewhatImplemented("public flash.ui.ContextMenu::set builtInItems");
                        this._builtInItems = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenu.prototype, "customItems", {
                    get: function () {
                        // TODO: Should clone here probably.
                        release || somewhatImplemented("public flash.ui.ContextMenu::get customItems");
                        return this._customItems;
                    },
                    set: function (value) {
                        // TODO: Should clone here probably.
                        value = value;
                        release || somewhatImplemented("public flash.ui.ContextMenu::set customItems");
                        this._customItems = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenu.prototype, "link", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.ContextMenu::get link");
                        return this._link;
                    },
                    set: function (value) {
                        value = value;
                        release || somewhatImplemented("public flash.ui.ContextMenu::set link");
                        this._link = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenu.prototype, "clipboardMenu", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.ContextMenu::get clipboardMenu");
                        return this._clipboardMenu;
                    },
                    set: function (value) {
                        value = !!value;
                        release || somewhatImplemented("public flash.ui.ContextMenu::set clipboardMenu");
                        this._clipboardMenu = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenu.prototype, "clipboardItems", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.ContextMenu::get clipboardItems");
                        return this._clipboardItems;
                    },
                    set: function (value) {
                        value = value;
                        release || somewhatImplemented("public flash.ui.ContextMenu::set clipboardItems");
                        this._clipboardItems = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                ContextMenu.prototype.hideBuiltInItems = function () {
                    var items = this.builtInItems;
                    if (!items) {
                        return;
                    }
                    items.save = false;
                    items.zoom = false;
                    items.quality = false;
                    items.play = false;
                    items.loop = false;
                    items.rewind = false;
                    items.forwardAndBack = false;
                    items.print = false;
                };
                ContextMenu.prototype.clone = function () {
                    var result = this._sec.ui.ContextMenu.create();
                    result._builtInItems = this._builtInItems.clone();
                    this.cloneLinkAndClipboardProperties(result);
                    var customItems = this._customItems;
                    for (var i = 0; i < customItems.length; i++) {
                        result._customItems.push(customItems[i].clone());
                    }
                    return result;
                };
                ContextMenu.prototype.cloneLinkAndClipboardProperties = function (c) {
                    c = c;
                    release || somewhatImplemented("public flash.ui.ContextMenu::cloneLinkAndClipboardProperties");
                    return;
                };
                return ContextMenu;
            }(flash.display.NativeMenu));
            ui.ContextMenu = ContextMenu;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ContextMenuBuiltInItems
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var ContextMenuBuiltInItems = /** @class */ (function (_super) {
                __extends(ContextMenuBuiltInItems, _super);
                function ContextMenuBuiltInItems() {
                    var _this = _super.call(this) || this;
                    _this._save = true;
                    _this._zoom = true;
                    _this._quality = true;
                    _this._play = true;
                    _this._loop = true;
                    _this._rewind = true;
                    _this._forwardAndBack = true;
                    _this._print = true;
                    return _this;
                }
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "save", {
                    get: function () {
                        return this._save;
                    },
                    set: function (val) {
                        this._save = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "zoom", {
                    get: function () {
                        return this._zoom;
                    },
                    set: function (val) {
                        this._zoom = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "quality", {
                    get: function () {
                        return this._quality;
                    },
                    set: function (val) {
                        this._quality = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "play", {
                    get: function () {
                        return this._play;
                    },
                    set: function (val) {
                        this._play = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "loop", {
                    get: function () {
                        return this._loop;
                    },
                    set: function (val) {
                        this._loop = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "rewind", {
                    get: function () {
                        return this._rewind;
                    },
                    set: function (val) {
                        this._rewind = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "forwardAndBack", {
                    get: function () {
                        return this._forwardAndBack;
                    },
                    set: function (val) {
                        this._forwardAndBack = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuBuiltInItems.prototype, "print", {
                    get: function () {
                        return this._print;
                    },
                    set: function (val) {
                        this._print = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                ContextMenuBuiltInItems.prototype.clone = function () {
                    var items = this._sec.ui.ContextMenuBuiltInItems.create();
                    items._save = this._save;
                    items._zoom = this._zoom;
                    items._quality = this._quality;
                    items._play = this._play;
                    items._loop = this._loop;
                    items._rewind = this._rewind;
                    items._forwardAndBack = this._forwardAndBack;
                    items._print = this._print;
                    return items;
                };
                return ContextMenuBuiltInItems;
            }(flash.LegacyEntity));
            ui.ContextMenuBuiltInItems = ContextMenuBuiltInItems;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ContextMenuClipboardItems
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var ContextMenuClipboardItems = /** @class */ (function (_super) {
                __extends(ContextMenuClipboardItems, _super);
                function ContextMenuClipboardItems() {
                    var _this = _super.call(this) || this;
                    _this._cut = true;
                    _this._copy = true;
                    _this._paste = true;
                    _this._clear = true;
                    _this._selectAll = true;
                    return _this;
                }
                Object.defineProperty(ContextMenuClipboardItems.prototype, "cut", {
                    get: function () {
                        release || somewhatImplemented("cut");
                        return this._cut;
                    },
                    set: function (val) {
                        release || somewhatImplemented("cut");
                        this._cut = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuClipboardItems.prototype, "copy", {
                    get: function () {
                        release || somewhatImplemented("copy");
                        return this._copy;
                    },
                    set: function (val) {
                        release || somewhatImplemented("copy");
                        this._copy = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuClipboardItems.prototype, "paste", {
                    get: function () {
                        release || somewhatImplemented("paste");
                        return this._paste;
                    },
                    set: function (val) {
                        release || somewhatImplemented("paste");
                        this._paste = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuClipboardItems.prototype, "clear", {
                    get: function () {
                        release || somewhatImplemented("clear");
                        return this._clear;
                    },
                    set: function (val) {
                        release || somewhatImplemented("clear");
                        this._clear = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuClipboardItems.prototype, "selectAll", {
                    get: function () {
                        release || somewhatImplemented("selectAll");
                        return this._selectAll;
                    },
                    set: function (val) {
                        release || somewhatImplemented("selectAll");
                        this._selectAll = !!val;
                    },
                    enumerable: true,
                    configurable: true
                });
                ContextMenuClipboardItems.prototype.clone = function () {
                    var items = this._sec.ui.ContextMenuClipboardItems.create();
                    items._cut = this._cut;
                    items._copy = this._copy;
                    items._paste = this._paste;
                    items._clear = this._clear;
                    items._selectAll = this._selectAll;
                    return items;
                };
                return ContextMenuClipboardItems;
            }(flash.LegacyEntity));
            ui.ContextMenuClipboardItems = ContextMenuClipboardItems;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: ContextMenuItem
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var ContextMenuItem = /** @class */ (function (_super) {
                __extends(ContextMenuItem, _super);
                function ContextMenuItem(caption, separatorBefore, enabled, visible) {
                    if (separatorBefore === void 0) { separatorBefore = false; }
                    if (enabled === void 0) { enabled = true; }
                    if (visible === void 0) { visible = true; }
                    var _this = _super.call(this) || this;
                    separatorBefore = !!separatorBefore;
                    enabled = !!enabled;
                    visible = !!visible;
                    _this._caption = caption ? caption : "";
                    _this._separatorBefore = separatorBefore;
                    _this._enabled = enabled;
                    _this._visible = visible;
                    return _this;
                }
                Object.defineProperty(ContextMenuItem.prototype, "caption", {
                    get: function () {
                        return this._caption;
                    },
                    set: function (value) {
                        this._caption = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuItem.prototype, "separatorBefore", {
                    get: function () {
                        return this._separatorBefore;
                    },
                    set: function (value) {
                        value = !!value;
                        this._separatorBefore = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ContextMenuItem.prototype, "visible", {
                    get: function () {
                        return this._visible;
                    },
                    set: function (value) {
                        value = !!value;
                        this._visible = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ContextMenuItem;
            }(flash.display.NativeMenuItem));
            ui.ContextMenuItem = ContextMenuItem;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInput
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var GameInput = /** @class */ (function (_super) {
                __extends(GameInput, _super);
                function GameInput() {
                    return _super.call(this, undefined) || this;
                }
                Object.defineProperty(GameInput.prototype, "numDevices", {
                    // JS -> AS Bindings
                    // AS -> JS Bindings
                    // static _numDevices: number /*int*/;
                    // static _isSupported: boolean;
                    get: function () {
                        release || somewhatImplemented("public flash.ui.GameInput::get numDevices");
                        return 0;
                        // return this._numDevices;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInput.prototype, "isSupported", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.GameInput::get isSupported");
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                GameInput.getDeviceAt = function (index /*int*/) {
                    index = index | 0;
                    release || somewhatImplemented("public flash.ui.GameInput::static getDeviceAt");
                    flash.system._currentDomain.throwError("RangeError", Shumway.Errors.ParamRangeError, "index");
                    return null;
                };
                return GameInput;
            }(flash.events.EventDispatcher));
            ui.GameInput = GameInput;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputControl
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var notImplemented = Shumway.Debug.notImplemented;
            var GameInputControl = /** @class */ (function (_super) {
                __extends(GameInputControl, _super);
                function GameInputControl() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(GameInputControl.prototype, "numValues", {
                    // _numValues: number /*int*/;
                    // _index: number /*int*/;
                    // _relative: boolean;
                    // _type: string;
                    // _hand: string;
                    // _finger: string;
                    // _device: flash.ui.GameInputDevice;
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get numValues");
                        return 0;
                        // return this._numValues;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "index", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get index");
                        return 0;
                        // return this._index;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "relative", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get relative");
                        return false;
                        // return this._relative;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "type", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get type");
                        return "";
                        // return this._type;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "hand", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get hand");
                        return "";
                        // return this._hand;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "finger", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get finger");
                        return "";
                        // return this._finger;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputControl.prototype, "device", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputControl::get device");
                        return null;
                        // return this._device;
                    },
                    enumerable: true,
                    configurable: true
                });
                GameInputControl.prototype.getValueAt = function (index) {
                    if (index === void 0) { index = 0; }
                    index = index | 0;
                    release || notImplemented("public flash.ui.GameInputControl::getValueAt");
                    return 0;
                };
                return GameInputControl;
            }(flash.events.EventDispatcher));
            ui.GameInputControl = GameInputControl;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputControlType
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var GameInputControlType;
            (function (GameInputControlType) {
                GameInputControlType["MOVEMENT"] = "movement";
                GameInputControlType["ROTATION"] = "rotation";
                GameInputControlType["DIRECTION"] = "direction";
                GameInputControlType["ACCELERATION"] = "acceleration";
                GameInputControlType["BUTTON"] = "button";
                GameInputControlType["TRIGGER"] = "trigger";
            })(GameInputControlType = ui.GameInputControlType || (ui.GameInputControlType = {}));
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputDevice
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var notImplemented = Shumway.Debug.notImplemented;
            var GameInputDevice = /** @class */ (function (_super) {
                __extends(GameInputDevice, _super);
                function GameInputDevice() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(GameInputDevice.prototype, "numControls", {
                    // _numControls: number /*int*/;
                    // _sampleInterval: number /*int*/;
                    // _enabled: boolean;
                    // _id: string;
                    // _name: string;
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputDevice::get numControls");
                        return 0;
                        // return this._numControls;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputDevice.prototype, "sampleInterval", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputDevice::get sampleInterval");
                        return 0;
                        // return this._sampleInterval;
                    },
                    set: function (val /*int*/) {
                        val = val | 0;
                        release || notImplemented("public flash.ui.GameInputDevice::set sampleInterval");
                        return;
                        // this._sampleInterval = val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputDevice.prototype, "enabled", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputDevice::get enabled");
                        return false;
                        // return this._enabled;
                    },
                    set: function (val) {
                        val = !!val;
                        release || notImplemented("public flash.ui.GameInputDevice::set enabled");
                        return;
                        // this._enabled = val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputDevice.prototype, "id", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputDevice::get id");
                        return "";
                        // return this._id;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GameInputDevice.prototype, "name", {
                    get: function () {
                        release || notImplemented("public flash.ui.GameInputDevice::get name");
                        return "";
                        // return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                GameInputDevice.prototype.getControlAt = function (i /*int*/) {
                    i = i | 0;
                    release || notImplemented("public flash.ui.GameInputDevice::getControlAt");
                    return null;
                };
                GameInputDevice.prototype.startCachingSamples = function (numSamples /*int*/, controls) {
                    numSamples = numSamples | 0;
                    controls = controls;
                    release || notImplemented("public flash.ui.GameInputDevice::startCachingSamples");
                    return;
                };
                GameInputDevice.prototype.stopCachingSamples = function () {
                    release || notImplemented("public flash.ui.GameInputDevice::stopCachingSamples");
                    return;
                };
                GameInputDevice.prototype.getCachedSamples = function (data, append) {
                    if (append === void 0) { append = false; }
                    data = data;
                    append = !!append;
                    release || notImplemented("public flash.ui.GameInputDevice::getCachedSamples");
                    return 0;
                };
                GameInputDevice.MAX_BUFFER_SIZE = 4800;
                return GameInputDevice;
            }(flash.events.EventDispatcher));
            ui.GameInputDevice = GameInputDevice;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputFinger
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var GameInputFinger;
            (function (GameInputFinger) {
                GameInputFinger["THUMB"] = "thumb";
                GameInputFinger["INDEX"] = "index";
                GameInputFinger["MIDDLE"] = "middle";
                GameInputFinger["UNKNOWN"] = "unknown";
            })(GameInputFinger = ui.GameInputFinger || (ui.GameInputFinger = {}));
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: GameInputHand
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var GameInputHand;
            (function (GameInputHand) {
                GameInputHand["RIGHT"] = "right";
                GameInputHand["LEFT"] = "left";
                GameInputHand["UNKNOWN"] = "unknown";
            })(GameInputHand = ui.GameInputHand || (ui.GameInputHand = {}));
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Keyboard
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var notImplemented = Shumway.Debug.notImplemented;
            /**
             * Dispatches AS3 keyboard events to the focus event dispatcher.
             */
            var KeyboardEventDispatcher = /** @class */ (function () {
                function KeyboardEventDispatcher() {
                    this._lastKeyCode = 0;
                    this._captureKeyPress = false;
                    this._charCodeMap = [];
                }
                /**
                 * Converts DOM keyboard event data into AS3 keyboard events.
                 */
                KeyboardEventDispatcher.prototype.dispatchKeyboardEvent = function (event) {
                    var keyCode = event.keyCode;
                    if (event.type === 'keydown') {
                        this._lastKeyCode = keyCode;
                        // Trying to capture charCode for ASCII keys.
                        this._captureKeyPress = keyCode === 8 || keyCode === 9 ||
                            keyCode === 13 || keyCode === 32 || (keyCode >= 48 && keyCode <= 90) ||
                            keyCode > 145;
                        if (this._captureKeyPress) {
                            return; // skipping keydown, waiting for keypress
                        }
                        this._charCodeMap[keyCode] = 0;
                    }
                    else if (event.type === 'keypress') {
                        if (this._captureKeyPress) {
                            keyCode = this._lastKeyCode;
                            this._charCodeMap[keyCode] = event.charCode;
                        }
                        else {
                            return;
                        }
                    }
                    if (this.target) {
                        var isKeyUp = event.type === 'keyup';
                        this.target.dispatchEvent(this.target._sec.events.KeyboardEvent.create([
                            isKeyUp ? 'keyUp' : 'keyDown',
                            true,
                            false,
                            isKeyUp ? this._charCodeMap[keyCode] : event.charCode,
                            isKeyUp ? event.keyCode : this._lastKeyCode,
                            event.location,
                            event.ctrlKey,
                            event.altKey,
                            event.shiftKey
                        ]));
                    }
                };
                return KeyboardEventDispatcher;
            }());
            ui.KeyboardEventDispatcher = KeyboardEventDispatcher;
            var Keyboard = /** @class */ (function (_super) {
                __extends(Keyboard, _super);
                function Keyboard() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Keyboard, "capsLock", {
                    // JS -> AS Bindings
                    //static KEYNAME_UPARROW: string = "Up";
                    //static KEYNAME_DOWNARROW: string = "Down";
                    //static KEYNAME_LEFTARROW: string = "Left";
                    //static KEYNAME_RIGHTARROW: string = "Right";
                    //static KEYNAME_F1: string = "F1";
                    //static KEYNAME_F2: string = "F2";
                    //static KEYNAME_F3: string = "F3";
                    //static KEYNAME_F4: string = "F4";
                    //static KEYNAME_F5: string = "F5";
                    //static KEYNAME_F6: string = "F6";
                    //static KEYNAME_F7: string = "F7";
                    //static KEYNAME_F8: string = "F8";
                    //static KEYNAME_F9: string = "F9";
                    //static KEYNAME_F10: string = "F10";
                    //static KEYNAME_F11: string = "F11";
                    //static KEYNAME_F12: string = "F12";
                    //static KEYNAME_F13: string = "F13";
                    //static KEYNAME_F14: string = "F14";
                    //static KEYNAME_F15: string = "F15";
                    //static KEYNAME_F16: string = "F16";
                    //static KEYNAME_F17: string = "F17";
                    //static KEYNAME_F18: string = "F18";
                    //static KEYNAME_F19: string = "F19";
                    //static KEYNAME_F20: string = "F20";
                    //static KEYNAME_F21: string = "F21";
                    //static KEYNAME_F22: string = "F22";
                    //static KEYNAME_F23: string = "F23";
                    //static KEYNAME_F24: string = "F24";
                    //static KEYNAME_F25: string = "F25";
                    //static KEYNAME_F26: string = "F26";
                    //static KEYNAME_F27: string = "F27";
                    //static KEYNAME_F28: string = "F28";
                    //static KEYNAME_F29: string = "F29";
                    //static KEYNAME_F30: string = "F30";
                    //static KEYNAME_F31: string = "F31";
                    //static KEYNAME_F32: string = "F32";
                    //static KEYNAME_F33: string = "F33";
                    //static KEYNAME_F34: string = "F34";
                    //static KEYNAME_F35: string = "F35";
                    //static KEYNAME_INSERT: string = "Insert";
                    //static KEYNAME_DELETE: string = "Delete";
                    //static KEYNAME_HOME: string = "Home";
                    //static KEYNAME_BEGIN: string = "Begin";
                    //static KEYNAME_END: string = "End";
                    //static KEYNAME_PAGEUP: string = "PgUp";
                    //static KEYNAME_PAGEDOWN: string = "PgDn";
                    //static KEYNAME_PRINTSCREEN: string = "PrntScrn";
                    //static KEYNAME_SCROLLLOCK: string = "ScrlLck";
                    //static KEYNAME_PAUSE: string = "Pause";
                    //static KEYNAME_SYSREQ: string = "SysReq";
                    //static KEYNAME_BREAK: string = "Break";
                    //static KEYNAME_RESET: string = "Reset";
                    //static KEYNAME_STOP: string = "Stop";
                    //static KEYNAME_MENU: string = "Menu";
                    //static KEYNAME_USER: string = "User";
                    //static KEYNAME_SYSTEM: string = "Sys";
                    //static KEYNAME_PRINT: string = "Print";
                    //static KEYNAME_CLEARLINE: string = "ClrLn";
                    //static KEYNAME_CLEARDISPLAY: string = "ClrDsp";
                    //static KEYNAME_INSERTLINE: string = "InsLn";
                    //static KEYNAME_DELETELINE: string = "DelLn";
                    //static KEYNAME_INSERTCHAR: string = "InsChr";
                    //static KEYNAME_DELETECHAR: string = "DelChr";
                    //static KEYNAME_PREV: string = "Prev";
                    //static KEYNAME_NEXT: string = "Next";
                    //static KEYNAME_SELECT: string = "Select";
                    //static KEYNAME_EXECUTE: string = "Exec";
                    //static KEYNAME_UNDO: string = "Undo";
                    //static KEYNAME_REDO: string = "Redo";
                    //static KEYNAME_FIND: string = "Find";
                    //static KEYNAME_HELP: string = "Help";
                    //static KEYNAME_MODESWITCH: string = "ModeSw";
                    //static STRING_UPARROW: string = "";
                    //static STRING_DOWNARROW: string = "";
                    //static STRING_LEFTARROW: string = "";
                    //static STRING_RIGHTARROW: string = "";
                    //static STRING_F1: string = "";
                    //static STRING_F2: string = "";
                    //static STRING_F3: string = "";
                    //static STRING_F4: string = "";
                    //static STRING_F5: string = "";
                    //static STRING_F6: string = "";
                    //static STRING_F7: string = "";
                    //static STRING_F8: string = "";
                    //static STRING_F9: string = "";
                    //static STRING_F10: string = "";
                    //static STRING_F11: string = "";
                    //static STRING_F12: string = "";
                    //static STRING_F13: string = "";
                    //static STRING_F14: string = "";
                    //static STRING_F15: string = "";
                    //static STRING_F16: string = "";
                    //static STRING_F17: string = "";
                    //static STRING_F18: string = "";
                    //static STRING_F19: string = "";
                    //static STRING_F20: string = "";
                    //static STRING_F21: string = "";
                    //static STRING_F22: string = "";
                    //static STRING_F23: string = "";
                    //static STRING_F24: string = "";
                    //static STRING_F25: string = "";
                    //static STRING_F26: string = "";
                    //static STRING_F27: string = "";
                    //static STRING_F28: string = "";
                    //static STRING_F29: string = "";
                    //static STRING_F30: string = "";
                    //static STRING_F31: string = "";
                    //static STRING_F32: string = "";
                    //static STRING_F33: string = "";
                    //static STRING_F34: string = "";
                    //static STRING_F35: string = "";
                    //static STRING_INSERT: string = "";
                    //static STRING_DELETE: string = "";
                    //static STRING_HOME: string = "";
                    //static STRING_BEGIN: string = "";
                    //static STRING_END: string = "";
                    //static STRING_PAGEUP: string = "";
                    //static STRING_PAGEDOWN: string = "";
                    //static STRING_PRINTSCREEN: string = "";
                    //static STRING_SCROLLLOCK: string = "";
                    //static STRING_PAUSE: string = "";
                    //static STRING_SYSREQ: string = "";
                    //static STRING_BREAK: string = "";
                    //static STRING_RESET: string = "";
                    //static STRING_STOP: string = "";
                    //static STRING_MENU: string = "";
                    //static STRING_USER: string = "";
                    //static STRING_SYSTEM: string = "";
                    //static STRING_PRINT: string = "";
                    //static STRING_CLEARLINE: string = "";
                    //static STRING_CLEARDISPLAY: string = "";
                    //static STRING_INSERTLINE: string = "";
                    //static STRING_DELETELINE: string = "";
                    //static STRING_INSERTCHAR: string = "";
                    //static STRING_DELETECHAR: string = "";
                    //static STRING_PREV: string = "";
                    //static STRING_NEXT: string = "";
                    //static STRING_SELECT: string = "";
                    //static STRING_EXECUTE: string = "";
                    //static STRING_UNDO: string = "";
                    //static STRING_REDO: string = "";
                    //static STRING_FIND: string = "";
                    //static STRING_HELP: string = "";
                    //static STRING_MODESWITCH: string = "";
                    //static CharCodeStrings: any [] = undefined;
                    //static NUMBER_0: number /*uint*/ = 48;
                    //static NUMBER_1: number /*uint*/ = 49;
                    //static NUMBER_2: number /*uint*/ = 50;
                    //static NUMBER_3: number /*uint*/ = 51;
                    //static NUMBER_4: number /*uint*/ = 52;
                    //static NUMBER_5: number /*uint*/ = 53;
                    //static NUMBER_6: number /*uint*/ = 54;
                    //static NUMBER_7: number /*uint*/ = 55;
                    //static NUMBER_8: number /*uint*/ = 56;
                    //static NUMBER_9: number /*uint*/ = 57;
                    //static A: number /*uint*/ = 65;
                    //static B: number /*uint*/ = 66;
                    //static C: number /*uint*/ = 67;
                    //static D: number /*uint*/ = 68;
                    //static E: number /*uint*/ = 69;
                    //static F: number /*uint*/ = 70;
                    //static G: number /*uint*/ = 71;
                    //static H: number /*uint*/ = 72;
                    //static I: number /*uint*/ = 73;
                    //static J: number /*uint*/ = 74;
                    //static K: number /*uint*/ = 75;
                    //static L: number /*uint*/ = 76;
                    //static M: number /*uint*/ = 77;
                    //static N: number /*uint*/ = 78;
                    //static O: number /*uint*/ = 79;
                    //static P: number /*uint*/ = 80;
                    //static Q: number /*uint*/ = 81;
                    //static R: number /*uint*/ = 82;
                    //static S: number /*uint*/ = 83;
                    //static T: number /*uint*/ = 84;
                    //static U: number /*uint*/ = 85;
                    //static V: number /*uint*/ = 86;
                    //static W: number /*uint*/ = 87;
                    //static X: number /*uint*/ = 88;
                    //static Y: number /*uint*/ = 89;
                    //static Z: number /*uint*/ = 90;
                    //static SEMICOLON: number /*uint*/ = 186;
                    //static EQUAL: number /*uint*/ = 187;
                    //static COMMA: number /*uint*/ = 188;
                    //static MINUS: number /*uint*/ = 189;
                    //static PERIOD: number /*uint*/ = 190;
                    //static SLASH: number /*uint*/ = 191;
                    //static BACKQUOTE: number /*uint*/ = 192;
                    //static LEFTBRACKET: number /*uint*/ = 219;
                    //static BACKSLASH: number /*uint*/ = 220;
                    //static RIGHTBRACKET: number /*uint*/ = 221;
                    //static QUOTE: number /*uint*/ = 222;
                    //static ALTERNATE: number /*uint*/ = 18;
                    //static BACKSPACE: number /*uint*/ = 8;
                    //static CAPS_LOCK: number /*uint*/ = 20;
                    //static COMMAND: number /*uint*/ = 15;
                    //static CONTROL: number /*uint*/ = 17;
                    //static DELETE: number /*uint*/ = 46;
                    //static DOWN: number /*uint*/ = 40;
                    //static END: number /*uint*/ = 35;
                    //static ENTER: number /*uint*/ = 13;
                    //static ESCAPE: number /*uint*/ = 27;
                    //static F1: number /*uint*/ = 112;
                    //static F2: number /*uint*/ = 113;
                    //static F3: number /*uint*/ = 114;
                    //static F4: number /*uint*/ = 115;
                    //static F5: number /*uint*/ = 116;
                    //static F6: number /*uint*/ = 117;
                    //static F7: number /*uint*/ = 118;
                    //static F8: number /*uint*/ = 119;
                    //static F9: number /*uint*/ = 120;
                    //static F10: number /*uint*/ = 121;
                    //static F11: number /*uint*/ = 122;
                    //static F12: number /*uint*/ = 123;
                    //static F13: number /*uint*/ = 124;
                    //static F14: number /*uint*/ = 125;
                    //static F15: number /*uint*/ = 126;
                    //static HOME: number /*uint*/ = 36;
                    //static INSERT: number /*uint*/ = 45;
                    //static LEFT: number /*uint*/ = 37;
                    //static NUMPAD: number /*uint*/ = 21;
                    //static NUMPAD_0: number /*uint*/ = 96;
                    //static NUMPAD_1: number /*uint*/ = 97;
                    //static NUMPAD_2: number /*uint*/ = 98;
                    //static NUMPAD_3: number /*uint*/ = 99;
                    //static NUMPAD_4: number /*uint*/ = 100;
                    //static NUMPAD_5: number /*uint*/ = 101;
                    //static NUMPAD_6: number /*uint*/ = 102;
                    //static NUMPAD_7: number /*uint*/ = 103;
                    //static NUMPAD_8: number /*uint*/ = 104;
                    //static NUMPAD_9: number /*uint*/ = 105;
                    //static NUMPAD_ADD: number /*uint*/ = 107;
                    //static NUMPAD_DECIMAL: number /*uint*/ = 110;
                    //static NUMPAD_DIVIDE: number /*uint*/ = 111;
                    //static NUMPAD_ENTER: number /*uint*/ = 108;
                    //static NUMPAD_MULTIPLY: number /*uint*/ = 106;
                    //static NUMPAD_SUBTRACT: number /*uint*/ = 109;
                    //static PAGE_DOWN: number /*uint*/ = 34;
                    //static PAGE_UP: number /*uint*/ = 33;
                    //static RIGHT: number /*uint*/ = 39;
                    //static SHIFT: number /*uint*/ = 16;
                    //static SPACE: number /*uint*/ = 32;
                    //static TAB: number /*uint*/ = 9;
                    //static UP: number /*uint*/ = 38;
                    //static RED: number /*uint*/ = 16777216;
                    //static GREEN: number /*uint*/ = 16777217;
                    //static YELLOW: number /*uint*/ = 16777218;
                    //static BLUE: number /*uint*/ = 16777219;
                    //static CHANNEL_UP: number /*uint*/ = 16777220;
                    //static CHANNEL_DOWN: number /*uint*/ = 16777221;
                    //static RECORD: number /*uint*/ = 16777222;
                    //static PLAY: number /*uint*/ = 16777223;
                    //static PAUSE: number /*uint*/ = 16777224;
                    //static STOP: number /*uint*/ = 16777225;
                    //static FAST_FORWARD: number /*uint*/ = 16777226;
                    //static REWIND: number /*uint*/ = 16777227;
                    //static SKIP_FORWARD: number /*uint*/ = 16777228;
                    //static SKIP_BACKWARD: number /*uint*/ = 16777229;
                    //static NEXT: number /*uint*/ = 16777230;
                    //static PREVIOUS: number /*uint*/ = 16777231;
                    //static LIVE: number /*uint*/ = 16777232;
                    //static LAST: number /*uint*/ = 16777233;
                    //static MENU: number /*uint*/ = 16777234;
                    //static INFO: number /*uint*/ = 16777235;
                    //static GUIDE: number /*uint*/ = 16777236;
                    //static EXIT: number /*uint*/ = 16777237;
                    //static BACK: number /*uint*/ = 16777238;
                    //static AUDIO: number /*uint*/ = 16777239;
                    //static SUBTITLE: number /*uint*/ = 16777240;
                    //static DVR: number /*uint*/ = 16777241;
                    //static VOD: number /*uint*/ = 16777242;
                    //static INPUT: number /*uint*/ = 16777243;
                    //static SETUP: number /*uint*/ = 16777244;
                    //static HELP: number /*uint*/ = 16777245;
                    //static MASTER_SHELL: number /*uint*/ = 16777246;
                    //static SEARCH: number /*uint*/ = 16777247;
                    // AS -> JS Bindings
                    // static _capsLock: boolean;
                    // static _numLock: boolean;
                    // static _hasVirtualKeyboard: boolean;
                    // static _physicalKeyboardType: string;
                    get: function () {
                        release || notImplemented("public flash.ui.Keyboard::get capsLock");
                        return false;
                        // return this._capsLock;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard, "numLock", {
                    get: function () {
                        release || notImplemented("public flash.ui.Keyboard::get numLock");
                        return false;
                        // return this._numLock;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard, "hasVirtualKeyboard", {
                    get: function () {
                        release || notImplemented("public flash.ui.Keyboard::get hasVirtualKeyboard");
                        return false;
                        // return this._hasVirtualKeyboard;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Keyboard, "physicalKeyboardType", {
                    get: function () {
                        release || notImplemented("public flash.ui.Keyboard::get physicalKeyboardType");
                        return "";
                        // return this._physicalKeyboardType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Keyboard.isAccessible = function () {
                    release || notImplemented("public flash.ui.Keyboard::static isAccessible");
                    return false;
                };
                // Called whenever the class is initialized.
                Keyboard.classInitializer = null;
                // List of static symbols to link.
                Keyboard.classSymbols = null; // [];
                // List of instance symbols to link.
                Keyboard.instanceSymbols = null; // [];
                return Keyboard;
            }(flash.LegacyEntity));
            ui.Keyboard = Keyboard;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Mouse
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var notImplemented = Shumway.Debug.notImplemented;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var assert = Shumway.Debug.assert;
            var events = flash.events;
            /**
             * Dispatches AS3 mouse events.
             */
            var MouseEventDispatcher = /** @class */ (function () {
                function MouseEventDispatcher() {
                    this.stage = null;
                    this.currentTarget = null;
                }
                /**
                 * Finds the interactive object on which the event is dispatched.
                 */
                MouseEventDispatcher.prototype._findTarget = function (point, testingType) {
                    var globalX = point.x * 20 | 0;
                    var globalY = point.y * 20 | 0;
                    var objects = [];
                    this.stage._containsGlobalPoint(globalX, globalY, testingType, objects);
                    release || assert(objects.length < 2);
                    if (objects.length) {
                        return objects[0];
                    }
                    return objects.length ? objects[0] : null;
                };
                /**
                 * Converts DOM mouse event data into AS3 mouse events.
                 */
                MouseEventDispatcher.prototype._dispatchMouseEvent = function (target, type, data, relatedObject) {
                    if (relatedObject === void 0) { relatedObject = null; }
                    var localPoint = target.globalToLocal(data.point);
                    var event = this.stage._sec.events.MouseEvent.create([
                        type,
                        type !== events.MouseEvent.ROLL_OVER &&
                            type !== events.MouseEvent.ROLL_OUT &&
                            type !== events.MouseEvent.MOUSE_LEAVE,
                        false,
                        localPoint.x,
                        localPoint.y,
                        relatedObject,
                        data.ctrlKey,
                        data.altKey,
                        data.shiftKey,
                        !!data.buttons
                    ]);
                    target.dispatchEvent(event);
                };
                /**
                 * Handles the mouse event and returns the target on which the event was dispatched.
                 */
                MouseEventDispatcher.prototype.handleMouseEvent = function (data) {
                    var stage = this.stage;
                    if (!stage) {
                        return stage;
                    }
                    var globalPoint = data.point;
                    var mouseClass = this.stage._sec.ui.Mouse;
                    mouseClass.updateCurrentPosition(globalPoint);
                    var currentTarget = this.currentTarget;
                    var target = null;
                    var type = flash.events.MouseEvent.typeFromDOMType(data.type);
                    if (globalPoint.x >= 0 && globalPoint.x < stage.stageWidth &&
                        globalPoint.y >= 0 && globalPoint.y < stage.stageHeight) {
                        target = this._findTarget(globalPoint, 3 /* Mouse */) || this.stage;
                    }
                    else {
                        if (!currentTarget) {
                            return stage;
                        }
                        this._dispatchMouseEvent(stage, events.MouseEvent.MOUSE_LEAVE, data);
                        if (type !== events.MouseEvent.MOUSE_MOVE) {
                            return stage;
                        }
                    }
                    if (mouseClass.draggableObject) {
                        var dropTarget = this._findTarget(globalPoint, 5 /* Drop */);
                        mouseClass.draggableObject._updateDragState(dropTarget);
                    }
                    switch (type) {
                        case events.MouseEvent.MOUSE_DOWN:
                            if ((data.buttons & 1 /* Left */) !== 0) {
                                data.buttons = 1 /* Left */;
                            }
                            else if ((data.buttons & 2 /* Middle */) !== 0) {
                                type = events.MouseEvent.MIDDLE_MOUSE_DOWN;
                                data.buttons = 2 /* Middle */;
                            }
                            else if ((data.buttons & 4 /* Right */) !== 0) {
                                type = events.MouseEvent.RIGHT_MOUSE_DOWN;
                                data.buttons = 4 /* Right */;
                            }
                            target._mouseDown = true;
                            break;
                        case events.MouseEvent.MOUSE_UP:
                            if ((data.buttons & 1 /* Left */) !== 0) {
                                data.buttons = 1 /* Left */;
                            }
                            else if ((data.buttons & 2 /* Middle */) !== 0) {
                                type = events.MouseEvent.MIDDLE_MOUSE_UP;
                                data.buttons = 2 /* Middle */;
                            }
                            else if ((data.buttons & 4 /* Right */) !== 0) {
                                type = events.MouseEvent.RIGHT_MOUSE_UP;
                                data.buttons = 4 /* Right */;
                            }
                            target._mouseDown = false;
                            break;
                        case events.MouseEvent.CLICK:
                            if ((data.buttons & 1 /* Left */) === 0) {
                                if ((data.buttons & 2 /* Middle */) !== 0) {
                                    type = events.MouseEvent.MIDDLE_CLICK;
                                }
                                else if ((data.buttons & 4 /* Right */) !== 0) {
                                    type = events.MouseEvent.RIGHT_CLICK;
                                }
                            }
                            data.buttons = 0;
                            break;
                        case events.MouseEvent.DOUBLE_CLICK:
                            if (!target.doubleClickEnabled) {
                                return null;
                                // AMBIGUOUS
                                // return stage;
                            }
                            data.buttons = 0;
                            break;
                        case events.MouseEvent.MOUSE_MOVE:
                            this.currentTarget = target;
                            data.buttons &= 1 /* Left */;
                            if (target === currentTarget) {
                                break;
                            }
                            var commonAncestor = target ? target.findNearestCommonAncestor(currentTarget) : stage;
                            if (currentTarget && currentTarget !== stage) {
                                currentTarget._mouseOver = false;
                                // TODO: Support track as menu.
                                currentTarget._mouseDown = false;
                                this._dispatchMouseEvent(currentTarget, events.MouseEvent.MOUSE_OUT, data, target);
                                var nodeLeft = currentTarget;
                                while (nodeLeft && nodeLeft !== commonAncestor) {
                                    this._dispatchMouseEvent(nodeLeft, events.MouseEvent.ROLL_OUT, data, target);
                                    nodeLeft = nodeLeft.parent;
                                }
                            }
                            if (!target) {
                                return stage;
                            }
                            if (target === stage) {
                                break;
                            }
                            var nodeEntered = target;
                            while (nodeEntered && nodeEntered !== commonAncestor) {
                                this._dispatchMouseEvent(nodeEntered, events.MouseEvent.ROLL_OVER, data, currentTarget);
                                nodeEntered = nodeEntered.parent;
                            }
                            target._mouseOver = true;
                            this._dispatchMouseEvent(target, events.MouseEvent.MOUSE_OVER, data, currentTarget);
                            return target;
                    }
                    // TODO: handle MOUSE_WHEEL and MOUSE_RELEASE_OUTSIDE
                    this._dispatchMouseEvent(target, type, data);
                    return target;
                };
                return MouseEventDispatcher;
            }());
            ui.MouseEventDispatcher = MouseEventDispatcher;
            var MouseButtonFlags;
            (function (MouseButtonFlags) {
                MouseButtonFlags[MouseButtonFlags["Left"] = 1] = "Left";
                MouseButtonFlags[MouseButtonFlags["Middle"] = 2] = "Middle";
                MouseButtonFlags[MouseButtonFlags["Right"] = 4] = "Right";
            })(MouseButtonFlags = ui.MouseButtonFlags || (ui.MouseButtonFlags = {}));
            var Mouse = /** @class */ (function (_super) {
                __extends(Mouse, _super);
                function Mouse() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Mouse, "supportsCursor", {
                    // JS -> AS Bindings
                    // AS -> JS Bindings
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Mouse, "cursor", {
                    get: function () {
                        return flash.system._currentDomain.ui.Mouse._cursor;
                    },
                    set: function (value) {
                        if (ui.MouseCursor.toNumber(value) < 0) {
                            flash.system._currentDomain.throwError("ArgumentError", Shumway.Errors.InvalidParamError, "cursor");
                        }
                        // @ivanpopelyshev: TODO: find sec reference in axClass
                        flash.system._currentDomain.ui.Mouse._cursor = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Mouse, "supportsNativeCursor", {
                    get: function () {
                        return true;
                    },
                    enumerable: true,
                    configurable: true
                });
                Mouse.hide = function () {
                    release || somewhatImplemented("public flash.ui.Mouse::static hide");
                    return;
                };
                Mouse.show = function () {
                    release || somewhatImplemented("public flash.ui.Mouse::static show");
                    return;
                };
                Mouse.registerCursor = function (name, cursor) {
                    name = name;
                    cursor = cursor;
                    release || notImplemented("public flash.ui.Mouse::static registerCursor");
                    return;
                };
                Mouse.unregisterCursor = function (name) {
                    name = name;
                    release || notImplemented("public flash.ui.Mouse::static unregisterCursor");
                    return;
                };
                return Mouse;
            }(flash.LegacyEntity));
            ui.Mouse = Mouse;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MouseCursor
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var MouseCursor;
            (function (MouseCursor) {
                MouseCursor["AUTO"] = "auto";
                MouseCursor["ARROW"] = "arrow";
                MouseCursor["BUTTON"] = "button";
                MouseCursor["HAND"] = "hand";
                MouseCursor["IBEAM"] = "ibeam";
            })(MouseCursor = ui.MouseCursor || (ui.MouseCursor = {}));
            (function (MouseCursor) {
                function fromNumber(n) {
                    switch (n) {
                        case 0:
                            return MouseCursor.AUTO;
                        case 1:
                            return MouseCursor.ARROW;
                        case 2:
                            return MouseCursor.BUTTON;
                        case 3:
                            return MouseCursor.HAND;
                        case 4:
                            return MouseCursor.IBEAM;
                        default:
                            return null;
                    }
                }
                MouseCursor.fromNumber = fromNumber;
                function toNumber(value) {
                    switch (value) {
                        case MouseCursor.AUTO:
                            return 0;
                        case MouseCursor.ARROW:
                            return 1;
                        case MouseCursor.BUTTON:
                            return 2;
                        case MouseCursor.HAND:
                            return 3;
                        case MouseCursor.IBEAM:
                            return 4;
                        default:
                            return -1;
                    }
                }
                MouseCursor.toNumber = toNumber;
            })(MouseCursor = ui.MouseCursor || (ui.MouseCursor = {}));
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MouseCursorData
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var notImplemented = Shumway.Debug.notImplemented;
            var MouseCursorData = /** @class */ (function (_super) {
                __extends(MouseCursorData, _super);
                function MouseCursorData() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(MouseCursorData.prototype, "data", {
                    // _data: any /*ASVector*/;
                    // _hotSpot: flash.geom.Point;
                    // _frameRate: number;
                    get: function () {
                        release || notImplemented("public flash.ui.MouseCursorData::get data");
                        return null;
                        // return this._data;
                    },
                    set: function (data) {
                        data = data;
                        release || notImplemented("public flash.ui.MouseCursorData::set data");
                        return;
                        // this._data = data;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseCursorData.prototype, "hotSpot", {
                    get: function () {
                        release || notImplemented("public flash.ui.MouseCursorData::get hotSpot");
                        return null;
                        // return this._hotSpot;
                    },
                    set: function (data) {
                        data = data;
                        release || notImplemented("public flash.ui.MouseCursorData::set hotSpot");
                        return;
                        // this._hotSpot = data;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MouseCursorData.prototype, "frameRate", {
                    get: function () {
                        release || notImplemented("public flash.ui.MouseCursorData::get frameRate");
                        return 0;
                        // return this._frameRate;
                    },
                    set: function (data) {
                        data = +data;
                        release || notImplemented("public flash.ui.MouseCursorData::set frameRate");
                        return;
                        // this._frameRate = data;
                    },
                    enumerable: true,
                    configurable: true
                });
                return MouseCursorData;
            }(flash.LegacyEntity));
            ui.MouseCursorData = MouseCursorData;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Multitouch
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var notImplemented = Shumway.Debug.notImplemented;
            var Multitouch = /** @class */ (function (_super) {
                __extends(Multitouch, _super);
                function Multitouch() {
                    return _super.call(this) || this;
                }
                Object.defineProperty(Multitouch, "inputMode", {
                    // static _inputMode: string;
                    // static _supportsTouchEvents: boolean;
                    // static _supportsGestureEvents: boolean;
                    // static _supportedGestures: any /*ASVector*/;
                    // static _maxTouchPoints: number /*int*/;
                    // static _mapTouchToMouse: boolean;
                    get: function () {
                        release || notImplemented("public flash.ui.Multitouch::get inputMode");
                        return "";
                        // return this._inputMode;
                    },
                    set: function (value) {
                        value = value;
                        release || notImplemented("public flash.ui.Multitouch::set inputMode");
                        return;
                        // this._inputMode = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multitouch, "supportsTouchEvents", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.Multitouch::get supportsTouchEvents");
                        return false;
                        // return this._supportsTouchEvents;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multitouch, "supportsGestureEvents", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.Multitouch::get supportsGestureEvents");
                        return false;
                        // return this._supportsGestureEvents;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multitouch, "supportedGestures", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.Multitouch::get supportedGestures");
                        return null;
                        // return this._supportedGestures;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multitouch, "maxTouchPoints", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.Multitouch::get maxTouchPoints");
                        return 0;
                        // return this._maxTouchPoints;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Multitouch, "mapTouchToMouse", {
                    get: function () {
                        release || somewhatImplemented("public flash.ui.Multitouch::get mapTouchToMouse");
                        return true;
                        // return this._mapTouchToMouse;
                    },
                    set: function (value) {
                        value = !!value;
                        release || notImplemented("public flash.ui.Multitouch::set mapTouchToMouse");
                        return;
                        // this._mapTouchToMouse = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Multitouch;
            }(flash.LegacyEntity));
            ui.Multitouch = Multitouch;
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: MultitouchInputMode
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var ui;
        (function (ui) {
            var MultitouchInputMode;
            (function (MultitouchInputMode) {
                MultitouchInputMode["NONE"] = "none";
                MultitouchInputMode["GESTURE"] = "gesture";
                MultitouchInputMode["TOUCH_POINT"] = "touchPoint";
            })(MultitouchInputMode = ui.MultitouchInputMode || (ui.MultitouchInputMode = {}));
        })(ui = flash.ui || (flash.ui = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Endian
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var utils;
        (function (utils) {
            var Endian;
            (function (Endian) {
                Endian["BIG_ENDIAN"] = "bigEndian";
                Endian["LITTLE_ENDIAN"] = "littleEndian";
            })(Endian = utils.Endian || (utils.Endian = {}));
        })(utils = flash.utils || (flash.utils = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Timer
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var utils;
        (function (utils) {
            var Timer = /** @class */ (function (_super) {
                __extends(Timer, _super);
                function Timer(delay, repeatCount /*int = 0 */) {
                    var _this = _super.call(this) || this;
                    _this._delay = +delay;
                    _this._repeatCount = repeatCount | 0;
                    _this._iteration = 0;
                    return _this;
                }
                Object.defineProperty(Timer.prototype, "running", {
                    get: function () {
                        return this._running;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Timer.prototype, "delay", {
                    get: function () {
                        return this._delay;
                    },
                    set: function (value) {
                        value = +value;
                        if (value < 0 || !isFinite(value)) {
                            this._sec.throwError('RangeError', Shumway.Errors.DelayRangeError);
                        }
                        this._delay = value;
                        if (this._running) {
                            this.stop();
                            this.start();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Timer.prototype, "repeatCount", {
                    get: function () {
                        return this._repeatCount;
                    },
                    set: function (value) {
                        this._repeatCount = value | 0;
                        if (this._repeatCount && this._running && this._iteration >= this._repeatCount) {
                            this.stop();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Timer.prototype, "currentCount", {
                    get: function () {
                        return this._iteration;
                    },
                    enumerable: true,
                    configurable: true
                });
                Timer.prototype.reset = function () {
                    if (this._running) {
                        this.stop();
                    }
                    this._iteration = 0;
                };
                Timer.prototype.stop = function () {
                    this._running = false;
                    clearInterval(this._interval);
                };
                Timer.prototype.start = function () {
                    if (this._running) {
                        return;
                    }
                    this._running = true;
                    this._interval = setInterval(this._tick.bind(this), this._delay);
                };
                Timer.prototype._tick = function () {
                    this._iteration++;
                    if (!this._running) {
                        return;
                    }
                    if (flash.utils.Timer.dispatchingEnabled) {
                        Shumway.enterTimeline("Timer.Timer");
                        try {
                            this.dispatchEvent(this._sec.events.TimerEvent.create(["timer", true, false]));
                        }
                        catch (e) {
                            Shumway.Debug.warning('caught error under Timer TIMER event: ', e);
                        }
                        Shumway.leaveTimeline();
                    }
                    if (this._repeatCount !== 0 && this._iteration >= this._repeatCount) {
                        this.stop();
                        Shumway.enterTimeline("Timer.TimerComplete");
                        try {
                            this.dispatchEvent(this._sec.events.TimerEvent.create([flash.events.TimerEvent.TIMER_COMPLETE,
                                false, false]));
                        }
                        catch (e) {
                            Shumway.Debug.warning('caught error under Timer COMPLETE event: ', e);
                        }
                        Shumway.leaveTimeline();
                    }
                };
                /**
                 * This lets you toggle timer event dispatching which is useful when trying to profile other
                 * parts of the system.
                 */
                Timer.dispatchingEnabled = true;
                return Timer;
            }(flash.events.EventDispatcher));
            utils.Timer = Timer;
        })(utils = flash.utils || (flash.utils = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: SetIntervalTimer
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var utils;
        (function (utils) {
            var SetIntervalTimer = /** @class */ (function (_super) {
                __extends(SetIntervalTimer, _super);
                function SetIntervalTimer(closure, delay, repeats, rest) {
                    var _this = _super.call(this, +delay, !!repeats ? 0 : 1) || this;
                    closure = closure;
                    rest = rest;
                    return _this;
                }
                return SetIntervalTimer;
            }(flash.utils.Timer));
            utils.SetIntervalTimer = SetIntervalTimer;
        })(utils = flash.utils || (flash.utils = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var assert = Shumway.Debug.assert;
            var Event = flash.events.Event;
            var EventsNamespace = /** @class */ (function (_super) {
                __extends(EventsNamespace, _super);
                function EventsNamespace() {
                    var _this = _super.call(this) || this;
                    _this.EventDispatcher = new system.LegacyClass(flash.events.EventDispatcher);
                    _this.Event = new system.LegacyClass(Event);
                    _this.ErrorEvent = new system.LegacyClass(flash.events.ErrorEvent);
                    _this.AsyncErrorEvent = new system.LegacyClass(flash.events.AsyncErrorEvent);
                    _this.ProgressEvent = new system.LegacyClass(flash.events.ProgressEvent);
                    _this.StatusEvent = new system.LegacyClass(flash.events.StatusEvent);
                    _this.GestureEvent = new system.LegacyClass(flash.events.GestureEvent);
                    _this.KeyboardEvent = new system.LegacyClass(flash.events.KeyboardEvent);
                    _this.MouseEvent = new system.LegacyClass(flash.events.MouseEvent);
                    _this.TextEvent = new system.LegacyClass(flash.events.TextEvent);
                    _this.TimerEvent = new system.LegacyClass(flash.events.TimerEvent);
                    _this.TouchEvent = new system.LegacyClass(flash.events.TouchEvent);
                    _this.UncaughtErrorEvents = new system.LegacyClass(flash.events.UncaughtErrorEvents);
                    _this.NetStatusEvent = new system.LegacyClass(flash.events.NetStatusEvent);
                    _this.HTTPStatusEvent = new system.LegacyClass(flash.events.HTTPStatusEvent);
                    _this.IOErrorEvent = new system.LegacyClass(flash.events.IOErrorEvent);
                    _this._instances = Shumway.ObjectUtilities.createMap();
                    _this.broadcastEventDispatchQueue = new flash.events.BroadcastEventDispatchQueue();
                    return _this;
                }
                EventsNamespace.prototype.getInstance = function (type, bubbles, cancelable) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    var instance = this._instances[type];
                    if (!instance) {
                        instance = this.Event.create([type, bubbles, cancelable]);
                        this._instances[type] = instance;
                    }
                    instance._bubbles = bubbles;
                    instance._cancelable = cancelable;
                    return instance;
                };
                EventsNamespace.prototype.getBroadcastInstance = function (type, bubbles, cancelable) {
                    if (bubbles === void 0) { bubbles = false; }
                    if (cancelable === void 0) { cancelable = false; }
                    var instance = this._instances[type];
                    if (!instance) {
                        instance = this.Event.create([type, bubbles, cancelable]);
                        this._instances[type] = instance;
                        // Some events are documented as broadcast event in the AS3 docs. We can't set |_isBroadcastEvent| flag in the
                        // constructor because if you create custom events with these types they do capture and bubble.
                        release || assert(Event.isBroadcastEventType(type));
                    }
                    instance._isBroadcastEvent = true;
                    instance._bubbles = bubbles;
                    instance._cancelable = cancelable;
                    return instance;
                };
                return EventsNamespace;
            }(system.LegacyNamespace));
            system.EventsNamespace = EventsNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var UtilsNamespace = /** @class */ (function (_super) {
                __extends(UtilsNamespace, _super);
                function UtilsNamespace() {
                    var _this = _super.call(this) || this;
                    _this.ByteArray = new system.ByteArrayClass();
                    return _this;
                }
                return UtilsNamespace;
            }(system.LegacyNamespace));
            system.UtilsNamespace = UtilsNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            // static fabric
            var PerspectiveProjectionClass = /** @class */ (function (_super) {
                __extends(PerspectiveProjectionClass, _super);
                function PerspectiveProjectionClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                PerspectiveProjectionClass.prototype.FromDisplayObject = function (displayObject) {
                    release || Shumway.Debug.assert(displayObject);
                    var projection = this.create();
                    projection._displayObject = displayObject;
                    return projection;
                };
                PerspectiveProjectionClass.prototype.clone = function (this_) {
                    var clone = this.createObject();
                    clone._fieldOfView = this_._fieldOfView;
                    clone._centerX = this_._centerX;
                    clone._centerY = this_._centerY;
                    clone._displayObject = this_._displayObject;
                    return clone;
                };
                return PerspectiveProjectionClass;
            }(system.LegacyClass));
            system.PerspectiveProjectionClass = PerspectiveProjectionClass;
            var Matrix3DClass = /** @class */ (function (_super) {
                __extends(Matrix3DClass, _super);
                function Matrix3DClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Matrix3DClass.prototype.FromArray = function (matrix) {
                    var mat = Object.create(this.jsClass.prototype);
                    mat._matrix = new Float32Array(matrix);
                    mat._sec = this._sec;
                    return mat;
                };
                return Matrix3DClass;
            }(system.LegacyClass));
            system.Matrix3DClass = Matrix3DClass;
            var MatrixClass = /** @class */ (function (_super) {
                __extends(MatrixClass, _super);
                function MatrixClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                MatrixClass.prototype.clone = function (this_) {
                    var m = this_._data;
                    return this.create([m[0], m[1], m[2], m[3], m[4], m[5]]);
                };
                MatrixClass.prototype.FromUntyped = function (object) {
                    return this.create([object.a, object.b, object.c, object.d,
                        object.tx, object.ty]);
                };
                // Keep in sync with writeExternal below!
                MatrixClass.prototype.FromDataBuffer = function (input) {
                    return this.create([input.readFloat(), input.readFloat(),
                        input.readFloat(), input.readFloat(),
                        input.readFloat(), input.readFloat()]);
                };
                return MatrixClass;
            }(system.LegacyClass));
            system.MatrixClass = MatrixClass;
            var PointClass = /** @class */ (function (_super) {
                __extends(PointClass, _super);
                function PointClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                PointClass.prototype.clone = function (this_) {
                    return this.create([this_.x, this_.y]);
                };
                PointClass.prototype.interpolate = function (p1, p2, f) {
                    var f1 = 1 - f;
                    return this.create([p1.x * f + p2.x * f1, p1.y * f + p2.y * f1]);
                };
                PointClass.prototype.distance = function (p1, p2) {
                    var dx = p2.x - p1.x;
                    var dy = p2.y - p1.y;
                    return (dx === 0) ? Math.abs(dy) : (dy === 0) ? Math.abs(dx) : Math.sqrt(dx * dx + dy * dy);
                };
                PointClass.prototype.polar = function (length, angle) {
                    length = +length;
                    angle = +angle;
                    return this.create([length * Math.cos(angle),
                        length * Math.sin(angle)]);
                };
                return PointClass;
            }(system.LegacyClass));
            system.PointClass = PointClass;
            var RectangleClass = /** @class */ (function (_super) {
                __extends(RectangleClass, _super);
                function RectangleClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                RectangleClass.prototype.FromBounds = function (bounds) {
                    var xMin = bounds.xMin;
                    var yMin = bounds.yMin;
                    return this.create([xMin / 20, yMin / 20,
                        (bounds.xMax - xMin) / 20,
                        (bounds.yMax - yMin) / 20]);
                };
                RectangleClass.prototype.clone = function (this_) {
                    return this.create([this_.x, this_.y, this_.width, this_.height]);
                };
                return RectangleClass;
            }(system.LegacyClass));
            system.RectangleClass = RectangleClass;
            var ColorTransformClass = /** @class */ (function (_super) {
                __extends(ColorTransformClass, _super);
                function ColorTransformClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ColorTransformClass.prototype.clone = function (this_) {
                    return this.create([
                        this_.redMultiplier,
                        this_.greenMultiplier,
                        this_.blueMultiplier,
                        this_.alphaMultiplier,
                        this_.redOffset,
                        this_.greenOffset,
                        this_.blueOffset,
                        this_.alphaOffset
                    ]);
                };
                return ColorTransformClass;
            }(system.LegacyClass));
            system.ColorTransformClass = ColorTransformClass;
            var GeomNamespace = /** @class */ (function () {
                function GeomNamespace() {
                    this.Point = new PointClass(flash.geom.Point);
                    this.Matrix = new MatrixClass(flash.geom.Matrix);
                    this.Matrix3D = new Matrix3DClass(flash.geom.Matrix3D);
                    this.PerspectiveProjection = new PerspectiveProjectionClass(flash.geom.PerspectiveProjection);
                    this.Rectangle = new RectangleClass(flash.geom.Rectangle);
                    this.ColorTransform = new ColorTransformClass(flash.geom.ColorTransform);
                    this.Vector3D = new system.LegacyClass(flash.geom.Vector3D);
                    this.Transform = new system.LegacyClass(flash.geom.Transform);
                    this._temporaryRectangle = new flash.geom.Rectangle();
                    this.FROZEN_IDENTITY_MATRIX = Object.freeze(this.Matrix.create());
                    this.TEMP_MATRIX = this.Matrix.create();
                    this.FROZEN_IDENTITY_COLOR_TRANSFORM = Object.freeze(this.ColorTransform.create());
                    this.TEMP_COLOR_TRANSFORM = this.ColorTransform.create();
                }
                return GeomNamespace;
            }());
            system.GeomNamespace = GeomNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var assert = Shumway.Debug.assert;
            var enterTimeline = Shumway.enterTimeline;
            var leaveTimeline = Shumway.leaveTimeline;
            var DisplayNamespace = /** @class */ (function (_super) {
                __extends(DisplayNamespace, _super);
                function DisplayNamespace() {
                    var _this = _super.call(this) || this;
                    _this._runScripts = true;
                    _this._stage = null;
                    _this._instanceID = 1;
                    _this.displayObjectReset();
                    _this.movieClipReset();
                    _this.DisplayObject = new system.LegacyClass(flash.display.DisplayObject);
                    _this.DisplayObjectContainer = new system.LegacyClass(flash.display.DisplayObjectContainer);
                    _this.Sprite = new system.LegacyClass(flash.display.Sprite);
                    _this.InteractiveObject = new system.LegacyClass(flash.display.InteractiveObject);
                    _this.MovieClip = new system.LegacyClass(flash.display.MovieClip);
                    _this.BitmapData = new system.LegacyClass(flash.display.BitmapData);
                    _this.Bitmap = new system.LegacyClass(flash.display.Bitmap);
                    _this.Graphics = new system.LegacyClass(flash.display.Graphics);
                    _this.AVM1Movie = new system.LegacyClass(flash.display.AVM1Movie);
                    _this.Stage = new system.LegacyClass(flash.display.Stage);
                    _this.SimpleButton = new system.LegacyClass(flash.display.SimpleButton);
                    _this.Loader = new system.LoaderClass();
                    _this.FrameLabel = new system.LegacyClass(flash.display.FrameLabel);
                    _this.LoaderInfo = new system.LegacyClass(flash.display.LoaderInfo);
                    _this.Scene = new system.LegacyClass(flash.display.Scene);
                    _this.MorphShape = new system.LegacyClass(flash.display.MorphShape);
                    _this.Shape = new system.LegacyClass(flash.display.Shape);
                    return _this;
                }
                //system
                // DisplayObject system
                DisplayNamespace.prototype._broadcastFrameEvent = function (type) {
                    var events = this._sec.events;
                    var event = events.getBroadcastInstance(type);
                    events.broadcastEventDispatchQueue.dispatchEvent(event);
                };
                /**
                 * DisplayObject#name is set to an initial value of 'instanceN', where N is auto-incremented.
                 * This is true for all DisplayObjects except for Stage, so it happens in an overrideable
                 * method.
                 */
                DisplayNamespace.prototype.displayObjectReset = function () {
                    this._advancableInstances = new Shumway.WeakList();
                };
                /**
                 * Runs one full turn of the frame events cycle.
                 *
                 * Frame navigation methods on MovieClip can trigger nested frame events cycles. These nested
                 * cycles do everything the outermost cycle does, except for broadcasting the ENTER_FRAME
                 * event.
                 *
                 * If runScripts is true, no events are dispatched and Movieclip frame scripts are run. This
                 * is true for nested cycles, too. (We keep static state for that.)
                 */
                DisplayNamespace.prototype.performFrameNavigation = function (mainLoop, runScripts) {
                    if (mainLoop) {
                        this._runScripts = runScripts;
                    }
                    else {
                        runScripts = this._runScripts;
                    }
                    release || assert(this._advancableInstances.length < 1024 * 16, "Too many advancable instances.");
                    // Step 1: Remove timeline objects that don't exist on new frame, update existing ones with
                    // new properties, and declare, but not create, new ones, update numChildren.
                    // NOTE: the Order Of Operations senocular article is wrong on this: timeline objects are
                    // removed from stage at the beginning of a frame, just as new objects are declared at that
                    // point.
                    // Also, changed properties of existing objects are updated here instead of during frame
                    // construction after ENTER_FRAME.
                    // Thus, all these can be done together.
                    enterTimeline("DisplayObject.InitFrame");
                    this._advancableInstances.forEach(function (value) {
                        value._initFrame(mainLoop);
                    });
                    leaveTimeline();
                    // Step 2: Dispatch ENTER_FRAME, only called in outermost invocation.
                    enterTimeline("DisplayObject.EnterFrame");
                    if (mainLoop && runScripts) {
                        this._broadcastFrameEvent(flash.events.Event.ENTER_FRAME);
                    }
                    leaveTimeline();
                    // Step 3: Create new timeline objects.
                    enterTimeline("DisplayObject.ConstructFrame");
                    this._advancableInstances.forEach(function (value) {
                        value._constructFrame();
                    });
                    leaveTimeline();
                    // Step 4: Dispatch FRAME_CONSTRUCTED.
                    if (runScripts) {
                        enterTimeline("DisplayObject.FrameConstructed");
                        this._broadcastFrameEvent(flash.events.Event.FRAME_CONSTRUCTED);
                        leaveTimeline();
                        // Step 5: Run frame scripts
                        // Flash seems to enqueue all frame scripts recursively, starting at the root of each
                        // independent object graph. That can be the stage or a container that isn't itself on
                        // stage, but has (grand-)children.
                        // The order in which these independent graphs are processed seems not to follow a
                        // specific system: in some testing scenarios all independent graphs are processes before
                        // the stage, in others the first-created such graph is processes *after* the stage, all
                        // others before the stage. There might be other permutations of this, but it seems
                        // doubtful anybody could reasonably rely on the exact details of all this.
                        // Of course, nothing guarantees that there isn't content that accidentally does, so it'd
                        // be nice to eventually get this right.
                        enterTimeline("DisplayObject.EnqueueFrameScripts");
                        var displayObjectContainerClass_1 = this.DisplayObjectContainer;
                        this._advancableInstances.forEach(function (value) {
                            var container = value;
                            if (displayObjectContainerClass_1.axIsType(container) && !container.parent) {
                                container._enqueueFrameScripts();
                            }
                        });
                        this._stage._enqueueFrameScripts();
                        leaveTimeline();
                        enterTimeline("DisplayObject.RunFrameScript");
                        if (this.frameNavigationModel === 1 /* SWF1 */) {
                            this.runAvm1FrameScripts();
                        }
                        else {
                            this.runFrameScripts();
                        }
                        leaveTimeline();
                        // Step 6: Dispatch EXIT_FRAME.
                        enterTimeline("DisplayObject.ExitFrame");
                        this._broadcastFrameEvent(flash.events.Event.EXIT_FRAME);
                        leaveTimeline();
                    }
                    else {
                        this.movieClipReset();
                    }
                    if (mainLoop) {
                        this._runScripts = true;
                    }
                };
                DisplayNamespace.prototype.movieClipReset = function () {
                    this.frameNavigationModel = 10 /* SWF10 */;
                    this._callQueue = [];
                };
                DisplayNamespace.prototype.runFrameScripts = function () {
                    enterTimeline("MovieClip.executeFrame");
                    var queue = this._callQueue;
                    this._callQueue = [];
                    for (var i = 0; i < queue.length; i++) {
                        var instance = queue[i];
                        instance._allowFrameNavigation = false;
                        instance.callFrame(instance._currentFrame);
                        instance._allowFrameNavigation = true;
                        // If the destination frame isn't the same as before the `callFrame` operation, a frame
                        // navigation has happened inside the frame script. In that case, we didn't immediately
                        // run frame navigation as described in `_gotoFrameAbs`. Instead, we have to do it here.
                        if (instance._nextFrame !== instance._currentFrame) {
                            if (this.frameNavigationModel === 9 /* SWF9 */) {
                                instance._advanceFrame();
                                instance._constructFrame();
                                instance._removeFlags(8192 /* HasFrameScriptPending */);
                                instance.callFrame(instance._currentFrame);
                            }
                            else {
                                this.performFrameNavigation(false, true);
                            }
                        }
                    }
                    leaveTimeline();
                };
                DisplayNamespace.prototype.runAvm1FrameScripts = function () {
                    enterTimeline("MovieClip.runAvm1FrameScripts");
                    var queue = this._callQueue;
                    this._callQueue = [];
                    var unsortedScripts = [];
                    for (var i = 0; i < queue.length; i++) {
                        var instance = queue[i];
                        instance.queueAvm1FrameScripts(instance._currentFrame, unsortedScripts);
                    }
                    if (unsortedScripts.length) {
                        unsortedScripts.sort(compareFrameScripts);
                        for (var i = 0; i < queue.length; i++) {
                            var instance = queue[i];
                            instance._allowFrameNavigation = false;
                        }
                        var frameScripts = unsortedScripts;
                        for (var i = 0; i < frameScripts.length; i++) {
                            var script = frameScripts[i];
                            var mc = script.context;
                            release || assert(mc);
                            script.call(mc);
                        }
                        for (var i = 0; i < queue.length; i++) {
                            var instance = queue[i];
                            instance._allowFrameNavigation = true;
                            if (instance._nextFrame !== instance._currentFrame) {
                                this.performFrameNavigation(false, true);
                            }
                        }
                    }
                    leaveTimeline();
                };
                return DisplayNamespace;
            }(system.LegacyNamespace));
            system.DisplayNamespace = DisplayNamespace;
            function compareFrameScripts(a, b) {
                if (!a.precedence) {
                    return !b.precedence ? 0 : -1;
                }
                else if (!b.precedence) {
                    return 1;
                }
                var i = 0;
                while (i < a.precedence.length && i < b.precedence.length &&
                    a.precedence[i] === b.precedence[i]) {
                    i++;
                }
                if (i >= a.precedence.length) {
                    return a.precedence.length === b.precedence.length ? 0 : -1;
                }
                else {
                    return i >= b.precedence.length ? 1 : a.precedence[i] - b.precedence[i];
                }
            }
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var ApplicationDomain = system.ApplicationDomain;
            var SystemNamespace = /** @class */ (function (_super) {
                __extends(SystemNamespace, _super);
                function SystemNamespace() {
                    var _this = _super.call(this) || this;
                    _this.JPEGLoaderContext = new system.LegacyClass(system.JPEGLoaderContext);
                    _this.ApplicationDomain = new system.LegacyClass(system.ApplicationDomain);
                    _this._systemDomain = new ApplicationDomain(null);
                    _this._applicationDomain = new ApplicationDomain(_this._systemDomain);
                    _this.LoaderContext = new system.LegacyClass(system.LoaderContext);
                    _this._currentDomain = _this._applicationDomain;
                    return _this;
                }
                return SystemNamespace;
            }(system.LegacyNamespace));
            system.SystemNamespace = SystemNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var assert = Shumway.Debug.assert;
            var FontType = flash.text.FontType;
            var FontStyle = flash.text.FontStyle;
            var TextNamespace = /** @class */ (function (_super) {
                __extends(TextNamespace, _super);
                function TextNamespace() {
                    var _this = _super.call(this) || this;
                    _this.DEFAULT_FONT_SANS = 'Arial';
                    _this.DEFAULT_FONT_SERIF = 'Times New Roman';
                    _this.DEFAULT_FONT_TYPEWRITER = 'Courier New';
                    _this.DEVICE_FONT_METRICS_BUILTIN = {
                        "_sans": [0.9, 0.22, 0.08],
                        "_serif": [0.88, 0.26, 0.08],
                        "_typewriter": [0.86, 0.24, 0.08]
                    };
                    // Measurements taken on a freshly installed Windows 7 (Ultimate).
                    _this.DEVICE_FONT_METRICS_WIN = {
                        __proto__: _this.DEVICE_FONT_METRICS_BUILTIN,
                        "Arial": [1, 0.25],
                        "Arial Baltic": [1, 0.25],
                        "Arial Black": [1.0833, 0.3333],
                        "Arial CE": [1, 0.25],
                        "Arial CYR": [1, 0.25],
                        "Arial Greek": [1, 0.25],
                        "Arial TUR": [1, 0.25],
                        "Comic Sans MS": [1.0833, 0.3333],
                        "Courier New": [1, 0.25],
                        "Courier New Baltic": [1, 0.25],
                        "Courier New CE": [1, 0.25],
                        "Courier New CYR": [1, 0.25],
                        "Courier New Greek": [1, 0.25],
                        "Courier New TUR": [1, 0.25],
                        "Estrangelo Edessa": [0.75, 0.3333],
                        "Franklin Gothic Medium": [1, 0.3333],
                        "Gautami": [0.9167, 0.8333],
                        "Georgia": [1, 0.25],
                        "Impact": [1.0833, 0.25],
                        "Latha": [1.0833, 0.25],
                        "Lucida Console": [0.75, 0.25],
                        "Lucida Sans Unicode": [1.0833, 0.25],
                        "Mangal": [1.0833, 0.25],
                        "Marlett": [1, 0],
                        "Microsoft Sans Serif": [1.0833, 0.1667],
                        "MV Boli": [0.9167, 0.25],
                        "Palatino Linotype": [1.0833, 0.3333],
                        "Raavi": [1.0833, 0.6667],
                        "Shruti": [1, 0.5],
                        "Sylfaen": [1, 0.3333],
                        "Symbol": [1, 0.25],
                        "Tahoma": [1, 0.1667],
                        "Times New Roman": [1, 0.25],
                        "Times New Roman Baltic": [1, 0.25],
                        "Times New Roman CE": [1, 0.25],
                        "Times New Roman CYR": [1, 0.25],
                        "Times New Roman Greek": [1, 0.25],
                        "Times New Roman TUR": [1, 0.25],
                        "Trebuchet MS": [1.0833, 0.4167],
                        "Tunga": [1, 0.75],
                        "Verdana": [1, 0.1667],
                        "Webdings": [1.0833, 0.5],
                        "Wingdings": [0.9167, 0.25]
                    };
                    // Measurements taken on a freshly installed Mac OS X 10.10 (Yosemite).
                    _this.DEVICE_FONT_METRICS_MAC = {
                        __proto__: _this.DEVICE_FONT_METRICS_BUILTIN,
                        "Al Bayan Bold": [1, 0.5833],
                        "Al Bayan Plain": [1, 0.5],
                        "Al Nile": [0.8333, 0.5],
                        "Al Nile Bold": [0.8333, 0.5],
                        "Al Tarikh Regular": [0.5833, 0.4167],
                        "American Typewriter": [0.9167, 0.25],
                        "American Typewriter Bold": [0.9167, 0.25],
                        "American Typewriter Condensed": [0.9167, 0.25],
                        "American Typewriter Condensed Bold": [0.9167, 0.25],
                        "American Typewriter Condensed Light": [0.8333, 0.25],
                        "American Typewriter Light": [0.9167, 0.25],
                        "Andale Mono": [0.9167, 0.25],
                        "Apple Braille": [0.75, 0.25],
                        "Apple Braille Outline 6 Dot": [0.75, 0.25],
                        "Apple Braille Outline 8 Dot": [0.75, 0.25],
                        "Apple Braille Pinpoint 6 Dot": [0.75, 0.25],
                        "Apple Braille Pinpoint 8 Dot": [0.75, 0.25],
                        "Apple Chancery": [1.0833, 0.5],
                        "Apple Color Emoji": [1.25, 0.4167],
                        "Apple SD Gothic Neo Bold": [0.9167, 0.3333],
                        "Apple SD Gothic Neo Heavy": [0.9167, 0.3333],
                        "Apple SD Gothic Neo Light": [0.9167, 0.3333],
                        "Apple SD Gothic Neo Medium": [0.9167, 0.3333],
                        "Apple SD Gothic Neo Regular": [0.9167, 0.3333],
                        "Apple SD Gothic Neo SemiBold": [0.9167, 0.3333],
                        "Apple SD Gothic Neo Thin": [0.9167, 0.3333],
                        "Apple SD Gothic Neo UltraLight": [0.9167, 0.3333],
                        "Apple SD GothicNeo ExtraBold": [0.9167, 0.3333],
                        "Apple Symbols": [0.6667, 0.25],
                        "AppleGothic Regular": [0.9167, 0.3333],
                        "AppleMyungjo Regular": [0.8333, 0.3333],
                        "Arial": [0.9167, 0.25],
                        "Arial Black": [1.0833, 0.3333],
                        "Arial Bold": [0.9167, 0.25],
                        "Arial Bold Italic": [0.9167, 0.25],
                        "Arial Hebrew": [0.75, 0.3333],
                        "Arial Hebrew Bold": [0.75, 0.3333],
                        "Arial Hebrew Light": [0.75, 0.3333],
                        "Arial Hebrew Scholar": [0.75, 0.3333],
                        "Arial Hebrew Scholar Bold": [0.75, 0.3333],
                        "Arial Hebrew Scholar Light": [0.75, 0.3333],
                        "Arial Italic": [0.9167, 0.25],
                        "Arial Narrow": [0.9167, 0.25],
                        "Arial Narrow Bold": [0.9167, 0.25],
                        "Arial Narrow Bold Italic": [0.9167, 0.25],
                        "Arial Narrow Italic": [0.9167, 0.25],
                        "Arial Rounded MT Bold": [0.9167, 0.25],
                        "Arial Unicode MS": [1.0833, 0.25],
                        "Athelas Bold": [0.9167, 0.25],
                        "Athelas Bold Italic": [0.9167, 0.25],
                        "Athelas Italic": [0.9167, 0.25],
                        "Athelas Regular": [0.9167, 0.25],
                        "Avenir Black": [1, 0.3333],
                        "Avenir Black Oblique": [1, 0.3333],
                        "Avenir Book": [1, 0.3333],
                        "Avenir Book Oblique": [1, 0.3333],
                        "Avenir Heavy": [1, 0.3333],
                        "Avenir Heavy Oblique": [1, 0.3333],
                        "Avenir Light": [1, 0.3333],
                        "Avenir Light Oblique": [1, 0.3333],
                        "Avenir Medium": [1, 0.3333],
                        "Avenir Medium Oblique": [1, 0.3333],
                        "Avenir Next Bold": [1, 0.3333],
                        "Avenir Next Bold Italic": [1, 0.3333],
                        "Avenir Next Condensed Bold": [1, 0.3333],
                        "Avenir Next Condensed Bold Italic": [1, 0.3333],
                        "Avenir Next Condensed Demi Bold": [1, 0.3333],
                        "Avenir Next Condensed Demi Bold Italic": [1, 0.3333],
                        "Avenir Next Condensed Heavy": [1, 0.3333],
                        "Avenir Next Condensed Heavy Italic": [1, 0.3333],
                        "Avenir Next Condensed Italic": [1, 0.3333],
                        "Avenir Next Condensed Medium": [1, 0.3333],
                        "Avenir Next Condensed Medium Italic": [1, 0.3333],
                        "Avenir Next Condensed Regular": [1, 0.3333],
                        "Avenir Next Condensed Ultra Light": [1, 0.3333],
                        "Avenir Next Condensed Ultra Light Italic": [1, 0.3333],
                        "Avenir Next Demi Bold": [1, 0.3333],
                        "Avenir Next Demi Bold Italic": [1, 0.3333],
                        "Avenir Next Heavy": [1, 0.3333],
                        "Avenir Next Heavy Italic": [1, 0.3333],
                        "Avenir Next Italic": [1, 0.3333],
                        "Avenir Next Medium": [1, 0.3333],
                        "Avenir Next Medium Italic": [1, 0.3333],
                        "Avenir Next Regular": [1, 0.3333],
                        "Avenir Next Ultra Light": [1, 0.3333],
                        "Avenir Next Ultra Light Italic": [1, 0.3333],
                        "Avenir Oblique": [1, 0.3333],
                        "Avenir Roman": [1, 0.3333],
                        "Ayuthaya": [1.0833, 0.3333],
                        "Baghdad Regular": [0.9167, 0.4167],
                        "Bangla MN": [1.0833, 0.75],
                        "Bangla MN Bold": [1.0833, 0.75],
                        "Bangla Sangam MN": [0.9167, 0.4167],
                        "Bangla Sangam MN Bold": [0.9167, 0.4167],
                        "Baoli SC Regular": [1.0833, 0.3333],
                        "Baskerville": [0.9167, 0.25],
                        "Baskerville Bold": [0.9167, 0.25],
                        "Baskerville Bold Italic": [0.9167, 0.25],
                        "Baskerville Italic": [0.9167, 0.25],
                        "Baskerville SemiBold": [0.9167, 0.25],
                        "Baskerville SemiBold Italic": [0.9167, 0.25],
                        "Beirut Regular": [0.75, 0.25],
                        "Big Caslon Medium": [0.9167, 0.25],
                        "Bodoni 72 Bold": [0.9167, 0.25],
                        "Bodoni 72 Book": [0.9167, 0.25],
                        "Bodoni 72 Book Italic": [0.9167, 0.3333],
                        "Bodoni 72 Oldstyle Bold": [0.9167, 0.25],
                        "Bodoni 72 Oldstyle Book": [0.9167, 0.25],
                        "Bodoni 72 Oldstyle Book Italic": [0.9167, 0.3333],
                        "Bodoni 72 Smallcaps Book": [0.9167, 0.25],
                        "Bodoni Ornaments": [0.8333, 0.1667],
                        "Bradley Hand Bold": [0.8333, 0.4167],
                        "Brush Script MT Italic": [0.9167, 0.3333],
                        "Chalkboard": [1, 0.25],
                        "Chalkboard Bold": [1, 0.25],
                        "Chalkboard SE Bold": [1.1667, 0.25],
                        "Chalkboard SE Light": [1.1667, 0.25],
                        "Chalkboard SE Regular": [1.1667, 0.25],
                        "Chalkduster": [1, 0.25],
                        "Charter Black": [1, 0.25],
                        "Charter Black Italic": [1, 0.25],
                        "Charter Bold": [1, 0.25],
                        "Charter Bold Italic": [1, 0.25],
                        "Charter Italic": [1, 0.25],
                        "Charter Roman": [1, 0.25],
                        "Cochin": [0.9167, 0.25],
                        "Cochin Bold": [0.9167, 0.25],
                        "Cochin Bold Italic": [0.9167, 0.25],
                        "Cochin Italic": [0.9167, 0.25],
                        "Comic Sans MS": [1.0833, 0.25],
                        "Comic Sans MS Bold": [1.0833, 0.25],
                        "Copperplate": [0.75, 0.25],
                        "Copperplate Bold": [0.75, 0.25],
                        "Copperplate Light": [0.75, 0.25],
                        "Corsiva Hebrew": [0.6667, 0.3333],
                        "Corsiva Hebrew Bold": [0.6667, 0.3333],
                        "Courier": [0.75, 0.25],
                        "Courier Bold": [0.75, 0.25],
                        "Courier Bold Oblique": [0.75, 0.25],
                        "Courier New": [0.8333, 0.3333],
                        "Courier New Bold": [0.8333, 0.3333],
                        "Courier New Bold Italic": [0.8333, 0.3333],
                        "Courier New Italic": [0.8333, 0.3333],
                        "Courier Oblique": [0.75, 0.25],
                        "Damascus Bold": [0.5833, 0.4167],
                        "Damascus Light": [0.5833, 0.4167],
                        "Damascus Medium": [0.5833, 0.4167],
                        "Damascus Regular": [0.5833, 0.4167],
                        "Damascus Semi Bold": [0.5833, 0.4167],
                        "DecoType Naskh Regular": [1.1667, 0.6667],
                        "Devanagari MT": [0.9167, 0.6667],
                        "Devanagari MT Bold": [0.9167, 0.6667],
                        "Devanagari Sangam MN": [0.9167, 0.4167],
                        "Devanagari Sangam MN Bold": [0.9167, 0.4167],
                        "Didot": [0.9167, 0.3333],
                        "Didot Bold": [1, 0.3333],
                        "Didot Italic": [0.9167, 0.25],
                        "DIN Alternate Bold": [0.9167, 0.25],
                        "DIN Condensed Bold": [0.75, 0.25],
                        "Diwan Kufi Regular": [1.4167, 0.5],
                        "Diwan Thuluth Regular": [1, 0.6667],
                        "Euphemia UCAS": [1.0833, 0.25],
                        "Euphemia UCAS Bold": [1.0833, 0.25],
                        "Euphemia UCAS Italic": [1.0833, 0.25],
                        "Farah Regular": [0.75, 0.25],
                        "Farisi Regular": [1.0833, 1],
                        "Futura Condensed ExtraBold": [1, 0.25],
                        "Futura Condensed Medium": [1, 0.25],
                        "Futura Medium": [1, 0.25],
                        "Futura Medium Italic": [1, 0.25],
                        "GB18030 Bitmap": [1.1667, 0.1667],
                        "Geeza Pro Bold": [0.9167, 0.3333],
                        "Geeza Pro Regular": [0.9167, 0.3333],
                        "Geneva": [1, 0.25],
                        "Georgia": [0.9167, 0.25],
                        "Georgia Bold": [0.9167, 0.25],
                        "Georgia Bold Italic": [0.9167, 0.25],
                        "Georgia Italic": [0.9167, 0.25],
                        "Gill Sans": [0.9167, 0.25],
                        "Gill Sans Bold": [0.9167, 0.25],
                        "Gill Sans Bold Italic": [0.9167, 0.25],
                        "Gill Sans Italic": [0.9167, 0.25],
                        "Gill Sans Light": [0.9167, 0.25],
                        "Gill Sans Light Italic": [0.9167, 0.25],
                        "Gill Sans SemiBold": [0.9167, 0.25],
                        "Gill Sans SemiBold Italic": [0.9167, 0.25],
                        "Gill Sans UltraBold": [1, 0.25],
                        "Gujarati MT": [0.9167, 0.6667],
                        "Gujarati MT Bold": [0.9167, 0.6667],
                        "Gujarati Sangam MN": [0.8333, 0.4167],
                        "Gujarati Sangam MN Bold": [0.8333, 0.4167],
                        "GungSeo Regular": [0.8333, 0.25],
                        "Gurmukhi MN": [0.9167, 0.25],
                        "Gurmukhi MN Bold": [0.9167, 0.25],
                        "Gurmukhi MT": [0.8333, 0.4167],
                        "Gurmukhi Sangam MN": [0.9167, 0.3333],
                        "Gurmukhi Sangam MN Bold": [0.9167, 0.3333],
                        "Hannotate SC Bold": [1.0833, 0.3333],
                        "Hannotate SC Regular": [1.0833, 0.3333],
                        "Hannotate TC Bold": [1.0833, 0.3333],
                        "Hannotate TC Regular": [1.0833, 0.3333],
                        "HanziPen SC Bold": [1.0833, 0.3333],
                        "HanziPen SC Regular": [1.0833, 0.3333],
                        "HanziPen TC Bold": [1.0833, 0.3333],
                        "HanziPen TC Regular": [1.0833, 0.3333],
                        "HeadLineA Regular": [0.8333, 0.1667],
                        "Heiti SC Light": [0.8333, 0.1667],
                        "Heiti SC Medium": [0.8333, 0.1667],
                        "Heiti TC Light": [0.8333, 0.1667],
                        "Heiti TC Medium": [0.8333, 0.1667],
                        "Helvetica": [0.75, 0.25],
                        "Helvetica Bold": [0.75, 0.25],
                        "Helvetica Bold Oblique": [0.75, 0.25],
                        "Helvetica Light": [0.75, 0.25],
                        "Helvetica Light Oblique": [0.75, 0.25],
                        "Helvetica Neue": [0.9167, 0.25],
                        "Helvetica Neue Bold": [1, 0.25],
                        "Helvetica Neue Bold Italic": [1, 0.25],
                        "Helvetica Neue Condensed Black": [1, 0.25],
                        "Helvetica Neue Condensed Bold": [1, 0.25],
                        "Helvetica Neue Italic": [0.9167, 0.25],
                        "Helvetica Neue Light": [1, 0.25],
                        "Helvetica Neue Light Italic": [0.9167, 0.25],
                        "Helvetica Neue Medium": [1, 0.25],
                        "Helvetica Neue Medium Italic": [1, 0.25],
                        "Helvetica Neue Thin": [1, 0.25],
                        "Helvetica Neue Thin Italic": [1, 0.25],
                        "Helvetica Neue UltraLight": [0.9167, 0.25],
                        "Helvetica Neue UltraLight Italic": [0.9167, 0.25],
                        "Helvetica Oblique": [0.75, 0.25],
                        "Herculanum": [0.8333, 0.1667],
                        "Hiragino Kaku Gothic Pro W3": [0.9167, 0.0833],
                        "Hiragino Kaku Gothic Pro W6": [0.9167, 0.0833],
                        "Hiragino Kaku Gothic ProN W3": [0.9167, 0.0833],
                        "Hiragino Kaku Gothic ProN W6": [0.9167, 0.0833],
                        "Hiragino Kaku Gothic Std W8": [0.9167, 0.0833],
                        "Hiragino Kaku Gothic StdN W8": [0.9167, 0.0833],
                        "Hiragino Maru Gothic Pro W4": [0.9167, 0.0833],
                        "Hiragino Maru Gothic ProN W4": [0.9167, 0.0833],
                        "Hiragino Mincho Pro W3": [0.9167, 0.0833],
                        "Hiragino Mincho Pro W6": [0.9167, 0.0833],
                        "Hiragino Mincho ProN W3": [0.9167, 0.0833],
                        "Hiragino Mincho ProN W6": [0.9167, 0.0833],
                        "Hiragino Sans GB W3": [0.9167, 0.0833],
                        "Hiragino Sans GB W6": [0.9167, 0.0833],
                        "Hoefler Text": [0.75, 0.25],
                        "Hoefler Text Black": [0.75, 0.25],
                        "Hoefler Text Black Italic": [0.75, 0.25],
                        "Hoefler Text Italic": [0.75, 0.25],
                        "Hoefler Text Ornaments": [0.8333, 0.1667],
                        "Impact": [1, 0.25],
                        "InaiMathi": [0.8333, 0.4167],
                        "Iowan Old Style Black": [1, 0.3333],
                        "Iowan Old Style Black Italic": [1, 0.3333],
                        "Iowan Old Style Bold": [1, 0.3333],
                        "Iowan Old Style Bold Italic": [1, 0.3333],
                        "Iowan Old Style Italic": [1, 0.3333],
                        "Iowan Old Style Roman": [1, 0.3333],
                        "Iowan Old Style Titling": [1, 0.3333],
                        "ITF Devanagari Bold": [1.0833, 0.3333],
                        "ITF Devanagari Book": [1.0833, 0.3333],
                        "ITF Devanagari Demi": [1.0833, 0.3333],
                        "ITF Devanagari Light": [1.0833, 0.3333],
                        "ITF Devanagari Medium": [1.0833, 0.3333],
                        "Kailasa Regular": [1.0833, 0.5833],
                        "Kaiti SC Black": [1.0833, 0.3333],
                        "Kaiti SC Bold": [1.0833, 0.3333],
                        "Kaiti SC Regular": [1.0833, 0.3333],
                        "Kaiti TC Bold": [1.0833, 0.3333],
                        "Kaiti TC Regular": [1.0833, 0.3333],
                        "Kannada MN": [0.9167, 0.25],
                        "Kannada MN Bold": [0.9167, 0.25],
                        "Kannada Sangam MN": [1, 0.5833],
                        "Kannada Sangam MN Bold": [1, 0.5833],
                        "Kefa Bold": [0.9167, 0.25],
                        "Kefa Regular": [0.9167, 0.25],
                        "Khmer MN": [1, 0.8333],
                        "Khmer MN Bold": [1, 0.8333],
                        "Khmer Sangam MN": [1.0833, 0.8333],
                        "Kohinoor Devanagari Bold": [1.0833, 0.3333],
                        "Kohinoor Devanagari Book": [1.0833, 0.3333],
                        "Kohinoor Devanagari Demi": [1.0833, 0.3333],
                        "Kohinoor Devanagari Light": [1.0833, 0.3333],
                        "Kohinoor Devanagari Medium": [1.0833, 0.3333],
                        "Kokonor Regular": [1.0833, 0.5833],
                        "Krungthep": [1, 0.25],
                        "KufiStandardGK Regular": [0.9167, 0.5],
                        "Lantinghei SC Demibold": [1, 0.3333],
                        "Lantinghei SC Extralight": [1, 0.3333],
                        "Lantinghei SC Heavy": [1, 0.3333],
                        "Lantinghei TC Demibold": [1, 0.3333],
                        "Lantinghei TC Extralight": [1, 0.3333],
                        "Lantinghei TC Heavy": [1, 0.3333],
                        "Lao MN": [0.9167, 0.4167],
                        "Lao MN Bold": [0.9167, 0.4167],
                        "Lao Sangam MN": [1, 0.3333],
                        "Libian SC Regular": [1.0833, 0.3333],
                        "LiHei Pro": [0.8333, 0.1667],
                        "LiSong Pro": [0.8333, 0.1667],
                        "Lucida Grande": [1, 0.25],
                        "Lucida Grande Bold": [1, 0.25],
                        "Luminari": [1, 0.3333],
                        "Malayalam MN": [1, 0.4167],
                        "Malayalam MN Bold": [1, 0.4167],
                        "Malayalam Sangam MN": [0.8333, 0.4167],
                        "Malayalam Sangam MN Bold": [0.8333, 0.4167],
                        "Marion Bold": [0.6667, 0.3333],
                        "Marion Italic": [0.6667, 0.3333],
                        "Marion Regular": [0.6667, 0.3333],
                        "Marker Felt Thin": [0.8333, 0.25],
                        "Marker Felt Wide": [0.9167, 0.25],
                        "Menlo Bold": [0.9167, 0.25],
                        "Menlo Bold Italic": [0.9167, 0.25],
                        "Menlo Italic": [0.9167, 0.25],
                        "Menlo Regular": [0.9167, 0.25],
                        "Microsoft Sans Serif": [0.9167, 0.25],
                        "Mishafi Gold Regular": [0.75, 0.6667],
                        "Mishafi Regular": [0.75, 0.6667],
                        "Monaco": [1, 0.25],
                        "Mshtakan": [0.9167, 0.25],
                        "Mshtakan Bold": [0.9167, 0.25],
                        "Mshtakan BoldOblique": [0.9167, 0.25],
                        "Mshtakan Oblique": [0.9167, 0.25],
                        "Muna Black": [0.75, 0.3333],
                        "Muna Bold": [0.75, 0.3333],
                        "Muna Regular": [0.75, 0.3333],
                        "Myanmar MN": [1, 0.4167],
                        "Myanmar MN Bold": [1, 0.4167],
                        "Myanmar Sangam MN": [0.9167, 0.4167],
                        "Nadeem Regular": [0.9167, 0.4167],
                        "Nanum Brush Script": [0.9167, 0.25],
                        "Nanum Pen Script": [0.9167, 0.25],
                        "NanumGothic": [0.9167, 0.25],
                        "NanumGothic Bold": [0.9167, 0.25],
                        "NanumGothic ExtraBold": [0.9167, 0.25],
                        "NanumMyeongjo": [0.9167, 0.25],
                        "NanumMyeongjo Bold": [0.9167, 0.25],
                        "NanumMyeongjo ExtraBold": [0.9167, 0.25],
                        "New Peninim MT": [0.75, 0.3333],
                        "New Peninim MT Bold": [0.75, 0.3333],
                        "New Peninim MT Bold Inclined": [0.75, 0.3333],
                        "New Peninim MT Inclined": [0.75, 0.3333],
                        "Noteworthy Bold": [1.25, 0.3333],
                        "Noteworthy Light": [1.25, 0.3333],
                        "Optima Bold": [0.9167, 0.25],
                        "Optima Bold Italic": [0.9167, 0.25],
                        "Optima ExtraBlack": [1, 0.25],
                        "Optima Italic": [0.9167, 0.25],
                        "Optima Regular": [0.9167, 0.25],
                        "Oriya MN": [0.9167, 0.25],
                        "Oriya MN Bold": [0.9167, 0.25],
                        "Oriya Sangam MN": [0.8333, 0.4167],
                        "Oriya Sangam MN Bold": [0.8333, 0.4167],
                        "Osaka": [1, 0.25],
                        "Osaka-Mono": [0.8333, 0.1667],
                        "Palatino": [0.8333, 0.25],
                        "Palatino Bold": [0.8333, 0.25],
                        "Palatino Bold Italic": [0.8333, 0.25],
                        "Palatino Italic": [0.8333, 0.25],
                        "Papyrus": [0.9167, 0.5833],
                        "Papyrus Condensed": [0.9167, 0.5833],
                        "PCMyungjo Regular": [0.8333, 0.25],
                        "Phosphate Inline": [0.9167, 0.25],
                        "Phosphate Solid": [0.9167, 0.25],
                        "PilGi Regular": [0.8333, 0.25],
                        "Plantagenet Cherokee": [0.6667, 0.25],
                        "PT Mono": [0.9167, 0.25],
                        "PT Mono Bold": [0.9167, 0.25],
                        "PT Sans": [0.9167, 0.25],
                        "PT Sans Bold": [0.9167, 0.25],
                        "PT Sans Bold Italic": [0.9167, 0.25],
                        "PT Sans Caption": [0.9167, 0.25],
                        "PT Sans Caption Bold": [0.9167, 0.25],
                        "PT Sans Italic": [0.9167, 0.25],
                        "PT Sans Narrow": [0.9167, 0.25],
                        "PT Sans Narrow Bold": [0.9167, 0.25],
                        "PT Serif": [1, 0.25],
                        "PT Serif Bold": [1, 0.25],
                        "PT Serif Bold Italic": [1, 0.25],
                        "PT Serif Caption": [1, 0.25],
                        "PT Serif Caption Italic": [1, 0.25],
                        "PT Serif Italic": [1, 0.25],
                        "Raanana": [0.75, 0.25],
                        "Raanana Bold": [0.75, 0.25],
                        "Sana Regular": [0.75, 0.25],
                        "Sathu": [0.9167, 0.3333],
                        "Savoye LET Plain CC.:1.0": [1.0833, 0.75],
                        "Savoye LET Plain:1.0": [0.6667, 0.5],
                        "Seravek": [0.9167, 0.3333],
                        "Seravek Bold": [0.9167, 0.3333],
                        "Seravek Bold Italic": [0.9167, 0.3333],
                        "Seravek ExtraLight": [0.9167, 0.3333],
                        "Seravek ExtraLight Italic": [0.9167, 0.3333],
                        "Seravek Italic": [0.9167, 0.3333],
                        "Seravek Light": [0.9167, 0.3333],
                        "Seravek Light Italic": [0.9167, 0.3333],
                        "Seravek Medium": [0.9167, 0.3333],
                        "Seravek Medium Italic": [0.9167, 0.3333],
                        "Shree Devanagari 714": [0.9167, 0.4167],
                        "Shree Devanagari 714 Bold": [0.9167, 0.4167],
                        "Shree Devanagari 714 Bold Italic": [0.9167, 0.4167],
                        "Shree Devanagari 714 Italic": [0.9167, 0.4167],
                        "SignPainter-HouseScript": [0.6667, 0.1667],
                        "Silom": [1, 0.3333],
                        "Sinhala MN": [0.9167, 0.25],
                        "Sinhala MN Bold": [0.9167, 0.25],
                        "Sinhala Sangam MN": [1.1667, 0.3333],
                        "Sinhala Sangam MN Bold": [1.1667, 0.3333],
                        "Skia Black": [0.75, 0.25],
                        "Skia Black Condensed": [0.75, 0.25],
                        "Skia Black Extended": [0.75, 0.25],
                        "Skia Bold": [0.75, 0.25],
                        "Skia Condensed": [0.75, 0.25],
                        "Skia Extended": [0.75, 0.25],
                        "Skia Light": [0.75, 0.25],
                        "Skia Light Condensed": [0.75, 0.25],
                        "Skia Light Extended": [0.75, 0.25],
                        "Skia Regular": [0.75, 0.25],
                        "Snell Roundhand": [0.9167, 0.3333],
                        "Snell Roundhand Black": [0.9167, 0.3333],
                        "Snell Roundhand Bold": [0.9167, 0.3333],
                        "Songti SC Black": [1.0833, 0.3333],
                        "Songti SC Bold": [1.0833, 0.3333],
                        "Songti SC Light": [1.0833, 0.3333],
                        "Songti SC Regular": [1.0833, 0.3333],
                        "Songti TC Bold": [1.0833, 0.3333],
                        "Songti TC Light": [1.0833, 0.3333],
                        "Songti TC Regular": [1.0833, 0.3333],
                        "STFangsong": [0.8333, 0.1667],
                        "STHeiti": [0.8333, 0.1667],
                        "STIXGeneral-Bold": [1.0833, 0.4167],
                        "STIXGeneral-BoldItalic": [1.0833, 0.4167],
                        "STIXGeneral-Italic": [1.0833, 0.4167],
                        "STIXGeneral-Regular": [1.0833, 0.4167],
                        "STIXIntegralsD-Bold": [2.1667, 0.4167],
                        "STIXIntegralsD-Regular": [2.1667, 0.4167],
                        "STIXIntegralsSm-Bold": [1.0833, 0.4167],
                        "STIXIntegralsSm-Regular": [1.0833, 0.4167],
                        "STIXIntegralsUp-Bold": [1.0833, 0.4167],
                        "STIXIntegralsUp-Regular": [1.0833, 0.4167],
                        "STIXIntegralsUpD-Bold": [2.1667, 0.4167],
                        "STIXIntegralsUpD-Regular": [2.1667, 0.4167],
                        "STIXIntegralsUpSm-Bold": [1.0833, 0.4167],
                        "STIXIntegralsUpSm-Regular": [1.0833, 0.4167],
                        "STIXNonUnicode-Bold": [1.4167, 0.5833],
                        "STIXNonUnicode-BoldItalic": [1.4167, 0.5833],
                        "STIXNonUnicode-Italic": [1.4167, 0.5833],
                        "STIXNonUnicode-Regular": [1.4167, 0.5833],
                        "STIXSizeFiveSym-Regular": [1, 0.4167],
                        "STIXSizeFourSym-Bold": [2.5833, 0.5],
                        "STIXSizeFourSym-Regular": [2.5833, 0.5],
                        "STIXSizeOneSym-Bold": [1.5833, 0.3333],
                        "STIXSizeOneSym-Regular": [1.5833, 0.3333],
                        "STIXSizeThreeSym-Bold": [2.5833, 0.5],
                        "STIXSizeThreeSym-Regular": [2.5833, 0.5],
                        "STIXSizeTwoSym-Bold": [2.0833, 0.4167],
                        "STIXSizeTwoSym-Regular": [2.0833, 0.4167],
                        "STIXVariants-Bold": [1.0833, 0.4167],
                        "STIXVariants-Regular": [1.0833, 0.4167],
                        "STKaiti": [0.8333, 0.1667],
                        "STSong": [0.8333, 0.1667],
                        "STXihei": [0.8333, 0.1667],
                        "Sukhumvit Set Bold": [1.0833, 0.5],
                        "Sukhumvit Set Light": [1.0833, 0.5],
                        "Sukhumvit Set Medium": [1.0833, 0.5],
                        "Sukhumvit Set Semi Bold": [1.0833, 0.5],
                        "Sukhumvit Set Text": [1.0833, 0.5],
                        "Sukhumvit Set Thin": [1.0833, 0.5],
                        "Superclarendon Black": [1, 0.25],
                        "Superclarendon Black Italic": [1, 0.25],
                        "Superclarendon Bold": [1, 0.25],
                        "Superclarendon Bold Italic": [1, 0.25],
                        "Superclarendon Italic": [1, 0.25],
                        "Superclarendon Light": [1, 0.25],
                        "Superclarendon Light Italic": [1, 0.25],
                        "Superclarendon Regular": [1, 0.25],
                        "Symbol": [0.6667, 0.3333],
                        "System Font Bold": [1, 0.25],
                        "System Font Bold Italic": [1, 0.25],
                        "System Font Heavy": [1, 0.25],
                        "System Font Italic": [1, 0.25],
                        "System Font Light": [1, 0.25],
                        "System Font Medium Italic P4": [1, 0.25],
                        "System Font Medium P4": [1, 0.25],
                        "System Font Regular": [1, 0.25],
                        "System Font Thin": [1, 0.25],
                        "System Font UltraLight": [1, 0.25],
                        "Tahoma": [1, 0.1667],
                        "Tahoma Negreta": [1, 0.1667],
                        "Tamil MN": [0.9167, 0.25],
                        "Tamil MN Bold": [0.9167, 0.25],
                        "Tamil Sangam MN": [0.75, 0.25],
                        "Tamil Sangam MN Bold": [0.75, 0.25],
                        "Telugu MN": [0.9167, 0.25],
                        "Telugu MN Bold": [0.9167, 0.25],
                        "Telugu Sangam MN": [1, 0.5833],
                        "Telugu Sangam MN Bold": [1, 0.5833],
                        "Thonburi": [1.0833, 0.25],
                        "Thonburi Bold": [1.0833, 0.25],
                        "Thonburi Light": [1.0833, 0.25],
                        "Times Bold": [0.75, 0.25],
                        "Times Bold Italic": [0.75, 0.25],
                        "Times Italic": [0.75, 0.25],
                        "Times New Roman": [0.9167, 0.25],
                        "Times New Roman Bold": [0.9167, 0.25],
                        "Times New Roman Bold Italic": [0.9167, 0.25],
                        "Times New Roman Italic": [0.9167, 0.25],
                        "Times Roman": [0.75, 0.25],
                        "Trattatello": [1.1667, 0.6667],
                        "Trebuchet MS": [0.9167, 0.25],
                        "Trebuchet MS Bold": [0.9167, 0.25],
                        "Trebuchet MS Bold Italic": [0.9167, 0.25],
                        "Trebuchet MS Italic": [0.9167, 0.25],
                        "Verdana": [1, 0.25],
                        "Verdana Bold": [1, 0.25],
                        "Verdana Bold Italic": [1, 0.25],
                        "Verdana Italic": [1, 0.25],
                        "Waseem Light": [0.9167, 0.5833],
                        "Waseem Regular": [0.9167, 0.5833],
                        "Wawati SC Regular": [1.0833, 0.3333],
                        "Wawati TC Regular": [1.0833, 0.3333],
                        "Webdings": [0.8333, 0.1667],
                        "Weibei SC Bold": [1.0833, 0.3333],
                        "Weibei TC Bold": [1.0833, 0.3333],
                        "Wingdings": [0.9167, 0.25],
                        "Wingdings 2": [0.8333, 0.25],
                        "Wingdings 3": [0.9167, 0.25],
                        "Xingkai SC Bold": [1.0833, 0.3333],
                        "Xingkai SC Light": [1.0833, 0.3333],
                        "Yuanti SC Bold": [1.0833, 0.3333],
                        "Yuanti SC Light": [1.0833, 0.3333],
                        "Yuanti SC Regular": [1.0833, 0.3333],
                        "YuGothic Bold": [0.9167, 0.0833],
                        "YuGothic Medium": [0.9167, 0.0833],
                        "YuMincho Demibold": [0.9167, 0.0833],
                        "YuMincho Medium": [0.9167, 0.0833],
                        "Yuppy SC Regular": [1.0833, 0.3333],
                        "Yuppy TC Regular": [1.0833, 0.3333],
                        "Zapf Dingbats": [0.8333, 0.1667],
                        "Zapfino": [1.9167, 1.5]
                    };
                    // Measurements taken on a freshly installed Ubuntu Linux 12.04.5 (Precise Pangolin).
                    _this.DEVICE_FONT_METRICS_LINUX = {
                        __proto__: _this.DEVICE_FONT_METRICS_BUILTIN,
                        "KacstFarsi": [1.0417, 0.5208],
                        "Meera": [0.651, 0.4557],
                        "FreeMono": [0.7812, 0.1953],
                        "Loma": [1.1719, 0.4557],
                        "Century Schoolbook L": [0.9766, 0.3255],
                        "KacstTitleL": [1.0417, 0.5208],
                        "Garuda": [1.3021, 0.5859],
                        "Rekha": [1.1068, 0.2604],
                        "Purisa": [1.1068, 0.5208],
                        "DejaVu Sans Mono": [0.9115, 0.2604],
                        "Vemana2000": [0.9115, 0.8464],
                        "KacstOffice": [1.0417, 0.5208],
                        "Umpush": [1.237, 0.651],
                        "OpenSymbol": [0.7812, 0.1953],
                        "Sawasdee": [1.1068, 0.4557],
                        "URW Palladio L": [0.9766, 0.3255],
                        "FreeSerif": [0.9115, 0.3255],
                        "KacstDigital": [1.0417, 0.5208],
                        "Ubuntu Condensed": [0.9115, 0.1953],
                        "mry_KacstQurn": [1.4323, 0.7161],
                        "URW Gothic L": [0.9766, 0.2604],
                        "Dingbats": [0.8464, 0.1953],
                        "URW Chancery L": [0.9766, 0.3255],
                        "Phetsarath OT": [1.1068, 0.5208],
                        "Tlwg Typist": [0.9115, 0.3906],
                        "KacstLetter": [1.0417, 0.5208],
                        "utkal": [1.1719, 0.651],
                        "Norasi": [1.237, 0.5208],
                        "KacstOne": [1.237, 0.651],
                        "Liberation Sans Narrow": [0.9115, 0.2604],
                        "Symbol": [1.0417, 0.3255],
                        "NanumMyeongjo": [0.9115, 0.2604],
                        "Untitled1": [0.651, 0.5859],
                        "Lohit Gujarati": [0.9115, 0.3906],
                        "Liberation Mono": [0.8464, 0.3255],
                        "KacstArt": [1.0417, 0.5208],
                        "Mallige": [0.9766, 0.651],
                        "Bitstream Charter": [0.9766, 0.2604],
                        "NanumGothic": [0.9115, 0.2604],
                        "Liberation Serif": [0.9115, 0.2604],
                        "Ubuntu": [0.9115, 0.1953],
                        "Courier 10 Pitch": [0.8464, 0.3255],
                        "Nimbus Sans L": [0.9766, 0.3255],
                        "TakaoPGothic": [0.9115, 0.1953],
                        "WenQuanYi Micro Hei Mono": [0.9766, 0.2604],
                        "DejaVu Sans": [0.9115, 0.2604],
                        "Kedage": [0.9766, 0.651],
                        "Kinnari": [1.3021, 0.5208],
                        "TlwgMono": [0.8464, 0.3906],
                        "Standard Symbols L": [1.0417, 0.3255],
                        "Lohit Punjabi": [1.1719, 0.651],
                        "Nimbus Mono L": [0.8464, 0.3255],
                        "Rachana": [0.651, 0.5859],
                        "Waree": [1.237, 0.4557],
                        "KacstPoster": [1.0417, 0.5208],
                        "Khmer OS": [1.3021, 0.7161],
                        "FreeSans": [0.9766, 0.3255],
                        "gargi": [0.9115, 0.3255],
                        "Nimbus Roman No9 L": [0.9115, 0.3255],
                        "DejaVu Serif": [0.9115, 0.2604],
                        "WenQuanYi Micro Hei": [0.9766, 0.2604],
                        "Ubuntu Light": [0.9115, 0.1953],
                        "TlwgTypewriter": [0.9115, 0.3906],
                        "KacstPen": [1.0417, 0.5208],
                        "Tlwg Typo": [0.9115, 0.3906],
                        "Mukti Narrow": [1.237, 0.4557],
                        "Ubuntu Mono": [0.8464, 0.1953],
                        "Lohit Bengali": [0.9766, 0.4557],
                        "Liberation Sans": [0.9115, 0.2604],
                        "KacstDecorative": [1.1068, 0.5208],
                        "Khmer OS System": [1.237, 0.5859],
                        "Saab": [0.9766, 0.651],
                        "KacstTitle": [1.0417, 0.5208],
                        "Mukti Narrow Bold": [1.237, 0.4557],
                        "Lohit Hindi": [0.9766, 0.5208],
                        "KacstQurn": [1.0417, 0.5208],
                        "URW Bookman L": [0.9766, 0.3255],
                        "KacstNaskh": [1.0417, 0.5208],
                        "KacstScreen": [1.0417, 0.5208],
                        "Pothana2000": [0.9115, 0.8464],
                        "Lohit Tamil": [0.8464, 0.3906],
                        "KacstBook": [1.0417, 0.5208],
                        "Sans": [0.9115, 0.2604],
                        "Times": [0.9115, 0.3255],
                        "Monospace": [0.9115, 0.2604]
                    };
                    _this.StaticText = new system.LegacyClass(flash.text.StaticText);
                    _this.Font = new system.LegacyClass(flash.text.Font);
                    _this.TextRun = new system.LegacyClass(flash.text.TextRun);
                    _this.TextFormat = new system.LegacyClass(flash.text.TextFormat);
                    _this.TextLineMetrics = new system.LegacyClass(flash.text.TextLineMetrics);
                    _this.TextField = new system.LegacyClass(flash.text.TextField);
                    _this._fonts = [];
                    _this._fontsBySymbolId = Shumway.ObjectUtilities.createMap();
                    _this._fontsByName = Shumway.ObjectUtilities.createMap();
                    var userAgent = self.navigator.userAgent;
                    if (userAgent.indexOf("Windows") > -1) {
                        _this._deviceFontMetrics = _this.DEVICE_FONT_METRICS_WIN;
                    }
                    else if (/(Macintosh|iPad|iPhone|iPod|Android)/.test(userAgent)) {
                        _this._deviceFontMetrics = _this.DEVICE_FONT_METRICS_MAC;
                        _this.DEFAULT_FONT_SANS = 'Helvetica';
                        _this.DEFAULT_FONT_SERIF = 'Times Roman';
                        _this.DEFAULT_FONT_TYPEWRITER = 'Courier';
                    }
                    else {
                        _this._deviceFontMetrics = _this.DEVICE_FONT_METRICS_LINUX;
                        _this.DEFAULT_FONT_SANS = 'Sans';
                        _this.DEFAULT_FONT_SERIF = 'Times';
                        _this.DEFAULT_FONT_TYPEWRITER = 'Monospace';
                    }
                    var metrics = _this._deviceFontMetrics;
                    for (var fontName in metrics) {
                        metrics[fontName.toLowerCase()] = metrics[fontName];
                    }
                    return _this;
                }
                TextNamespace.prototype._getFontMetrics = function (name, style) {
                    return this._deviceFontMetrics[name + style] || this._deviceFontMetrics[name];
                };
                TextNamespace.prototype.resolveFontName = function (name) {
                    if (name === '_sans') {
                        return this.DEFAULT_FONT_SANS;
                    }
                    else if (name === '_serif') {
                        return this.DEFAULT_FONT_SERIF;
                    }
                    else if (name === '_typewriter') {
                        return this.DEFAULT_FONT_TYPEWRITER;
                    }
                    return name;
                };
                TextNamespace.prototype.getBySymbolId = function (id) {
                    return this._fontsBySymbolId[id];
                };
                TextNamespace.prototype.getByNameAndStyle = function (name, style) {
                    var key;
                    var font;
                    // The name argument can be a string specifying a list of comma-delimited font names in which
                    // case the first available font should be used.
                    var names = name.split(',');
                    for (var i = 0; i < names.length && !font; i++) {
                        key = names[i].toLowerCase() + style;
                        font = this._fontsByName[key];
                    }
                    if (!font) {
                        font = this.Font.create();
                        font._fontName = names[0];
                        font._fontFamily = this.resolveFontName(names[0].toLowerCase());
                        font._fontStyle = style;
                        font._fontType = FontType.DEVICE;
                        this._fontsByName[key] = font;
                    }
                    if (font._fontType === FontType.DEVICE) {
                        var metrics = this._getFontMetrics(font._fontName, font._fontStyle);
                        if (!metrics) {
                            Shumway.Debug.warning('Font metrics for "' + font._fontName + '" unknown. Fallback to default.');
                            metrics = this._getFontMetrics(this.DEFAULT_FONT_SANS, font._fontStyle);
                            font._fontFamily = this.DEFAULT_FONT_SANS;
                        }
                        font.ascent = metrics[0];
                        font.descent = metrics[1];
                        font.leading = metrics[2] || 0;
                    }
                    return font;
                };
                TextNamespace.prototype.getDefaultFont = function () {
                    return this.getByNameAndStyle(this.DEFAULT_FONT_SANS, FontStyle.REGULAR);
                };
                /**
                 * Registers a font symbol as available in the system.
                 *
                 * Firefox decodes fonts synchronously, allowing us to do the decoding upon first actual use.
                 * All we need to do here is let the system know about the family name and ID, so that both
                 * TextFields/Labels referring to the font's symbol ID as well as HTML text specifying a font
                 * face can resolve the font.
                 *
                 * For all other browsers, the decoding has been triggered by the Loader at this point.
                 */
                TextNamespace.prototype.registerFontSymbol = function (fontMapping, loaderInfo) {
                    var syncId = flash.display.DisplayObject.getNextSyncID();
                    var key = fontMapping.name.toLowerCase() + fontMapping.style;
                    var resolverProp = {
                        get: this.resolveFontSymbol.bind(this, loaderInfo, fontMapping.id, syncId, key),
                        configurable: true
                    };
                    Object.defineProperty(this._fontsByName, key, resolverProp);
                    Object.defineProperty(this._fontsByName, 'swffont' + syncId + fontMapping.style, resolverProp);
                    Object.defineProperty(this._fontsBySymbolId, fontMapping.id + '', resolverProp);
                };
                TextNamespace.prototype.resolveFontSymbol = function (loaderInfo, id, syncId, key) {
                    // Force font resolution and installation in _fontsByName and _fontsBySymbolId.
                    release || assert('get' in Object.getOwnPropertyDescriptor(this._fontsBySymbolId, id + ''));
                    var symbol = loaderInfo.getSymbolById(id);
                    symbol.syncId = syncId;
                    release || assert('value' in Object.getOwnPropertyDescriptor(this._fontsBySymbolId, id + ''));
                    release || assert('value' in Object.getOwnPropertyDescriptor(this._fontsByName, key));
                    return this._fontsByName[key];
                };
                return TextNamespace;
            }(system.LegacyNamespace));
            system.TextNamespace = TextNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var assert = Shumway.Debug.assert;
            var DropShadowFilterClass = /** @class */ (function (_super) {
                __extends(DropShadowFilterClass, _super);
                function DropShadowFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                DropShadowFilterClass.prototype.FromUntyped = function (obj) {
                    // obj.colors is an array of RGBA colors.
                    // Here it contains exactly one color object, which maps to color and alpha.
                    release || assert(obj.colors && obj.colors.length === 1, "colors must be Array of length 1");
                    var color = obj.colors[0] >>> 8;
                    var alpha = (obj.colors[0] & 0xff) / 0xff;
                    // obj.angle is represented in radians, the api needs degrees
                    var angle = obj.angle * 180 / Math.PI;
                    // obj.compositeSource maps to !hideObject
                    var hideObject = !obj.compositeSource;
                    return this.create([
                        obj.distance,
                        angle,
                        color,
                        alpha,
                        obj.blurX,
                        obj.blurY,
                        obj.strength,
                        obj.quality,
                        obj.inner,
                        obj.knockout,
                        hideObject
                    ]);
                };
                return DropShadowFilterClass;
            }(system.LegacyClass));
            system.DropShadowFilterClass = DropShadowFilterClass;
            var BlurFilterClass = /** @class */ (function (_super) {
                __extends(BlurFilterClass, _super);
                function BlurFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                BlurFilterClass.prototype.FromUntyped = function (obj) {
                    return this.create([obj.blurX, obj.blurY, obj.quality]);
                };
                return BlurFilterClass;
            }(system.LegacyClass));
            system.BlurFilterClass = BlurFilterClass;
            var GlowFilterClass = /** @class */ (function (_super) {
                __extends(GlowFilterClass, _super);
                function GlowFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                GlowFilterClass.prototype.FromUntyped = function (obj) {
                    // obj.colors is an array of RGBA colors.
                    // Here it contains exactly one color object, which maps to color and alpha.
                    release || assert(obj.colors && obj.colors.length === 1, "colors must be Array of length 1");
                    var color = obj.colors[0] >>> 8;
                    var alpha = (obj.colors[0] & 0xff) / 0xff;
                    return this.create([
                        color,
                        alpha,
                        obj.blurX,
                        obj.blurY,
                        obj.strength,
                        obj.quality,
                        obj.inner,
                        obj.knockout
                    ]);
                };
                return GlowFilterClass;
            }(system.LegacyClass));
            system.GlowFilterClass = GlowFilterClass;
            var BevelFilterClass = /** @class */ (function (_super) {
                __extends(BevelFilterClass, _super);
                function BevelFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                BevelFilterClass.prototype.FromUntyped = function (obj) {
                    // obj.colors is an array of RGBA colors.
                    // Here it contains exactly two color objects (spec might state it differently):
                    //  - first maps to highlightColor and highlightAlpha;
                    //  - second maps to shadowColor and shadowAlpha;
                    release || assert(obj.colors && obj.colors.length === 2, "colors must be Array of length 2");
                    var highlightColor = obj.colors[0] >>> 8;
                    var highlightAlpha = (obj.colors[0] & 0xff) / 0xff;
                    var shadowColor = obj.colors[1] >>> 8;
                    var shadowAlpha = (obj.colors[1] & 0xff) / 0xff;
                    // type is derived from obj.onTop and obj.innerShadow
                    // obj.onTop true: type is FULL
                    // obj.inner true: type is INNER
                    // neither true: type is OUTER
                    var type = flash.filters.BitmapFilterType.OUTER;
                    if (!!obj.onTop) {
                        type = flash.filters.BitmapFilterType.FULL;
                    }
                    else if (!!obj.inner) {
                        type = flash.filters.BitmapFilterType.INNER;
                    }
                    // obj.angle is represented in radians, the api needs degrees
                    var angle = obj.angle * 180 / Math.PI;
                    return this.create([
                        obj.distance,
                        angle,
                        highlightColor,
                        highlightAlpha,
                        shadowColor,
                        shadowAlpha,
                        obj.blurX,
                        obj.blurY,
                        obj.strength,
                        obj.quality,
                        type,
                        obj.knockout
                    ]);
                };
                return BevelFilterClass;
            }(system.LegacyClass));
            system.BevelFilterClass = BevelFilterClass;
            var GradientGlowFilterClass = /** @class */ (function (_super) {
                __extends(GradientGlowFilterClass, _super);
                function GradientGlowFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                GradientGlowFilterClass.prototype.FromUntyped = function (obj) {
                    // obj.colors is an array of RGBA colors.
                    // The RGB and alpha parts must be separated into colors and alphas arrays.
                    var colors = [];
                    var alphas = [];
                    for (var i = 0; i < obj.colors.length; i++) {
                        var color = obj.colors[i];
                        colors.push(color >>> 8);
                        alphas.push((color & 0xff) / 0xff);
                    }
                    // type is derived from obj.onTop and obj.innerShadow
                    // obj.onTop true: type is FULL
                    // obj.inner true: type is INNER
                    // neither true: type is OUTER
                    var type = flash.filters.BitmapFilterType.OUTER;
                    if (!!obj.onTop) {
                        type = flash.filters.BitmapFilterType.FULL;
                    }
                    else if (!!obj.inner) {
                        type = flash.filters.BitmapFilterType.INNER;
                    }
                    // obj.angle is represented in radians, the api needs degrees
                    var angle = obj.angle * 180 / Math.PI;
                    return this.create([
                        obj.distance,
                        angle,
                        // Boxing these is obviously not ideal, but everything else is just annoying.
                        colors,
                        alphas,
                        obj.ratios,
                        obj.blurX,
                        obj.blurY,
                        obj.strength,
                        obj.quality,
                        type,
                        obj.knockout
                    ]);
                };
                return GradientGlowFilterClass;
            }(system.LegacyClass));
            system.GradientGlowFilterClass = GradientGlowFilterClass;
            var ConvolutionFilterClass = /** @class */ (function (_super) {
                __extends(ConvolutionFilterClass, _super);
                function ConvolutionFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ConvolutionFilterClass.prototype.FromUntyped = function (obj) {
                    return this.create([
                        obj.matrixX,
                        obj.matrixY,
                        obj.matrix,
                        obj.divisor,
                        obj.bias,
                        obj.preserveAlpha,
                        obj.clamp,
                        // obj.color is an RGBA color.
                        obj.color >>> 8,
                        (obj.color & 0xff) / 0xff
                    ]);
                };
                return ConvolutionFilterClass;
            }(system.LegacyClass));
            system.ConvolutionFilterClass = ConvolutionFilterClass;
            var ColorMatrixFilterClass = /** @class */ (function (_super) {
                __extends(ColorMatrixFilterClass, _super);
                function ColorMatrixFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ColorMatrixFilterClass.prototype.FromUntyped = function (obj) {
                    var filter = this.createObject();
                    filter._matrix = obj.matrix;
                    return filter;
                };
                return ColorMatrixFilterClass;
            }(system.LegacyClass));
            system.ColorMatrixFilterClass = ColorMatrixFilterClass;
            var GradientBevelFilterClass = /** @class */ (function (_super) {
                __extends(GradientBevelFilterClass, _super);
                function GradientBevelFilterClass() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                GradientBevelFilterClass.prototype.FromUntyped = function (obj) {
                    // obj.colors is an array of RGBA colors.
                    // The RGB and alpha parts must be separated into colors and alphas arrays.
                    var colors = [];
                    var alphas = [];
                    for (var i = 0; i < obj.colors.length; i++) {
                        var color = obj.colors[i];
                        colors.push(color >>> 8);
                        alphas.push((color & 0xff) / 0xff);
                    }
                    // type is derived from obj.onTop and obj.innerShadow
                    // obj.onTop true: type is FULL
                    // obj.inner true: type is INNER
                    // neither true: type is OUTER
                    var type = flash.filters.BitmapFilterType.OUTER;
                    if (!!obj.onTop) {
                        type = flash.filters.BitmapFilterType.FULL;
                    }
                    else if (!!obj.inner) {
                        type = flash.filters.BitmapFilterType.INNER;
                    }
                    // obj.angle is represented in radians, the api needs degrees
                    var angle = obj.angle * 180 / Math.PI;
                    return this.create([
                        obj.distance,
                        angle,
                        // Boxing these is obviously not ideal, but everything else is just annoying.
                        colors,
                        alphas,
                        obj.ratios,
                        obj.blurX,
                        obj.blurY,
                        obj.strength,
                        obj.quality,
                        type,
                        obj.knockout
                    ]);
                };
                return GradientBevelFilterClass;
            }(system.LegacyClass));
            system.GradientBevelFilterClass = GradientBevelFilterClass;
            var FiltersNamespace = /** @class */ (function (_super) {
                __extends(FiltersNamespace, _super);
                function FiltersNamespace() {
                    var _this = _super.call(this) || this;
                    _this.BitmapFilter = new system.LegacyClass(flash.filters.BitmapFilter);
                    _this.DropShadowFilter = new DropShadowFilterClass(flash.filters.DropShadowFilter);
                    _this.BlurFilter = new BlurFilterClass(flash.filters.BlurFilter);
                    _this.GlowFilter = new GlowFilterClass(flash.filters.GlowFilter);
                    _this.BevelFilter = new BevelFilterClass(flash.filters.BevelFilter);
                    _this.GradientGlowFilter = new GradientGlowFilterClass(flash.filters.GradientGlowFilter);
                    _this.ConvolutionFilter = new ConvolutionFilterClass(flash.filters.ConvolutionFilter);
                    _this.ColorMatrixFilter = new ColorMatrixFilterClass(flash.filters.ColorMatrixFilter);
                    _this.GradientBevelFilter = new GradientBevelFilterClass(flash.filters.GradientBevelFilter);
                    _this.DisplacementMapFilter = new system.LegacyClass(flash.filters.DisplacementMapFilter);
                    _this.swfFilterTypes = [_this.DropShadowFilter, _this.BlurFilter, _this.GlowFilter, _this.BevelFilter,
                        _this.GradientGlowFilter, _this.ConvolutionFilter, _this.ColorMatrixFilter, _this.GradientBevelFilter];
                    return _this;
                }
                return FiltersNamespace;
            }(system.LegacyNamespace));
            system.FiltersNamespace = FiltersNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var MediaNamespace = /** @class */ (function () {
                function MediaNamespace() {
                    this.ID3Info = new system.LegacyClass(flash.media.ID3Info);
                    this.Sound = new system.LegacyClass(flash.media.Sound);
                    this.SoundChannel = new system.LegacyClass(flash.media.SoundChannel);
                    this.SoundTransform = new system.LegacyClass(flash.media.SoundTransform);
                    this.Video = new system.LegacyClass(flash.media.Video);
                }
                return MediaNamespace;
            }());
            system.MediaNamespace = MediaNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var SharedObjectClass = /** @class */ (function (_super) {
                __extends(SharedObjectClass, _super);
                function SharedObjectClass() {
                    return _super.call(this, flash.net.SharedObject) || this;
                }
                return SharedObjectClass;
            }(system.LegacyClass));
            system.SharedObjectClass = SharedObjectClass;
            var NetNamespace = /** @class */ (function () {
                function NetNamespace() {
                    this.URLRequestHeader = new system.LegacyClass(flash.net.URLRequestHeader);
                    this.URLVariables = new system.LegacyClass(flash.net.URLVariables);
                    this.URLStream = new system.LegacyClass(flash.net.URLStream);
                    this.URLRequest = new system.LegacyClass(flash.net.URLRequest);
                    this.SharedObject = new SharedObjectClass();
                    this.NetStreamInfo = new system.LegacyClass(flash.net.NetStreamInfo);
                }
                return NetNamespace;
            }());
            system.NetNamespace = NetNamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var UINamespace = /** @class */ (function (_super) {
                __extends(UINamespace, _super);
                function UINamespace() {
                    var _this = _super.call(this) || this;
                    _this.Mouse = new system.MouseClass();
                    _this.ContextMenu = new system.LegacyClass(flash.ui.ContextMenu);
                    _this.ContextMenuBuiltInItems = new system.LegacyClass(flash.ui.ContextMenuBuiltInItems);
                    _this.ContextMenuClipboardItems = new system.LegacyClass(flash.ui.ContextMenuClipboardItems);
                    return _this;
                }
                return UINamespace;
            }(system.LegacyNamespace));
            system.UINamespace = UINamespace;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var assert = Shumway.Debug.assert;
            var LoadStatus = flash.display.LoadStatus;
            var LoadingType = flash.display.LoadingType;
            var Event = flash.events.Event;
            var ProgressEvent = flash.events.ProgressEvent;
            var enterTimeline = Shumway.enterTimeline;
            var leaveTimeline = Shumway.leaveTimeline;
            var LoaderClass = /** @class */ (function (_super) {
                __extends(LoaderClass, _super);
                function LoaderClass() {
                    var _this = _super.call(this, flash.display.Loader) || this;
                    _this.runtimeStartTime = 0;
                    _this._rootLoader = null;
                    _this._loadQueue = [];
                    _this._embeddedContentLoadCount = 0;
                    // LoaderInfo
                    _this.CtorToken = {};
                    _this.init();
                    return _this;
                }
                LoaderClass.prototype.init = function () {
                    this._rootLoader = null;
                    this._loadQueue = [];
                    this.runtimeStartTime = 0;
                    this._embeddedContentLoadCount = 0;
                };
                /**
                 * Creates or returns the root Loader instance. The loader property of that instance's
                 * LoaderInfo object is always null. Also, no OPEN event ever gets dispatched.
                 */
                LoaderClass.prototype.getRootLoader = function () {
                    if (this._rootLoader) {
                        return this._rootLoader;
                    }
                    var loader = this._sec.display.Loader.create();
                    // The root loaderInfo's `loader` property is always null.
                    loader._contentLoaderInfo._loader = null;
                    this._rootLoader = loader;
                    return loader;
                };
                LoaderClass.prototype.reset = function () {
                    this._loadQueue.forEach(function (loader) { return loader.unload(); });
                    this.init();
                };
                /**
                 * In each turn of the event loop, Loader events are processed in two batches:
                 * first INIT and COMPLETE events are dispatched for all active Loaders, then
                 * OPEN and PROGRESS.
                 *
                 * A slightly weird result of this is that INIT and COMPLETE are dispatched at
                 * least one turn later than the other events: INIT is dispatched after the
                 * content has been created. That, in turn, happens under
                 * `DisplayObject.performFrameNavigation` in reaction to enough data being
                 * marked as available - which happens in the second batch of Loader event
                 * processing.
                 */
                LoaderClass.prototype.processEvents = function () {
                    this.processEarlyEvents();
                    this.processLateEvents();
                };
                LoaderClass.prototype.processEarlyEvents = function () {
                    var queue = this._loadQueue;
                    for (var i = 0; i < queue.length; i++) {
                        var instance = queue[i];
                        release || assert(instance._loadStatus !== LoadStatus.Complete);
                        var loaderInfo = instance._contentLoaderInfo;
                        var imageSymbol = instance._imageSymbol;
                        // For images, only dispatch INIT and COMPLETE once the image has been decoded.
                        if (loaderInfo._file instanceof Shumway.ImageFile) {
                            if (!imageSymbol || !imageSymbol.ready || instance._queuedLoadUpdate) {
                                continue;
                            }
                            release || assert(loaderInfo.bytesLoaded === loaderInfo.bytesTotal);
                            instance._applyDecodedImage(imageSymbol);
                            release || assert(instance._content);
                        }
                        if (instance._loadStatus === LoadStatus.Opened && instance._content) {
                            enterTimeline("Loader.INIT");
                            try {
                                loaderInfo.dispatchEvent(this._sec.events.getInstance(Event.INIT));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under loaderInfo INIT event:', e);
                            }
                            leaveTimeline();
                            instance._loadStatus = LoadStatus.Initialized;
                            // Only for the root loader, progress events for the data loaded up until now are
                            // dispatched here.
                            if (instance === this._rootLoader) {
                                enterTimeline("Loader.Progress", 'rootLoader');
                                try {
                                    loaderInfo.dispatchEvent(this._sec.events.ProgressEvent.create([
                                        flash.events.ProgressEvent.PROGRESS,
                                        false, false,
                                        loaderInfo.bytesLoaded,
                                        loaderInfo.bytesTotal
                                    ]));
                                }
                                catch (e) {
                                    Shumway.Debug.warning('caught error under loaderInfo PROGRESS event:', e);
                                }
                                leaveTimeline();
                            }
                        }
                        if (instance._loadStatus === LoadStatus.Initialized &&
                            loaderInfo.bytesLoaded === loaderInfo.bytesTotal) {
                            queue.splice(i--, 1);
                            release || assert(queue.indexOf(instance) === -1);
                            instance._loadStatus = LoadStatus.Complete;
                            enterTimeline("Loader.Complete");
                            try {
                                loaderInfo.dispatchEvent(this._sec.events.getInstance(Event.COMPLETE));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under loaderInfo COMPLETE event: ', e);
                            }
                            leaveTimeline();
                        }
                    }
                };
                LoaderClass.prototype.processLateEvents = function () {
                    var queue = this._loadQueue;
                    for (var i = 0; i < queue.length; i++) {
                        var instance = queue[i];
                        release || assert(instance._loadStatus !== LoadStatus.Complete);
                        var loaderInfo = instance._contentLoaderInfo;
                        var update = instance._queuedLoadUpdate;
                        var bytesTotal = loaderInfo._bytesTotal;
                        if ((!update || !bytesTotal) && instance._loadStatus !== LoadStatus.Opened) {
                            continue;
                        }
                        instance._queuedLoadUpdate = null;
                        var progressEventCtor = this._sec.events.ProgressEvent;
                        if (instance._loadStatus === LoadStatus.Unloaded) {
                            // OPEN is only dispatched when loading external resources, not for loadBytes.
                            if (instance._loadingType === LoadingType.External) {
                                enterTimeline("Loader.Open");
                                try {
                                    loaderInfo.dispatchEvent(this._sec.events.getInstance(Event.OPEN));
                                }
                                catch (e) {
                                    Shumway.Debug.warning('caught error under loaderInfo OPEN event: ', e);
                                }
                                leaveTimeline();
                            }
                            // The first time any progress is made at all, a progress event with bytesLoaded = 0
                            // is dispatched.
                            enterTimeline("Loader.Progress");
                            try {
                                loaderInfo.dispatchEvent(progressEventCtor.create([ProgressEvent.PROGRESS,
                                    false, false, 0, bytesTotal]));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under loaderInfo PROGRESS event: ', e);
                            }
                            leaveTimeline();
                            instance._loadStatus = LoadStatus.Opened;
                        }
                        // TODO: The Flash player reports progress in 16kb chunks, in a tight loop right here.
                        if (update) {
                            instance._applyLoadUpdate(update);
                            enterTimeline("Loader.Progress");
                            try {
                                loaderInfo.dispatchEvent(progressEventCtor.create([ProgressEvent.PROGRESS,
                                    false, false, update.bytesLoaded,
                                    bytesTotal]));
                            }
                            catch (e) {
                                Shumway.Debug.warning('caught error under loaderInfo PROGRESS event: ', e);
                            }
                            leaveTimeline();
                        }
                    }
                };
                return LoaderClass;
            }(system.LegacyClass));
            system.LoaderClass = LoaderClass;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            var MouseCursor = flash.ui.MouseCursor;
            var MouseClass = /** @class */ (function (_super) {
                __extends(MouseClass, _super);
                function MouseClass() {
                    var _this = _super.call(this, flash.ui.Mouse) || this;
                    _this.init();
                    return _this;
                }
                MouseClass.prototype.init = function () {
                    this._currentPosition = this._sec.geom.Point.create();
                    this._cursor = MouseCursor.AUTO;
                    this.draggableObject = null;
                };
                //static _supportsCursor: boolean;
                //static _supportsNativeCursor: boolean;
                /**
                 * Remembers the current mouse position.
                 */
                MouseClass.prototype.updateCurrentPosition = function (value) {
                    this._currentPosition.copyFrom(value);
                };
                return MouseClass;
            }(system.LegacyClass));
            system.MouseClass = MouseClass;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var flash;
    (function (flash) {
        var system;
        (function (system) {
            function M(name, asClass) {
                flash.lang.registerNativeClass(name, asClass);
            }
            M("flash.display.DisplayObject", flash.display.DisplayObject);
            M("flash.display.InteractiveObject", flash.display.InteractiveObject);
            M("flash.display.DisplayObjectContainer", flash.display.DisplayObjectContainer);
            M("flash.display.Sprite", flash.display.Sprite);
            M("flash.display.MovieClip", flash.display.MovieClip);
            M("flash.display.Shape", flash.display.Shape);
            M("flash.display.Bitmap", flash.display.Bitmap);
            M("flash.display.BitmapData", flash.display.BitmapData);
            M("flash.display.Stage", flash.display.Stage);
            M("flash.display.Loader", flash.display.Loader);
            M("flash.display.LoaderInfo", flash.display.LoaderInfo);
            M("flash.display.Graphics", flash.display.Graphics);
            M("flash.display.SimpleButton", flash.display.SimpleButton);
            M("flash.display.MorphShape", flash.display.MorphShape);
            M("flash.display.NativeMenu", flash.display.NativeMenu);
            M("flash.display.NativeMenuItem", flash.display.NativeMenuItem);
            M("flash.display.FrameLabel", flash.display.FrameLabel);
            M("flash.display.Scene", flash.display.Scene);
            M("flash.display.AVM1Movie", flash.display.AVM1Movie);
            M("flash.display.GradientType", flash.display.GradientType);
            M("flash.display.SpreadMethod", flash.display.SpreadMethod);
            M("flash.display.InterpolationMethod", flash.display.InterpolationMethod);
            M("flash.display.LineScaleMode", flash.display.LineScaleMode);
            M("flash.display.CapsStyle", flash.display.CapsStyle);
            M("flash.display.JointStyle", flash.display.JointStyle);
            M("flash.filters.BevelFilter", flash.filters.BevelFilter);
            M("flash.filters.BitmapFilter", flash.filters.BitmapFilter);
            M("flash.filters.BlurFilter", flash.filters.BlurFilter);
            M("flash.filters.ColorMatrixFilter", flash.filters.ColorMatrixFilter);
            M("flash.filters.ConvolutionFilter", flash.filters.ConvolutionFilter);
            M("flash.filters.DisplacementMapFilter", flash.filters.DisplacementMapFilter);
            M("flash.filters.DropShadowFilter", flash.filters.DropShadowFilter);
            M("flash.filters.GlowFilter", flash.filters.GlowFilter);
            M("flash.filters.GradientBevelFilter", flash.filters.GradientBevelFilter);
            M("flash.filters.GradientGlowFilter", flash.filters.GradientGlowFilter);
            M("flash.geom.Point", flash.geom.Point);
            M("flash.geom.Rectangle", flash.geom.Rectangle);
            M("flash.geom.Matrix", flash.geom.Matrix);
            M("flash.geom.Matrix3D", flash.geom.Matrix3D);
            M("flash.geom.Vector3D", flash.geom.Vector3D);
            M("flash.geom.Transform", flash.geom.Transform);
            M("flash.geom.ColorTransform", flash.geom.ColorTransform);
            M("flash.geom.PerspectiveProjection", flash.geom.PerspectiveProjection);
            M("flash.events.EventDispatcher", flash.events.EventDispatcher);
            M("flash.events.Event", flash.events.Event);
            M("flash.events.ErrorEvent", flash.events.ErrorEvent);
            M("flash.events.IOErrorEvent", flash.events.IOErrorEvent);
            M("flash.events.KeyboardEvent", flash.events.KeyboardEvent);
            M("flash.events.MouseEvent", flash.events.MouseEvent);
            M("flash.events.GestureEvent", flash.events.GestureEvent);
            M("flash.events.TextEvent", flash.events.TextEvent);
            M("flash.events.TimerEvent", flash.events.TimerEvent);
            M("flash.events.ProgressEvent", flash.events.ProgressEvent);
            M("flash.events.StatusEvent", flash.events.StatusEvent);
            M("flash.events.NetStatusEvent", flash.events.NetStatusEvent);
            M("flash.events.HTTPStatusEvent", flash.events.HTTPStatusEvent);
            M("flash.events.AsyncErrorEvent", flash.events.AsyncErrorEvent);
            M("flash.events.UncaughtErrorEvents", flash.events.UncaughtErrorEvents);
            M("flash.external.ExternalInterface", flash.external.ExternalInterface);
            M("flash.ui.ContextMenu", flash.ui.ContextMenu);
            M("flash.ui.ContextMenuItem", flash.ui.ContextMenuItem);
            M("flash.ui.ContextMenuBuiltInItems", flash.ui.ContextMenuBuiltInItems);
            M("flash.ui.ContextMenuClipboardItems", flash.ui.ContextMenuClipboardItems);
            M("flash.ui.Keyboard", flash.ui.Keyboard);
            M("flash.ui.Mouse", flash.ui.Mouse);
            M("flash.ui.MouseCursorData", flash.ui.MouseCursorData);
            M("flash.ui.GameInput", flash.ui.GameInput);
            M("flash.events.GameInputEvent", flash.events.GameInputEvent);
            M("flash.ui.GameInputControl", flash.ui.GameInputControl);
            M("flash.ui.GameInputControlType", flash.ui.GameInputControlType);
            M("flash.ui.GameInputDevice", flash.ui.GameInputDevice);
            M("flash.ui.GameInputFinger", flash.ui.GameInputFinger);
            M("flash.ui.GameInputHand", flash.ui.GameInputHand);
            M("flash.ui.Multitouch", flash.ui.Multitouch);
            M("flash.ui.MultitouchInputMode", flash.ui.MultitouchInputMode);
            M("flash.events.TouchEvent", flash.events.TouchEvent);
            M("flash.text.Font", flash.text.Font);
            M("flash.text.TextField", flash.text.TextField);
            M("flash.text.StaticText", flash.text.StaticText);
            M("flash.text.StyleSheet", flash.text.StyleSheet);
            M("flash.text.TextFormat", flash.text.TextFormat);
            M("flash.text.TextRun", flash.text.TextRun);
            M("flash.text.TextSnapshot", flash.text.TextSnapshot);
            M("flash.text.TextLineMetrics", flash.text.TextLineMetrics);
            M("flash.media.Sound", flash.media.Sound);
            M("flash.media.SoundChannel", flash.media.SoundChannel);
            M("flash.media.SoundMixer", flash.media.SoundMixer);
            M("flash.media.SoundTransform", flash.media.SoundTransform);
            M("flash.media.Video", flash.media.Video);
            M("flash.media.StageVideo", flash.media.StageVideo);
            M("flash.media.ID3Info", flash.media.ID3Info);
            M("flash.media.Microphone", flash.media.Microphone);
            M("flash.media.Camera", flash.media.Camera);
            M("flash.net.FileFilter", flash.net.FileFilter);
            M("flash.net.FileReference", flash.net.FileReference);
            M("flash.net.FileReferenceList", flash.net.FileReferenceList);
            M("flash.net.NetConnection", flash.net.NetConnection);
            M("flash.net.NetStream", flash.net.NetStream);
            M("flash.net.NetStreamInfo", flash.net.NetStreamInfo);
            M("flash.net.Responder", flash.net.Responder);
            M("flash.net.URLRequest", flash.net.URLRequest);
            M("flash.net.URLRequestHeader", flash.net.URLRequestHeader);
            M("flash.net.URLStream", flash.net.URLStream);
            M("flash.net.URLLoader", flash.net.URLLoader);
            M("flash.net.SharedObject", flash.net.SharedObject);
            M("flash.net.ObjectEncoding", flash.net.ObjectEncoding);
            M("flash.net.LocalConnection", flash.net.LocalConnection);
            M("flash.net.Socket", flash.net.Socket);
            M("flash.net.URLVariables", flash.net.URLVariables);
            M("flash.system.Capabilities", flash.system.Capabilities);
            M("flash.system.Security", flash.system.Security);
            // @ivanpopelyshev: System
            // M("flash.system.System", flash.system.System);
            M("flash.system.SecurityDomain", flash.system.SecurityDomain);
            M("flash.system.ApplicationDomain", flash.system.ApplicationDomain);
            M("flash.system.JPEGLoaderContext", flash.system.JPEGLoaderContext);
            M("flash.system.LoaderContext", flash.system.LoaderContext);
            M("flash.accessibility.Accessibility", flash.accessibility.Accessibility);
            M("flash.accessibility.AccessibilityProperties", flash.accessibility.AccessibilityProperties);
            M("flash.utils.Timer", flash.utils.Timer);
            M("flash.utils.ByteArray", flash.utils.ByteArray);
            // @ivanpopelyshev: XML
            // M("flash.xml.XMLNode", flash.xml.XMLNode);
            // M("flash.xml.XMLDocument", flash.xml.XMLDocument);
            // registerNativeFunction('flash.system.fscommand', flash.system.fscommand);
            function constructClassFromSymbol(symbol, axClass) {
                system._currentSymbol = symbol;
                var instance = axClass.create();
                release || Shumway.Debug.assert(instance._symbol === symbol);
                return instance;
            }
            system.constructClassFromSymbol = constructClassFromSymbol;
        })(system = flash.system || (flash.system = {}));
    })(flash = Shumway.flash || (Shumway.flash = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='lang/lazy.ts'/>
///<reference path='lang/nat.ts'/>
///<reference path='module.ts' />
///<reference path='../htmlparser.ts' />
///<reference path='TextContent.ts' />
///<reference path='settings.ts' />
///<reference path='symbol.ts' />
///<reference path='geom/Matrix.ts' />
///<reference path='geom/Matrix3D.ts' />
///<reference path='geom/Orientation3D.ts' />
///<reference path='geom/PerspectiveProjection.ts' />
///<reference path='geom/Point.ts' />
///<reference path='geom/Rectangle.ts' />
///<reference path='geom/Transform.ts' />
///<reference path='geom/Utils3D.ts' />
///<reference path='geom/Vector3D.ts' />
///<reference path='accessibility/Accessibility.ts' />
///<reference path='accessibility/AccessibilityImplementation.ts' />
///<reference path='accessibility/AccessibilityProperties.ts' />
///<reference path='events/Event.ts' />
///<reference path='events/EventDispatcher.ts' />
///<reference path='events/EventPhase.ts' />
///<reference path='events/TextEvent.ts' />
///<reference path='events/ErrorEvent.ts' />
///<reference path='events/AsyncErrorEvent.ts' />
///<reference path='events/GameInputEvent.ts' />
///<reference path='events/GestureEvent.ts' />
///<reference path='events/HTTPStatusEvent.ts' />
///<reference path='events/IEventDispatcher.ts' />
///<reference path='events/IOErrorEvent.ts' />
///<reference path='events/KeyboardEvent.ts' />
///<reference path='events/MouseEvent.ts' />
///<reference path='events/NetStatusEvent.ts' />
///<reference path='events/ProgressEvent.ts' />
///<reference path='events/SecurityErrorEvent.ts' />
///<reference path='events/StatusEvent.ts' />
///<reference path='events/TimerEvent.ts' />
///<reference path='events/TouchEvent.ts' />
///<reference path='events/UncaughtErrorEvent.ts' />
///<reference path='events/UncaughtErrorEvents.ts' />
///<reference path='display/DisplayObject.ts' />
///<reference path='display/Bitmap.ts' />
///<reference path='display/graphics/Shape.ts' />
///<reference path='display/InteractiveObject.ts' />
///<reference path='display/SimpleButton.ts' />
///<reference path='display/DisplayObjectContainer.ts' />
///<reference path='display/enums/JointStyle.ts' />
///<reference path='display/enums/CapsStyle.ts' />
///<reference path='display/enums/LineScaleMode.ts' />
///<reference path='display/enums/GradientType.ts' />
///<reference path='display/enums/SpreadMethod.ts' />
///<reference path='display/enums/InterpolationMethod.ts' />
///<reference path='display/graphics/GraphicsBitmapFill.ts' />
///<reference path='display/graphics/GraphicsEndFill.ts' />
///<reference path='display/graphics/GraphicsGradientFill.ts' />
///<reference path='display/graphics/GraphicsPath.ts' />
///<reference path='display/enums/GraphicsPathCommand.ts' />
///<reference path='display/enums/GraphicsPathWinding.ts' />
// ///<reference path='display/GraphicsShaderFill.ts' />
///<reference path='display/graphics/GraphicsSolidFill.ts' />
///<reference path='display/graphics/GraphicsStroke.ts' />
///<reference path='display/graphics/GraphicsTrianglePath.ts' />
///<reference path='display/graphics/IDrawCommand.ts' />
///<reference path='display/graphics/IGraphicsData.ts' />
///<reference path='display/graphics/IGraphicsFill.ts' />
///<reference path='display/graphics/IGraphicsPath.ts' />
///<reference path='display/graphics/IGraphicsStroke.ts' />
///<reference path='display/graphics/Graphics.ts' />
///<reference path='display/Sprite.ts' />
///<reference path='display/MovieClip.ts' />
///<reference path='display/MovieClipSoundStream.ts' />
///<reference path='display/Stage.ts' />
///<reference path='display/enums/ActionScriptVersion.ts' />
///<reference path='display/enums/BlendMode.ts' />
///<reference path='display/enums/ColorCorrection.ts' />
///<reference path='display/enums/ColorCorrectionSupport.ts' />
///<reference path='display/enums/FocusDirection.ts' />
///<reference path='display/FrameLabel.ts' />
///<reference path='display/BitmapData.ts' />
///<reference path='display/enums/BitmapDataChannel.ts' />
///<reference path='display/enums/BitmapEncodingColorSpace.ts' />
///<reference path='display/IBitmapDrawable.ts' />
///<reference path='display/JPEGEncoderOptions.ts' />
// ///<reference path='display/JPEGXREncoderOptions.ts' />
///<reference path='display/Loader.ts' />
///<reference path='display/LoaderInfo.ts' />
///<reference path='display/graphics/MorphShape.ts' />
///<reference path='display/NativeMenu.ts' />
///<reference path='display/NativeMenuItem.ts' />
///<reference path='display/PNGEncoderOptions.ts' />
///<reference path='display/enums/PixelSnapping.ts' />
///<reference path='display/enums/SWFVersion.ts' />
///<reference path='display/Scene.ts' />
// ///<reference path='display/Shader.ts' />
// ///<reference path='display/ShaderData.ts' />
// ///<reference path='display/ShaderInput.ts' />
// ///<reference path='display/ShaderJob.ts' />
// ///<reference path='display/ShaderParameter.ts' />
// ///<reference path='display/ShaderParameterType.ts' />
// ///<reference path='display/ShaderPrecision.ts' />
// ///<reference path='display/Stage3D.ts' />
///<reference path='display/enums/StageAlign.ts' />
///<reference path='display/enums/StageDisplayState.ts' />
///<reference path='display/enums/StageQuality.ts' />
///<reference path='display/enums/StageScaleMode.ts' />
///<reference path='display/enums/TriangleCulling.ts' />
///<reference path='display/AVM1Movie.ts' />
///<reference path='external/ExternalInterface.ts' />
///<reference path='filters/BitmapFilterQuality.ts' />
///<reference path='filters/BitmapFilterType.ts' />
///<reference path='filters/BitmapFilter.ts' />
///<reference path='filters/BevelFilter.ts' />
///<reference path='filters/BlurFilter.ts' />
///<reference path='filters/ColorMatrixFilter.ts' />
///<reference path='filters/ConvolutionFilter.ts' />
///<reference path='filters/DisplacementMapFilterMode.ts' />
///<reference path='filters/DisplacementMapFilter.ts' />
///<reference path='filters/DropShadowFilter.ts' />
///<reference path='filters/GlowFilter.ts' />
///<reference path='filters/GradientBevelFilter.ts' />
///<reference path='filters/GradientGlowFilter.ts' />
///<reference path='geom/ColorTransform.ts' />
///<reference path='media/Camera.ts' />
///<reference path='media/ID3Info.ts' />
///<reference path='media/Microphone.ts' />
///<reference path='media/Sound.ts' />
///<reference path='media/SoundChannel.ts' />
///<reference path='media/SoundLoaderContext.ts' />
///<reference path='media/SoundMixer.ts' />
///<reference path='media/SoundTransform.ts' />
///<reference path='media/StageVideo.ts' />
///<reference path='media/StageVideoAvailability.ts' />
///<reference path='media/Video.ts' />
///<reference path='media/VideoStreamSettings.ts' />
///<reference path='net/FileFilter.ts' />
///<reference path='net/FileReference.ts' />
///<reference path='net/FileReferenceList.ts' />
///<reference path='net/LocalConnection.ts' />
///<reference path='net/NetConnection.ts' />
///<reference path='net/NetStream.ts' />
///<reference path='net/NetStreamInfo.ts' />
///<reference path='net/NetStreamMulticastInfo.ts' />
///<reference path='net/NetStreamPlayOptions.ts' />
///<reference path='net/Responder.ts' />
///<reference path='net/SharedObject.ts' />
///<reference path='net/Socket.ts' />
///<reference path='net/URLLoader.ts' />
///<reference path='net/URLRequest.ts' />
///<reference path='net/URLRequestHeader.ts' />
///<reference path='net/URLStream.ts' />
///<reference path='net/URLVariables.ts' />
///<reference path='system/ApplicationDomain.ts' />
///<reference path='system/Capabilities.ts' />
///<reference path='system/FSCommand.ts' />
///<reference path='system/ImageDecodingPolicy.ts' />
///<reference path='system/LoaderContext.ts' />
///<reference path='system/JPEGLoaderContext.ts' />
///<reference path='system/MessageChannel.ts' />
///<reference path='system/MessageChannelState.ts' />
///<reference path='system/Security.ts' />
///<reference path='system/SecurityDomain.ts' />
///<reference path='system/SecurityPanel.ts' />
///<reference path='system/TouchscreenType.ts' />
///<reference path='text/AntiAliasType.ts' />
// ///<reference path='text/CSMSettings.ts' />
///<reference path='text/FontStyle.ts' />
///<reference path='text/FontType.ts' />
///<reference path='text/Font.ts' />
///<reference path='text/GridFitType.ts' />
///<reference path='text/StaticText.ts' />
///<reference path='text/StyleSheet.ts' />
// ///<reference path='text/TextColorType.ts' />
///<reference path='text/TextDisplayMode.ts' />
// ///<reference path='text/TextExtent.ts' />
///<reference path='text/TextField.ts' />
///<reference path='text/TextFieldAutoSize.ts' />
///<reference path='text/TextFieldType.ts' />
///<reference path='text/TextFormat.ts' />
///<reference path='text/TextFormatAlign.ts' />
///<reference path='text/TextFormatDisplay.ts' />
///<reference path='text/TextInteractionMode.ts' />
///<reference path='text/TextLineMetrics.ts' />
// ///<reference path='text/TextRenderer.ts' />
///<reference path='text/TextRun.ts' />
///<reference path='text/TextSnapshot.ts' />
///<reference path='trace/Trace.ts' />
///<reference path='ui/ContextMenu.ts' />
///<reference path='ui/ContextMenuBuiltInItems.ts' />
///<reference path='ui/ContextMenuClipboardItems.ts' />
///<reference path='ui/ContextMenuItem.ts' />
///<reference path='ui/GameInput.ts' />
///<reference path='ui/GameInputControl.ts' />
///<reference path='ui/GameInputControlType.ts' />
///<reference path='ui/GameInputDevice.ts' />
///<reference path='ui/GameInputFinger.ts' />
///<reference path='ui/GameInputHand.ts' />
///<reference path='ui/Keyboard.ts' />
///<reference path='ui/Mouse.ts' />
///<reference path='ui/MouseCursor.ts' />
///<reference path='ui/MouseCursorData.ts' />
///<reference path='ui/Multitouch.ts' />
///<reference path='ui/MultitouchInputMode.ts' />
///<reference path='utils/Endian.ts' />
///<reference path='utils/IExternalizable.ts' />
///<reference path='utils/Timer.ts' />
///<reference path='utils/SetIntervalTimer.ts' />
///<reference path='system/SecurityDomain.ts'/>
///<reference path='statics/EventsNamespace.ts'/>
///<reference path='statics/UtilsNamespace.ts'/>
///<reference path='statics/GeomNamespace.ts'/>
///<reference path='statics/DisplayNamespace.ts'/>
///<reference path='statics/SystemNamespace.ts'/>
///<reference path='statics/TextNamespace.ts'/>
///<reference path='statics/FiltersNamespace.ts'/>
///<reference path='statics/MediaNamespace.ts'/>
///<reference path='statics/NetNamespace.ts'/>
///<reference path='statics/UINamespace.ts'/>
///<reference path='statics/LoaderClass.ts'/>
///<reference path='statics/MouseClass.ts'/>
///<reference path='link.ts' />
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var assert = Shumway.Debug.assert;
        var clamp = Shumway.NumberUtilities.clamp;
        var TraceLevel;
        (function (TraceLevel) {
            TraceLevel[TraceLevel["None"] = 0] = "None";
            TraceLevel[TraceLevel["Brief"] = 1] = "Brief";
            TraceLevel[TraceLevel["Verbose"] = 2] = "Verbose";
        })(TraceLevel = GFX.TraceLevel || (GFX.TraceLevel = {}));
        var counter = Shumway.Metrics.Counter.instance;
        GFX.frameCounter = new Shumway.Metrics.Counter(true);
        GFX.traceLevel = 2 /* Verbose */;
        GFX.writer = null;
        function frameCount(name) {
            counter.count(name);
            GFX.frameCounter.count(name);
        }
        GFX.frameCount = frameCount;
        GFX.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer("GFX") : null;
        function enterTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.enter(name, data);
        }
        GFX.enterTimeline = enterTimeline;
        function leaveTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.leave(name, data);
        }
        GFX.leaveTimeline = leaveTimeline;
        var nativeAddColorStop = null;
        var nativeCreateLinearGradient = null;
        var nativeCreateRadialGradient = null;
        /**
         * Transforms a fill or stroke style by the given color matrix.
         */
        function transformStyle(context, style, colorMatrix) {
            if (!polyfillColorTransform || !colorMatrix) {
                return style;
            }
            if (typeof style === "string") {
                // Parse CSS color styles and transform them.
                var rgba = Shumway.ColorUtilities.cssStyleToRGBA(style);
                return Shumway.ColorUtilities.rgbaToCSSStyle(colorMatrix.transformRGBA(rgba));
            }
            else if (style instanceof CanvasGradient) {
                if (style._template) {
                    // If gradient style has a template, construct a new gradient style from it whith
                    // its color stops transformed.
                    return style._template.createCanvasGradient(context, colorMatrix);
                }
            }
            return style; // "#ff69b4"
        }
        /**
         * Whether to polyfill color transforms. This adds a |globalColorMatrix| property on |CanvasRenderingContext2D|
         * that is used to transform all stroke and fill styles before a drawing operation happens.
         */
        var polyfillColorTransform = true;
        /**
         * Gradients are opaque objects and their properties cannot be inspected. Here we hijack gradient style constructors
         * and attach "template" objects on gradients so that we can keep track of their position attributes and color stops.
         * Using these "template" objects, we can clone and transform gradients.
         */
        if (polyfillColorTransform && typeof CanvasRenderingContext2D !== 'undefined') {
            nativeAddColorStop = CanvasGradient.prototype.addColorStop;
            nativeCreateLinearGradient = CanvasRenderingContext2D.prototype.createLinearGradient;
            nativeCreateRadialGradient = CanvasRenderingContext2D.prototype.createRadialGradient;
            CanvasRenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
                var gradient = new CanvasLinearGradient(x0, y0, x1, y1);
                return gradient.createCanvasGradient(this, null);
            };
            CanvasRenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
                var gradient = new CanvasRadialGradient(x0, y0, r0, x1, y1, r1);
                return gradient.createCanvasGradient(this, null);
            };
            CanvasGradient.prototype.addColorStop = function (offset, color) {
                nativeAddColorStop.call(this, offset, color);
                this._template.addColorStop(offset, color);
            };
        }
        var ColorStop = /** @class */ (function () {
            function ColorStop(offset, color) {
                this.offset = offset;
                this.color = color;
                // ...
            }
            return ColorStop;
        }());
        /**
         * Template for linear gradients.
         */
        var CanvasLinearGradient = /** @class */ (function () {
            function CanvasLinearGradient(x0, y0, x1, y1) {
                this.x0 = x0;
                this.y0 = y0;
                this.x1 = x1;
                this.y1 = y1;
                this.colorStops = [];
                // ...
            }
            CanvasLinearGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasLinearGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateLinearGradient.call(context, this.x0, this.y0, this.x1, this.y1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasLinearGradient;
        }());
        /**
         * Template for radial gradients.
         */
        var CanvasRadialGradient = /** @class */ (function () {
            function CanvasRadialGradient(x0, y0, r0, x1, y1, r1) {
                this.x0 = x0;
                this.y0 = y0;
                this.r0 = r0;
                this.x1 = x1;
                this.y1 = y1;
                this.r1 = r1;
                this.colorStops = [];
                // ...
            }
            CanvasRadialGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasRadialGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateRadialGradient.call(context, this.x0, this.y0, this.r0, this.x1, this.y1, this.r1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasRadialGradient;
        }());
        var PathCommand;
        (function (PathCommand) {
            PathCommand[PathCommand["ClosePath"] = 1] = "ClosePath";
            PathCommand[PathCommand["MoveTo"] = 2] = "MoveTo";
            PathCommand[PathCommand["LineTo"] = 3] = "LineTo";
            PathCommand[PathCommand["QuadraticCurveTo"] = 4] = "QuadraticCurveTo";
            PathCommand[PathCommand["BezierCurveTo"] = 5] = "BezierCurveTo";
            PathCommand[PathCommand["ArcTo"] = 6] = "ArcTo";
            PathCommand[PathCommand["Rect"] = 7] = "Rect";
            PathCommand[PathCommand["Arc"] = 8] = "Arc";
            PathCommand[PathCommand["Save"] = 9] = "Save";
            PathCommand[PathCommand["Restore"] = 10] = "Restore";
            PathCommand[PathCommand["Transform"] = 11] = "Transform";
        })(PathCommand || (PathCommand = {}));
        /**
         * Polyfill for missing |Path2D|. An instance of this class keeps a record of all drawing commands
         * ever called on it.
         */
        var Path = /** @class */ (function () {
            function Path(arg) {
                this._commands = new Uint8Array(Path._arrayBufferPool.acquire(8), 0, 8);
                this._commandPosition = 0;
                this._data = new Float64Array(Path._arrayBufferPool.acquire(8 * Float64Array.BYTES_PER_ELEMENT), 0, 8);
                this._dataPosition = 0;
                if (arg instanceof Path) {
                    this.addPath(arg);
                }
            }
            /**
             * Takes a |Path2D| instance and a 2d context to replay the recorded drawing commands.
             */
            Path._apply = function (path, context) {
                var commands = path._commands;
                var d = path._data;
                var i = 0;
                var j = 0;
                context.beginPath();
                var commandPosition = path._commandPosition;
                while (i < commandPosition) {
                    switch (commands[i++]) {
                        case PathCommand.ClosePath:
                            context.closePath();
                            break;
                        case PathCommand.MoveTo:
                            // https://bugs.chromium.org/p/chromium/issues/detail?id=824145
                            var x = d[j++], y = d[j++];
                            if (i < commandPosition && commands[i] === PathCommand.MoveTo) {
                                break;
                            }
                            context.moveTo(x, y);
                            break;
                        case PathCommand.LineTo:
                            context.lineTo(d[j++], d[j++]);
                            break;
                        case PathCommand.QuadraticCurveTo:
                            context.quadraticCurveTo(d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case PathCommand.BezierCurveTo:
                            context.bezierCurveTo(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case PathCommand.ArcTo:
                            context.arcTo(d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case PathCommand.Rect:
                            context.rect(d[j++], d[j++], d[j++], d[j++]);
                            break;
                        case PathCommand.Arc:
                            context.arc(d[j++], d[j++], d[j++], d[j++], d[j++], !!d[j++]);
                            break;
                        case PathCommand.Save:
                            context.save();
                            break;
                        case PathCommand.Restore:
                            context.restore();
                            break;
                        case PathCommand.Transform:
                            context.transform(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                            break;
                    }
                }
            };
            Path.prototype._ensureCommandCapacity = function (length) {
                this._commands = Path._arrayBufferPool.ensureUint8ArrayLength(this._commands, length);
            };
            Path.prototype._ensureDataCapacity = function (length) {
                this._data = Path._arrayBufferPool.ensureFloat64ArrayLength(this._data, length);
            };
            Path.prototype._writeCommand = function (command) {
                if (this._commandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(this._commandPosition + 1);
                }
                this._commands[this._commandPosition++] = command;
            };
            Path.prototype._writeData = function (a, b, c, d, e, f) {
                var argc = arguments.length;
                release || assert(argc <= 6 && (argc % 2 === 0 || argc === 5));
                if (this._dataPosition + argc >= this._data.length) {
                    this._ensureDataCapacity(this._dataPosition + argc);
                }
                var data = this._data;
                var p = this._dataPosition;
                data[p] = a;
                data[p + 1] = b;
                if (argc > 2) {
                    data[p + 2] = c;
                    data[p + 3] = d;
                    if (argc > 4) {
                        data[p + 4] = e;
                        if (argc === 6) {
                            data[p + 5] = f;
                        }
                    }
                }
                this._dataPosition += argc;
            };
            Path.prototype.closePath = function () {
                this._writeCommand(PathCommand.ClosePath);
            };
            Path.prototype.moveTo = function (x, y) {
                this._writeCommand(PathCommand.MoveTo);
                this._writeData(x, y);
            };
            Path.prototype.lineTo = function (x, y) {
                this._writeCommand(PathCommand.LineTo);
                this._writeData(x, y);
            };
            Path.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
                this._writeCommand(PathCommand.QuadraticCurveTo);
                this._writeData(cpx, cpy, x, y);
            };
            Path.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
                this._writeCommand(PathCommand.BezierCurveTo);
                this._writeData(cp1x, cp1y, cp2x, cp2y, x, y);
            };
            Path.prototype.arcTo = function (x1, y1, x2, y2, radius) {
                this._writeCommand(PathCommand.ArcTo);
                this._writeData(x1, y1, x2, y2, radius);
            };
            Path.prototype.rect = function (x, y, width, height) {
                this._writeCommand(PathCommand.Rect);
                this._writeData(x, y, width, height);
            };
            Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                this._writeCommand(PathCommand.Arc);
                this._writeData(x, y, radius, startAngle, endAngle, +anticlockwise);
            };
            /**
             * Copies and transforms all drawing commands stored in |path|.
             */
            Path.prototype.addPath = function (path, transformation) {
                if (transformation) {
                    this._writeCommand(PathCommand.Save);
                    this._writeCommand(PathCommand.Transform);
                    this._writeData(transformation.a, transformation.b, transformation.c, transformation.d, transformation.e, transformation.f);
                }
                // Copy commands.
                var newCommandPosition = this._commandPosition + path._commandPosition;
                if (newCommandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(newCommandPosition);
                }
                var commands = this._commands;
                var pathCommands = path._commands;
                for (var i = this._commandPosition, j = 0; i < newCommandPosition; i++) {
                    commands[i] = pathCommands[j++];
                }
                this._commandPosition = newCommandPosition;
                // Copy data.
                var newDataPosition = this._dataPosition + path._dataPosition;
                if (newDataPosition >= this._data.length) {
                    this._ensureDataCapacity(newDataPosition);
                }
                var data = this._data;
                var pathData = path._data;
                for (var i = this._dataPosition, j = 0; i < newDataPosition; i++) {
                    data[i] = pathData[j++];
                }
                this._dataPosition = newDataPosition;
                if (transformation) {
                    this._writeCommand(PathCommand.Restore);
                }
            };
            Path._arrayBufferPool = new Shumway.ArrayBufferPool();
            return Path;
        }());
        GFX.Path = Path;
        // Polyfill |Path2D| if it is not defined or if its |addPath| method doesn't exist. This means that we
        // always need to polyfill this in FF until addPath lands which sucks.
        if (typeof CanvasRenderingContext2D !== 'undefined' && (typeof Path2D === 'undefined' || !Path2D.prototype.addPath)) {
            /**
             * We override all methods of |CanvasRenderingContext2D| that accept a |Path2D| object as one
             * of its arguments, so that we can apply all recorded drawing commands before calling the
             * original function.
             */
            var nativeFill_1 = CanvasRenderingContext2D.prototype.fill;
            CanvasRenderingContext2D.prototype.fill = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    }
                    else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeFill_1.call(this, fillRule);
                }
                else {
                    nativeFill_1.call(this);
                }
            });
            var nativeStroke_1 = CanvasRenderingContext2D.prototype.stroke;
            CanvasRenderingContext2D.prototype.stroke = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    }
                    else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeStroke_1.call(this, fillRule);
                }
                else {
                    nativeStroke_1.call(this);
                }
            });
            var nativeClip_1 = CanvasRenderingContext2D.prototype.clip;
            CanvasRenderingContext2D.prototype.clip = (function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    }
                    else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeClip_1.call(this, fillRule);
                }
                else {
                    nativeClip_1.call(this);
                }
            });
            // Expose our pollyfill to the global object.
            window['Path2D'] = Path;
        }
        function setTransform(matrix) {
            this._transform = matrix;
            if (this._template) {
                this._template._transform = matrix;
            }
        }
        if (typeof CanvasPattern !== "undefined") {
            /**
             * Polyfill |setTransform| on |CanvasPattern| and |CanvasGradient|. Firefox implements this for |CanvasPattern|
             * in Nightly but doesn't for |CanvasGradient| yet.
             *
             * This polyfill uses |Path2D|, which is polyfilled above. You can get a native implementaiton of |Path2D| in
             * Chrome if you enable experimental canvas features in |chrome://flags/|. In Firefox you'll have to wait for
             * https://bugzilla.mozilla.org/show_bug.cgi?id=985801 to land.
             */
            if (Path2D.prototype.addPath) {
                if (!CanvasPattern.prototype.setTransform) {
                    CanvasPattern.prototype.setTransform = setTransform;
                }
                if (!CanvasGradient.prototype.setTransform) {
                    CanvasGradient.prototype.setTransform = setTransform;
                }
                var originalFill_1 = CanvasRenderingContext2D.prototype.fill;
                var originalStroke_1 = CanvasRenderingContext2D.prototype.stroke;
                /**
                 * If the current fillStyle is a |CanvasPattern| or |CanvasGradient| that has a SVGMatrix transformed applied to it, we
                 * first apply the pattern's transform to the current context and then draw the path with the
                 * inverse fillStyle transform applied to it so that it is drawn in the expected original location.
                 */
                CanvasRenderingContext2D.prototype.fill = (function fill(path, fillRule) {
                    var supportsStyle = this.fillStyle instanceof CanvasPattern || this.fillStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.fillStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.fillStyle._transform;
                        var i = void 0;
                        try {
                            i = m.inverse();
                        }
                        catch (e) {
                            i = m = GFX.Geometry.Matrix.createIdentitySVGMatrix();
                        }
                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);
                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);
                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        originalFill_1.call(this, transformedPath, fillRule);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        return;
                    }
                    if (arguments.length === 0) {
                        originalFill_1.call(this);
                    }
                    else if (arguments.length === 1) {
                        originalFill_1.call(this, path);
                    }
                    else if (arguments.length === 2) {
                        originalFill_1.call(this, path, fillRule);
                    }
                });
                /**
                 * Same as for |fill| above.
                 */
                CanvasRenderingContext2D.prototype.stroke = (function stroke(path) {
                    var supportsStyle = this.strokeStyle instanceof CanvasPattern || this.strokeStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.strokeStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.strokeStyle._transform;
                        var i = void 0;
                        try {
                            i = m.inverse();
                        }
                        catch (e) {
                            i = m = GFX.Geometry.Matrix.createIdentitySVGMatrix();
                        }
                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);
                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);
                        // Scale the lineWidth down since it will be scaled up by the current transform.
                        var oldLineWidth = this.lineWidth;
                        this.lineWidth *= Math.sqrt((i.a + i.c) * (i.a + i.c) +
                            (i.d + i.b) * (i.d + i.b)) * Math.SQRT1_2;
                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        originalStroke_1.call(this, transformedPath);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        this.lineWidth = oldLineWidth;
                        return;
                    }
                    if (arguments.length === 0) {
                        originalStroke_1.call(this);
                    }
                    else if (arguments.length === 1) {
                        originalStroke_1.call(this, path);
                    }
                });
            }
        }
        if (typeof CanvasRenderingContext2D !== 'undefined') {
            (function () {
                /**
                 * Flash does not go below this number.
                 */
                var MIN_LINE_WIDTH = 1;
                /**
                 * Arbitrarily chosen large number.
                 */
                var MAX_LINE_WIDTH = 1024;
                var hasCurrentTransform = 'currentTransform' in CanvasRenderingContext2D.prototype;
                /**
                 * There's an impedance mismatch between Flash's vector drawing model and that of Canvas2D[1]: Flash applies scaling
                 * of stroke widths once by (depending on settings for the shape) using the concatenated horizontal scaling, vertical
                 * scaling, or a geometric average of the two. The calculated width is then uniformly applied at every point on the
                 * stroke. Canvas2D, OTOH, calculates scaling for each point individually. I.e., horizontal line segments aren't
                 * affected by vertical scaling and vice versa, with non-axis-alined line segments being partly affected.
                 * Additionally, Flash draws all strokes with at least 1px on-stage width, whereas Canvas draws finer-in-appearance
                 * lines by interpolating colors accordingly. To fix both of these, we have to apply any transforms to the geometry
                 * only, not the stroke style. That's only possible by building the untransformed geometry in a Path2D and, each time
                 * we rasterize, adding that with the current concatenated transform applied to a temporary Path2D, which we then draw
                 * in global coordinate space.
                 *
                 * Implements Flash stroking behavior.
                 */
                CanvasRenderingContext2D.prototype.flashStroke = function (path, lineScaleMode) {
                    if (!hasCurrentTransform) {
                        // Chrome doesn't have |currentTransform| yet, so fall back on normal stroking.
                        // |currentTransform| is available only if you enable experimental features.
                        this.stroke(path);
                        return;
                    }
                    var m = this.currentTransform;
                    var transformedPath = new Path2D();
                    // Transform the path by the current transform ...
                    transformedPath.addPath(path, m);
                    var oldLineWidth = this.lineWidth;
                    this.setTransform(1, 0, 0, 1, 0, 0);
                    // We need to scale the |lineWidth| based on the current transform.
                    // If we scale square 1x1 using this transform, it will fit into a
                    // rectangular area, that has sides parallel to the x- and y-axis,
                    // (a + c) x (d + b).
                    switch (lineScaleMode) {
                        case 0 /* None */:
                            break;
                        case 1 /* Normal */:
                            var scale = Math.sqrt((m.a + m.c) * (m.a + m.c) +
                                (m.d + m.b) * (m.d + m.b)) * Math.SQRT1_2;
                            this.lineWidth = clamp(oldLineWidth * scale, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                            break;
                        case 2 /* Vertical */:
                            var scaleHeight = m.d + m.b;
                            this.lineWidth = clamp(oldLineWidth * scaleHeight, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                            break;
                        case 3 /* Horizontal */:
                            var scaleWidth = m.a + m.c;
                            this.lineWidth = clamp(oldLineWidth * scaleWidth, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                            break;
                    }
                    // Stroke and restore the previous matrix.
                    this.stroke(transformedPath);
                    this.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                    this.lineWidth = oldLineWidth;
                };
                // A complete polyfill of currentTransform isn't feasible: we want to only use it if it gives
                // us a meaningful value. That we can only get if the platform gives us any means at all to
                // get that value. Gecko does so in the form of mozCurrentTransform, most engines don't.
                // For Chrome, at least return whatever transform was set using setTransform to ensure
                // clipping works in our 2D backend.
                if (!hasCurrentTransform) {
                    if ('mozCurrentTransform' in CanvasRenderingContext2D.prototype) {
                        Object.defineProperty(CanvasRenderingContext2D.prototype, 'currentTransform', {
                            get: mozPolyfillCurrentTransform
                        });
                        hasCurrentTransform = true;
                    }
                    else {
                        var nativeSetTransform_1 = CanvasRenderingContext2D.prototype.setTransform;
                        CanvasRenderingContext2D.prototype.setTransform = (function setTransform(a, b, c, d, e, f) {
                            var transform = this.currentTransform;
                            transform.a = a;
                            transform.b = b;
                            transform.c = c;
                            transform.d = d;
                            transform.e = e;
                            transform.f = f;
                            nativeSetTransform_1.call(this, a, b, c, d, e, f);
                        });
                        Object.defineProperty(CanvasRenderingContext2D.prototype, 'currentTransform', {
                            get: function () {
                                return this._currentTransform || (this._currentTransform = GFX.Geometry.Matrix.createIdentitySVGMatrix());
                            }
                        });
                    }
                }
                function mozPolyfillCurrentTransform() {
                    release || assert(this.mozCurrentTransform);
                    return GFX.Geometry.Matrix.createSVGMatrixFromArray(this.mozCurrentTransform);
                }
            })();
        }
        /**
         * Polyfill |globalColorMatrix| on |CanvasRenderingContext2D|.
         */
        if (typeof CanvasRenderingContext2D !== 'undefined' && CanvasRenderingContext2D.prototype.globalColorMatrix === undefined) {
            var previousFill_1 = CanvasRenderingContext2D.prototype.fill;
            var previousStroke_1 = CanvasRenderingContext2D.prototype.stroke;
            var previousFillText_1 = CanvasRenderingContext2D.prototype.fillText;
            var previousStrokeText_1 = CanvasRenderingContext2D.prototype.strokeText;
            Object.defineProperty(CanvasRenderingContext2D.prototype, "globalColorMatrix", {
                get: function () {
                    if (this._globalColorMatrix) {
                        return this._globalColorMatrix.clone();
                    }
                    return null;
                },
                set: function (matrix) {
                    if (!matrix) {
                        this._globalColorMatrix = null;
                        return;
                    }
                    if (this._globalColorMatrix) {
                        this._globalColorMatrix.set(matrix);
                    }
                    else {
                        this._globalColorMatrix = matrix.clone();
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Intercept calls to |fill| and transform fill style if a |globalColorMatrix| is set.
             */
            CanvasRenderingContext2D.prototype.fill = (function (a, b) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousFill_1.call(this);
                }
                else if (arguments.length === 1) {
                    previousFill_1.call(this, a);
                }
                else if (arguments.length === 2) {
                    previousFill_1.call(this, a, b);
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            });
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.stroke = (function (a, b) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousStroke_1.call(this);
                }
                else if (arguments.length === 1) {
                    previousStroke_1.call(this, a);
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            });
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.fillText = (function (text, x, y, maxWidth) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousFillText_1.call(this, text, x, y);
                }
                else if (arguments.length === 4) {
                    previousFillText_1.call(this, text, x, y, maxWidth);
                }
                else {
                    Shumway.Debug.unexpected();
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            });
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.strokeText = (function (text, x, y, maxWidth) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousStrokeText_1.call(this, text, x, y);
                }
                else if (arguments.length === 4) {
                    previousStrokeText_1.call(this, text, x, y, maxWidth);
                }
                else {
                    Shumway.Debug.unexpected();
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            });
        }
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var ScreenShot = /** @class */ (function () {
            function ScreenShot(dataURL, w, h, pixelRatio) {
                this.dataURL = dataURL;
                this.w = w;
                this.h = h;
                this.pixelRatio = pixelRatio;
                // ...
            }
            return ScreenShot;
        }());
        GFX.ScreenShot = ScreenShot;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var assert = Shumway.Debug.assert;
    /**
     * Maintains a LRU doubly-linked list.
     */
    var LRUList = /** @class */ (function () {
        function LRUList() {
            this._count = 0;
            this._head = this._tail = null;
        }
        Object.defineProperty(LRUList.prototype, "count", {
            get: function () {
                return this._count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LRUList.prototype, "head", {
            /**
             * Gets the node at the front of the list. Returns |null| if the list is empty.
             */
            get: function () {
                return this._head;
            },
            enumerable: true,
            configurable: true
        });
        LRUList.prototype._unshift = function (node) {
            release || assert(!node.next && !node.previous);
            if (this._count === 0) {
                this._head = this._tail = node;
            }
            else {
                node.next = this._head;
                node.next.previous = node;
                this._head = node;
            }
            this._count++;
        };
        LRUList.prototype._remove = function (node) {
            release || assert(this._count > 0);
            if (node === this._head && node === this._tail) {
                this._head = this._tail = null;
            }
            else if (node === this._head) {
                this._head = (node.next);
                this._head.previous = null;
            }
            else if (node == this._tail) {
                this._tail = (node.previous);
                this._tail.next = null;
            }
            else {
                node.previous.next = node.next;
                node.next.previous = node.previous;
            }
            node.previous = node.next = null;
            this._count--;
        };
        /**
         * Adds or moves a node to the front of the list.
         */
        LRUList.prototype.use = function (node) {
            if (this._head === node) {
                return;
            }
            if (node.next || node.previous || this._tail === node) {
                this._remove(node);
            }
            this._unshift(node);
        };
        /**
         * Removes a node from the front of the list.
         */
        LRUList.prototype.pop = function () {
            if (!this._tail) {
                return null;
            }
            var node = this._tail;
            this._remove(node);
            return node;
        };
        /**
         * Visits each node in the list in the forward or reverse direction as long as
         * the callback returns |true|;
         */
        LRUList.prototype.visit = function (callback, forward) {
            if (forward === void 0) { forward = true; }
            var node = (forward ? this._head : this._tail);
            while (node) {
                if (!callback(node)) {
                    break;
                }
                node = (forward ? node.next : node.previous);
            }
        };
        return LRUList;
    }());
    Shumway.LRUList = LRUList;
    // Registers a default font to render non-spacing and non-marking glyphs for undefined characters in embedded fonts.
    // Embeds the Adobe Blank web font (https://github.com/adobe-fonts/adobe-blank).
    function registerFallbackFont() {
        var style = document.styleSheets[0];
        var rule = '@font-face{font-family:AdobeBlank;src:url("data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIDTeCDQAACFkAAAZPERTSUcAAAABAABKqAAAAAhPUy8yAF+xmwAAARAAAABgY21hcCRDbtEAAAdcAAAZ6GhlYWQFl9tDAAAArAAAADZoaGVhB1oD7wAAAOQAAAAkaG10eAPoAHwAADqgAAAQBm1heHAIAVAAAAABCAAAAAZuYW1lIE0HkgAAAXAAAAXrcG9zdP+4ADIAACFEAAAAIAABAAAAAQuFfcPHtV8PPPUAAwPoAAAAANFMRfMAAAAA0UxF8wB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAAAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAAAwPoAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCTwBAAAD//wNw/4gAAANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA6AC0AAQAAAAAABgAKAGcAAwABBAkAAACUAHEAAwABBAkAAQAWAQUAAwABBAkAAgAOARsAAwABBAkAAwA2ASkAAwABBAkABAAWAQUAAwABBAkABQB0AV8AAwABBAkABgAUAdMAAwABBAkACAA0AecAAwABBAkACwA0AhsAAwABBAkADQKWAk8AAwABBAkADgA0BOVBZG9iZSBCbGFua1JlZ3VsYXIxLjA0NTtBREJPO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDQ1O1BTIDEuMDQ1O2hvdGNvbnYgMS4wLjgyO21ha2VvdGYubGliMi41LjYzNDA2QWRvYmVCbGFuawBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAzACwAIAAyADAAMQA1ACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAANAA1ADsAQQBEAEIATwA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADQANQA7AFAAUwAgADEALgAwADQANQA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADgAMgA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADYAMwA0ADAANgBBAGQAbwBiAGUAQgBsAGEAbgBrAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAbwBuACAAYQBuACAAIgBBAFMAIABJAFMAIgAgAEIAQQBTAEkAUwAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAFIAIABDAE8ATgBEAEkAVABJAE8ATgBTACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABlAGkAdABoAGUAcgAgAGUAeABwAHIAZQBzAHMAIABvAHIAIABpAG0AcABsAGkAZQBkAC4AIABTAGUAZQAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIABmAG8AcgAgAHQAaABlACAAcwBwAGUAYwBpAGYAaQBjACAAbABhAG4AZwB1AGEAZwBlACwAIABwAGUAcgBtAGkAcwBzAGkAbwBuAHMAIABhAG4AZAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AcwAgAGcAbwB2AGUAcgBuAGkAbgBnACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALgBoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAAAAABQAAAAMAAAA4AAAABAAAAFgAAQAAAAAALAADAAEAAAA4AAMACgAAAFgABgAMAAAAAAABAAAABAAgAAAABAAEAAEAAAf///8AAAAA//8AAQABAAAAAAAMAAAAABmQAAAAAAAAAiAAAAAAAAAH/wAAAAEAAAgAAAAP/wAAAAEAABAAAAAX/wAAAAEAABgAAAAf/wAAAAEAACAAAAAn/wAAAAEAACgAAAAv/wAAAAEAADAAAAA3/wAAAAEAADgAAAA//wAAAAEAAEAAAABH/wAAAAEAAEgAAABP/wAAAAEAAFAAAABX/wAAAAEAAFgAAABf/wAAAAEAAGAAAABn/wAAAAEAAGgAAABv/wAAAAEAAHAAAAB3/wAAAAEAAHgAAAB//wAAAAEAAIAAAACH/wAAAAEAAIgAAACP/wAAAAEAAJAAAACX/wAAAAEAAJgAAACf/wAAAAEAAKAAAACn/wAAAAEAAKgAAACv/wAAAAEAALAAAAC3/wAAAAEAALgAAAC//wAAAAEAAMAAAADH/wAAAAEAAMgAAADP/wAAAAEAANAAAADX/wAAAAEAAOAAAADn/wAAAAEAAOgAAADv/wAAAAEAAPAAAAD3/wAAAAEAAPgAAAD9zwAAAAEAAP3wAAD//QAABfEAAQAAAAEH/wAAAAEAAQgAAAEP/wAAAAEAARAAAAEX/wAAAAEAARgAAAEf/wAAAAEAASAAAAEn/wAAAAEAASgAAAEv/wAAAAEAATAAAAE3/wAAAAEAATgAAAE//wAAAAEAAUAAAAFH/wAAAAEAAUgAAAFP/wAAAAEAAVAAAAFX/wAAAAEAAVgAAAFf/wAAAAEAAWAAAAFn/wAAAAEAAWgAAAFv/wAAAAEAAXAAAAF3/wAAAAEAAXgAAAF//wAAAAEAAYAAAAGH/wAAAAEAAYgAAAGP/wAAAAEAAZAAAAGX/wAAAAEAAZgAAAGf/wAAAAEAAaAAAAGn/wAAAAEAAagAAAGv/wAAAAEAAbAAAAG3/wAAAAEAAbgAAAG//wAAAAEAAcAAAAHH/wAAAAEAAcgAAAHP/wAAAAEAAdAAAAHX/wAAAAEAAdgAAAHf/wAAAAEAAeAAAAHn/wAAAAEAAegAAAHv/wAAAAEAAfAAAAH3/wAAAAEAAfgAAAH//QAAAAEAAgAAAAIH/wAAAAEAAggAAAIP/wAAAAEAAhAAAAIX/wAAAAEAAhgAAAIf/wAAAAEAAiAAAAIn/wAAAAEAAigAAAIv/wAAAAEAAjAAAAI3/wAAAAEAAjgAAAI//wAAAAEAAkAAAAJH/wAAAAEAAkgAAAJP/wAAAAEAAlAAAAJX/wAAAAEAAlgAAAJf/wAAAAEAAmAAAAJn/wAAAAEAAmgAAAJv/wAAAAEAAnAAAAJ3/wAAAAEAAngAAAJ//wAAAAEAAoAAAAKH/wAAAAEAAogAAAKP/wAAAAEAApAAAAKX/wAAAAEAApgAAAKf/wAAAAEAAqAAAAKn/wAAAAEAAqgAAAKv/wAAAAEAArAAAAK3/wAAAAEAArgAAAK//wAAAAEAAsAAAALH/wAAAAEAAsgAAALP/wAAAAEAAtAAAALX/wAAAAEAAtgAAALf/wAAAAEAAuAAAALn/wAAAAEAAugAAALv/wAAAAEAAvAAAAL3/wAAAAEAAvgAAAL//QAAAAEAAwAAAAMH/wAAAAEAAwgAAAMP/wAAAAEAAxAAAAMX/wAAAAEAAxgAAAMf/wAAAAEAAyAAAAMn/wAAAAEAAygAAAMv/wAAAAEAAzAAAAM3/wAAAAEAAzgAAAM//wAAAAEAA0AAAANH/wAAAAEAA0gAAANP/wAAAAEAA1AAAANX/wAAAAEAA1gAAANf/wAAAAEAA2AAAANn/wAAAAEAA2gAAANv/wAAAAEAA3AAAAN3/wAAAAEAA3gAAAN//wAAAAEAA4AAAAOH/wAAAAEAA4gAAAOP/wAAAAEAA5AAAAOX/wAAAAEAA5gAAAOf/wAAAAEAA6AAAAOn/wAAAAEAA6gAAAOv/wAAAAEAA7AAAAO3/wAAAAEAA7gAAAO//wAAAAEAA8AAAAPH/wAAAAEAA8gAAAPP/wAAAAEAA9AAAAPX/wAAAAEAA9gAAAPf/wAAAAEAA+AAAAPn/wAAAAEAA+gAAAPv/wAAAAEAA/AAAAP3/wAAAAEAA/gAAAP//QAAAAEABAAAAAQH/wAAAAEABAgAAAQP/wAAAAEABBAAAAQX/wAAAAEABBgAAAQf/wAAAAEABCAAAAQn/wAAAAEABCgAAAQv/wAAAAEABDAAAAQ3/wAAAAEABDgAAAQ//wAAAAEABEAAAARH/wAAAAEABEgAAARP/wAAAAEABFAAAARX/wAAAAEABFgAAARf/wAAAAEABGAAAARn/wAAAAEABGgAAARv/wAAAAEABHAAAAR3/wAAAAEABHgAAAR//wAAAAEABIAAAASH/wAAAAEABIgAAASP/wAAAAEABJAAAASX/wAAAAEABJgAAASf/wAAAAEABKAAAASn/wAAAAEABKgAAASv/wAAAAEABLAAAAS3/wAAAAEABLgAAAS//wAAAAEABMAAAATH/wAAAAEABMgAAATP/wAAAAEABNAAAATX/wAAAAEABNgAAATf/wAAAAEABOAAAATn/wAAAAEABOgAAATv/wAAAAEABPAAAAT3/wAAAAEABPgAAAT//QAAAAEABQAAAAUH/wAAAAEABQgAAAUP/wAAAAEABRAAAAUX/wAAAAEABRgAAAUf/wAAAAEABSAAAAUn/wAAAAEABSgAAAUv/wAAAAEABTAAAAU3/wAAAAEABTgAAAU//wAAAAEABUAAAAVH/wAAAAEABUgAAAVP/wAAAAEABVAAAAVX/wAAAAEABVgAAAVf/wAAAAEABWAAAAVn/wAAAAEABWgAAAVv/wAAAAEABXAAAAV3/wAAAAEABXgAAAV//wAAAAEABYAAAAWH/wAAAAEABYgAAAWP/wAAAAEABZAAAAWX/wAAAAEABZgAAAWf/wAAAAEABaAAAAWn/wAAAAEABagAAAWv/wAAAAEABbAAAAW3/wAAAAEABbgAAAW//wAAAAEABcAAAAXH/wAAAAEABcgAAAXP/wAAAAEABdAAAAXX/wAAAAEABdgAAAXf/wAAAAEABeAAAAXn/wAAAAEABegAAAXv/wAAAAEABfAAAAX3/wAAAAEABfgAAAX//QAAAAEABgAAAAYH/wAAAAEABggAAAYP/wAAAAEABhAAAAYX/wAAAAEABhgAAAYf/wAAAAEABiAAAAYn/wAAAAEABigAAAYv/wAAAAEABjAAAAY3/wAAAAEABjgAAAY//wAAAAEABkAAAAZH/wAAAAEABkgAAAZP/wAAAAEABlAAAAZX/wAAAAEABlgAAAZf/wAAAAEABmAAAAZn/wAAAAEABmgAAAZv/wAAAAEABnAAAAZ3/wAAAAEABngAAAZ//wAAAAEABoAAAAaH/wAAAAEABogAAAaP/wAAAAEABpAAAAaX/wAAAAEABpgAAAaf/wAAAAEABqAAAAan/wAAAAEABqgAAAav/wAAAAEABrAAAAa3/wAAAAEABrgAAAa//wAAAAEABsAAAAbH/wAAAAEABsgAAAbP/wAAAAEABtAAAAbX/wAAAAEABtgAAAbf/wAAAAEABuAAAAbn/wAAAAEABugAAAbv/wAAAAEABvAAAAb3/wAAAAEABvgAAAb//QAAAAEABwAAAAcH/wAAAAEABwgAAAcP/wAAAAEABxAAAAcX/wAAAAEABxgAAAcf/wAAAAEAByAAAAcn/wAAAAEABygAAAcv/wAAAAEABzAAAAc3/wAAAAEABzgAAAc//wAAAAEAB0AAAAdH/wAAAAEAB0gAAAdP/wAAAAEAB1AAAAdX/wAAAAEAB1gAAAdf/wAAAAEAB2AAAAdn/wAAAAEAB2gAAAdv/wAAAAEAB3AAAAd3/wAAAAEAB3gAAAd//wAAAAEAB4AAAAeH/wAAAAEAB4gAAAeP/wAAAAEAB5AAAAeX/wAAAAEAB5gAAAef/wAAAAEAB6AAAAen/wAAAAEAB6gAAAev/wAAAAEAB7AAAAe3/wAAAAEAB7gAAAe//wAAAAEAB8AAAAfH/wAAAAEAB8gAAAfP/wAAAAEAB9AAAAfX/wAAAAEAB9gAAAff/wAAAAEAB+AAAAfn/wAAAAEAB+gAAAfv/wAAAAEAB/AAAAf3/wAAAAEAB/gAAAf//QAAAAEACAAAAAgH/wAAAAEACAgAAAgP/wAAAAEACBAAAAgX/wAAAAEACBgAAAgf/wAAAAEACCAAAAgn/wAAAAEACCgAAAgv/wAAAAEACDAAAAg3/wAAAAEACDgAAAg//wAAAAEACEAAAAhH/wAAAAEACEgAAAhP/wAAAAEACFAAAAhX/wAAAAEACFgAAAhf/wAAAAEACGAAAAhn/wAAAAEACGgAAAhv/wAAAAEACHAAAAh3/wAAAAEACHgAAAh//wAAAAEACIAAAAiH/wAAAAEACIgAAAiP/wAAAAEACJAAAAiX/wAAAAEACJgAAAif/wAAAAEACKAAAAin/wAAAAEACKgAAAiv/wAAAAEACLAAAAi3/wAAAAEACLgAAAi//wAAAAEACMAAAAjH/wAAAAEACMgAAAjP/wAAAAEACNAAAAjX/wAAAAEACNgAAAjf/wAAAAEACOAAAAjn/wAAAAEACOgAAAjv/wAAAAEACPAAAAj3/wAAAAEACPgAAAj//QAAAAEACQAAAAkH/wAAAAEACQgAAAkP/wAAAAEACRAAAAkX/wAAAAEACRgAAAkf/wAAAAEACSAAAAkn/wAAAAEACSgAAAkv/wAAAAEACTAAAAk3/wAAAAEACTgAAAk//wAAAAEACUAAAAlH/wAAAAEACUgAAAlP/wAAAAEACVAAAAlX/wAAAAEACVgAAAlf/wAAAAEACWAAAAln/wAAAAEACWgAAAlv/wAAAAEACXAAAAl3/wAAAAEACXgAAAl//wAAAAEACYAAAAmH/wAAAAEACYgAAAmP/wAAAAEACZAAAAmX/wAAAAEACZgAAAmf/wAAAAEACaAAAAmn/wAAAAEACagAAAmv/wAAAAEACbAAAAm3/wAAAAEACbgAAAm//wAAAAEACcAAAAnH/wAAAAEACcgAAAnP/wAAAAEACdAAAAnX/wAAAAEACdgAAAnf/wAAAAEACeAAAAnn/wAAAAEACegAAAnv/wAAAAEACfAAAAn3/wAAAAEACfgAAAn//QAAAAEACgAAAAoH/wAAAAEACggAAAoP/wAAAAEAChAAAAoX/wAAAAEAChgAAAof/wAAAAEACiAAAAon/wAAAAEACigAAAov/wAAAAEACjAAAAo3/wAAAAEACjgAAAo//wAAAAEACkAAAApH/wAAAAEACkgAAApP/wAAAAEAClAAAApX/wAAAAEAClgAAApf/wAAAAEACmAAAApn/wAAAAEACmgAAApv/wAAAAEACnAAAAp3/wAAAAEACngAAAp//wAAAAEACoAAAAqH/wAAAAEACogAAAqP/wAAAAEACpAAAAqX/wAAAAEACpgAAAqf/wAAAAEACqAAAAqn/wAAAAEACqgAAAqv/wAAAAEACrAAAAq3/wAAAAEACrgAAAq//wAAAAEACsAAAArH/wAAAAEACsgAAArP/wAAAAEACtAAAArX/wAAAAEACtgAAArf/wAAAAEACuAAAArn/wAAAAEACugAAArv/wAAAAEACvAAAAr3/wAAAAEACvgAAAr//QAAAAEACwAAAAsH/wAAAAEACwgAAAsP/wAAAAEACxAAAAsX/wAAAAEACxgAAAsf/wAAAAEACyAAAAsn/wAAAAEACygAAAsv/wAAAAEACzAAAAs3/wAAAAEACzgAAAs//wAAAAEAC0AAAAtH/wAAAAEAC0gAAAtP/wAAAAEAC1AAAAtX/wAAAAEAC1gAAAtf/wAAAAEAC2AAAAtn/wAAAAEAC2gAAAtv/wAAAAEAC3AAAAt3/wAAAAEAC3gAAAt//wAAAAEAC4AAAAuH/wAAAAEAC4gAAAuP/wAAAAEAC5AAAAuX/wAAAAEAC5gAAAuf/wAAAAEAC6AAAAun/wAAAAEAC6gAAAuv/wAAAAEAC7AAAAu3/wAAAAEAC7gAAAu//wAAAAEAC8AAAAvH/wAAAAEAC8gAAAvP/wAAAAEAC9AAAAvX/wAAAAEAC9gAAAvf/wAAAAEAC+AAAAvn/wAAAAEAC+gAAAvv/wAAAAEAC/AAAAv3/wAAAAEAC/gAAAv//QAAAAEADAAAAAwH/wAAAAEADAgAAAwP/wAAAAEADBAAAAwX/wAAAAEADBgAAAwf/wAAAAEADCAAAAwn/wAAAAEADCgAAAwv/wAAAAEADDAAAAw3/wAAAAEADDgAAAw//wAAAAEADEAAAAxH/wAAAAEADEgAAAxP/wAAAAEADFAAAAxX/wAAAAEADFgAAAxf/wAAAAEADGAAAAxn/wAAAAEADGgAAAxv/wAAAAEADHAAAAx3/wAAAAEADHgAAAx//wAAAAEADIAAAAyH/wAAAAEADIgAAAyP/wAAAAEADJAAAAyX/wAAAAEADJgAAAyf/wAAAAEADKAAAAyn/wAAAAEADKgAAAyv/wAAAAEADLAAAAy3/wAAAAEADLgAAAy//wAAAAEADMAAAAzH/wAAAAEADMgAAAzP/wAAAAEADNAAAAzX/wAAAAEADNgAAAzf/wAAAAEADOAAAAzn/wAAAAEADOgAAAzv/wAAAAEADPAAAAz3/wAAAAEADPgAAAz//QAAAAEADQAAAA0H/wAAAAEADQgAAA0P/wAAAAEADRAAAA0X/wAAAAEADRgAAA0f/wAAAAEADSAAAA0n/wAAAAEADSgAAA0v/wAAAAEADTAAAA03/wAAAAEADTgAAA0//wAAAAEADUAAAA1H/wAAAAEADUgAAA1P/wAAAAEADVAAAA1X/wAAAAEADVgAAA1f/wAAAAEADWAAAA1n/wAAAAEADWgAAA1v/wAAAAEADXAAAA13/wAAAAEADXgAAA1//wAAAAEADYAAAA2H/wAAAAEADYgAAA2P/wAAAAEADZAAAA2X/wAAAAEADZgAAA2f/wAAAAEADaAAAA2n/wAAAAEADagAAA2v/wAAAAEADbAAAA23/wAAAAEADbgAAA2//wAAAAEADcAAAA3H/wAAAAEADcgAAA3P/wAAAAEADdAAAA3X/wAAAAEADdgAAA3f/wAAAAEADeAAAA3n/wAAAAEADegAAA3v/wAAAAEADfAAAA33/wAAAAEADfgAAA3//QAAAAEADgAAAA4H/wAAAAEADggAAA4P/wAAAAEADhAAAA4X/wAAAAEADhgAAA4f/wAAAAEADiAAAA4n/wAAAAEADigAAA4v/wAAAAEADjAAAA43/wAAAAEADjgAAA4//wAAAAEADkAAAA5H/wAAAAEADkgAAA5P/wAAAAEADlAAAA5X/wAAAAEADlgAAA5f/wAAAAEADmAAAA5n/wAAAAEADmgAAA5v/wAAAAEADnAAAA53/wAAAAEADngAAA5//wAAAAEADoAAAA6H/wAAAAEADogAAA6P/wAAAAEADpAAAA6X/wAAAAEADpgAAA6f/wAAAAEADqAAAA6n/wAAAAEADqgAAA6v/wAAAAEADrAAAA63/wAAAAEADrgAAA6//wAAAAEADsAAAA7H/wAAAAEADsgAAA7P/wAAAAEADtAAAA7X/wAAAAEADtgAAA7f/wAAAAEADuAAAA7n/wAAAAEADugAAA7v/wAAAAEADvAAAA73/wAAAAEADvgAAA7//QAAAAEADwAAAA8H/wAAAAEADwgAAA8P/wAAAAEADxAAAA8X/wAAAAEADxgAAA8f/wAAAAEADyAAAA8n/wAAAAEADygAAA8v/wAAAAEADzAAAA83/wAAAAEADzgAAA8//wAAAAEAD0AAAA9H/wAAAAEAD0gAAA9P/wAAAAEAD1AAAA9X/wAAAAEAD1gAAA9f/wAAAAEAD2AAAA9n/wAAAAEAD2gAAA9v/wAAAAEAD3AAAA93/wAAAAEAD3gAAA9//wAAAAEAD4AAAA+H/wAAAAEAD4gAAA+P/wAAAAEAD5AAAA+X/wAAAAEAD5gAAA+f/wAAAAEAD6AAAA+n/wAAAAEAD6gAAA+v/wAAAAEAD7AAAA+3/wAAAAEAD7gAAA+//wAAAAEAD8AAAA/H/wAAAAEAD8gAAA/P/wAAAAEAD9AAAA/X/wAAAAEAD9gAAA/f/wAAAAEAD+AAAA/n/wAAAAEAD+gAAA/v/wAAAAEAD/AAAA/3/wAAAAEAD/gAAA///QAAAAEAEAAAABAH/wAAAAEAEAgAABAP/wAAAAEAEBAAABAX/wAAAAEAEBgAABAf/wAAAAEAECAAABAn/wAAAAEAECgAABAv/wAAAAEAEDAAABA3/wAAAAEAEDgAABA//wAAAAEAEEAAABBH/wAAAAEAEEgAABBP/wAAAAEAEFAAABBX/wAAAAEAEFgAABBf/wAAAAEAEGAAABBn/wAAAAEAEGgAABBv/wAAAAEAEHAAABB3/wAAAAEAEHgAABB//wAAAAEAEIAAABCH/wAAAAEAEIgAABCP/wAAAAEAEJAAABCX/wAAAAEAEJgAABCf/wAAAAEAEKAAABCn/wAAAAEAEKgAABCv/wAAAAEAELAAABC3/wAAAAEAELgAABC//wAAAAEAEMAAABDH/wAAAAEAEMgAABDP/wAAAAEAENAAABDX/wAAAAEAENgAABDf/wAAAAEAEOAAABDn/wAAAAEAEOgAABDv/wAAAAEAEPAAABD3/wAAAAEAEPgAABD//QAAAAEAAwAAAAAAAP+1ADIAAAAAAAAAAAAAAAAAAAAAAAAAAAEABAIAAQEBC0Fkb2JlQmxhbmsAAQEBMPgb+ByLDB74HQH4HgKL+wz6APoEBR4aBF8MHxwIAQwi91UP92IR91oMJRwZHwwkAAUBAQYOVmFwQWRvYmVJZGVudGl0eUNvcHlyaWdodCAyMDEzLCAyMDE1IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIChodHRwOi8vd3d3LmFkb2JlLmNvbS8pLkFkb2JlIEJsYW5rQWRvYmVCbGFuay0yMDQ5AAACAAEH/wMAAQAAAAgBCAECAAEASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wEAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIIQwhECEUIRghHCEgISQhKCEsg+wy3+iS3AfcQt/kstwP3EPoEFf58+YT6fAf9WP4nFfnSB/fF/DMFprAV+8X4NwX49gamYhX90gf7xfgzBXBmFffF/DcF/PYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAAEBAQr4HwwmmhwZLRL7joscBUaLBr0KvQv65xUD6AB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA==");}';
        style.insertRule(rule, style.cssRules.length);
    }
    Shumway.registerFallbackFont = registerFallbackFont;
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        var rendererOptions = shumwayOptions.register(new OptionSet("Renderer Options"));
        GFX.imageUpdateOption = rendererOptions.register(new Option("", "imageUpdate", "boolean", true, "Enable image updating."));
        GFX.imageConvertOption = rendererOptions.register(new Option("", "imageConvert", "boolean", true, "Enable image conversion."));
        GFX.stageOptions = shumwayOptions.register(new OptionSet("Stage Renderer Options"));
        GFX.forcePaint = GFX.stageOptions.register(new Option("", "forcePaint", "boolean", false, "Force repainting."));
        GFX.ignoreViewport = GFX.stageOptions.register(new Option("", "ignoreViewport", "boolean", false, "Cull elements outside of the viewport."));
        GFX.viewportLoupeDiameter = GFX.stageOptions.register(new Option("", "viewportLoupeDiameter", "number", 256, "Size of the viewport loupe.", {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
        GFX.disableClipping = GFX.stageOptions.register(new Option("", "disableClipping", "boolean", false, "Disable clipping."));
        GFX.debugClipping = GFX.stageOptions.register(new Option("", "debugClipping", "boolean", false, "Disable clipping."));
        GFX.hud = GFX.stageOptions.register(new Option("", "hud", "boolean", false, "Enable HUD."));
        var canvas2DOptions = GFX.stageOptions.register(new OptionSet("Canvas2D Options"));
        GFX.clipDirtyRegions = canvas2DOptions.register(new Option("", "clipDirtyRegions", "boolean", false, "Clip dirty regions."));
        GFX.clipCanvas = canvas2DOptions.register(new Option("", "clipCanvas", "boolean", false, "Clip Regions."));
        GFX.cull = canvas2DOptions.register(new Option("", "cull", "boolean", false, "Enable culling."));
        GFX.snapToDevicePixels = canvas2DOptions.register(new Option("", "snapToDevicePixels", "boolean", false, ""));
        GFX.imageSmoothing = canvas2DOptions.register(new Option("", "imageSmoothing", "boolean", false, ""));
        GFX.masking = canvas2DOptions.register(new Option("", "masking", "boolean", true, "Composite Mask."));
        GFX.blending = canvas2DOptions.register(new Option("", "blending", "boolean", true, ""));
        GFX.debugLayers = canvas2DOptions.register(new Option("", "debugLayers", "boolean", false, ""));
        GFX.filters = canvas2DOptions.register(new Option("", "filters", "boolean", true, ""));
        GFX.cacheShapes = canvas2DOptions.register(new Option("", "cacheShapes", "boolean", true, ""));
        GFX.cacheShapesMaxSize = canvas2DOptions.register(new Option("", "cacheShapesMaxSize", "number", 256, "", {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
        GFX.cacheShapesThreshold = canvas2DOptions.register(new Option("", "cacheShapesThreshold", "number", 256, "", {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Geometry;
        (function (Geometry) {
            var clamp = Shumway.NumberUtilities.clamp;
            var pow2 = Shumway.NumberUtilities.pow2;
            var epsilonEquals = Shumway.NumberUtilities.epsilonEquals;
            var assert = Shumway.Debug.assert;
            function radianToDegrees(r) {
                return r * 180 / Math.PI;
            }
            Geometry.radianToDegrees = radianToDegrees;
            function degreesToRadian(d) {
                return d * Math.PI / 180;
            }
            Geometry.degreesToRadian = degreesToRadian;
            var E = 0.0001;
            function eqFloat(a, b) {
                return Math.abs(a - b) < E;
            }
            var Point = /** @class */ (function () {
                function Point(x, y) {
                    this.x = x;
                    this.y = y;
                }
                Point.prototype.setElements = function (x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                };
                Point.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    return this;
                };
                Point.prototype.dot = function (other) {
                    return this.x * other.x + this.y * other.y;
                };
                Point.prototype.squaredLength = function () {
                    return this.dot(this);
                };
                Point.prototype.distanceTo = function (other) {
                    return Math.sqrt(this.dot(other));
                };
                Point.prototype.sub = function (other) {
                    this.x -= other.x;
                    this.y -= other.y;
                    return this;
                };
                Point.prototype.mul = function (value) {
                    this.x *= value;
                    this.y *= value;
                    return this;
                };
                Point.prototype.clone = function () {
                    return new Point(this.x, this.y);
                };
                Point.prototype.toString = function (digits) {
                    if (digits === void 0) { digits = 2; }
                    return "{x: " + this.x.toFixed(digits) + ", y: " + this.y.toFixed(digits) + "}";
                };
                Point.prototype.inTriangle = function (a, b, c) {
                    var s = a.y * c.x - a.x * c.y + (c.y - a.y) * this.x + (a.x - c.x) * this.y;
                    var t = a.x * b.y - a.y * b.x + (a.y - b.y) * this.x + (b.x - a.x) * this.y;
                    if ((s < 0) != (t < 0)) {
                        return false;
                    }
                    var T = -b.y * c.x + a.y * (c.x - b.x) + a.x * (b.y - c.y) + b.x * c.y;
                    if (T < 0.0) {
                        s = -s;
                        t = -t;
                        T = -T;
                    }
                    return s > 0 && t > 0 && (s + t) < T;
                };
                Point.createEmpty = function () {
                    return new Point(0, 0);
                };
                Point.createEmptyPoints = function (count) {
                    var result = [];
                    for (var i = 0; i < count; i++) {
                        result.push(new Point(0, 0));
                    }
                    return result;
                };
                return Point;
            }());
            Geometry.Point = Point;
            var Rectangle = /** @class */ (function () {
                function Rectangle(x, y, w, h) {
                    this.setElements(x, y, w, h);
                    Rectangle.allocationCount++;
                }
                Rectangle.prototype.setElements = function (x, y, w, h) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                };
                Rectangle.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    this.w = other.w;
                    this.h = other.h;
                };
                Rectangle.prototype.contains = function (other) {
                    var r1 = other.x + other.w;
                    var b1 = other.y + other.h;
                    var r2 = this.x + this.w;
                    var b2 = this.y + this.h;
                    return (other.x >= this.x) &&
                        (other.x < r2) &&
                        (other.y >= this.y) &&
                        (other.y < b2) &&
                        (r1 > this.x) &&
                        (r1 <= r2) &&
                        (b1 > this.y) &&
                        (b1 <= b2);
                };
                Rectangle.prototype.containsPoint = function (point) {
                    return (point.x >= this.x) &&
                        (point.x < this.x + this.w) &&
                        (point.y >= this.y) &&
                        (point.y < this.y + this.h);
                };
                Rectangle.prototype.isContained = function (others) {
                    for (var i = 0; i < others.length; i++) {
                        if (others[i].contains(this)) {
                            return true;
                        }
                    }
                    return false;
                };
                Rectangle.prototype.isSmallerThan = function (other) {
                    return this.w < other.w && this.h < other.h;
                };
                Rectangle.prototype.isLargerThan = function (other) {
                    return this.w > other.w && this.h > other.h;
                };
                Rectangle.prototype.union = function (other) {
                    if (this.isEmpty()) {
                        this.set(other);
                        return;
                    }
                    else if (other.isEmpty()) {
                        return;
                    }
                    var x = this.x, y = this.y;
                    if (this.x > other.x) {
                        x = other.x;
                    }
                    if (this.y > other.y) {
                        y = other.y;
                    }
                    var x0 = this.x + this.w;
                    if (x0 < other.x + other.w) {
                        x0 = other.x + other.w;
                    }
                    var y0 = this.y + this.h;
                    if (y0 < other.y + other.h) {
                        y0 = other.y + other.h;
                    }
                    this.x = x;
                    this.y = y;
                    this.w = x0 - x;
                    this.h = y0 - y;
                };
                Rectangle.prototype.isEmpty = function () {
                    return this.w <= 0 || this.h <= 0;
                };
                Rectangle.prototype.setEmpty = function () {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                };
                Rectangle.prototype.intersect = function (other) {
                    var result = Rectangle.createEmpty();
                    if (this.isEmpty() || other.isEmpty()) {
                        result.setEmpty();
                        return;
                    }
                    result.x = Math.max(this.x, other.x);
                    result.y = Math.max(this.y, other.y);
                    result.w = Math.min(this.x + this.w, other.x + other.w) - result.x;
                    result.h = Math.min(this.y + this.h, other.y + other.h) - result.y;
                    if (result.isEmpty()) {
                        result.setEmpty();
                    }
                    this.set(result);
                };
                Rectangle.prototype.intersects = function (other) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x);
                    var y = Math.max(this.y, other.y);
                    var w = Math.min(this.x + this.w, other.x + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };
                /**
                 * Tests if this rectangle intersects the AABB of the given rectangle.
                 */
                Rectangle.prototype.intersectsTransformedAABB = function (other, matrix) {
                    var rectangle = Rectangle._temporary;
                    rectangle.set(other);
                    matrix.transformRectangleAABB(rectangle);
                    return this.intersects(rectangle);
                };
                Rectangle.prototype.intersectsTranslated = function (other, tx, ty) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x + tx);
                    var y = Math.max(this.y, other.y + ty);
                    var w = Math.min(this.x + this.w, other.x + tx + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + ty + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };
                Rectangle.prototype.area = function () {
                    return this.w * this.h;
                };
                Rectangle.prototype.clone = function () {
                    var rectangle = Rectangle.allocate();
                    rectangle.set(this);
                    return rectangle;
                };
                Rectangle.allocate = function () {
                    var dirtyStack = Rectangle._dirtyStack;
                    if (dirtyStack.length) {
                        return dirtyStack.pop();
                    }
                    else {
                        return new Rectangle(12345, 67890, 12345, 67890);
                    }
                };
                Rectangle.prototype.free = function () {
                    Rectangle._dirtyStack.push(this);
                };
                /**
                 * Snaps the rectangle to pixel boundaries. The computed rectangle covers
                 * the original rectangle.
                 */
                Rectangle.prototype.snap = function () {
                    var x1 = Math.ceil(this.x + this.w);
                    var y1 = Math.ceil(this.y + this.h);
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.w = x1 - this.x;
                    this.h = y1 - this.y;
                    return this;
                };
                Rectangle.prototype.scale = function (x, y) {
                    this.x *= x;
                    this.y *= y;
                    this.w *= x;
                    this.h *= y;
                    return this;
                };
                Rectangle.prototype.offset = function (x, y) {
                    this.x += x;
                    this.y += y;
                    return this;
                };
                Rectangle.prototype.resize = function (w, h) {
                    this.w += w;
                    this.h += h;
                    return this;
                };
                Rectangle.prototype.expand = function (w, h) {
                    this.offset(-w, -h).resize(2 * w, 2 * h);
                    return this;
                };
                Rectangle.prototype.getCenter = function () {
                    return new Point(this.x + this.w / 2, this.y + this.h / 2);
                };
                Rectangle.prototype.getAbsoluteBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };
                Rectangle.prototype.toString = function (digits) {
                    if (digits === void 0) { digits = 2; }
                    return "{" +
                        this.x.toFixed(digits) + ", " +
                        this.y.toFixed(digits) + ", " +
                        this.w.toFixed(digits) + ", " +
                        this.h.toFixed(digits) +
                        "}";
                };
                Rectangle.createEmpty = function () {
                    var rectangle = Rectangle.allocate();
                    rectangle.setEmpty();
                    return rectangle;
                };
                Rectangle.createSquare = function (size) {
                    return new Rectangle(-size / 2, -size / 2, size, size);
                };
                /**
                 * Creates the maximum rectangle representable by signed 16 bit integers.
                 */
                Rectangle.createMaxI16 = function () {
                    return new Rectangle(-32768 /* MinI16 */, -32768 /* MinI16 */, 65535 /* MaxU16 */, 65535 /* MaxU16 */);
                };
                Rectangle.prototype.setMaxI16 = function () {
                    this.setElements(-32768 /* MinI16 */, -32768 /* MinI16 */, 65535 /* MaxU16 */, 65535 /* MaxU16 */);
                };
                Rectangle.prototype.getCorners = function (points) {
                    points[0].x = this.x;
                    points[0].y = this.y;
                    points[1].x = this.x + this.w;
                    points[1].y = this.y;
                    points[2].x = this.x + this.w;
                    points[2].y = this.y + this.h;
                    points[3].x = this.x;
                    points[3].y = this.y + this.h;
                };
                Rectangle.allocationCount = 0;
                Rectangle._temporary = new Rectangle(0, 0, 0, 0);
                Rectangle._dirtyStack = [];
                return Rectangle;
            }());
            Geometry.Rectangle = Rectangle;
            var OBB = /** @class */ (function () {
                function OBB(corners) {
                    this.corners = corners.map(function (corner) {
                        return corner.clone();
                    });
                    this.axes = [
                        corners[1].clone().sub(corners[0]),
                        corners[3].clone().sub(corners[0])
                    ];
                    this.origins = [];
                    for (var i = 0; i < 2; i++) {
                        this.axes[i].mul(1 / this.axes[i].squaredLength());
                        this.origins.push(corners[0].dot(this.axes[i]));
                    }
                }
                OBB.prototype.getBounds = function () {
                    return OBB.getBounds(this.corners);
                };
                OBB.getBounds = function (points) {
                    var min = new Point(Number.MAX_VALUE, Number.MAX_VALUE);
                    var max = new Point(Number.MIN_VALUE, Number.MIN_VALUE);
                    for (var i = 0; i < 4; i++) {
                        var x = points[i].x, y = points[i].y;
                        min.x = Math.min(min.x, x);
                        min.y = Math.min(min.y, y);
                        max.x = Math.max(max.x, x);
                        max.y = Math.max(max.y, y);
                    }
                    return new Rectangle(min.x, min.y, max.x - min.x, max.y - min.y);
                };
                /**
                 * http://www.flipcode.com/archives/2D_OBB_Intersection.shtml
                 */
                OBB.prototype.intersects = function (other) {
                    return this.intersectsOneWay(other) && other.intersectsOneWay(this);
                };
                OBB.prototype.intersectsOneWay = function (other) {
                    for (var i = 0; i < 2; i++) {
                        var tMin = void 0, tMax = void 0;
                        for (var j = 0; j < 4; j++) {
                            var t = other.corners[j].dot(this.axes[i]);
                            if (j === 0) {
                                tMax = tMin = t;
                            }
                            else {
                                if (t < tMin) {
                                    tMin = t;
                                }
                                else if (t > tMax) {
                                    tMax = t;
                                }
                            }
                        }
                        if ((tMin > 1 + this.origins[i]) || (tMax < this.origins[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                return OBB;
            }());
            Geometry.OBB = OBB;
            /**
             * Used to write fast paths for common matrix types.
             */
            var MatrixType;
            (function (MatrixType) {
                MatrixType[MatrixType["Unknown"] = 0] = "Unknown";
                MatrixType[MatrixType["Identity"] = 1] = "Identity";
                MatrixType[MatrixType["Translation"] = 2] = "Translation";
            })(MatrixType = Geometry.MatrixType || (Geometry.MatrixType = {}));
            var Matrix = /** @class */ (function () {
                function Matrix(a, b, c, d, tx, ty) {
                    this._data = new Float64Array(6);
                    this._type = 0 /* Unknown */;
                    this.setElements(a, b, c, d, tx, ty);
                    Matrix.allocationCount++;
                }
                Object.defineProperty(Matrix.prototype, "a", {
                    get: function () {
                        return this._data[0];
                    },
                    set: function (a) {
                        this._data[0] = a;
                        this._type = 0 /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "b", {
                    get: function () {
                        return this._data[1];
                    },
                    set: function (b) {
                        this._data[1] = b;
                        this._type = 0 /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "c", {
                    get: function () {
                        return this._data[2];
                    },
                    set: function (c) {
                        this._data[2] = c;
                        this._type = 0 /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "d", {
                    get: function () {
                        return this._data[3];
                    },
                    set: function (d) {
                        this._data[3] = d;
                        this._type = 0 /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "tx", {
                    get: function () {
                        return this._data[4];
                    },
                    set: function (tx) {
                        this._data[4] = tx;
                        if (this._type === 1 /* Identity */) {
                            this._type = 2 /* Translation */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, "ty", {
                    get: function () {
                        return this._data[5];
                    },
                    set: function (ty) {
                        this._data[5] = ty;
                        if (this._type === 1 /* Identity */) {
                            this._type = 2 /* Translation */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Matrix._createSVGMatrix = function () {
                    if (!Matrix._svg) {
                        Matrix._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    }
                    return Matrix._svg.createSVGMatrix();
                };
                Matrix.prototype.setElements = function (a, b, c, d, tx, ty) {
                    var m = this._data;
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0 /* Unknown */;
                };
                Matrix.prototype.set = function (other) {
                    var m = this._data, n = other._data;
                    m[0] = n[0];
                    m[1] = n[1];
                    m[2] = n[2];
                    m[3] = n[3];
                    m[4] = n[4];
                    m[5] = n[5];
                    this._type = other._type;
                };
                /**
                 * Whether the transformed query rectangle is empty after this transform is applied to it.
                 */
                Matrix.prototype.emptyArea = function (query) {
                    var m = this._data;
                    // TODO: Work out the details here.
                    if (m[0] === 0 || m[3] === 0) {
                        return true;
                    }
                    return false;
                };
                /**
                 * Whether the area of transformed query rectangle is infinite after this transform is applied to it.
                 */
                Matrix.prototype.infiniteArea = function (query) {
                    var m = this._data;
                    // TODO: Work out the details here.
                    if (Math.abs(m[0]) === Infinity ||
                        Math.abs(m[3]) === Infinity) {
                        return true;
                    }
                    return false;
                };
                Matrix.prototype.isEqual = function (other) {
                    if (this._type === 1 /* Identity */ && other._type === 1 /* Identity */) {
                        return true;
                    }
                    var m = this._data, n = other._data;
                    return m[0] === n[0] &&
                        m[1] === n[1] &&
                        m[2] === n[2] &&
                        m[3] === n[3] &&
                        m[4] === n[4] &&
                        m[5] === n[5];
                };
                Matrix.prototype.clone = function () {
                    var matrix = Matrix.allocate();
                    matrix.set(this);
                    return matrix;
                };
                Matrix.allocate = function () {
                    var dirtyStack = Matrix._dirtyStack;
                    var matrix = null;
                    if (dirtyStack.length) {
                        return dirtyStack.pop();
                    }
                    else {
                        return new Matrix(12345, 12345, 12345, 12345, 12345, 12345);
                    }
                };
                Matrix.prototype.free = function () {
                    Matrix._dirtyStack.push(this);
                };
                Matrix.prototype.transform = function (a, b, c, d, tx, ty) {
                    var m = this._data;
                    var _a = m[0], _b = m[1], _c = m[2], _d = m[3], _tx = m[4], _ty = m[5];
                    m[0] = _a * a + _c * b;
                    m[1] = _b * a + _d * b;
                    m[2] = _a * c + _c * d;
                    m[3] = _b * c + _d * d;
                    m[4] = _a * tx + _c * ty + _tx;
                    m[5] = _b * tx + _d * ty + _ty;
                    this._type = 0 /* Unknown */;
                    return this;
                };
                Matrix.prototype.transformRectangle = function (rectangle, points) {
                    release || assert(points.length === 4);
                    var m = this._data, a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;
                    /*
        
                     0---1
                     | / |
                     3---2
        
                     */
                    points[0].x = a * x + c * y + tx;
                    points[0].y = b * x + d * y + ty;
                    points[1].x = a * (x + w) + c * y + tx;
                    points[1].y = b * (x + w) + d * y + ty;
                    points[2].x = a * (x + w) + c * (y + h) + tx;
                    points[2].y = b * (x + w) + d * (y + h) + ty;
                    points[3].x = a * x + c * (y + h) + tx;
                    points[3].y = b * x + d * (y + h) + ty;
                };
                Matrix.prototype.isTranslationOnly = function () {
                    if (this._type === 2 /* Translation */) {
                        return true;
                    }
                    var m = this._data;
                    if (m[0] === 1 &&
                        m[1] === 0 &&
                        m[2] === 0 &&
                        m[3] === 1) {
                        this._type = 2 /* Translation */;
                        return true;
                    }
                    else if (epsilonEquals(m[0], 1) &&
                        epsilonEquals(m[1], 0) &&
                        epsilonEquals(m[2], 0) &&
                        epsilonEquals(m[3], 1)) {
                        this._type = 2 /* Translation */;
                        return true;
                    }
                    return false;
                };
                Matrix.prototype.transformRectangleAABB = function (rectangle) {
                    var m = this._data;
                    if (this._type === 1 /* Identity */) {
                        return;
                    }
                    else if (this._type === 2 /* Translation */) {
                        rectangle.x += m[4];
                        rectangle.y += m[5];
                        return;
                    }
                    var a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;
                    /*
        
                     0---1
                     | / |
                     3---2
        
                     */
                    var x0 = a * x + c * y + tx;
                    var y0 = b * x + d * y + ty;
                    var x1 = a * (x + w) + c * y + tx;
                    var y1 = b * (x + w) + d * y + ty;
                    var x2 = a * (x + w) + c * (y + h) + tx;
                    var y2 = b * (x + w) + d * (y + h) + ty;
                    var x3 = a * x + c * (y + h) + tx;
                    var y3 = b * x + d * (y + h) + ty;
                    var tmp = 0;
                    // Manual Min/Max is a lot faster than calling Math.min/max
                    // X Min-Max
                    if (x0 > x1) {
                        tmp = x0;
                        x0 = x1;
                        x1 = tmp;
                    }
                    if (x2 > x3) {
                        tmp = x2;
                        x2 = x3;
                        x3 = tmp;
                    }
                    rectangle.x = x0 < x2 ? x0 : x2;
                    rectangle.w = (x1 > x3 ? x1 : x3) - rectangle.x;
                    // Y Min-Max
                    if (y0 > y1) {
                        tmp = y0;
                        y0 = y1;
                        y1 = tmp;
                    }
                    if (y2 > y3) {
                        tmp = y2;
                        y2 = y3;
                        y3 = tmp;
                    }
                    rectangle.y = y0 < y2 ? y0 : y2;
                    rectangle.h = (y1 > y3 ? y1 : y3) - rectangle.y;
                };
                Matrix.prototype.scale = function (x, y) {
                    var m = this._data;
                    m[0] *= x;
                    m[1] *= y;
                    m[2] *= x;
                    m[3] *= y;
                    m[4] *= x;
                    m[5] *= y;
                    this._type = 0 /* Unknown */;
                    return this;
                };
                Matrix.prototype.scaleClone = function (x, y) {
                    if (x === 1 && y === 1) {
                        return this;
                    }
                    return this.clone().scale(x, y);
                };
                Matrix.prototype.rotate = function (angle) {
                    var m = this._data, a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var cos = Math.cos(angle);
                    var sin = Math.sin(angle);
                    m[0] = cos * a - sin * b;
                    m[1] = sin * a + cos * b;
                    m[2] = cos * c - sin * d;
                    m[3] = sin * c + cos * d;
                    m[4] = cos * tx - sin * ty;
                    m[5] = sin * tx + cos * ty;
                    this._type = 0 /* Unknown */;
                    return this;
                };
                Matrix.prototype.concat = function (other) {
                    if (other._type === 1 /* Identity */) {
                        return this;
                    }
                    var m = this._data, n = other._data;
                    var a = m[0] * n[0];
                    var b = 0.0;
                    var c = 0.0;
                    var d = m[3] * n[3];
                    var tx = m[4] * n[0] + n[4];
                    var ty = m[5] * n[3] + n[5];
                    if (m[1] !== 0.0 || m[2] !== 0.0 || n[1] !== 0.0 || n[2] !== 0.0) {
                        a += m[1] * n[2];
                        d += m[2] * n[1];
                        b += m[0] * n[1] + m[1] * n[3];
                        c += m[2] * n[0] + m[3] * n[2];
                        tx += m[5] * n[2];
                        ty += m[4] * n[1];
                    }
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0 /* Unknown */;
                    return this;
                };
                Matrix.prototype.concatClone = function (other) {
                    return this.clone().concat(other);
                };
                /**
                 * this = other * this
                 */
                Matrix.prototype.preMultiply = function (other) {
                    var m = this._data, n = other._data;
                    if (other._type === 2 /* Translation */ &&
                        (this._type & (1 /* Identity */ | 2 /* Translation */))) {
                        m[4] += n[4];
                        m[5] += n[5];
                        this._type = 2 /* Translation */;
                        return;
                    }
                    else if (other._type === 1 /* Identity */) {
                        return;
                    }
                    var a = n[0] * m[0];
                    var b = 0.0;
                    var c = 0.0;
                    var d = n[3] * m[3];
                    var tx = n[4] * m[0] + m[4];
                    var ty = n[5] * m[3] + m[5];
                    if (n[1] !== 0.0 || n[2] !== 0.0 || m[1] !== 0.0 || m[2] !== 0.0) {
                        a += n[1] * m[2];
                        d += n[2] * m[1];
                        b += n[0] * m[1] + n[1] * m[3];
                        c += n[2] * m[0] + n[3] * m[2];
                        tx += n[5] * m[2];
                        ty += n[4] * m[1];
                    }
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0 /* Unknown */;
                };
                Matrix.prototype.translate = function (x, y) {
                    var m = this._data;
                    m[4] += x;
                    m[5] += y;
                    if (this._type === 1 /* Identity */) {
                        this._type = 2 /* Translation */;
                    }
                    return this;
                };
                Matrix.prototype.setIdentity = function () {
                    var m = this._data;
                    m[0] = 1;
                    m[1] = 0;
                    m[2] = 0;
                    m[3] = 1;
                    m[4] = 0;
                    m[5] = 0;
                    this._type = 1 /* Identity */;
                };
                Matrix.prototype.isIdentity = function () {
                    if (this._type === 1 /* Identity */) {
                        return true;
                    }
                    var m = this._data;
                    return m[0] === 1 && m[1] === 0 && m[2] === 0 &&
                        m[3] === 1 && m[4] === 0 && m[5] === 0;
                };
                Matrix.prototype.transformPoint = function (point) {
                    if (this._type === 1 /* Identity */) {
                        return;
                    }
                    var m = this._data;
                    var x = point.x;
                    var y = point.y;
                    point.x = m[0] * x + m[2] * y + m[4];
                    point.y = m[1] * x + m[3] * y + m[5];
                };
                Matrix.prototype.transformPoints = function (points) {
                    if (this._type === 1 /* Identity */) {
                        return;
                    }
                    for (var i = 0; i < points.length; i++) {
                        this.transformPoint(points[i]);
                    }
                };
                Matrix.prototype.deltaTransformPoint = function (point) {
                    if (this._type === 1 /* Identity */) {
                        return;
                    }
                    var m = this._data;
                    var x = point.x;
                    var y = point.y;
                    point.x = m[0] * x + m[2] * y;
                    point.y = m[1] * x + m[3] * y;
                };
                Matrix.prototype.inverse = function (result) {
                    var m = this._data, r = result._data;
                    if (this._type === 1 /* Identity */) {
                        result.setIdentity();
                        return;
                    }
                    else if (this._type === 2 /* Translation */) {
                        r[0] = 1;
                        r[1] = 0;
                        r[2] = 0;
                        r[3] = 1;
                        r[4] = -m[4];
                        r[5] = -m[5];
                        result._type = 2 /* Translation */;
                        return;
                    }
                    var b = m[1];
                    var c = m[2];
                    var tx = m[4];
                    var ty = m[5];
                    if (b === 0 && c === 0) {
                        var a = r[0] = 1 / m[0];
                        var d = r[3] = 1 / m[3];
                        r[1] = 0;
                        r[2] = 0;
                        r[4] = -a * tx;
                        r[5] = -d * ty;
                    }
                    else {
                        var a = m[0];
                        var d = m[3];
                        var determinant = a * d - b * c;
                        if (determinant === 0) {
                            result.setIdentity();
                            return;
                        }
                        determinant = 1 / determinant;
                        r[0] = d * determinant;
                        b = r[1] = -b * determinant;
                        c = r[2] = -c * determinant;
                        d = r[3] = a * determinant;
                        r[4] = -(r[0] * tx + c * ty);
                        r[5] = -(b * tx + d * ty);
                    }
                    result._type = 0 /* Unknown */;
                    return;
                };
                Matrix.prototype.getTranslateX = function () {
                    return this._data[4];
                };
                Matrix.prototype.getTranslateY = function () {
                    return this._data[4];
                };
                Matrix.prototype.getScaleX = function () {
                    var m = this._data;
                    if (m[0] === 1 && m[1] === 0) {
                        return 1;
                    }
                    var result = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
                    return m[0] > 0 ? result : -result;
                };
                Matrix.prototype.getScaleY = function () {
                    var m = this._data;
                    if (m[2] === 0 && m[3] === 1) {
                        return 1;
                    }
                    var result = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
                    return m[3] > 0 ? result : -result;
                };
                Matrix.prototype.getScale = function () {
                    return (this.getScaleX() + this.getScaleY()) / 2;
                };
                Matrix.prototype.getAbsoluteScaleX = function () {
                    return Math.abs(this.getScaleX());
                };
                Matrix.prototype.getAbsoluteScaleY = function () {
                    return Math.abs(this.getScaleY());
                };
                Matrix.prototype.getRotation = function () {
                    var m = this._data;
                    return Math.atan(m[1] / m[0]) * 180 / Math.PI;
                };
                Matrix.prototype.isScaleOrRotation = function () {
                    var m = this._data;
                    return Math.abs(m[0] * m[2] + m[1] * m[3]) < 0.01;
                };
                Matrix.prototype.toString = function (digits) {
                    if (digits === void 0) { digits = 2; }
                    var m = this._data;
                    return "{" +
                        m[0].toFixed(digits) + ", " +
                        m[1].toFixed(digits) + ", " +
                        m[2].toFixed(digits) + ", " +
                        m[3].toFixed(digits) + ", " +
                        m[4].toFixed(digits) + ", " +
                        m[5].toFixed(digits) + "}";
                };
                Matrix.prototype.toWebGLMatrix = function () {
                    var m = this._data;
                    return new Float32Array([
                        m[0], m[1], 0, m[2], m[3], 0, m[4], m[5], 1
                    ]);
                };
                Matrix.prototype.toCSSTransform = function () {
                    var m = this._data;
                    return "matrix(" +
                        m[0] + ", " +
                        m[1] + ", " +
                        m[2] + ", " +
                        m[3] + ", " +
                        m[4] + ", " +
                        m[5] + ")";
                };
                Matrix.createIdentity = function () {
                    var matrix = Matrix.allocate();
                    matrix.setIdentity();
                    return matrix;
                };
                Matrix.prototype.toSVGMatrix = function () {
                    var m = this._data;
                    var matrix = Matrix._createSVGMatrix();
                    try {
                        matrix.a = m[0];
                        matrix.b = m[1];
                        matrix.c = m[2];
                        matrix.d = m[3];
                        matrix.e = m[4];
                        matrix.f = m[5];
                    }
                    catch (e) {
                        // The setters on SVGMatrix throw if the assigned value is `NaN`, which we sometimes
                        // produce. In that case, just fall back to an identity matrix for now.
                        return Matrix._createSVGMatrix();
                    }
                    return matrix;
                };
                Matrix.prototype.snap = function () {
                    var m = this._data;
                    if (this.isTranslationOnly()) {
                        m[0] = 1;
                        m[1] = 0;
                        m[2] = 0;
                        m[3] = 1;
                        m[4] = Math.round(m[4]);
                        m[5] = Math.round(m[5]);
                        this._type = 2 /* Translation */;
                        return true;
                    }
                    return false;
                };
                Matrix.createIdentitySVGMatrix = function () {
                    return Matrix._createSVGMatrix();
                };
                Matrix.createSVGMatrixFromArray = function (array) {
                    var matrix = Matrix._createSVGMatrix();
                    matrix.a = array[0];
                    matrix.b = array[1];
                    matrix.c = array[2];
                    matrix.d = array[3];
                    matrix.e = array[4];
                    matrix.f = array[5];
                    return matrix;
                };
                Matrix.allocationCount = 0;
                Matrix._dirtyStack = [];
                Matrix.multiply = function (dst, src) {
                    var n = src._data;
                    dst.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
                };
                return Matrix;
            }());
            Geometry.Matrix = Matrix;
            var DirtyRegion = /** @class */ (function () {
                function DirtyRegion(w, h, sizeInBits) {
                    if (sizeInBits === void 0) { sizeInBits = 7; }
                    var size = this.size = 1 << sizeInBits;
                    this.sizeInBits = sizeInBits;
                    this.w = w;
                    this.h = h;
                    this.c = Math.ceil(w / size);
                    this.r = Math.ceil(h / size);
                    this.grid = [];
                    for (var y = 0; y < this.r; y++) {
                        this.grid.push([]);
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x] = new DirtyRegion.Cell(new Rectangle(x * size, y * size, size, size));
                        }
                    }
                }
                DirtyRegion.prototype.clear = function () {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x].clear();
                        }
                    }
                };
                DirtyRegion.prototype.getBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };
                DirtyRegion.prototype.addDirtyRectangle = function (rectangle) {
                    var x = rectangle.x >> this.sizeInBits;
                    var y = rectangle.y >> this.sizeInBits;
                    if (x >= this.c || y >= this.r) {
                        return;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                    if (y < 0) {
                        y = 0;
                    }
                    var cell = this.grid[y][x];
                    rectangle = rectangle.clone();
                    rectangle.snap();
                    if (cell.region.contains(rectangle)) {
                        if (cell.bounds.isEmpty()) {
                            cell.bounds.set(rectangle);
                        }
                        else if (!cell.bounds.contains(rectangle)) {
                            cell.bounds.union(rectangle);
                        }
                    }
                    else {
                        var w = Math.min(this.c, Math.ceil((rectangle.x + rectangle.w) / this.size)) - x;
                        var h = Math.min(this.r, Math.ceil((rectangle.y + rectangle.h) / this.size)) - y;
                        for (var i = 0; i < w; i++) {
                            for (var j = 0; j < h; j++) {
                                var cell_1 = this.grid[y + j][x + i];
                                var intersection = cell_1.region.clone();
                                intersection.intersect(rectangle);
                                if (!intersection.isEmpty()) {
                                    this.addDirtyRectangle(intersection);
                                }
                            }
                        }
                    }
                };
                DirtyRegion.prototype.gatherRegions = function (regions) {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var bounds = this.grid[y][x].bounds;
                            if (!bounds.isEmpty()) {
                                regions.push(this.grid[y][x].bounds);
                            }
                        }
                    }
                };
                DirtyRegion.prototype.gatherOptimizedRegions = function (regions) {
                    this.gatherRegions(regions);
                };
                DirtyRegion.prototype.getDirtyRatio = function () {
                    var totalArea = this.w * this.h;
                    if (totalArea === 0) {
                        return 0;
                    }
                    var dirtyArea = 0;
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            dirtyArea += this.grid[y][x].region.area();
                        }
                    }
                    return dirtyArea / totalArea;
                };
                DirtyRegion.prototype.render = function (context, options) {
                    function drawRectangle(rectangle) {
                        context.rect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
                    }
                    if (options && options.drawGrid) {
                        context.strokeStyle = "white";
                        for (var y = 0; y < this.r; y++) {
                            for (var x = 0; x < this.c; x++) {
                                var cell = this.grid[y][x];
                                context.beginPath();
                                drawRectangle(cell.region);
                                context.closePath();
                                context.stroke();
                            }
                        }
                    }
                    context.strokeStyle = "#E0F8D8";
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var cell = this.grid[y][x];
                            context.beginPath();
                            drawRectangle(cell.bounds);
                            context.closePath();
                            context.stroke();
                        }
                    }
                    //      context.strokeStyle = "#5856d6";
                    //      let regions = [];
                    //      this.gatherOptimizedRegions(regions);
                    //      for (let i = 0; i < regions.length; i++) {
                    //        context.beginPath();
                    //        drawRectangle(regions[i]);
                    //        context.closePath();
                    //        context.stroke();
                    //      }
                };
                DirtyRegion.tmpRectangle = Rectangle.createEmpty();
                return DirtyRegion;
            }());
            Geometry.DirtyRegion = DirtyRegion;
            (function (DirtyRegion) {
                var Cell = /** @class */ (function () {
                    function Cell(region) {
                        this.region = region;
                        this.bounds = Rectangle.createEmpty();
                    }
                    Cell.prototype.clear = function () {
                        this.bounds.setEmpty();
                    };
                    return Cell;
                }());
                DirtyRegion.Cell = Cell;
            })(DirtyRegion = Geometry.DirtyRegion || (Geometry.DirtyRegion = {}));
            var Tile = /** @class */ (function () {
                function Tile(index, x, y, w, h, scale) {
                    this.index = index;
                    this.x = x;
                    this.y = y;
                    this.scale = scale;
                    this.bounds = new Rectangle(x * w, y * h, w, h);
                }
                Tile.prototype.getOBB = function () {
                    if (this._obb) {
                        return this._obb;
                    }
                    this.bounds.getCorners(Tile.corners);
                    return this._obb = new OBB(Tile.corners);
                };
                Tile.corners = Point.createEmptyPoints(4);
                return Tile;
            }());
            Geometry.Tile = Tile;
            /**
             * A grid data structure that lets you query tiles that intersect a transformed rectangle.
             */
            var TileCache = /** @class */ (function () {
                function TileCache(w, h, tileW, tileH, scale) {
                    this.tileW = tileW;
                    this.tileH = tileH;
                    this.scale = scale;
                    this.w = w;
                    this.h = h;
                    this.rows = Math.ceil(h / tileH);
                    this.columns = Math.ceil(w / tileW);
                    release || assert(this.rows < 2048 && this.columns < 2048);
                    this.tiles = [];
                    var index = 0;
                    for (var y = 0; y < this.rows; y++) {
                        for (var x = 0; x < this.columns; x++) {
                            this.tiles.push(new Tile(index++, x, y, tileW, tileH, scale));
                        }
                    }
                }
                /**
                 * Query tiles using a transformed rectangle.
                 * TODO: Fine-tune these heuristics.
                 */
                TileCache.prototype.getTiles = function (query, transform) {
                    if (transform.emptyArea(query)) {
                        return [];
                    }
                    else if (transform.infiniteArea(query)) {
                        return this.tiles;
                    }
                    var tileCount = this.columns * this.rows;
                    // The |getFewTiles| algorithm works better for a few tiles but it can't handle skew transforms.
                    if (tileCount < 40 && transform.isScaleOrRotation()) {
                        var precise = tileCount > 10;
                        return this.getFewTiles(query, transform, precise);
                    }
                    else {
                        return this.getManyTiles(query, transform);
                    }
                };
                /**
                 * Precise indicates that we want to do an exact OBB intersection.
                 */
                TileCache.prototype.getFewTiles = function (query, transform, precise) {
                    if (precise === void 0) { precise = true; }
                    if (transform.isTranslationOnly() && this.tiles.length === 1) {
                        if (this.tiles[0].bounds.intersectsTranslated(query, transform.tx, transform.ty)) {
                            return [this.tiles[0]];
                        }
                        return [];
                    }
                    transform.transformRectangle(query, TileCache._points);
                    var queryOBB;
                    var queryBounds = new Rectangle(0, 0, this.w, this.h);
                    if (precise) {
                        queryOBB = new OBB(TileCache._points);
                    }
                    queryBounds.intersect(OBB.getBounds(TileCache._points));
                    if (queryBounds.isEmpty()) {
                        return [];
                    }
                    var minX = queryBounds.x / this.tileW | 0;
                    var minY = queryBounds.y / this.tileH | 0;
                    var maxX = Math.ceil((queryBounds.x + queryBounds.w) / this.tileW) | 0;
                    var maxY = Math.ceil((queryBounds.y + queryBounds.h) / this.tileH) | 0;
                    minX = clamp(minX, 0, this.columns);
                    maxX = clamp(maxX, 0, this.columns);
                    minY = clamp(minY, 0, this.rows);
                    maxY = clamp(maxY, 0, this.rows);
                    var tiles = [];
                    for (var x = minX; x < maxX; x++) {
                        for (var y = minY; y < maxY; y++) {
                            var tile = this.tiles[y * this.columns + x];
                            if (tile.bounds.intersects(queryBounds) && (precise ? tile.getOBB().intersects(queryOBB) : true)) {
                                tiles.push(tile);
                            }
                        }
                    }
                    return tiles;
                };
                TileCache.prototype.getManyTiles = function (query, transform) {
                    function intersectX(x, p1, p2) {
                        // (x - x1) * (y2 - y1) = (y - y1) * (x2 - x1)
                        return (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;
                    }
                    function appendTiles(tiles, cache, column, startRow, endRow) {
                        if (column < 0 || column >= cache.columns) {
                            return;
                        }
                        var j1 = clamp(startRow, 0, cache.rows);
                        var j2 = clamp(endRow + 1, 0, cache.rows);
                        for (var j = j1; j < j2; j++) {
                            tiles.push(cache.tiles[j * cache.columns + column]);
                        }
                    }
                    var rectPoints = TileCache._points;
                    transform.transformRectangle(query, rectPoints);
                    // finding minimal-x point, placing at first (and last)
                    var i1 = rectPoints[0].x < rectPoints[1].x ? 0 : 1;
                    var i2 = rectPoints[2].x < rectPoints[3].x ? 2 : 3;
                    var i0 = rectPoints[i1].x < rectPoints[i2].x ? i1 : i2;
                    var lines = [];
                    for (var j = 0; j < 5; j++, i0++) {
                        lines.push(rectPoints[i0 % 4]);
                    }
                    // and keeping points ordered counterclockwise
                    if ((lines[1].x - lines[0].x) * (lines[3].y - lines[0].y) <
                        (lines[1].y - lines[0].y) * (lines[3].x - lines[0].x)) {
                        var tmp = lines[1];
                        lines[1] = lines[3];
                        lines[3] = tmp;
                    }
                    var tiles = [];
                    var lastY1, lastY2;
                    var i = Math.floor(lines[0].x / this.tileW);
                    var nextX = (i + 1) * this.tileW;
                    if (lines[2].x < nextX) {
                        // edge case: all fits into one column
                        lastY1 = Math.min(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        lastY2 = Math.max(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        var j1 = Math.floor(lastY1 / this.tileH);
                        var j2 = Math.floor(lastY2 / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        return tiles;
                    }
                    var line1 = 0, line2 = 4;
                    var lastSegment1 = false, lastSegment2 = false;
                    if (lines[0].x === lines[1].x || lines[0].x === lines[3].x) {
                        // edge case: first rectangle side parallel to columns
                        if (lines[0].x === lines[1].x) {
                            lastSegment1 = true;
                            line1++;
                        }
                        else {
                            lastSegment2 = true;
                            line2--;
                        }
                        lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                        var j1 = Math.floor(lines[line1].y / this.tileH);
                        var j2 = Math.floor(lines[line2].y / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        i++;
                    }
                    do {
                        var nextY1 = void 0, nextY2 = void 0;
                        var nextSegment1 = void 0, nextSegment2 = void 0;
                        if (lines[line1 + 1].x < nextX) {
                            nextY1 = lines[line1 + 1].y;
                            nextSegment1 = true;
                        }
                        else {
                            nextY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                            nextSegment1 = false;
                        }
                        if (lines[line2 - 1].x < nextX) {
                            nextY2 = lines[line2 - 1].y;
                            nextSegment2 = true;
                        }
                        else {
                            nextY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                            nextSegment2 = false;
                        }
                        var j1 = Math.floor((lines[line1].y < lines[line1 + 1].y ? lastY1 : nextY1) / this.tileH);
                        var j2 = Math.floor((lines[line2].y > lines[line2 - 1].y ? lastY2 : nextY2) / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        if (nextSegment1 && lastSegment1) {
                            break;
                        }
                        if (nextSegment1) {
                            lastSegment1 = true;
                            line1++;
                            lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        }
                        else {
                            lastY1 = nextY1;
                        }
                        if (nextSegment2) {
                            lastSegment2 = true;
                            line2--;
                            lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                        }
                        else {
                            lastY2 = nextY2;
                        }
                        i++;
                        nextX = (i + 1) * this.tileW;
                    } while (line1 < line2);
                    return tiles;
                };
                TileCache._points = Point.createEmptyPoints(4);
                return TileCache;
            }());
            Geometry.TileCache = TileCache;
            var MIN_CACHE_LEVELS = 5;
            var MAX_CACHE_LEVELS = 3;
            /**
             * Manages tile caches at different scales.
             */
            var RenderableTileCache = /** @class */ (function () {
                function RenderableTileCache(source, tileSize, minUntiledSize) {
                    this._cacheLevels = [];
                    this._source = source;
                    this._tileSize = tileSize;
                    this._minUntiledSize = minUntiledSize;
                }
                /**
                 * Gets the tiles covered by the specified |query| rectangle and transformed by the given |transform| matrix.
                 */
                RenderableTileCache.prototype._getTilesAtScale = function (query, transform, scratchBounds) {
                    var transformScale = Math.max(transform.getAbsoluteScaleX(), transform.getAbsoluteScaleY());
                    // Use log2(1 / transformScale) to figure out the tile level.
                    var level = 0;
                    if (transformScale !== 1) {
                        level = clamp(Math.round(Math.log(1 / transformScale) / Math.LN2), -MIN_CACHE_LEVELS, MAX_CACHE_LEVELS);
                    }
                    var scale = pow2(level);
                    // Since we use a single tile for dynamic sources, we've got to make sure that it fits in our surface caches ...
                    if (this._source.hasFlags(256 /* Dynamic */)) {
                        // .. so try a lower scale level until it fits.
                        while (true) {
                            scale = pow2(level);
                            if (scratchBounds.contains(this._source.getBounds().getAbsoluteBounds().clone().scale(scale, scale))) {
                                break;
                            }
                            level--;
                            release || assert(level >= -MIN_CACHE_LEVELS);
                        }
                    }
                    // If the source is not scalable don't cache any tiles at a higher scale factor. However, it may still make
                    // sense to cache at a lower scale factor in case we need to evict larger cached images.
                    if (!(this._source.hasFlags(512 /* Scalable */))) {
                        level = clamp(level, -MIN_CACHE_LEVELS, 0);
                    }
                    scale = pow2(level);
                    var levelIndex = MIN_CACHE_LEVELS + level;
                    var cache = this._cacheLevels[levelIndex];
                    if (!cache) {
                        var bounds = this._source.getBounds().getAbsoluteBounds();
                        var scaledBounds = bounds.clone().scale(scale, scale);
                        var tileW = void 0, tileH = void 0;
                        if (this._source.hasFlags(256 /* Dynamic */) ||
                            !this._source.hasFlags(1024 /* Tileable */) || Math.max(scaledBounds.w, scaledBounds.h) <= this._minUntiledSize) {
                            tileW = scaledBounds.w;
                            tileH = scaledBounds.h;
                        }
                        else {
                            tileW = tileH = this._tileSize;
                        }
                        cache = this._cacheLevels[levelIndex] = new TileCache(scaledBounds.w, scaledBounds.h, tileW, tileH, scale);
                    }
                    return cache.getTiles(query, transform.scaleClone(scale, scale));
                };
                RenderableTileCache.prototype.fetchTiles = function (query, transform, scratchContext, cacheImageCallback) {
                    var scratchBounds = new Rectangle(0, 0, scratchContext.canvas.width, scratchContext.canvas.height);
                    var tiles = this._getTilesAtScale(query, transform, scratchBounds);
                    var uncachedTiles;
                    var source = this._source;
                    for (var i = 0; i < tiles.length; i++) {
                        var tile = tiles[i];
                        if (!tile.cachedSurfaceRegion || !tile.cachedSurfaceRegion.surface || (source.hasFlags(256 /* Dynamic */ | 4096 /* Dirty */))) {
                            if (!uncachedTiles) {
                                uncachedTiles = [];
                            }
                            uncachedTiles.push(tile);
                        }
                    }
                    if (uncachedTiles) {
                        this._cacheTiles(scratchContext, uncachedTiles, cacheImageCallback, scratchBounds);
                    }
                    source.removeFlags(4096 /* Dirty */);
                    return tiles;
                };
                RenderableTileCache.prototype._getTileBounds = function (tiles) {
                    var bounds = Rectangle.createEmpty();
                    for (var i = 0; i < tiles.length; i++) {
                        bounds.union(tiles[i].bounds);
                    }
                    return bounds;
                };
                /**
                 * This caches raster versions of the specified |uncachedTiles|. The tiles are generated using a scratch
                 * canvas2D context (|scratchContext|) and then cached via |cacheImageCallback|. Ideally, we want to render
                 * all tiles in one go, but they may not fit in the |scratchContext| in which case we need to render the
                 * source shape several times.
                 *
                 * TODO: Find a good algorithm to do this since it's quite important that we don't repaint too many times.
                 * Spending some time trying to figure out the *optimal* solution may pay-off since painting is soo expensive.
                 */
                RenderableTileCache.prototype._cacheTiles = function (scratchContext, uncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth) {
                    if (maxRecursionDepth === void 0) { maxRecursionDepth = 4; }
                    release || assert(maxRecursionDepth > 0, "Infinite recursion is likely.");
                    var uncachedTileBounds = this._getTileBounds(uncachedTiles);
                    scratchContext.save();
                    scratchContext.setTransform(1, 0, 0, 1, 0, 0);
                    scratchContext.clearRect(0, 0, scratchBounds.w, scratchBounds.h);
                    scratchContext.translate(-uncachedTileBounds.x, -uncachedTileBounds.y);
                    scratchContext.scale(uncachedTiles[0].scale, uncachedTiles[0].scale);
                    // Translate so that the source is drawn at the origin.
                    var sourceBounds = this._source.getBounds();
                    scratchContext.translate(-sourceBounds.x, -sourceBounds.y);
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.enter("renderTiles");
                    GFX.traceLevel >= 2 /* Verbose */ && GFX.writer && GFX.writer.writeLn("Rendering Tiles: " + uncachedTileBounds);
                    this._source.render(scratchContext, 0);
                    scratchContext.restore();
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.leave("renderTiles");
                    var remainingUncachedTiles = null;
                    for (var i = 0; i < uncachedTiles.length; i++) {
                        var tile = uncachedTiles[i];
                        var region = tile.bounds.clone();
                        region.x -= uncachedTileBounds.x;
                        region.y -= uncachedTileBounds.y;
                        if (!scratchBounds.contains(region)) {
                            if (!remainingUncachedTiles) {
                                remainingUncachedTiles = [];
                            }
                            remainingUncachedTiles.push(tile);
                        }
                        tile.cachedSurfaceRegion = cacheImageCallback(tile.cachedSurfaceRegion, scratchContext, region);
                    }
                    if (remainingUncachedTiles) {
                        // This is really dumb at the moment; if we have some tiles left over, partition the tile set in half and recurse.
                        if (remainingUncachedTiles.length >= 2) {
                            var a = remainingUncachedTiles.slice(0, remainingUncachedTiles.length / 2 | 0);
                            var b = remainingUncachedTiles.slice(a.length);
                            this._cacheTiles(scratchContext, a, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                            this._cacheTiles(scratchContext, b, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        }
                        else {
                            this._cacheTiles(scratchContext, remainingUncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        }
                    }
                };
                return RenderableTileCache;
            }());
            Geometry.RenderableTileCache = RenderableTileCache;
        })(Geometry = GFX.Geometry || (GFX.Geometry = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var roundToMultipleOfPowerOfTwo = Shumway.IntegerUtilities.roundToMultipleOfPowerOfTwo;
        var assert = Shumway.Debug.assert;
        var Rectangle = GFX.Geometry.Rectangle;
        /**
         * Various 2D rectangular region allocators. These are used to manage
         * areas of surfaces, 2D Canvases or WebGL surfaces. Each allocator
         * implements the |IRegionAllocator| interface and must provied two
         * methods to allocate and free regions.
         *
         * CompactAllocator: Good for tightly packed surface atlases but becomes
         * fragmented easily. Allocation / freeing cost is high and should only
         * be used for long lived regions.
         *
         * GridAllocator: Very fast at allocation and freeing but is not very
         * tightly packed. Space is initially partitioned in equally sized grid
         * cells which may be much larger than the allocated regions. This should
         * be used for fixed size allocation regions.
         *
         * BucketAllocator: Manages a list of GridAllocators with different grid
         * sizes.
         */
        var RegionAllocator;
        (function (RegionAllocator) {
            var Region = /** @class */ (function (_super) {
                __extends(Region, _super);
                function Region() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return Region;
            }(GFX.Geometry.Rectangle));
            RegionAllocator.Region = Region;
            /**
             * Simple 2D bin-packing algorithm that recursively partitions space along the x and y axis. The binary tree
             * can get quite deep so watch out of deep recursive calls. This algorithm works best when inserting items
             * that are sorted by width and height, from largest to smallest.
             */
            var CompactAllocator = /** @class */ (function () {
                function CompactAllocator(w, h) {
                    this._root = new CompactCell(0, 0, w | 0, h | 0, false);
                }
                CompactAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var result = this._root.insert(w, h);
                    if (result) {
                        result.allocator = this;
                        result.allocated = true;
                    }
                    return result;
                };
                CompactAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.clear();
                    region.allocated = false;
                };
                /**
                 * Try out randomizing the orientation of each subdivision, sometimes this can lead to better results.
                 */
                CompactAllocator.RANDOM_ORIENTATION = true;
                CompactAllocator.MAX_DEPTH = 256;
                return CompactAllocator;
            }());
            RegionAllocator.CompactAllocator = CompactAllocator;
            var CompactCell = /** @class */ (function (_super) {
                __extends(CompactCell, _super);
                function CompactCell(x, y, w, h, horizontal) {
                    var _this = _super.call(this, x, y, w, h) || this;
                    _this._children = null;
                    _this._horizontal = horizontal;
                    _this.allocated = false;
                    return _this;
                }
                CompactCell.prototype.clear = function () {
                    this._children = null;
                    this.allocated = false;
                };
                CompactCell.prototype.insert = function (w, h) {
                    return this._insert(w, h, 0);
                };
                CompactCell.prototype._insert = function (w, h, depth) {
                    if (depth > CompactAllocator.MAX_DEPTH) {
                        return null;
                    }
                    if (this.allocated) {
                        return null;
                    }
                    if (this.w < w || this.h < h) {
                        return null;
                    }
                    if (!this._children) {
                        var orientation_1 = !this._horizontal;
                        if (CompactAllocator.RANDOM_ORIENTATION) {
                            orientation_1 = Math.random() >= 0.5;
                        }
                        if (this._horizontal) {
                            this._children = [
                                new CompactCell(this.x, this.y, this.w, h, false),
                                new CompactCell(this.x, this.y + h, this.w, this.h - h, orientation_1),
                            ];
                        }
                        else {
                            this._children = [
                                new CompactCell(this.x, this.y, w, this.h, true),
                                new CompactCell(this.x + w, this.y, this.w - w, this.h, orientation_1),
                            ];
                        }
                        var first = this._children[0];
                        if (first.w === w && first.h === h) {
                            first.allocated = true;
                            return first;
                        }
                        return this._insert(w, h, depth + 1);
                    }
                    else {
                        var result = void 0;
                        result = this._children[0]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                        result = this._children[1]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                    }
                    return null;
                };
                return CompactCell;
            }(RegionAllocator.Region));
            /**
             * Simple grid allocator. Starts off with an empty free list and allocates empty cells. Once a cell
             * is freed it's pushed into the free list. It gets poped off the next time a region is allocated.
             */
            var GridAllocator = /** @class */ (function () {
                function GridAllocator(w, h, sizeW, sizeH) {
                    this._columns = w / sizeW | 0;
                    this._rows = h / sizeH | 0;
                    this._sizeW = sizeW;
                    this._sizeH = sizeH;
                    this._freeList = [];
                    this._index = 0;
                    this._total = this._columns * this._rows;
                }
                GridAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var sizeW = this._sizeW;
                    var sizeH = this._sizeH;
                    if (w > sizeW || h > sizeH) {
                        return null;
                    }
                    var freeList = this._freeList;
                    var index = this._index;
                    if (freeList.length > 0) {
                        var cell = freeList.pop();
                        release || assert(cell.allocated === false);
                        cell.w = w;
                        cell.h = h;
                        cell.allocated = true;
                        return cell;
                    }
                    else if (index < this._total) {
                        var y = (index / this._columns) | 0;
                        var x = index - (y * this._columns);
                        var cell = new GridCell(x * sizeW, y * sizeH, w, h);
                        cell.index = index;
                        cell.allocator = this;
                        cell.allocated = true;
                        this._index++;
                        return cell;
                    }
                    return null;
                };
                GridAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.allocated = false;
                    this._freeList.push(cell);
                };
                return GridAllocator;
            }());
            RegionAllocator.GridAllocator = GridAllocator;
            var GridCell = /** @class */ (function (_super) {
                __extends(GridCell, _super);
                function GridCell(x, y, w, h) {
                    var _this = _super.call(this, x, y, w, h) || this;
                    _this.index = -1;
                    return _this;
                }
                return GridCell;
            }(RegionAllocator.Region));
            RegionAllocator.GridCell = GridCell;
            var Bucket = /** @class */ (function () {
                function Bucket(size, region, allocator) {
                    this.size = size;
                    this.region = region;
                    this.allocator = allocator;
                }
                return Bucket;
            }());
            var BucketCell = /** @class */ (function (_super) {
                __extends(BucketCell, _super);
                function BucketCell(x, y, w, h, region) {
                    var _this = _super.call(this, x, y, w, h) || this;
                    _this.region = region;
                    return _this;
                }
                return BucketCell;
            }(RegionAllocator.Region));
            RegionAllocator.BucketCell = BucketCell;
            var BucketAllocator = /** @class */ (function () {
                function BucketAllocator(w, h) {
                    release || assert(w > 0 && h > 0);
                    this._buckets = [];
                    this._w = w | 0;
                    this._h = h | 0;
                    this._filled = 0;
                }
                /**
                 * Finds the first bucket that is large enough to hold the requested region. If no
                 * such bucket exists, then allocates a new bucket if there is room otherwise
                 * returns null;
                 */
                BucketAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var size = Math.max(w, h);
                    if (w > this._w || h > this._h) {
                        // Too big, cannot allocate this.
                        return null;
                    }
                    var region = null;
                    var bucket;
                    var buckets = this._buckets;
                    do {
                        for (var i = 0; i < buckets.length; i++) {
                            if (buckets[i].size >= size) {
                                bucket = buckets[i];
                                region = bucket.allocator.allocate(w, h);
                                if (region) {
                                    break;
                                }
                            }
                        }
                        if (!region) {
                            var remainingSpace = this._h - this._filled;
                            if (remainingSpace < h) {
                                // Couldn't allocate region and there is no more vertical space to allocate
                                // a new bucket that can fit the requested size. So give up.
                                return null;
                            }
                            var gridSize = roundToMultipleOfPowerOfTwo(size, 8);
                            var bucketHeight = gridSize * 2;
                            if (bucketHeight > remainingSpace) {
                                bucketHeight = remainingSpace;
                            }
                            if (bucketHeight < gridSize) {
                                return null;
                            }
                            var bucketRegion = new Rectangle(0, this._filled, this._w, bucketHeight);
                            this._buckets.push(new Bucket(gridSize, bucketRegion, new GridAllocator(bucketRegion.w, bucketRegion.h, gridSize, gridSize)));
                            this._filled += bucketHeight;
                        }
                    } while (!region);
                    return new BucketCell(bucket.region.x + region.x, bucket.region.y + region.y, region.w, region.h, region);
                };
                BucketAllocator.prototype.free = function (region) {
                    region.region.allocator.free(region.region);
                };
                return BucketAllocator;
            }());
            RegionAllocator.BucketAllocator = BucketAllocator;
        })(RegionAllocator = GFX.RegionAllocator || (GFX.RegionAllocator = {}));
        var SurfaceRegionAllocator;
        (function (SurfaceRegionAllocator) {
            var SimpleAllocator = /** @class */ (function () {
                function SimpleAllocator(createSurface) {
                    this._createSurface = createSurface;
                    this._surfaces = [];
                }
                Object.defineProperty(SimpleAllocator.prototype, "surfaces", {
                    get: function () {
                        return this._surfaces;
                    },
                    enumerable: true,
                    configurable: true
                });
                SimpleAllocator.prototype._createNewSurface = function (w, h) {
                    var surface = this._createSurface(w, h);
                    this._surfaces.push(surface);
                    return surface;
                };
                SimpleAllocator.prototype.addSurface = function (surface) {
                    this._surfaces.push(surface);
                };
                SimpleAllocator.prototype.allocate = function (w, h, excludeSurface) {
                    for (var i = 0; i < this._surfaces.length; i++) {
                        var surface = this._surfaces[i];
                        if (surface === excludeSurface) {
                            continue;
                        }
                        var region = surface.allocate(w, h);
                        if (region) {
                            return region;
                        }
                    }
                    return this._createNewSurface(w, h).allocate(w, h);
                };
                SimpleAllocator.prototype.free = function (region) {
                };
                return SimpleAllocator;
            }());
            SurfaceRegionAllocator.SimpleAllocator = SimpleAllocator;
        })(SurfaceRegionAllocator = GFX.SurfaceRegionAllocator || (GFX.SurfaceRegionAllocator = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Rectangle = GFX.Geometry.Rectangle;
        var Matrix = GFX.Geometry.Matrix;
        var DirtyRegion = GFX.Geometry.DirtyRegion;
        var assert = Shumway.Debug.assert;
        var BlendMode;
        (function (BlendMode) {
            BlendMode[BlendMode["Normal"] = 1] = "Normal";
            BlendMode[BlendMode["Layer"] = 2] = "Layer";
            BlendMode[BlendMode["Multiply"] = 3] = "Multiply";
            BlendMode[BlendMode["Screen"] = 4] = "Screen";
            BlendMode[BlendMode["Lighten"] = 5] = "Lighten";
            BlendMode[BlendMode["Darken"] = 6] = "Darken";
            BlendMode[BlendMode["Difference"] = 7] = "Difference";
            BlendMode[BlendMode["Add"] = 8] = "Add";
            BlendMode[BlendMode["Subtract"] = 9] = "Subtract";
            BlendMode[BlendMode["Invert"] = 10] = "Invert";
            BlendMode[BlendMode["Alpha"] = 11] = "Alpha";
            BlendMode[BlendMode["Erase"] = 12] = "Erase";
            BlendMode[BlendMode["Overlay"] = 13] = "Overlay";
            BlendMode[BlendMode["HardLight"] = 14] = "HardLight";
        })(BlendMode = GFX.BlendMode || (GFX.BlendMode = {}));
        var NodeFlags;
        (function (NodeFlags) {
            NodeFlags[NodeFlags["None"] = 0] = "None";
            NodeFlags[NodeFlags["Visible"] = 1] = "Visible";
            NodeFlags[NodeFlags["Transparent"] = 2] = "Transparent";
            /**
             * Whether this node acts as a mask for another node.
             */
            NodeFlags[NodeFlags["IsMask"] = 4] = "IsMask";
            /**
             * Whether this node is marked to be cached as a bitmap. This isn't just a performance optimization,
             * but also affects the way masking is performed.
             */
            NodeFlags[NodeFlags["CacheAsBitmap"] = 16] = "CacheAsBitmap";
            /**
             * Whether this node's contents should be drawn snapped to pixel boundaries.
             * Only relevant for bitmaps.
             */
            NodeFlags[NodeFlags["PixelSnapping"] = 32] = "PixelSnapping";
            /**
             * Whether this node's contents should use higher quality image smoothing.
             * Only relevant for bitmaps.
             */
            NodeFlags[NodeFlags["ImageSmoothing"] = 64] = "ImageSmoothing";
            /**
             * Whether source has dynamic content.
             */
            NodeFlags[NodeFlags["Dynamic"] = 256] = "Dynamic";
            /**
             * Whether the source's content can be scaled and drawn at a higher resolution.
             */
            NodeFlags[NodeFlags["Scalable"] = 512] = "Scalable";
            /**
             * Whether the source's content should be tiled.
             */
            NodeFlags[NodeFlags["Tileable"] = 1024] = "Tileable";
            /**
             * Whether this node's bounding box is automatically computed from its children. If this
             * flag is |false| then this node's bounding box can only be set via |setBounds|.
             */
            NodeFlags[NodeFlags["BoundsAutoCompute"] = 2048] = "BoundsAutoCompute";
            /**
             * Whether this node needs to be repainted.
             */
            NodeFlags[NodeFlags["Dirty"] = 4096] = "Dirty";
            /**
             * Whether this node's bounds is invalid and needs to be recomputed. Only nodes that have the
             * |BoundsAutoCompute| flag set can have this flag set.
             */
            NodeFlags[NodeFlags["InvalidBounds"] = 8192] = "InvalidBounds";
            /**
             * Whether this node's concatenated matrix is invalid. This happens whenever a node's ancestor
             * is moved in the node tree.
             */
            NodeFlags[NodeFlags["InvalidConcatenatedMatrix"] = 16384] = "InvalidConcatenatedMatrix";
            /**
             * Whether this node's inverted concatenated matrix is invalid. This happens whenever a node's ancestor
             * is moved in the node tree.
             */
            NodeFlags[NodeFlags["InvalidInvertedConcatenatedMatrix"] = 32768] = "InvalidInvertedConcatenatedMatrix";
            /**
             * Same as above, but for colors.
             */
            NodeFlags[NodeFlags["InvalidConcatenatedColorMatrix"] = 65536] = "InvalidConcatenatedColorMatrix";
            /**
             * Flags to propagate upwards when a node is added or removed from a group.
             */
            NodeFlags[NodeFlags["UpOnAddedOrRemoved"] = 12288] = "UpOnAddedOrRemoved";
            /**
             * Flags to propagate downwards when a node is added or removed from a group.
             */
            NodeFlags[NodeFlags["DownOnAddedOrRemoved"] = 114688] = "DownOnAddedOrRemoved";
            /**
             * Flags to propagate upwards when a node is moved.
             */
            NodeFlags[NodeFlags["UpOnMoved"] = 12288] = "UpOnMoved";
            /**
             * Flags to propagate downwards when a node is moved.
             */
            NodeFlags[NodeFlags["DownOnMoved"] = 49152] = "DownOnMoved";
            /**
             * Flags to propagate upwards when a node's color matrix is changed.
             */
            NodeFlags[NodeFlags["UpOnColorMatrixChanged"] = 4096] = "UpOnColorMatrixChanged";
            /**
             * Flags to propagate downwards when a node's color matrix is changed.
             */
            NodeFlags[NodeFlags["DownOnColorMatrixChanged"] = 65536] = "DownOnColorMatrixChanged";
            /**
             * Flags to propagate upwards when a node is invalidated.
             */
            NodeFlags[NodeFlags["UpOnInvalidate"] = 12288] = "UpOnInvalidate";
            /**
             * Default node flags, however not all node types use these defaults.
             */
            NodeFlags[NodeFlags["Default"] = 59393] = "Default";
        })(NodeFlags = GFX.NodeFlags || (GFX.NodeFlags = {}));
        /**
         * Scene graph object hierarchy. This enum makes it possible to write fast type checks.
         */
        var NodeType;
        (function (NodeType) {
            NodeType[NodeType["Node"] = 1] = "Node";
            NodeType[NodeType["Shape"] = 3] = "Shape";
            NodeType[NodeType["Group"] = 5] = "Group";
            NodeType[NodeType["Stage"] = 13] = "Stage";
            NodeType[NodeType["Renderable"] = 33] = "Renderable"; // 0x0020 | Node
        })(NodeType = GFX.NodeType || (GFX.NodeType = {}));
        function getNodeTypeName(nodeType) {
            if (nodeType === 1 /* Node */)
                return "Node";
            else if (nodeType === 3 /* Shape */)
                return "Shape";
            else if (nodeType === 5 /* Group */)
                return "Group";
            else if (nodeType === 13 /* Stage */)
                return "Stage";
            else if (nodeType === 33 /* Renderable */)
                return "Renderable";
            return "";
        }
        /**
         * Basic event types. Not much here.
         */
        var NodeEventType;
        (function (NodeEventType) {
            NodeEventType[NodeEventType["None"] = 0] = "None";
            NodeEventType[NodeEventType["OnStageBoundsChanged"] = 1] = "OnStageBoundsChanged";
            NodeEventType[NodeEventType["RemovedFromStage"] = 2] = "RemovedFromStage";
        })(NodeEventType = GFX.NodeEventType || (GFX.NodeEventType = {}));
        /**
         * Basic node visitor. Inherit from this if you want a more sophisticated visitor, for instance all
         * renderers extends this class.
         */
        var NodeVisitor = /** @class */ (function () {
            function NodeVisitor() {
            }
            NodeVisitor.prototype.visitNode = function (node, state) {
                // ...
            };
            NodeVisitor.prototype.visitShape = function (node, state) {
                this.visitNode(node, state);
            };
            NodeVisitor.prototype.visitGroup = function (node, state) {
                this.visitNode(node, state);
                var children = node.getChildren();
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
            };
            NodeVisitor.prototype.visitStage = function (node, state) {
                this.visitGroup(node, state);
            };
            NodeVisitor.prototype.visitRenderable = function (node, state) {
                this.visitNode(node, state);
            };
            return NodeVisitor;
        }());
        GFX.NodeVisitor = NodeVisitor;
        /**
         * Nodes that cache transformation state. These are used to thread state when traversing
         * the scene graph. Since they keep track of rendering state, they might as well become
         * scene graph nodes.
         */
        var State = /** @class */ (function () {
            function State() {
            }
            return State;
        }());
        GFX.State = State;
        var PreRenderState = /** @class */ (function (_super) {
            __extends(PreRenderState, _super);
            function PreRenderState() {
                var _this = _super.call(this) || this;
                _this.depth = 0;
                return _this;
            }
            return PreRenderState;
        }(State));
        GFX.PreRenderState = PreRenderState;
        /**
         * Helper visitor that checks and resets the dirty bit and calculates stack levels. If the root
         * node is dirty, then we have to repaint the entire node tree.
         */
        var PreRenderVisitor = /** @class */ (function (_super) {
            __extends(PreRenderVisitor, _super);
            function PreRenderVisitor() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isDirty = true;
                _this._dirtyRegion = null;
                _this._depth = 0;
                return _this;
            }
            PreRenderVisitor.prototype.start = function (node, dirtyRegion) {
                this._dirtyRegion = dirtyRegion;
                this._depth = 0;
                node.visit(this, null);
            };
            PreRenderVisitor.prototype.visitGroup = function (node, state) {
                var children = node.getChildren();
                this.visitNode(node, state);
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
            };
            PreRenderVisitor.prototype.visitNode = function (node, state) {
                if (node.hasFlags(4096 /* Dirty */)) {
                    this.isDirty = true;
                }
                node.toggleFlags(4096 /* Dirty */, false);
                node.depth = this._depth++;
            };
            return PreRenderVisitor;
        }(NodeVisitor));
        GFX.PreRenderVisitor = PreRenderVisitor;
        /**
         * Debugging visitor.
         */
        var TracingNodeVisitor = /** @class */ (function (_super) {
            __extends(TracingNodeVisitor, _super);
            function TracingNodeVisitor(writer) {
                var _this = _super.call(this) || this;
                _this.writer = writer;
                return _this;
            }
            TracingNodeVisitor.prototype.visitNode = function (node, state) {
                // ...
            };
            TracingNodeVisitor.prototype.visitShape = function (node, state) {
                this.writer.writeLn(node.toString());
                this.visitNode(node, state);
            };
            TracingNodeVisitor.prototype.visitGroup = function (node, state) {
                this.visitNode(node, state);
                var children = node.getChildren();
                this.writer.enter(node.toString() + " " + children.length);
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
                this.writer.outdent();
            };
            TracingNodeVisitor.prototype.visitStage = function (node, state) {
                this.visitGroup(node, state);
            };
            return TracingNodeVisitor;
        }(NodeVisitor));
        GFX.TracingNodeVisitor = TracingNodeVisitor;
        /**
         * Base class of all nodes in the scene graph.
         */
        var Node = /** @class */ (function () {
            function Node() {
                /**
                 * Number of sibillings to clip.
                 */
                this._clip = -1;
                this._eventListeners = null;
                this._id = Node._nextId++;
                this._type = 1 /* Node */;
                this._index = -1;
                this._parent = null;
                this.reset();
            }
            Object.defineProperty(Node.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype._dispatchEvent = function (type) {
                if (!this._eventListeners) {
                    return;
                }
                var listeners = this._eventListeners;
                for (var i = 0; i < listeners.length; i++) {
                    var listener = listeners[i];
                    if (listener.type === type) {
                        listener.listener(this, type);
                    }
                }
            };
            /**
             * Adds an event listener.
             */
            Node.prototype.addEventListener = function (type, listener) {
                if (!this._eventListeners) {
                    this._eventListeners = [];
                }
                this._eventListeners.push({ type: type, listener: listener });
            };
            /**
             * Removes an event listener.
             */
            Node.prototype.removeEventListener = function (type, listener) {
                var listeners = this._eventListeners;
                for (var i = 0; i < listeners.length; i++) {
                    var listenerObject = listeners[i];
                    if (listenerObject.type === type && listenerObject.listener === listener) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            };
            Object.defineProperty(Node.prototype, "properties", {
                get: function () {
                    return this._properties || (this._properties = {});
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Resets the Node to its initial state but preserves its identity.
             * It safe to call this on a child without disrupting ownership.
             */
            Node.prototype.reset = function () {
                this._flags = 59393 /* Default */;
                this._bounds = null;
                this._layer = null;
                this._transform = null;
                this._properties = null;
                this.depth = -1;
            };
            Object.defineProperty(Node.prototype, "clip", {
                get: function () {
                    return this._clip;
                },
                set: function (value) {
                    this._clip = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype.getTransformedBounds = function (target) {
                var bounds = this.getBounds(true);
                if (target === this || bounds.isEmpty()) {
                    // Nop.
                }
                else {
                    var m = this.getTransform().getConcatenatedMatrix();
                    if (target) {
                        var t = target.getTransform().getInvertedConcatenatedMatrix(true);
                        t.preMultiply(m);
                        t.transformRectangleAABB(bounds);
                        t.free();
                    }
                    else {
                        m.transformRectangleAABB(bounds);
                    }
                }
                return bounds;
            };
            Node.prototype._markCurrentBoundsAsDirtyRegion = function () {
                // return;
                var stage = this.getStage();
                if (!stage) {
                    return;
                }
                var bounds = this.getTransformedBounds(stage);
                stage.dirtyRegion.addDirtyRectangle(bounds);
            };
            Node.prototype.getStage = function (withDirtyRegion) {
                if (withDirtyRegion === void 0) { withDirtyRegion = true; }
                var node = this._parent;
                while (node) {
                    if (node.isType(13 /* Stage */)) {
                        var stage = node;
                        if (withDirtyRegion) {
                            if (stage.dirtyRegion) {
                                return stage;
                            }
                        }
                        else {
                            return stage;
                        }
                    }
                    node = node._parent;
                }
                return null;
            };
            /**
             * This shouldn't be used on any hot path becuse it allocates.
             */
            Node.prototype.getChildren = function (clone) {
                if (clone === void 0) { clone = false; }
                throw Shumway.Debug.abstractMethod("Node::getChildren");
            };
            Node.prototype.getBounds = function (clone) {
                if (clone === void 0) { clone = false; }
                throw Shumway.Debug.abstractMethod("Node::getBounds");
            };
            /**
             * Can only be set on nodes without the |NodeFlags.BoundsAutoCompute| flag set.
             */
            Node.prototype.setBounds = function (value) {
                release || assert(!(this._flags & 2048 /* BoundsAutoCompute */));
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                bounds.set(value);
                this.removeFlags(8192 /* InvalidBounds */);
            };
            Node.prototype.clone = function () {
                throw Shumway.Debug.abstractMethod("Node::clone");
            };
            Node.prototype.setFlags = function (flags) {
                this._flags |= flags;
            };
            Node.prototype.hasFlags = function (flags) {
                return (this._flags & flags) === flags;
            };
            Node.prototype.hasAnyFlags = function (flags) {
                return !!(this._flags & flags);
            };
            Node.prototype.removeFlags = function (flags) {
                this._flags &= ~flags;
            };
            Node.prototype.toggleFlags = function (flags, on) {
                if (on) {
                    this._flags |= flags;
                }
                else {
                    this._flags &= ~flags;
                }
            };
            /**
             * Propagates flags up the tree. Propagation stops if all flags are already set.
             */
            Node.prototype._propagateFlagsUp = function (flags) {
                if (flags === 0 /* None */ || this.hasFlags(flags)) {
                    return;
                }
                if (!this.hasFlags(2048 /* BoundsAutoCompute */)) {
                    flags &= ~8192 /* InvalidBounds */;
                }
                this.setFlags(flags);
                var parent = this._parent;
                if (parent) {
                    parent._propagateFlagsUp(flags);
                }
            };
            /**
             * Propagates flags down the tree. Non-containers just set the flags on themselves.
             */
            Node.prototype._propagateFlagsDown = function (flags) {
                throw Shumway.Debug.abstractMethod("Node::_propagateFlagsDown");
            };
            Node.prototype.isAncestor = function (node) {
                while (node) {
                    if (node === this) {
                        return true;
                    }
                    release || assert(node !== node._parent);
                    node = node._parent;
                }
                return false;
            };
            /**
             * Return's a list of ancestors excluding the |last|, the return list is reused.
             */
            Node._getAncestors = function (node, last) {
                var path = Node._path;
                path.length = 0;
                while (node && node !== last) {
                    release || assert(node !== node._parent);
                    path.push(node);
                    node = node._parent;
                }
                release || assert(node === last, "Last ancestor is not an ancestor.");
                return path;
            };
            /**
             * Finds the closest ancestor with a given set of flags that are either turned on or off.
             */
            Node.prototype._findClosestAncestor = function (flags, on) {
                var node = this;
                while (node) {
                    if (node.hasFlags(flags) === on) {
                        return node;
                    }
                    release || assert(node !== node._parent);
                    node = node._parent;
                }
                return null;
            };
            /**
             * Type check.
             */
            Node.prototype.isType = function (type) {
                return this._type === type;
            };
            /**
             * Subtype check.
             */
            Node.prototype.isTypeOf = function (type) {
                return (this._type & type) === type;
            };
            Node.prototype.isLeaf = function () {
                return this.isType(33 /* Renderable */) || this.isType(3 /* Shape */);
            };
            Node.prototype.isLinear = function () {
                if (this.isLeaf()) {
                    return true;
                }
                if (this.isType(5 /* Group */)) {
                    var children = this._children;
                    if (children.length === 1 && children[0].isLinear()) {
                        return true;
                    }
                }
                return false;
            };
            Node.prototype.getTransformMatrix = function (clone) {
                if (clone === void 0) { clone = false; }
                return this.getTransform().getMatrix(clone);
            };
            Node.prototype.getTransform = function () {
                if (this._transform === null) {
                    this._transform = new Transform(this);
                }
                return this._transform;
            };
            Node.prototype.getLayer = function () {
                if (this._layer === null) {
                    this._layer = new Layer(this);
                }
                return this._layer;
            };
            Node.prototype.getLayerBounds = function (includeFilters) {
                var bounds = this.getBounds();
                if (includeFilters && this._layer) {
                    this._layer.expandBounds(bounds);
                }
                return bounds;
            };
            //    public getConcatenatedMatrix(clone: boolean = false): Matrix {
            //      let transform: Transform = this.getTransform(false);
            //      if (transform) {
            //        return transform.getConcatenatedMatrix(clone);
            //      }
            //      return Matrix.createIdentity();
            //    }
            /**
             * Dispatch on node types.
             */
            Node.prototype.visit = function (visitor, state) {
                var thisAny = this;
                switch (this._type) {
                    case 1 /* Node */:
                        visitor.visitNode(this, state);
                        break;
                    case 5 /* Group */:
                        visitor.visitGroup(thisAny, state);
                        break;
                    case 13 /* Stage */:
                        visitor.visitStage(thisAny, state);
                        break;
                    case 3 /* Shape */:
                        visitor.visitShape(thisAny, state);
                        break;
                    case 33 /* Renderable */:
                        visitor.visitRenderable(thisAny, state);
                        break;
                    default:
                        Shumway.Debug.unexpectedCase();
                }
            };
            Node.prototype.invalidate = function () {
                this._markCurrentBoundsAsDirtyRegion();
                this._propagateFlagsUp(12288 /* UpOnInvalidate */);
            };
            Node.prototype.toString = function (bounds) {
                if (bounds === void 0) { bounds = false; }
                var s = getNodeTypeName(this._type) + " " + this._id;
                if (bounds) {
                    s += " " + this._bounds.toString();
                }
                return s;
            };
            /**
             * Temporary array of nodes to avoid allocations.
             */
            Node._path = [];
            /**
             * Used to give nodes unique ids.
             */
            Node._nextId = 0;
            return Node;
        }());
        GFX.Node = Node;
        /**
         * Nodes that contain other nodes.
         */
        var Group = /** @class */ (function (_super) {
            __extends(Group, _super);
            function Group() {
                var _this = _super.call(this) || this;
                _this._type = 5 /* Group */;
                _this._children = [];
                return _this;
            }
            Group.prototype.getChildren = function (clone) {
                if (clone === void 0) { clone = false; }
                if (clone) {
                    return this._children.slice(0);
                }
                return this._children;
            };
            Group.prototype.childAt = function (index) {
                release || assert(index >= 0 && index < this._children.length);
                return this._children[index];
            };
            Object.defineProperty(Group.prototype, "child", {
                get: function () {
                    release || assert(this._children.length === 1);
                    return this._children[0];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Group.prototype, "groupChild", {
                get: function () {
                    release || assert(this._children.length === 1);
                    release || assert(this._children[0] instanceof Group);
                    return this._children[0];
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Adds a node and remove's it from its previous location if it has a parent and propagates
             * flags accordingly.
             */
            Group.prototype.addChild = function (node) {
                release || assert(node);
                release || assert(!node.isAncestor(this));
                if (node._parent) {
                    node._parent.removeChildAt(node._index);
                }
                node._parent = this;
                node._index = this._children.length;
                this._children.push(node);
                this._propagateFlagsUp(12288 /* UpOnAddedOrRemoved */);
                node._propagateFlagsDown(114688 /* DownOnAddedOrRemoved */);
                node._markCurrentBoundsAsDirtyRegion();
            };
            /**
             * Removes a child at the given index and propagates flags accordingly.
             */
            Group.prototype.removeChildAt = function (index) {
                release || assert(index >= 0 && index < this._children.length);
                var node = this._children[index];
                release || assert(index === node._index);
                node._markCurrentBoundsAsDirtyRegion();
                this._children.splice(index, 1);
                node._index = -1;
                node._parent = null;
                this._propagateFlagsUp(12288 /* UpOnAddedOrRemoved */);
                node._propagateFlagsDown(114688 /* DownOnAddedOrRemoved */);
            };
            Group.prototype.clearChildren = function () {
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    child._markCurrentBoundsAsDirtyRegion();
                    if (child) {
                        child._index = -1;
                        child._parent = null;
                        child._propagateFlagsDown(114688 /* DownOnAddedOrRemoved */);
                    }
                }
                this._children.length = 0;
                this._propagateFlagsUp(12288 /* UpOnAddedOrRemoved */);
            };
            /**
             * Override and propagate flags to all children.
             */
            Group.prototype._propagateFlagsDown = function (flags) {
                if (this.hasFlags(flags)) {
                    return;
                }
                this.setFlags(flags);
                var children = this._children;
                for (var i = 0; i < children.length; i++) {
                    children[i]._propagateFlagsDown(flags);
                }
            };
            /**
             * Takes the union of all child bounds and caches the bounds locally.
             */
            Group.prototype.getBounds = function (clone) {
                if (clone === void 0) { clone = false; }
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                if (this.hasFlags(8192 /* InvalidBounds */)) {
                    bounds.setEmpty();
                    var children = this._children;
                    var childBounds = Rectangle.allocate();
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        childBounds.set(child.getBounds());
                        child.getTransformMatrix().transformRectangleAABB(childBounds);
                        bounds.union(childBounds);
                    }
                    childBounds.free();
                    this.removeFlags(8192 /* InvalidBounds */);
                }
                if (clone) {
                    return bounds.clone();
                }
                return bounds;
            };
            /**
             * Takes the union of all child bounds, optionaly including filter expansions.
             */
            Group.prototype.getLayerBounds = function (includeFilters) {
                if (!includeFilters) {
                    return this.getBounds();
                }
                var bounds = Rectangle.createEmpty();
                var children = this._children;
                var childBounds = Rectangle.allocate();
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    childBounds.set(child.getLayerBounds(includeFilters));
                    child.getTransformMatrix().transformRectangleAABB(childBounds);
                    bounds.union(childBounds);
                }
                childBounds.free();
                if (includeFilters && this._layer) {
                    this._layer.expandBounds(bounds);
                }
                return bounds;
            };
            return Group;
        }(Node));
        GFX.Group = Group;
        /**
         * Transform associated with a node. This helps to reduce the size of nodes.
         */
        var Transform = /** @class */ (function () {
            function Transform(node) {
                this._node = node;
                this._matrix = Matrix.createIdentity(); // MEMORY: Lazify construction.
                this._colorMatrix = GFX.ColorMatrix.createIdentity(); // MEMORY: Lazify construction.
                this._concatenatedMatrix = Matrix.createIdentity(); // MEMORY: Lazify construction.
                this._invertedConcatenatedMatrix = Matrix.createIdentity(); // MEMORY: Lazify construction.
                this._concatenatedColorMatrix = GFX.ColorMatrix.createIdentity(); // MEMORY: Lazify construction.
            }
            //    public get x(): number {
            //      return this._matrix.tx;
            //    }
            //
            //    public set x(value: number) {
            //      this._matrix.tx = value;
            //      this._node._propagateFlagsUp(NodeFlags.UpOnMoved);
            //      this._node._propagateFlagsDown(NodeFlags.DownOnMoved);
            //    }
            //
            //    public get y(): number {
            //      return this._matrix.ty;
            //    }
            //
            //    public set y(value: number) {
            //      this._matrix.ty = value;
            //      this._node._propagateFlagsUp(NodeFlags.UpOnMoved);
            //      this._node._propagateFlagsDown(NodeFlags.DownOnMoved);
            //    }
            /**
             * Set a node's transform matrix. You should never mutate the matrix object directly.
             */
            Transform.prototype.setMatrix = function (value) {
                if (this._matrix.isEqual(value)) {
                    return;
                }
                this._node._markCurrentBoundsAsDirtyRegion();
                this._matrix.set(value);
                this._node._propagateFlagsUp(12288 /* UpOnMoved */);
                this._node._propagateFlagsDown(49152 /* DownOnMoved */);
                this._node._markCurrentBoundsAsDirtyRegion();
            };
            Transform.prototype.setColorMatrix = function (value) {
                this._colorMatrix.set(value);
                this._node._propagateFlagsUp(4096 /* UpOnColorMatrixChanged */);
                this._node._propagateFlagsDown(65536 /* DownOnColorMatrixChanged */);
                this._node._markCurrentBoundsAsDirtyRegion();
            };
            Transform.prototype.getMatrix = function (clone) {
                if (clone === void 0) { clone = false; }
                if (clone) {
                    return this._matrix.clone();
                }
                return this._matrix;
            };
            Transform.prototype.hasColorMatrix = function () {
                return this._colorMatrix !== null;
            };
            Transform.prototype.getColorMatrix = function (clone) {
                if (clone === void 0) { clone = false; }
                if (this._colorMatrix === null) {
                    this._colorMatrix = GFX.ColorMatrix.createIdentity();
                }
                if (clone) {
                    return this._colorMatrix.clone();
                }
                return this._colorMatrix;
            };
            /**
             * Compute the concatenated transforms for this node and all of its ancestors since we're already doing
             * all the work.
             */
            Transform.prototype.getConcatenatedMatrix = function (clone) {
                if (clone === void 0) { clone = false; }
                if (this._node.hasFlags(16384 /* InvalidConcatenatedMatrix */)) {
                    var ancestor = this._node._findClosestAncestor(16384 /* InvalidConcatenatedMatrix */, false);
                    var path = Node._getAncestors(this._node, ancestor);
                    var m = ancestor ? ancestor.getTransform()._concatenatedMatrix.clone() : Matrix.createIdentity();
                    for (var i = path.length - 1; i >= 0; i--) {
                        var ancestor_1 = path[i];
                        var ancestorTransform = ancestor_1.getTransform();
                        release || assert(ancestor_1.hasFlags(16384 /* InvalidConcatenatedMatrix */));
                        m.preMultiply(ancestorTransform._matrix);
                        ancestorTransform._concatenatedMatrix.set(m);
                        ancestor_1.removeFlags(16384 /* InvalidConcatenatedMatrix */);
                    }
                }
                if (clone) {
                    return this._concatenatedMatrix.clone();
                }
                return this._concatenatedMatrix;
            };
            Transform.prototype.getInvertedConcatenatedMatrix = function (clone) {
                if (clone === void 0) { clone = false; }
                if (this._node.hasFlags(32768 /* InvalidInvertedConcatenatedMatrix */)) {
                    this.getConcatenatedMatrix().inverse(this._invertedConcatenatedMatrix);
                    this._node.removeFlags(32768 /* InvalidInvertedConcatenatedMatrix */);
                }
                if (clone) {
                    return this._invertedConcatenatedMatrix.clone();
                }
                return this._invertedConcatenatedMatrix;
            };
            //    public getConcatenatedColorMatrix(clone: boolean = false): ColorMatrix {
            //      // Compute the concatenated color transforms for this node and all of its ancestors.
            //      if (this.hasFlags(NodeFlags.InvalidConcatenatedColorMatrix)) {
            //        let ancestor = <Transform>this._findClosestAncestor(NodeFlags.InvalidConcatenatedColorMatrix, false);
            //        let path = <Transform []>Node._getAncestors(this, ancestor, NodeType.Transform);
            //        let m = ancestor ? ancestor._concatenatedColorMatrix.clone() : ColorMatrix.createIdentity();
            //        for (let i = path.length - 1; i >= 0; i--) {
            //          let ancestor = path[i];
            //          release || assert (ancestor.hasFlags(NodeFlags.InvalidConcatenatedColorMatrix));
            //          // TODO: Premultiply here.
            //          m.multiply(ancestor._colorMatrix);
            //          ancestor._concatenatedColorMatrix.set(m);
            //          ancestor.removeFlags(NodeFlags.InvalidConcatenatedColorMatrix);
            //        }
            //      }
            //      if (clone) {
            //        return this._concatenatedColorMatrix.clone();
            //      }
            //      return this._concatenatedColorMatrix;
            //    }
            Transform.prototype.toString = function () {
                return this._matrix.toString();
            };
            return Transform;
        }());
        GFX.Transform = Transform;
        /**
         * Layer information associated with a node. This helps to reduce the size of nodes.
         */
        var Layer = /** @class */ (function () {
            function Layer(node) {
                this._node = node;
                this._mask = null;
                this._blendMode = BlendMode.Normal;
            }
            Object.defineProperty(Layer.prototype, "filters", {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this._filters = value;
                    if (value.length) {
                        // TODO: We could avoid invalidating the node if the new filter list contains equal filter objects.
                        this._node.invalidate();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Layer.prototype, "blendMode", {
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    this._blendMode = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Layer.prototype, "mask", {
                get: function () {
                    return this._mask;
                },
                set: function (value) {
                    if (this._mask !== value) {
                        this._node.invalidate();
                        if (this._mask) {
                            this._mask.removeFlags(4 /* IsMask */);
                        }
                    }
                    this._mask = value;
                    if (this._mask) {
                        this._mask.setFlags(4 /* IsMask */);
                    }
                    // TODO: Keep track of masked object so we can propagate flags up.
                },
                enumerable: true,
                configurable: true
            });
            Layer.prototype.toString = function () {
                return BlendMode[this._blendMode];
            };
            Layer.prototype.expandBounds = function (bounds) {
                var filters = this._filters;
                if (filters) {
                    for (var i = 0; i < filters.length; i++) {
                        filters[i].expandBounds(bounds);
                    }
                }
            };
            return Layer;
        }());
        GFX.Layer = Layer;
        /**
         * Shapes are instantiations of Renderables.
         */
        var Shape = /** @class */ (function (_super) {
            __extends(Shape, _super);
            function Shape(source) {
                var _this = _super.call(this) || this;
                release || assert(source);
                _this._source = source;
                _this._type = 3 /* Shape */;
                _this._ratio = 0;
                return _this;
            }
            Shape.prototype.getBounds = function (clone) {
                if (clone === void 0) { clone = false; }
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                if (this.hasFlags(8192 /* InvalidBounds */)) {
                    bounds.set(this._source.getBounds());
                    this.removeFlags(8192 /* InvalidBounds */);
                }
                if (clone) {
                    return bounds.clone();
                }
                return bounds;
            };
            Object.defineProperty(Shape.prototype, "source", {
                get: function () {
                    return this._source;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Shape.prototype, "ratio", {
                get: function () {
                    return this._ratio;
                },
                set: function (value) {
                    if (value === this._ratio) {
                        return;
                    }
                    this.invalidate();
                    this._ratio = value;
                },
                enumerable: true,
                configurable: true
            });
            Shape.prototype._propagateFlagsDown = function (flags) {
                this.setFlags(flags);
            };
            Shape.prototype.getChildren = function (clone) {
                if (clone === void 0) { clone = false; }
                return [this._source];
            };
            return Shape;
        }(Node));
        GFX.Shape = Shape;
        function getRandomIntInclusive(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        var RendererOptions = /** @class */ (function () {
            function RendererOptions() {
                this.debug = false;
                this.paintRenderable = true;
                this.paintBounds = false;
                this.paintDirtyRegion = false;
                this.paintFlashing = false;
                this.paintViewport = false;
                this.clear = true;
            }
            return RendererOptions;
        }());
        GFX.RendererOptions = RendererOptions;
        var Backend;
        (function (Backend) {
            Backend[Backend["Canvas2D"] = 0] = "Canvas2D";
            Backend[Backend["WebGL"] = 1] = "WebGL";
            Backend[Backend["Both"] = 2] = "Both";
            Backend[Backend["DOM"] = 3] = "DOM";
            Backend[Backend["SVG"] = 4] = "SVG"; // Someday
        })(Backend = GFX.Backend || (GFX.Backend = {}));
        /**
         * Base class for all renderers.
         */
        var Renderer = /** @class */ (function (_super) {
            __extends(Renderer, _super);
            function Renderer(container, stage, options) {
                var _this = _super.call(this) || this;
                _this._container = container;
                _this._stage = stage;
                _this._options = options;
                _this._viewport = Rectangle.createSquare(1024);
                _this._devicePixelRatio = 1;
                return _this;
            }
            Object.defineProperty(Renderer.prototype, "viewport", {
                set: function (viewport) {
                    this._viewport.set(viewport);
                },
                enumerable: true,
                configurable: true
            });
            Renderer.prototype.render = function () {
                throw Shumway.Debug.abstractMethod("Renderer::render");
            };
            /**
             * Notify renderer that the viewport has changed.
             */
            Renderer.prototype.resize = function () {
                throw Shumway.Debug.abstractMethod("Renderer::resize");
            };
            /**
             * Captures a rectangular region of the easel as a dataURL as specified by |bounds|. |stageContent| indicates if the bounds
             * should be computed by looking at the bounds of the content of the easel rather than the easel itself.
             */
            Renderer.prototype.screenShot = function (bounds, stageContent, disableHidpi) {
                throw Shumway.Debug.abstractMethod("Renderer::screenShot");
            };
            return Renderer;
        }(NodeVisitor));
        GFX.Renderer = Renderer;
        /**
         * Node container that handles Flash style alignment and scale modes.
         */
        var Stage = /** @class */ (function (_super) {
            __extends(Stage, _super);
            function Stage(w, h, trackDirtyRegion) {
                if (trackDirtyRegion === void 0) { trackDirtyRegion = false; }
                var _this = _super.call(this) || this;
                _this._preVisitor = new PreRenderVisitor();
                _this._flags &= ~2048 /* BoundsAutoCompute */;
                _this._type = 13 /* Stage */;
                _this._scaleMode = Stage.DEFAULT_SCALE;
                _this._align = Stage.DEFAULT_ALIGN;
                _this._content = new Group();
                _this._content._flags &= ~2048 /* BoundsAutoCompute */;
                _this.addChild(_this._content);
                _this.setFlags(4096 /* Dirty */);
                _this.setBounds(new Rectangle(0, 0, w, h));
                if (trackDirtyRegion) {
                    _this._dirtyRegion = new DirtyRegion(w, h);
                    _this._dirtyRegion.addDirtyRectangle(new Rectangle(0, 0, w, h));
                }
                else {
                    _this._dirtyRegion = null;
                }
                _this._updateContentMatrix();
                return _this;
            }
            Object.defineProperty(Stage.prototype, "dirtyRegion", {
                get: function () {
                    return this._dirtyRegion;
                },
                enumerable: true,
                configurable: true
            });
            Stage.prototype.setBounds = function (value) {
                _super.prototype.setBounds.call(this, value);
                this._updateContentMatrix();
                this._dispatchEvent(1 /* OnStageBoundsChanged */);
                if (this._dirtyRegion) {
                    this._dirtyRegion = new DirtyRegion(value.w, value.h);
                    this._dirtyRegion.addDirtyRectangle(value);
                }
            };
            Object.defineProperty(Stage.prototype, "content", {
                get: function () {
                    return this._content;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Checks to see if we should render and if so, clears any relevant dirty flags. Returns
             * true if rendering should commence. Flag clearing is made optional here in case there
             * is any code that needs to check if rendering is about to happen.
             */
            Stage.prototype.readyToRender = function () {
                this._preVisitor.isDirty = false;
                this._preVisitor.start(this, this._dirtyRegion);
                if (this._preVisitor.isDirty) {
                    return true;
                }
                return false;
            };
            Object.defineProperty(Stage.prototype, "align", {
                get: function () {
                    return this._align;
                },
                set: function (value) {
                    this._align = value;
                    this._updateContentMatrix();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Stage.prototype, "scaleMode", {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    this._scaleMode = value;
                    this._updateContentMatrix();
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Figure out what the content transform shuold be given the current align and scale modes.
             */
            Stage.prototype._updateContentMatrix = function () {
                if (this._scaleMode === Stage.DEFAULT_SCALE && this._align === Stage.DEFAULT_ALIGN) {
                    // Shortcut and also guard to avoid using targetWidth/targetHeight.
                    // ThetargetWidth/targetHeight normally set in setScaleAndAlign call.
                    this._content.getTransform().setMatrix(new Matrix(1, 0, 0, 1, 0, 0));
                    return;
                }
                var bounds = this.getBounds();
                var contentBounds = this._content.getBounds();
                // Debug.assert(this.targetWidth > 0 && this.targetHeight > 0);
                var wScale = bounds.w / contentBounds.w;
                var hScale = bounds.h / contentBounds.h;
                var scaleX, scaleY;
                switch (this._scaleMode) {
                    case 2 /* NoBorder */:
                        scaleX = scaleY = Math.max(wScale, hScale);
                        break;
                    case 4 /* NoScale */:
                        scaleX = scaleY = 1;
                        break;
                    case 1 /* ExactFit */:
                        scaleX = wScale;
                        scaleY = hScale;
                        break;
                    // case StageScaleMode.ShowAll:
                    default:
                        scaleX = scaleY = Math.min(wScale, hScale);
                        break;
                }
                var offsetX;
                if ((this._align & 4 /* Left */)) {
                    offsetX = 0;
                }
                else if ((this._align & 8 /* Right */)) {
                    offsetX = bounds.w - contentBounds.w * scaleX;
                }
                else {
                    offsetX = (bounds.w - contentBounds.w * scaleX) / 2;
                }
                var offsetY;
                if ((this._align & 1 /* Top */)) {
                    offsetY = 0;
                }
                else if ((this._align & 2 /* Bottom */)) {
                    offsetY = bounds.h - contentBounds.h * scaleY;
                }
                else {
                    offsetY = (bounds.h - contentBounds.h * scaleY) / 2;
                }
                this._content.getTransform().setMatrix(new Matrix(scaleX, 0, 0, scaleY, offsetX, offsetY));
            };
            // Using these constants initially -- they don't require knowing bounds.
            // Notice that this default values are different from ActionScript object values.
            Stage.DEFAULT_SCALE = 4 /* NoScale */;
            Stage.DEFAULT_ALIGN = 4 /* Left */ | 1 /* Top */;
            return Stage;
        }(Group));
        GFX.Stage = Stage;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Point = GFX.Geometry.Point;
        var Rectangle = GFX.Geometry.Rectangle;
        var Matrix = GFX.Geometry.Matrix;
        var assertUnreachable = Shumway.Debug.assertUnreachable;
        var assert = Shumway.Debug.assert;
        var indexOf = Shumway.ArrayUtilities.indexOf;
        /**
         * Represents some source renderable content.
         */
        var Renderable = /** @class */ (function (_super) {
            __extends(Renderable, _super);
            function Renderable() {
                var _this = _super.call(this) || this;
                /**
                 * Back reference to nodes that use this renderable.
                 */
                _this._parents = [];
                /**
                 * Back reference to renderables that use this renderable.
                 */
                _this._renderableParents = [];
                _this._invalidateEventListeners = null;
                _this._flags &= ~2048 /* BoundsAutoCompute */;
                _this._type = 33 /* Renderable */;
                return _this;
            }
            Object.defineProperty(Renderable.prototype, "parents", {
                get: function () {
                    return this._parents;
                },
                enumerable: true,
                configurable: true
            });
            Renderable.prototype.addParent = function (frame) {
                release || assert(frame);
                var index = indexOf(this._parents, frame);
                release || assert(index < 0);
                this._parents.push(frame);
            };
            /**
             * Checks if this node will be reached by the renderer.
             */
            Renderable.prototype.willRender = function () {
                var parents = this._parents;
                for (var i = 0; i < parents.length; i++) {
                    var node = parents[i];
                    while (node) {
                        if (node.isType(13 /* Stage */)) {
                            return true;
                        }
                        if (!node.hasFlags(1 /* Visible */)) {
                            break;
                        }
                        node = node._parent;
                    }
                }
                return false;
            };
            Renderable.prototype.addRenderableParent = function (renderable) {
                release || assert(renderable);
                release || assert(this._renderableParents.indexOf(renderable) === -1);
                this._renderableParents.push(renderable);
            };
            /**
             * Returns the first unrooted parent or creates a new parent if none was found.
             */
            Renderable.prototype.wrap = function () {
                var node;
                var parents = this._parents;
                for (var i = 0; i < parents.length; i++) {
                    node = parents[i];
                    if (!node._parent) {
                        return node;
                    }
                }
                node = new GFX.Shape(this);
                this.addParent(node);
                return node;
            };
            Renderable.prototype.invalidate = function () {
                this.setFlags(4096 /* Dirty */);
                var nodes = this._parents;
                for (var i = 0; i < nodes.length; i++) {
                    nodes[i].invalidate();
                }
                var renderables = this._renderableParents;
                for (var i = 0; i < renderables.length; i++) {
                    renderables[i].invalidate();
                }
                var listeners = this._invalidateEventListeners;
                if (listeners) {
                    for (var i = 0; i < listeners.length; i++) {
                        listeners[i](this);
                    }
                }
            };
            Renderable.prototype.addInvalidateEventListener = function (listener) {
                if (!this._invalidateEventListeners) {
                    this._invalidateEventListeners = [];
                }
                var index = indexOf(this._invalidateEventListeners, listener);
                release || assert(index < 0);
                this._invalidateEventListeners.push(listener);
            };
            Renderable.prototype.getBounds = function (clone) {
                if (clone === void 0) { clone = false; }
                if (clone) {
                    return this._bounds.clone();
                }
                return this._bounds;
            };
            Renderable.prototype.getChildren = function (clone) {
                if (clone === void 0) { clone = false; }
                return null;
            };
            Renderable.prototype._propagateFlagsUp = function (flags) {
                if (flags === 0 /* None */ || this.hasFlags(flags)) {
                    return;
                }
                for (var i = 0; i < this._parents.length; i++) {
                    this._parents[i]._propagateFlagsUp(flags);
                }
            };
            /**
             * Render source content in the specified |context| or add one or more paths to |clipPath| if specified.
             * If specified, the rectangular |cullBounds| can be used to cull parts of the shape for better performance.
             * If |paintStencil| is |true| then we must not create any alpha values, and also not paint any strokes.
             */
            Renderable.prototype.render = function (context, ratio, cullBounds, clipPath, paintStencil) {
            };
            return Renderable;
        }(GFX.Node));
        GFX.Renderable = Renderable;
        var CustomRenderable = /** @class */ (function (_super) {
            __extends(CustomRenderable, _super);
            function CustomRenderable(bounds, render) {
                var _this = _super.call(this) || this;
                _this.setBounds(bounds);
                _this.render = render;
                return _this;
            }
            return CustomRenderable;
        }(Renderable));
        GFX.CustomRenderable = CustomRenderable;
        var RenderableVideoState;
        (function (RenderableVideoState) {
            RenderableVideoState[RenderableVideoState["Idle"] = 1] = "Idle";
            RenderableVideoState[RenderableVideoState["Playing"] = 2] = "Playing";
            RenderableVideoState[RenderableVideoState["Paused"] = 3] = "Paused";
            RenderableVideoState[RenderableVideoState["Ended"] = 4] = "Ended";
        })(RenderableVideoState = GFX.RenderableVideoState || (GFX.RenderableVideoState = {}));
        var RenderableVideo = /** @class */ (function (_super) {
            __extends(RenderableVideo, _super);
            function RenderableVideo(assetId, eventSerializer) {
                var _this = _super.call(this) || this;
                _this._flags = 256 /* Dynamic */ | 4096 /* Dirty */;
                _this._lastTimeInvalidated = 0;
                _this._lastPausedTime = 0;
                _this._seekHappening = false;
                _this._pauseHappening = false;
                _this._isDOMElement = true;
                _this.setBounds(new Rectangle(0, 0, 1, 1));
                _this._assetId = assetId;
                _this._eventSerializer = eventSerializer;
                var element = document.createElement('video');
                var elementEventHandler = _this._handleVideoEvent.bind(_this);
                element.preload = 'metadata'; // for mobile devices
                element.addEventListener("play", elementEventHandler);
                element.addEventListener("pause", elementEventHandler);
                element.addEventListener("ended", elementEventHandler);
                element.addEventListener("loadeddata", elementEventHandler);
                element.addEventListener("progress", elementEventHandler);
                element.addEventListener("suspend", elementEventHandler);
                element.addEventListener("loadedmetadata", elementEventHandler);
                element.addEventListener("error", elementEventHandler);
                element.addEventListener("seeking", elementEventHandler);
                element.addEventListener("seeked", elementEventHandler);
                element.addEventListener("canplay", elementEventHandler);
                element.style.position = 'absolute';
                _this._video = element;
                _this._videoEventHandler = elementEventHandler;
                RenderableVideo._renderableVideos.push(_this);
                if (typeof registerInspectorAsset !== "undefined") {
                    registerInspectorAsset(-1, -1, _this);
                }
                _this._state = 1 /* Idle */;
                return _this;
            }
            Object.defineProperty(RenderableVideo.prototype, "video", {
                get: function () {
                    return this._video;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableVideo.prototype, "state", {
                get: function () {
                    return this._state;
                },
                enumerable: true,
                configurable: true
            });
            RenderableVideo.prototype.play = function () {
                this._state = 2 /* Playing */;
                this._video.play();
            };
            RenderableVideo.prototype.pause = function () {
                this._state = 3 /* Paused */;
                this._video.pause();
            };
            RenderableVideo.prototype._handleVideoEvent = function (evt) {
                var type;
                var data = null;
                var element = this._video;
                switch (evt.type) {
                    case "play":
                        if (!this._pauseHappening) {
                            return;
                        }
                        type = 7 /* Unpause */;
                        break;
                    case "pause":
                        if (this._state === 2 /* Playing */) {
                            element.play();
                            return;
                        }
                        type = 6 /* Pause */;
                        this._pauseHappening = true;
                        break;
                    case "ended":
                        this._state = 4 /* Ended */;
                        this._notifyNetStream(3 /* PlayStop */, data);
                        type = 4 /* BufferEmpty */;
                        break;
                    case "loadeddata":
                        this._pauseHappening = false;
                        this._notifyNetStream(2 /* PlayStart */, data);
                        this.play();
                        return;
                    case "canplay":
                        if (this._pauseHappening) {
                            return;
                        }
                        type = 5 /* BufferFull */;
                        break;
                    case "progress":
                        type = 10 /* Progress */;
                        break;
                    case "suspend":
                        //          type = VideoPlaybackEvent.BufferEmpty;
                        //          break;
                        return;
                    case "loadedmetadata":
                        type = 1 /* Metadata */;
                        data = {
                            videoWidth: element.videoWidth,
                            videoHeight: element.videoHeight,
                            duration: element.duration
                        };
                        break;
                    case "error":
                        type = 11 /* Error */;
                        data = {
                            code: element.error.code
                        };
                        break;
                    case "seeking":
                        if (!this._seekHappening) {
                            return;
                        }
                        type = 8 /* Seeking */;
                        break;
                    case "seeked":
                        if (!this._seekHappening) {
                            return;
                        }
                        type = 9 /* Seeked */;
                        this._seekHappening = false;
                        break;
                    default:
                        return; // unhandled event
                }
                this._notifyNetStream(type, data);
            };
            RenderableVideo.prototype._notifyNetStream = function (eventType, data) {
                this._eventSerializer.sendVideoPlaybackEvent(this._assetId, eventType, data);
            };
            RenderableVideo.prototype.processControlRequest = function (type, data) {
                var videoElement = this._video;
                var ESTIMATED_VIDEO_SECOND_SIZE = 500;
                switch (type) {
                    case 1 /* Init */:
                        videoElement.src = data.url;
                        this.play();
                        this._notifyNetStream(0 /* Initialized */, null);
                        break;
                    case 9 /* EnsurePlaying */:
                        if (videoElement.paused) {
                            videoElement.play();
                        }
                        break;
                    case 2 /* Pause */:
                        if (videoElement) {
                            if (data.paused && !videoElement.paused) {
                                if (!isNaN(data.time)) {
                                    if (videoElement.seekable.length !== 0) {
                                        videoElement.currentTime = data.time;
                                    }
                                    this._lastPausedTime = data.time;
                                }
                                else {
                                    this._lastPausedTime = videoElement.currentTime;
                                }
                                this.pause();
                            }
                            else if (!data.paused && videoElement.paused) {
                                this.play();
                                if (!isNaN(data.time) && this._lastPausedTime !== data.time && videoElement.seekable.length !== 0) {
                                    videoElement.currentTime = data.time;
                                }
                            }
                        }
                        return;
                    case 3 /* Seek */:
                        if (videoElement && videoElement.seekable.length !== 0) {
                            this._seekHappening = true;
                            videoElement.currentTime = data.time;
                        }
                        return;
                    case 4 /* GetTime */:
                        return videoElement ? videoElement.currentTime : 0;
                    case 5 /* GetBufferLength */:
                        return videoElement ? videoElement.duration : 0;
                    case 6 /* SetSoundLevels */:
                        if (videoElement) {
                            videoElement.volume = data.volume;
                        }
                        return;
                    case 7 /* GetBytesLoaded */:
                        if (!videoElement) {
                            return 0;
                        }
                        var bufferedTill = -1;
                        if (videoElement.buffered) {
                            for (var i = 0; i < videoElement.buffered.length; i++) {
                                bufferedTill = Math.max(bufferedTill, videoElement.buffered.end(i));
                            }
                        }
                        else {
                            bufferedTill = videoElement.duration;
                        }
                        return Math.round(bufferedTill * ESTIMATED_VIDEO_SECOND_SIZE);
                    case 8 /* GetBytesTotal */:
                        return videoElement ? Math.round(videoElement.duration * ESTIMATED_VIDEO_SECOND_SIZE) : 0;
                }
            };
            RenderableVideo.prototype.checkForUpdate = function () {
                if (this._lastTimeInvalidated !== this._video.currentTime) {
                    // Videos composited using DOM elements don't need to invalidate parents.
                    if (!this._isDOMElement) {
                        this.invalidate();
                    }
                }
                this._lastTimeInvalidated = this._video.currentTime;
            };
            RenderableVideo.checkForVideoUpdates = function () {
                var renderables = RenderableVideo._renderableVideos;
                for (var i = 0; i < renderables.length; i++) {
                    var renderable = renderables[i];
                    // Check if the node will be reached by the renderer.
                    if (renderable.willRender()) {
                        // If the nodes video element isn't already on the video layer, mark the node as invalid to
                        // make sure the video element will be added the next time the renderer reaches it.
                        if (!renderable._video.parentElement) {
                            renderable.invalidate();
                        }
                        renderable._video.style.zIndex = renderable.parents[0].depth + '';
                    }
                    else if (renderable._video.parentElement) {
                        // The nodes video element should be removed if no longer visible.
                        renderable._dispatchEvent(2 /* RemovedFromStage */);
                    }
                    renderables[i].checkForUpdate();
                }
            };
            RenderableVideo.prototype.render = function (context, ratio, cullBounds) {
                GFX.enterTimeline("RenderableVideo.render");
                var videoElement = this._video;
                if (videoElement && videoElement.videoWidth > 0) {
                    context.drawImage(videoElement, 0, 0, videoElement.videoWidth, videoElement.videoHeight, 0, 0, this._bounds.w, this._bounds.h);
                }
                GFX.leaveTimeline("RenderableVideo.render");
            };
            RenderableVideo._renderableVideos = [];
            return RenderableVideo;
        }(Renderable));
        GFX.RenderableVideo = RenderableVideo;
        var RenderableBitmap = /** @class */ (function (_super) {
            __extends(RenderableBitmap, _super);
            function RenderableBitmap(source /* HTMLImageElement | HTMLCanvasElement */, bounds) {
                var _this = _super.call(this) || this;
                _this._flags = 256 /* Dynamic */ | 4096 /* Dirty */;
                _this.setBounds(bounds);
                if (source instanceof HTMLCanvasElement) {
                    _this._initializeSourceCanvas(source);
                }
                else {
                    _this._sourceImage = source;
                }
                return _this;
            }
            RenderableBitmap.FromDataBuffer = function (type, dataBuffer, bounds) {
                GFX.enterTimeline("RenderableBitmap.FromDataBuffer");
                var canvas = document.createElement("canvas");
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.updateFromDataBuffer(type, dataBuffer);
                GFX.leaveTimeline("RenderableBitmap.FromDataBuffer");
                return renderableBitmap;
            };
            RenderableBitmap.FromNode = function (source, matrix, colorMatrix, blendMode, clipRect) {
                GFX.enterTimeline("RenderableBitmap.FromFrame");
                var canvas = document.createElement("canvas");
                var bounds = source.getBounds();
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.drawNode(source, matrix, colorMatrix, blendMode, clipRect);
                GFX.leaveTimeline("RenderableBitmap.FromFrame");
                return renderableBitmap;
            };
            /**
             * Returns a RenderableBitmap from an Image element, which it uses as its source.
             *
             * Takes `width` and `height` as arguments so it can deal with non-decoded images,
             * which will only get their data after asynchronous decoding has completed.
             */
            RenderableBitmap.FromImage = function (image, width, height) {
                return new RenderableBitmap(image, new Rectangle(0, 0, width, height));
            };
            RenderableBitmap.prototype.updateFromDataBuffer = function (type, dataBuffer) {
                if (!GFX.imageUpdateOption.value) {
                    return;
                }
                var buffer = dataBuffer.buffer;
                GFX.enterTimeline("RenderableBitmap.updateFromDataBuffer", { length: dataBuffer.length });
                if (type === Shumway.ImageType.JPEG || type === Shumway.ImageType.PNG || type === Shumway.ImageType.GIF) {
                    release || Shumway.Debug.assertUnreachable("Mustn't encounter un-decoded images here");
                }
                else {
                    var bounds = this._bounds;
                    var imageData = this._imageData;
                    if (!imageData || imageData.width !== bounds.w || imageData.height !== bounds.h) {
                        imageData = this._imageData = this._context.createImageData(bounds.w, bounds.h);
                    }
                    if (GFX.imageConvertOption.value) {
                        GFX.enterTimeline("ColorUtilities.convertImage");
                        var pixels = new Int32Array(buffer);
                        var out = new Int32Array(imageData.data.buffer);
                        Shumway.ColorUtilities.convertImage(type, Shumway.ImageType.StraightAlphaRGBA, pixels, out);
                        GFX.leaveTimeline("ColorUtilities.convertImage");
                    }
                    GFX.enterTimeline("putImageData");
                    this._ensureSourceCanvas();
                    this._context.putImageData(imageData, 0, 0);
                    GFX.leaveTimeline("putImageData");
                }
                this.invalidate();
                GFX.leaveTimeline("RenderableBitmap.updateFromDataBuffer");
            };
            /**
             * Writes the image data into the given |output| data buffer.
             */
            RenderableBitmap.prototype.readImageData = function (output) {
                output.writeRawBytes(this.imageData.data);
            };
            RenderableBitmap.prototype.render = function (context, ratio, cullBounds) {
                GFX.enterTimeline("RenderableBitmap.render");
                if (this.renderSource) {
                    context.drawImage(this.renderSource, 0, 0);
                }
                else {
                    this._renderFallback(context);
                }
                GFX.leaveTimeline("RenderableBitmap.render");
            };
            RenderableBitmap.prototype.drawNode = function (source, matrix, colorMatrix, blendMode, clip) {
                // TODO: Support colorMatrix and blendMode.
                GFX.enterTimeline("RenderableBitmap.drawFrame");
                // TODO: Hack to be able to compile this as part of gfx-base.
                var Canvas2D = GFX.Canvas2D;
                var bounds = this.getBounds();
                // TODO: don't create a new renderer every time.
                var renderer = new Canvas2D.Canvas2DRenderer(this._canvas, null);
                renderer.renderNode(source, clip || bounds, matrix);
                GFX.leaveTimeline("RenderableBitmap.drawFrame");
            };
            RenderableBitmap.prototype.mask = function (alphaValues) {
                var imageData = this.imageData;
                var pixels = new Int32Array(imageData.data.buffer);
                var T = Shumway.ColorUtilities.getUnpremultiplyTable();
                for (var i = 0; i < alphaValues.length; i++) {
                    var a = alphaValues[i];
                    if (a === 0) {
                        pixels[i] = 0;
                        continue;
                    }
                    if (a === 0xff) {
                        continue;
                    }
                    var pixel = pixels[i];
                    var r = (pixel >> 0) & 0xff;
                    var g = (pixel >> 8) & 0xff;
                    var b = (pixel >> 16) & 0xff;
                    var o = a << 8;
                    r = T[o + Math.min(r, a)];
                    g = T[o + Math.min(g, a)];
                    b = T[o + Math.min(b, a)];
                    pixels[i] = a << 24 | b << 16 | g << 8 | r;
                }
                this._context.putImageData(imageData, 0, 0);
            };
            RenderableBitmap.prototype._initializeSourceCanvas = function (source) {
                this._canvas = source;
                this._context = this._canvas.getContext("2d");
            };
            RenderableBitmap.prototype._ensureSourceCanvas = function () {
                if (this._canvas) {
                    return;
                }
                var canvas = document.createElement("canvas");
                var bounds = this._bounds;
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                this._initializeSourceCanvas(canvas);
            };
            Object.defineProperty(RenderableBitmap.prototype, "imageData", {
                get: function () {
                    if (!this._canvas) {
                        release || assert(this._sourceImage);
                        this._ensureSourceCanvas();
                        this._context.drawImage(this._sourceImage, 0, 0);
                        this._sourceImage = null;
                    }
                    return this._context.getImageData(0, 0, this._bounds.w, this._bounds.h);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableBitmap.prototype, "renderSource", {
                get: function () {
                    return this._canvas || this._sourceImage;
                },
                enumerable: true,
                configurable: true
            });
            RenderableBitmap.prototype._renderFallback = function (context) {
                // Only render fallback in debug mode.
                if (release) {
                    return;
                }
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                context.restore();
            };
            return RenderableBitmap;
        }(Renderable));
        GFX.RenderableBitmap = RenderableBitmap;
        var PathType;
        (function (PathType) {
            PathType[PathType["Fill"] = 0] = "Fill";
            PathType[PathType["Stroke"] = 1] = "Stroke";
            PathType[PathType["StrokeFill"] = 2] = "StrokeFill"; /* Doesn't define thickness, caps and joints. */
        })(PathType = GFX.PathType || (GFX.PathType = {}));
        var StyledPath = /** @class */ (function () {
            function StyledPath(type, style, smoothImage, strokeProperties) {
                this.type = type;
                this.style = style;
                this.smoothImage = smoothImage;
                this.strokeProperties = strokeProperties;
                this.path = new Path2D();
                release || assert((type === 1 /* Stroke */ ||
                    type === 2 /* StrokeFill */) === !!strokeProperties);
            }
            return StyledPath;
        }());
        GFX.StyledPath = StyledPath;
        var StrokeProperties = /** @class */ (function () {
            function StrokeProperties(thickness, scaleMode, capsStyle, jointsStyle, miterLimit) {
                this.thickness = thickness;
                this.scaleMode = scaleMode;
                this.capsStyle = capsStyle;
                this.jointsStyle = jointsStyle;
                this.miterLimit = miterLimit;
            }
            return StrokeProperties;
        }());
        GFX.StrokeProperties = StrokeProperties;
        function morph(start, end, ratio) {
            return start + (end - start) * ratio;
        }
        function morphColor(start, end, ratio) {
            return morph(start >> 24 & 0xff, end >> 24 & 0xff, ratio) << 24 |
                morph(start >> 16 & 0xff, end >> 16 & 0xff, ratio) << 16 |
                morph(start >> 8 & 0xff, end >> 8 & 0xff, ratio) << 8 |
                morph(start & 0xff, end & 0xff, ratio);
        }
        var RenderableShape = /** @class */ (function (_super) {
            __extends(RenderableShape, _super);
            function RenderableShape(id, pathData, textures, bounds) {
                var _this = _super.call(this) || this;
                _this._flags = 4096 /* Dirty */ |
                    512 /* Scalable */ |
                    1024 /* Tileable */;
                _this.setBounds(bounds);
                _this._id = id;
                _this._pathData = pathData;
                _this._textures = textures;
                if (textures.length) {
                    _this.setFlags(256 /* Dynamic */);
                }
                return _this;
            }
            RenderableShape.prototype.update = function (pathData, textures, bounds) {
                this.setBounds(bounds);
                this._pathData = pathData;
                this._paths = null;
                this._textures = textures;
                this.setFlags(256 /* Dynamic */);
                this.invalidate();
            };
            /**
             * If |clipPath| is not |null| then we must add all paths to |clipPath| instead of drawing to |context|.
             * We also cannot call |save| or |restore| because those functions reset the current clipping region.
             * It looks like Flash ignores strokes when clipping so we can also ignore stroke paths when computing
             * the clip region.
             *
             * If |paintStencil| is |true| then we must not create any alpha values, and also not paint
             * any strokes.
             */
            RenderableShape.prototype.render = function (context, ratio, cullBounds, clipPath, paintStencil) {
                if (clipPath === void 0) { clipPath = null; }
                if (paintStencil === void 0) { paintStencil = false; }
                var paintStencilStyle = release ? '#000000' : '#FF4981';
                context.fillStyle = context.strokeStyle = 'transparent';
                var paths = this._deserializePaths(this._pathData, context, ratio);
                release || assert(paths);
                GFX.enterTimeline("RenderableShape.render", this);
                for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    context['mozImageSmoothingEnabled'] = context.msImageSmoothingEnabled =
                        context['imageSmoothingEnabled'] =
                            path.smoothImage;
                    if (path.type === 0 /* Fill */) {
                        if (clipPath) {
                            clipPath.addPath(path.path, context.currentTransform);
                        }
                        else {
                            context.fillStyle = paintStencil ? paintStencilStyle : path.style;
                            context.fill(path.path, 'evenodd');
                            context.fillStyle = 'transparent';
                        }
                    }
                    else if (!clipPath && !paintStencil) {
                        context.strokeStyle = path.style;
                        var lineScaleMode = 1 /* Normal */;
                        if (path.strokeProperties) {
                            lineScaleMode = path.strokeProperties.scaleMode;
                            context.lineWidth = path.strokeProperties.thickness;
                            context.lineCap = path.strokeProperties.capsStyle;
                            context.lineJoin = path.strokeProperties.jointsStyle;
                            context.miterLimit = path.strokeProperties.miterLimit;
                        }
                        // Special-cases 1px and 3px lines by moving the drawing position down/right by 0.5px.
                        // Flash apparently does this to create sharp, non-aliased lines in the normal case of thin
                        // lines drawn on round pixel values.
                        // Our handling doesn't always create the same results: for drawing coordinates with
                        // fractional values, Flash draws blurry lines. We do, too, but we still move the line
                        // down/right. Flash does something slightly different, with the result that a line drawn
                        // on coordinates slightly below round pixels (0.8, say) will be moved up/left.
                        // Properly fixing this would probably have to happen in the rasterizer. Or when replaying
                        // all the drawing commands, which seems expensive.
                        var lineWidth = context.lineWidth;
                        var isSpecialCaseWidth = lineWidth === 1 || lineWidth === 3;
                        if (isSpecialCaseWidth) {
                            context.translate(0.5, 0.5);
                        }
                        context.flashStroke(path.path, lineScaleMode);
                        if (isSpecialCaseWidth) {
                            context.translate(-0.5, -0.5);
                        }
                        context.strokeStyle = 'transparent';
                    }
                }
                GFX.leaveTimeline("RenderableShape.render");
            };
            RenderableShape.prototype._deserializePaths = function (data, context, ratio) {
                release || assert(data ? !this._paths : this._paths);
                GFX.enterTimeline("RenderableShape.deserializePaths");
                // TODO: Optimize path handling to use only one path if possible.
                // If both line and fill style are set at the same time, we don't need to duplicate the
                // geometry.
                if (this._paths) {
                    return this._paths;
                }
                var paths = this._paths = [];
                var fillPath = null;
                var strokePath = null;
                // We have to alway store the last position because Flash keeps the drawing cursor where it
                // was when changing fill or line style, whereas Canvas forgets it on beginning a new path.
                var x = 0;
                var y = 0;
                var cpX;
                var cpY;
                var formOpen = false;
                var formOpenX = 0;
                var formOpenY = 0;
                var commands = data.commands;
                var coordinates = data.coordinates;
                var styles = data.styles;
                styles.position = 0;
                var coordinatesIndex = 0;
                var commandsCount = data.commandsPosition;
                // Description of serialization format can be found in flash.display.Graphics.
                var commandIndex;
                for (commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                    var command = commands[commandIndex];
                    switch (command) {
                        case 9 /* MoveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            if (formOpen && fillPath) {
                                fillPath.lineTo(formOpenX, formOpenY);
                                strokePath && strokePath.lineTo(formOpenX, formOpenY);
                            }
                            formOpen = true;
                            x = formOpenX = coordinates[coordinatesIndex++] / 20;
                            y = formOpenY = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.moveTo(x, y);
                            strokePath && strokePath.moveTo(x, y);
                            break;
                        case 10 /* LineTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.lineTo(x, y);
                            strokePath && strokePath.lineTo(x, y);
                            break;
                        case 11 /* CurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                            cpX = coordinates[coordinatesIndex++] / 20;
                            cpY = coordinates[coordinatesIndex++] / 20;
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.quadraticCurveTo(cpX, cpY, x, y);
                            strokePath && strokePath.quadraticCurveTo(cpX, cpY, x, y);
                            break;
                        case 12 /* CubicCurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                            cpX = coordinates[coordinatesIndex++] / 20;
                            cpY = coordinates[coordinatesIndex++] / 20;
                            var cpX2 = coordinates[coordinatesIndex++] / 20;
                            var cpY2 = coordinates[coordinatesIndex++] / 20;
                            x = coordinates[coordinatesIndex++] / 20;
                            y = coordinates[coordinatesIndex++] / 20;
                            fillPath && fillPath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            strokePath && strokePath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            break;
                        case 1 /* BeginSolidFill */:
                            release || assert(styles.bytesAvailable >= 4);
                            fillPath = this._createPath(0 /* Fill */, Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt()), false, null, x, y);
                            break;
                        case 3 /* BeginBitmapFill */:
                            var bitmapStyle = this._readBitmap(styles, context);
                            fillPath = this._createPath(0 /* Fill */, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                            break;
                        case 2 /* BeginGradientFill */:
                            fillPath = this._createPath(0 /* Fill */, this._readGradient(styles, context), false, null, x, y);
                            break;
                        case 4 /* EndFill */:
                            fillPath = null;
                            break;
                        case 5 /* LineStyleSolid */:
                            var color = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());
                            // Skip pixel hinting.
                            styles.position += 1;
                            var scaleMode = styles.readByte();
                            var capsStyle = RenderableShape.LINE_CAPS_STYLES[styles.readByte()];
                            var jointsStyle = RenderableShape.LINE_JOINTS_STYLES[styles.readByte()];
                            var strokeProperties = new StrokeProperties(coordinates[coordinatesIndex++] / 20, scaleMode, capsStyle, jointsStyle, styles.readByte());
                            // Look ahead at the following command to determine if this is a complex stroke style.
                            if (commands[commandIndex + 1] === 6 /* LineStyleGradient */) {
                                commandIndex++;
                                strokePath = this._createPath(2 /* StrokeFill */, this._readGradient(styles, context), false, strokeProperties, x, y);
                            }
                            else if (commands[commandIndex + 1] === 6 /* LineStyleGradient */) {
                                commandIndex++;
                                var bitmapStyle_1 = this._readBitmap(styles, context);
                                strokePath = this._createPath(2 /* StrokeFill */, bitmapStyle_1.style, bitmapStyle_1.smoothImage, strokeProperties, x, y);
                            }
                            else {
                                strokePath = this._createPath(1 /* Stroke */, color, false, strokeProperties, x, y);
                            }
                            break;
                        case 8 /* LineEnd */:
                            strokePath = null;
                            break;
                        default:
                            release || assertUnreachable('Invalid command ' + command + ' encountered at index' +
                                commandIndex + ' of ' + commandsCount);
                    }
                }
                release || assert(styles.bytesAvailable === 0);
                release || assert(commandIndex === commandsCount);
                release || assert(coordinatesIndex === data.coordinatesPosition);
                if (formOpen && fillPath) {
                    fillPath.lineTo(formOpenX, formOpenY);
                    strokePath && strokePath.lineTo(formOpenX, formOpenY);
                }
                this._pathData = null;
                GFX.leaveTimeline("RenderableShape.deserializePaths");
                return paths;
            };
            RenderableShape.prototype._createPath = function (type, style, smoothImage, strokeProperties, x, y) {
                var path = new StyledPath(type, style, smoothImage, strokeProperties);
                this._paths.push(path);
                path.path.moveTo(x, y);
                return path.path;
            };
            RenderableShape.prototype._readMatrix = function (data) {
                return new Matrix(data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat());
            };
            RenderableShape.prototype._readGradient = function (styles, context) {
                // Assert at least one color stop.
                release || assert(styles.bytesAvailable >= 1 + 1 + 6 * 4 /* matrix fields as floats */ +
                    1 + 1 + 4 + 1 + 1);
                var gradientType = styles.readUnsignedByte();
                var focalPoint = styles.readShort() * 2 / 0xff;
                release || assert(focalPoint >= -1 && focalPoint <= 1);
                var transform = this._readMatrix(styles);
                var gradient = gradientType === 16 /* Linear */ ?
                    context.createLinearGradient(-1, 0, 1, 0) :
                    context.createRadialGradient(focalPoint, 0, 0, 0, 0, 1);
                gradient.setTransform && gradient.setTransform(transform.toSVGMatrix());
                var colorStopsCount = styles.readUnsignedByte();
                for (var i = 0; i < colorStopsCount; i++) {
                    var ratio = styles.readUnsignedByte() / 0xff;
                    var cssColor = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());
                    gradient.addColorStop(ratio, cssColor);
                }
                // Skip spread and interpolation modes for now.
                styles.position += 2;
                return gradient;
            };
            RenderableShape.prototype._readBitmap = function (styles, context) {
                release || assert(styles.bytesAvailable >= 4 + 6 * 4 /* matrix fields as floats */ + 1 + 1);
                var textureIndex = styles.readUnsignedInt();
                var fillTransform = this._readMatrix(styles);
                var repeat = styles.readBoolean() ? 'repeat' : 'no-repeat';
                var smooth = styles.readBoolean();
                var texture = this._textures[textureIndex];
                var fillStyle;
                if (texture) {
                    fillStyle = context.createPattern(texture.renderSource, repeat);
                    fillStyle.setTransform(fillTransform.toSVGMatrix());
                }
                else {
                    // TODO: Wire up initially-missing textures that become available later.
                    // An invalid SWF can have shape fills refer to images that occur later in the SWF. In that
                    // case, the image only becomes available once that frame is actually reached. Before that
                    // the fill isn't drawn; it is drawn once the image becomes available, though.
                    fillStyle = null;
                }
                return { style: fillStyle, smoothImage: smooth };
            };
            RenderableShape.prototype._renderFallback = function (context) {
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                //      context.textBaseline = "top";
                //      context.fillStyle = "white";
                //      context.fillText(String(id), bounds.x, bounds.y);
                context.restore();
            };
            RenderableShape.LINE_CAPS_STYLES = ['round', 'butt', 'square'];
            RenderableShape.LINE_JOINTS_STYLES = ['round', 'bevel', 'miter'];
            return RenderableShape;
        }(Renderable));
        GFX.RenderableShape = RenderableShape;
        var RenderableMorphShape = /** @class */ (function (_super) {
            __extends(RenderableMorphShape, _super);
            function RenderableMorphShape() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._flags = 256 /* Dynamic */ |
                    4096 /* Dirty */ |
                    512 /* Scalable */ |
                    1024 /* Tileable */;
                _this._morphPaths = Object.create(null);
                return _this;
            }
            RenderableMorphShape.prototype._deserializePaths = function (data, context, ratio) {
                GFX.enterTimeline("RenderableMorphShape.deserializePaths");
                // TODO: Optimize path handling to use only one path if possible.
                // If both line and fill style are set at the same time, we don't need to duplicate the
                // geometry.
                if (this._morphPaths[ratio]) {
                    return this._morphPaths[ratio];
                }
                var paths = this._morphPaths[ratio] = [];
                var fillPath = null;
                var strokePath = null;
                // We have to alway store the last position because Flash keeps the drawing cursor where it
                // was when changing fill or line style, whereas Canvas forgets it on beginning a new path.
                var x = 0;
                var y = 0;
                var cpX;
                var cpY;
                var formOpen = false;
                var formOpenX = 0;
                var formOpenY = 0;
                var commands = data.commands;
                var coordinates = data.coordinates;
                var morphCoordinates = data.morphCoordinates;
                var styles = data.styles;
                var morphStyles = data.morphStyles;
                styles.position = 0;
                morphStyles.position = 0;
                var coordinatesIndex = 0;
                var commandsCount = data.commandsPosition;
                // Description of serialization format can be found in flash.display.Graphics.
                var commandIndex;
                for (commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                    var command = commands[commandIndex];
                    switch (command) {
                        case 9 /* MoveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            if (formOpen && fillPath) {
                                fillPath.lineTo(formOpenX, formOpenY);
                                strokePath && strokePath.lineTo(formOpenX, formOpenY);
                            }
                            formOpen = true;
                            x = formOpenX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            y = formOpenY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            fillPath && fillPath.moveTo(x, y);
                            strokePath && strokePath.moveTo(x, y);
                            break;
                        case 10 /* LineTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                            x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            fillPath && fillPath.lineTo(x, y);
                            strokePath && strokePath.lineTo(x, y);
                            break;
                        case 11 /* CurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                            cpX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            cpY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            fillPath && fillPath.quadraticCurveTo(cpX, cpY, x, y);
                            strokePath && strokePath.quadraticCurveTo(cpX, cpY, x, y);
                            break;
                        case 12 /* CubicCurveTo */:
                            release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                            cpX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            cpY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            var cpX2 = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            var cpY2 = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            fillPath && fillPath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            strokePath && strokePath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                            break;
                        case 1 /* BeginSolidFill */:
                            release || assert(styles.bytesAvailable >= 4);
                            fillPath = this._createMorphPath(0 /* Fill */, ratio, Shumway.ColorUtilities.rgbaToCSSStyle(morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio)), false, null, x, y);
                            break;
                        case 3 /* BeginBitmapFill */:
                            var bitmapStyle = this._readMorphBitmap(styles, morphStyles, ratio, context);
                            fillPath = this._createMorphPath(0 /* Fill */, ratio, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                            break;
                        case 2 /* BeginGradientFill */:
                            var gradientStyle = this._readMorphGradient(styles, morphStyles, ratio, context);
                            fillPath = this._createMorphPath(0 /* Fill */, ratio, gradientStyle, false, null, x, y);
                            break;
                        case 4 /* EndFill */:
                            fillPath = null;
                            break;
                        case 5 /* LineStyleSolid */:
                            var width = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                            var color = Shumway.ColorUtilities.rgbaToCSSStyle(morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio));
                            // Skip pixel hinting.
                            styles.position += 1;
                            var scaleMode = styles.readByte();
                            var capsStyle = RenderableShape.LINE_CAPS_STYLES[styles.readByte()];
                            var jointsStyle = RenderableShape.LINE_JOINTS_STYLES[styles.readByte()];
                            var strokeProperties = new StrokeProperties(width, scaleMode, capsStyle, jointsStyle, styles.readByte());
                            if (strokeProperties.thickness > 0) {
                                strokePath = this._createMorphPath(1 /* Stroke */, ratio, color, false, strokeProperties, x, y);
                            }
                            break;
                        case 6 /* LineStyleGradient */:
                            gradientStyle = this._readMorphGradient(styles, morphStyles, ratio, context);
                            strokePath = this._createMorphPath(2 /* StrokeFill */, ratio, gradientStyle, false, null, x, y);
                            break;
                        case 7 /* LineStyleBitmap */:
                            bitmapStyle = this._readMorphBitmap(styles, morphStyles, ratio, context);
                            strokePath = this._createMorphPath(2 /* StrokeFill */, ratio, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                            break;
                        case 8 /* LineEnd */:
                            strokePath = null;
                            break;
                        default:
                            release || assertUnreachable('Invalid command ' + command + ' encountered at index' +
                                commandIndex + ' of ' + commandsCount);
                    }
                }
                release || assert(styles.bytesAvailable === 0);
                release || assert(commandIndex === commandsCount);
                release || assert(coordinatesIndex === data.coordinatesPosition);
                if (formOpen && fillPath) {
                    fillPath.lineTo(formOpenX, formOpenY);
                    strokePath && strokePath.lineTo(formOpenX, formOpenY);
                }
                GFX.leaveTimeline("RenderableMorphShape.deserializPaths");
                return paths;
            };
            RenderableMorphShape.prototype._createMorphPath = function (type, ratio, style, smoothImage, strokeProperties, x, y) {
                var path = new StyledPath(type, style, smoothImage, strokeProperties);
                this._morphPaths[ratio].push(path);
                path.path.moveTo(x, y);
                return path.path;
            };
            RenderableMorphShape.prototype._readMorphMatrix = function (data, morphData, ratio) {
                return new Matrix(morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio));
            };
            RenderableMorphShape.prototype._readMorphGradient = function (styles, morphStyles, ratio, context) {
                // Assert at least one color stop.
                release || assert(styles.bytesAvailable >= 1 + 1 + 6 * 4 /* matrix fields as floats */ +
                    1 + 1 + 4 + 1 + 1);
                var gradientType = styles.readUnsignedByte();
                var focalPoint = styles.readShort() * 2 / 0xff;
                release || assert(focalPoint >= -1 && focalPoint <= 1);
                var transform = this._readMorphMatrix(styles, morphStyles, ratio);
                var gradient = gradientType === 16 /* Linear */ ?
                    context.createLinearGradient(-1, 0, 1, 0) :
                    context.createRadialGradient(focalPoint, 0, 0, 0, 0, 1);
                gradient.setTransform && gradient.setTransform(transform.toSVGMatrix());
                var colorStopsCount = styles.readUnsignedByte();
                for (var i = 0; i < colorStopsCount; i++) {
                    var stop_3 = morph(styles.readUnsignedByte() / 0xff, morphStyles.readUnsignedByte() / 0xff, ratio);
                    var color = morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio);
                    var cssColor = Shumway.ColorUtilities.rgbaToCSSStyle(color);
                    gradient.addColorStop(stop_3, cssColor);
                }
                // Skip spread and interpolation modes for now.
                styles.position += 2;
                return gradient;
            };
            RenderableMorphShape.prototype._readMorphBitmap = function (styles, morphStyles, ratio, context) {
                release || assert(styles.bytesAvailable >= 4 + 6 * 4 /* matrix fields as floats */ + 1 + 1);
                var textureIndex = styles.readUnsignedInt();
                var fillTransform = this._readMorphMatrix(styles, morphStyles, ratio);
                var repeat = styles.readBoolean() ? 'repeat' : 'no-repeat';
                var smooth = styles.readBoolean();
                var texture = this._textures[textureIndex];
                release || assert(texture._canvas);
                var fillStyle = context.createPattern(texture._canvas, repeat);
                fillStyle.setTransform(fillTransform.toSVGMatrix());
                return { style: fillStyle, smoothImage: smooth };
            };
            return RenderableMorphShape;
        }(RenderableShape));
        GFX.RenderableMorphShape = RenderableMorphShape;
        var TextLine = /** @class */ (function () {
            function TextLine() {
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.ascent = 0;
                this.descent = 0;
                this.leading = 0;
                this.align = 0;
                this.runs = [];
            }
            TextLine._getMeasureContext = function () {
                if (!TextLine._measureContext) {
                    TextLine._measureContext = document.createElement('canvas').getContext('2d');
                }
                return TextLine._measureContext;
            };
            TextLine.prototype.addRun = function (font, fillStyle, text, letterSpacing, underline) {
                if (text) {
                    var measureContext = TextLine._getMeasureContext();
                    measureContext.font = font;
                    var width = measureText(measureContext, text, letterSpacing);
                    this.runs.push(new TextRun(font, fillStyle, text, width, letterSpacing, underline));
                    this.width += width;
                }
            };
            TextLine.prototype.wrap = function (maxWidth) {
                var lines = [this];
                var runs = this.runs;
                var currentLine = this;
                currentLine.width = 0;
                currentLine.runs = [];
                var measureContext = TextLine._getMeasureContext();
                for (var i = 0; i < runs.length; i++) {
                    var run = runs[i];
                    var text = run.text;
                    run.text = '';
                    run.width = 0;
                    measureContext.font = run.font;
                    var spaceLeft = maxWidth;
                    var words = text.split(/[\s.-]/);
                    var offset = 0;
                    for (var j = 0; j < words.length; j++) {
                        var word = words[j];
                        var chunk = text.substr(offset, word.length + 1);
                        var letterSpacing = run.letterSpacing;
                        var wordWidth = measureText(measureContext, chunk, letterSpacing);
                        if (wordWidth > spaceLeft) {
                            do {
                                if (run.text) {
                                    currentLine.runs.push(run);
                                    currentLine.width += run.width;
                                    run = new TextRun(run.font, run.fillStyle, '', 0, run.letterSpacing, run.underline);
                                    var newLine = new TextLine();
                                    newLine.y = (currentLine.y + currentLine.descent + currentLine.leading + currentLine.ascent) | 0;
                                    newLine.ascent = currentLine.ascent;
                                    newLine.descent = currentLine.descent;
                                    newLine.leading = currentLine.leading;
                                    newLine.align = currentLine.align;
                                    lines.push(newLine);
                                    currentLine = newLine;
                                }
                                spaceLeft = maxWidth - wordWidth;
                                if (spaceLeft < 0) {
                                    var k = chunk.length;
                                    var t = chunk;
                                    var w = wordWidth;
                                    while (k > 1) {
                                        k--;
                                        t = chunk.substr(0, k);
                                        w = measureText(measureContext, t, letterSpacing);
                                        if (w <= maxWidth) {
                                            break;
                                        }
                                    }
                                    run.text = t;
                                    run.width = w;
                                    chunk = chunk.substr(k);
                                    wordWidth = measureText(measureContext, chunk, letterSpacing);
                                }
                            } while (chunk && spaceLeft < 0);
                        }
                        else {
                            spaceLeft = spaceLeft - wordWidth;
                        }
                        run.text += chunk;
                        run.width += wordWidth;
                        offset += word.length + 1;
                    }
                    currentLine.runs.push(run);
                    currentLine.width += run.width;
                }
                return lines;
            };
            TextLine.prototype.toString = function () {
                return 'TextLine {x: ' + this.x + ', y: ' + this.y + ', width: ' + this.width +
                    ', height: ' + (this.ascent + this.descent + this.leading) + '}';
            };
            return TextLine;
        }());
        GFX.TextLine = TextLine;
        var TextRun = /** @class */ (function () {
            function TextRun(font, fillStyle, text, width, letterSpacing, underline) {
                if (font === void 0) { font = ''; }
                if (fillStyle === void 0) { fillStyle = ''; }
                if (text === void 0) { text = ''; }
                if (width === void 0) { width = 0; }
                if (letterSpacing === void 0) { letterSpacing = 0; }
                if (underline === void 0) { underline = false; }
                this.font = font;
                this.fillStyle = fillStyle;
                this.text = text;
                this.width = width;
                this.letterSpacing = letterSpacing;
                this.underline = underline;
            }
            return TextRun;
        }());
        GFX.TextRun = TextRun;
        function measureText(context, text, letterSpacing) {
            var width = context.measureText(text).width | 0;
            if (letterSpacing > 0) {
                width += text.length * letterSpacing;
            }
            return width;
        }
        var RenderableText = /** @class */ (function (_super) {
            __extends(RenderableText, _super);
            function RenderableText(bounds) {
                var _this = _super.call(this) || this;
                _this._flags = 256 /* Dynamic */ | 4096 /* Dirty */;
                _this._textBounds = bounds.clone();
                _this._textRunData = null;
                _this._plainText = '';
                _this._backgroundColor = 0;
                _this._borderColor = 0;
                _this._matrix = Matrix.createIdentity();
                _this._coords = null;
                _this._scrollV = 1;
                _this._scrollH = 0;
                _this.textRect = bounds.clone();
                _this.lines = [];
                _this.setBounds(bounds);
                return _this;
            }
            RenderableText.prototype.setBounds = function (bounds) {
                _super.prototype.setBounds.call(this, bounds);
                this._textBounds.set(bounds);
                this.textRect.setElements(bounds.x + 2, bounds.y + 2, bounds.w - 2, bounds.h - 2);
            };
            RenderableText.prototype.setContent = function (plainText, textRunData, matrix, coords) {
                this._textRunData = textRunData;
                this._plainText = plainText;
                this._matrix.set(matrix);
                this._coords = coords;
                this.lines = [];
            };
            RenderableText.prototype.setStyle = function (backgroundColor, borderColor, scrollV, scrollH) {
                this._backgroundColor = backgroundColor;
                this._borderColor = borderColor;
                this._scrollV = scrollV;
                this._scrollH = scrollH;
            };
            RenderableText.prototype.reflow = function (autoSize, wordWrap) {
                var textRunData = this._textRunData;
                if (!textRunData) {
                    return;
                }
                var bounds = this._bounds;
                var availableWidth = bounds.w - 4;
                var plainText = this._plainText;
                var lines = this.lines;
                var currentLine = new TextLine();
                var baseLinePos = 0;
                var maxWidth = 0;
                var maxAscent = 0;
                var maxDescent = 0;
                var maxLeading = -0xffffffff;
                var firstAlign = -1;
                var finishLine = function () {
                    if (!currentLine.runs.length) {
                        baseLinePos += maxAscent + maxDescent + maxLeading;
                        return;
                    }
                    if (lines.length) {
                        baseLinePos += maxLeading;
                    }
                    baseLinePos += maxAscent;
                    currentLine.y = baseLinePos | 0;
                    baseLinePos += maxDescent;
                    currentLine.ascent = maxAscent;
                    currentLine.descent = maxDescent;
                    currentLine.leading = maxLeading;
                    currentLine.align = firstAlign;
                    if (wordWrap && currentLine.width > availableWidth) {
                        var wrappedLines = currentLine.wrap(availableWidth);
                        for (var i = 0; i < wrappedLines.length; i++) {
                            var line = wrappedLines[i];
                            baseLinePos = line.y + line.descent + line.leading;
                            lines.push(line);
                            if (line.width > maxWidth) {
                                maxWidth = line.width;
                            }
                        }
                    }
                    else {
                        lines.push(currentLine);
                        if (currentLine.width > maxWidth) {
                            maxWidth = currentLine.width;
                        }
                    }
                    currentLine = new TextLine();
                };
                GFX.enterTimeline("RenderableText.reflow");
                while (textRunData.position < textRunData.length) {
                    var beginIndex = textRunData.readInt();
                    var endIndex = textRunData.readInt();
                    var size = textRunData.readInt();
                    var fontName = textRunData.readUTF();
                    var ascent = textRunData.readInt();
                    var descent = textRunData.readInt();
                    var leading = textRunData.readInt();
                    if (ascent > maxAscent) {
                        maxAscent = ascent;
                    }
                    if (descent > maxDescent) {
                        maxDescent = descent;
                    }
                    if (leading > maxLeading) {
                        maxLeading = leading;
                    }
                    var bold = textRunData.readBoolean();
                    var italic = textRunData.readBoolean();
                    var boldItalic = '';
                    if (italic) {
                        boldItalic += 'italic ';
                    }
                    if (bold) {
                        boldItalic += 'bold ';
                    }
                    var font = boldItalic + size + 'px ' + fontName + ', AdobeBlank';
                    var color = textRunData.readInt();
                    var fillStyle = Shumway.ColorUtilities.rgbToHex(color);
                    var align = textRunData.readInt();
                    if (firstAlign === -1) {
                        firstAlign = align;
                    }
                    var bullet = textRunData.readBoolean();
                    //let display = textRunData.readInt();
                    var indent = textRunData.readInt();
                    //let blockIndent = textRunData.readInt();
                    var kerning = textRunData.readInt();
                    var leftMargin = textRunData.readInt();
                    var letterSpacing = textRunData.readInt();
                    var rightMargin = textRunData.readInt();
                    //let tabStops = textRunData.readInt();
                    var underline = textRunData.readBoolean();
                    var text = '';
                    var eof = false;
                    for (var i = beginIndex; !eof; i++) {
                        var eof_1 = i >= endIndex - 1;
                        var char = plainText[i];
                        if (char !== '\r' && char !== '\n') {
                            text += char;
                            if (i < plainText.length - 1) {
                                continue;
                            }
                        }
                        currentLine.addRun(font, fillStyle, text, letterSpacing, underline);
                        finishLine();
                        text = '';
                        if (eof_1) {
                            maxAscent = 0;
                            maxDescent = 0;
                            maxLeading = -0xffffffff;
                            firstAlign = -1;
                            break;
                        }
                        if (char === '\r' && plainText[i + 1] === '\n') {
                            i++;
                        }
                    }
                    currentLine.addRun(font, fillStyle, text, letterSpacing, underline);
                }
                // Append an additional empty line if we find a line break character at the end of the text.
                var endCharacter = plainText[plainText.length - 1];
                if (endCharacter === '\r' || endCharacter === '\n') {
                    lines.push(currentLine);
                }
                var rect = this.textRect;
                rect.w = maxWidth;
                rect.h = baseLinePos;
                if (autoSize) {
                    if (!wordWrap) {
                        availableWidth = maxWidth;
                        var width = bounds.w;
                        switch (autoSize) {
                            case 1:// CENTER
                                rect.x = (width - (availableWidth + 4)) >> 1;
                                break;
                            case 2:// LEFT
                                break;
                            case 3:// RIGHT
                                rect.x = width - (availableWidth + 4);
                                break;
                        }
                        this._textBounds.setElements(rect.x - 2, rect.y - 2, rect.w + 4, rect.h + 4);
                        bounds.w = availableWidth + 4;
                    }
                    bounds.x = rect.x - 2;
                    bounds.h = baseLinePos + 4;
                }
                else {
                    this._textBounds = bounds;
                }
                var numLines = lines.length;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line.width < availableWidth) {
                        switch (line.align) {
                            case 0:// left
                                break;
                            case 1:// right
                                line.x = (availableWidth - line.width) | 0;
                                break;
                            case 2:// center
                                line.x = ((availableWidth - line.width) / 2) | 0;
                                break;
                        }
                    }
                }
                this.invalidate();
                GFX.leaveTimeline("RenderableText.reflow");
            };
            RenderableText.roundBoundPoints = function (points) {
                release || assert(points === RenderableText.absoluteBoundPoints);
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    point.x = Math.floor(point.x + .1) + .5;
                    point.y = Math.floor(point.y + .1) + .5;
                }
            };
            RenderableText.prototype.render = function (context) {
                GFX.enterTimeline("RenderableText.render");
                context.save();
                var rect = this._textBounds;
                if (this._backgroundColor) {
                    context.fillStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._backgroundColor);
                    context.fillRect(rect.x, rect.y, rect.w, rect.h);
                }
                if (this._borderColor) {
                    context.strokeStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._borderColor);
                    context.lineCap = 'square';
                    context.lineWidth = 1;
                    // TextField bounds are always drawn as 1px lines on (global-space) pixel boundaries.
                    // Their rounding is a bit weird, though: fractions below .9 are rounded down.
                    // We can only fully implement this in browsers that support `currentTransform`.
                    var boundPoints = RenderableText.absoluteBoundPoints;
                    var m = context['currentTransform'];
                    if (m) {
                        rect = rect.clone();
                        var matrix = new Matrix(m.a, m.b, m.c, m.d, m.e, m.f);
                        matrix.transformRectangle(rect, boundPoints);
                        context.setTransform(1, 0, 0, 1, 0, 0);
                    }
                    else {
                        boundPoints[0].x = rect.x;
                        boundPoints[0].y = rect.y;
                        boundPoints[1].x = rect.x + rect.w;
                        boundPoints[1].y = rect.y;
                        boundPoints[2].x = rect.x + rect.w;
                        boundPoints[2].y = rect.y + rect.h;
                        boundPoints[3].x = rect.x;
                        boundPoints[3].y = rect.y + rect.h;
                    }
                    RenderableText.roundBoundPoints(boundPoints);
                    var path = new Path2D();
                    path.moveTo(boundPoints[0].x, boundPoints[0].y);
                    path.lineTo(boundPoints[1].x, boundPoints[1].y);
                    path.lineTo(boundPoints[2].x, boundPoints[2].y);
                    path.lineTo(boundPoints[3].x, boundPoints[3].y);
                    path.lineTo(boundPoints[0].x, boundPoints[0].y);
                    context.stroke(path);
                    if (m) {
                        context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                    }
                }
                if (this._coords) {
                    this._renderChars(context);
                }
                else {
                    this._renderLines(context);
                }
                context.restore();
                GFX.leaveTimeline("RenderableText.render");
            };
            RenderableText.prototype._renderChars = function (context) {
                if (this._matrix) {
                    var m = this._matrix;
                    context.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                }
                var lines = this.lines;
                var coords = this._coords;
                coords.position = 0;
                var font = '';
                var fillStyle = '';
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        if (run.font !== font) {
                            context.font = font = run.font;
                        }
                        if (run.fillStyle !== fillStyle) {
                            context.fillStyle = fillStyle = run.fillStyle;
                        }
                        var text = run.text;
                        for (var k = 0; k < text.length; k++) {
                            var x = coords.readInt() / 20;
                            var y = coords.readInt() / 20;
                            context.fillText(text[k], x, y);
                        }
                    }
                }
            };
            RenderableText.prototype._renderLines = function (context) {
                // TODO: Render bullet points.
                var bounds = this._textBounds;
                context.beginPath();
                context.rect(bounds.x + 2, bounds.y + 2, bounds.w - 4, bounds.h - 4);
                context.clip();
                context.translate((bounds.x - this._scrollH) + 2, bounds.y + 2);
                var lines = this.lines;
                var scrollV = this._scrollV;
                var scrollY = 0;
                var font = '';
                var fillStyle = '';
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var x = line.x;
                    var y = line.y;
                    // Skip lines until we are within the scroll view.
                    if (i + 1 < scrollV) {
                        scrollY = y + line.descent + line.leading;
                        continue;
                    }
                    y -= scrollY;
                    // Flash skips rendering lines that are not fully visible in height (except of the very
                    // first line within the scroll view).
                    if ((i + 1) - scrollV && y > bounds.h) {
                        break;
                    }
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        if (run.font !== font) {
                            context.font = font = run.font;
                        }
                        if (run.fillStyle !== fillStyle) {
                            context.fillStyle = fillStyle = run.fillStyle;
                        }
                        if (run.underline) {
                            context.fillRect(x, (y + (line.descent / 2)) | 0, run.width, 1);
                        }
                        context.textAlign = "left";
                        context.textBaseline = "alphabetic";
                        if (run.letterSpacing > 0) {
                            var text = run.text;
                            for (var k = 0; k < text.length; k++) {
                                context.fillText(text[k], x, y);
                                x += measureText(context, text[k], run.letterSpacing);
                            }
                        }
                        else {
                            context.fillText(run.text, x, y);
                            x += run.width;
                        }
                    }
                }
            };
            RenderableText.absoluteBoundPoints = [new Point(0, 0), new Point(0, 0),
                new Point(0, 0), new Point(0, 0)];
            return RenderableText;
        }(Renderable));
        GFX.RenderableText = RenderableText;
        var Label = /** @class */ (function (_super) {
            __extends(Label, _super);
            function Label(w, h) {
                var _this = _super.call(this) || this;
                _this._flags = 256 /* Dynamic */ | 512 /* Scalable */;
                _this.setBounds(new Rectangle(0, 0, w, h));
                return _this;
            }
            Object.defineProperty(Label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (value) {
                    this._text = value;
                },
                enumerable: true,
                configurable: true
            });
            Label.prototype.render = function (context, ratio, cullBounds) {
                context.save();
                context.textBaseline = "top";
                context.fillStyle = "white";
                context.fillText(this.text, 0, 0);
                context.restore();
            };
            return Label;
        }(Renderable));
        GFX.Label = Label;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var clampByte = Shumway.ColorUtilities.clampByte;
        var assert = Shumway.Debug.assert;
        var Filter = /** @class */ (function () {
            function Filter() {
            }
            Filter.prototype.expandBounds = function (bounds) {
                // NOOP
            };
            return Filter;
        }());
        GFX.Filter = Filter;
        var EPS = 0.000000001;
        // Step widths for blur based filters, for quality values 1..15:
        // If we plot the border width added by expandBlurBounds for each blurX (or blurY) value, the
        // step width is the amount of blurX that adds one pixel to the border width. I.e. for quality = 1,
        // the border width increments at blurX = 2, 4, 6, ...
        var blurFilterStepWidths = [
            2,
            1 / 1.05,
            1 / 1.35,
            1 / 1.55,
            1 / 1.75,
            1 / 1.9,
            1 / 2,
            1 / 2.1,
            1 / 2.2,
            1 / 2.3,
            1 / 2.5,
            1 / 3,
            1 / 3,
            1 / 3.5,
            1 / 3.5
        ];
        function expandBlurBounds(bounds, quality, blurX, blurY, isBlurFilter) {
            var stepWidth = blurFilterStepWidths[quality - 1];
            var bx = blurX;
            var by = blurY;
            if (isBlurFilter) {
                // BlurFilter behaves slightly different from other blur based filters:
                // Given ascending blurX/blurY values, a BlurFilter expands the source rect later than with
                // i.e. GlowFilter. The difference appears to be stepWidth / 4 for all quality values.
                var stepWidth4 = stepWidth / 4;
                bx -= stepWidth4;
                by -= stepWidth4;
            }
            // Calculate horizontal and vertical borders:
            // blurX/blurY values <= 1 are always rounded up to 1, which means that we always expand the
            // source rect, even when blurX/blurY is 0.
            var bh = (Math.ceil((bx < 1 ? 1 : bx) / (stepWidth - EPS)));
            var bv = (Math.ceil((by < 1 ? 1 : by) / (stepWidth - EPS)));
            bounds.x -= bh;
            bounds.w += bh * 2;
            bounds.y -= bv;
            bounds.h += bv * 2;
        }
        var BlurFilter = /** @class */ (function (_super) {
            __extends(BlurFilter, _super);
            function BlurFilter(blurX, blurY, quality) {
                var _this = _super.call(this) || this;
                _this.blurX = blurX;
                _this.blurY = blurY;
                _this.quality = quality;
                return _this;
            }
            BlurFilter.prototype.expandBounds = function (bounds) {
                expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, true);
            };
            return BlurFilter;
        }(Filter));
        GFX.BlurFilter = BlurFilter;
        var DropshadowFilter = /** @class */ (function (_super) {
            __extends(DropshadowFilter, _super);
            function DropshadowFilter(alpha, angle, blurX, blurY, color, distance, hideObject, inner, knockout, quality, strength) {
                var _this = _super.call(this) || this;
                _this.alpha = alpha;
                _this.angle = angle;
                _this.blurX = blurX;
                _this.blurY = blurY;
                _this.color = color;
                _this.distance = distance;
                _this.hideObject = hideObject;
                _this.inner = inner;
                _this.knockout = knockout;
                _this.quality = quality;
                _this.strength = strength;
                return _this;
            }
            DropshadowFilter.prototype.expandBounds = function (bounds) {
                // TODO: Once we support inset drop shadows, bounds don't expand.
                //       For now, they will be rendered as normal drop shadows.
                // if (this.inner) {
                //   return;
                // }
                expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, false);
                if (this.distance) {
                    var a = this.angle * Math.PI / 180;
                    var dx = Math.cos(a) * this.distance;
                    var dy = Math.sin(a) * this.distance;
                    var xMin = bounds.x + (dx >= 0 ? 0 : Math.floor(dx));
                    var xMax = bounds.x + bounds.w + Math.ceil(Math.abs(dx));
                    var yMin = bounds.y + (dy >= 0 ? 0 : Math.floor(dy));
                    var yMax = bounds.y + bounds.h + Math.ceil(Math.abs(dy));
                    bounds.x = xMin;
                    bounds.w = xMax - xMin;
                    bounds.y = yMin;
                    bounds.h = yMax - yMin;
                }
            };
            return DropshadowFilter;
        }(Filter));
        GFX.DropshadowFilter = DropshadowFilter;
        var GlowFilter = /** @class */ (function (_super) {
            __extends(GlowFilter, _super);
            function GlowFilter(alpha, blurX, blurY, color, inner, knockout, quality, strength) {
                var _this = _super.call(this) || this;
                _this.alpha = alpha;
                _this.blurX = blurX;
                _this.blurY = blurY;
                _this.color = color;
                _this.inner = inner;
                _this.knockout = knockout;
                _this.quality = quality;
                _this.strength = strength;
                return _this;
            }
            GlowFilter.prototype.expandBounds = function (bounds) {
                if (!this.inner) {
                    expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, false);
                }
            };
            return GlowFilter;
        }(Filter));
        GFX.GlowFilter = GlowFilter;
        var ColorMatrixType;
        (function (ColorMatrixType) {
            ColorMatrixType[ColorMatrixType["Unknown"] = 0] = "Unknown";
            ColorMatrixType[ColorMatrixType["Identity"] = 1] = "Identity";
        })(ColorMatrixType = GFX.ColorMatrixType || (GFX.ColorMatrixType = {}));
        var ColorMatrix = /** @class */ (function (_super) {
            __extends(ColorMatrix, _super);
            function ColorMatrix(data) {
                var _this = _super.call(this) || this;
                release || assert(data.length === 20);
                _this._data = new Float32Array(data);
                _this._type = 0 /* Unknown */;
                return _this;
            }
            ColorMatrix.prototype.clone = function () {
                var colorMatrix = new ColorMatrix(this._data);
                colorMatrix._type = this._type;
                return colorMatrix;
            };
            ColorMatrix.prototype.set = function (other) {
                this._data.set(other._data);
                this._type = other._type;
            };
            ColorMatrix.prototype.toWebGLMatrix = function () {
                return new Float32Array(this._data);
            };
            ColorMatrix.prototype.asWebGLMatrix = function () {
                return this._data.subarray(0, 16);
            };
            ColorMatrix.prototype.asWebGLVector = function () {
                return this._data.subarray(16, 20);
            };
            ColorMatrix.prototype.isIdentity = function () {
                if (this._type & 1 /* Identity */) {
                    return true;
                }
                var m = this._data;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 &&
                    m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 &&
                    m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 &&
                    m[12] == 0 && m[13] == 0 && m[14] == 0 && m[15] == 1 &&
                    m[16] == 0 && m[17] == 0 && m[18] == 0 && m[19] == 0;
            };
            ColorMatrix.createIdentity = function () {
                var colorMatrix = new ColorMatrix([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1,
                    0, 0, 0, 0
                ]);
                colorMatrix._type = 1 /* Identity */;
                return colorMatrix;
            };
            ColorMatrix.prototype.setMultipliersAndOffsets = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                var m = this._data;
                for (var i = 0; i < m.length; i++) {
                    m[i] = 0;
                }
                m[0] = redMultiplier;
                m[5] = greenMultiplier;
                m[10] = blueMultiplier;
                m[15] = alphaMultiplier;
                m[16] = redOffset / 255;
                m[17] = greenOffset / 255;
                m[18] = blueOffset / 255;
                m[19] = alphaOffset / 255;
                this._type = 0 /* Unknown */;
            };
            ColorMatrix.prototype.transformRGBA = function (rgba) {
                var r = (rgba >> 24) & 0xff;
                var g = (rgba >> 16) & 0xff;
                var b = (rgba >> 8) & 0xff;
                var a = rgba & 0xff;
                var m = this._data;
                var R = clampByte(r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[16] * 255);
                var G = clampByte(r * m[4] + g * m[5] + b * m[6] + a * m[7] + m[17] * 255);
                var B = clampByte(r * m[8] + g * m[9] + b * m[10] + a * m[11] + m[18] * 255);
                var A = clampByte(r * m[12] + g * m[13] + b * m[14] + a * m[15] + m[19] * 255);
                return R << 24 | G << 16 | B << 8 | A;
            };
            ColorMatrix.prototype.multiply = function (other) {
                if (other._type & 1 /* Identity */) {
                    return;
                }
                var a = this._data, b = other._data;
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];
                var a40 = a[4 * 4 + 0];
                var a41 = a[4 * 4 + 1];
                var a42 = a[4 * 4 + 2];
                var a43 = a[4 * 4 + 3];
                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                var b40 = b[4 * 4 + 0];
                var b41 = b[4 * 4 + 1];
                var b42 = b[4 * 4 + 2];
                var b43 = b[4 * 4 + 3];
                a[0 * 4 + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
                a[0 * 4 + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
                a[0 * 4 + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
                a[0 * 4 + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
                a[1 * 4 + 0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
                a[1 * 4 + 1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
                a[1 * 4 + 2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
                a[1 * 4 + 3] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
                a[2 * 4 + 0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
                a[2 * 4 + 1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
                a[2 * 4 + 2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
                a[2 * 4 + 3] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
                a[3 * 4 + 0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
                a[3 * 4 + 1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
                a[3 * 4 + 2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
                a[3 * 4 + 3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
                a[4 * 4 + 0] = a00 * b40 + a10 * b41 + a20 * b42 + a30 * b43 + a40;
                a[4 * 4 + 1] = a01 * b40 + a11 * b41 + a21 * b42 + a31 * b43 + a41;
                a[4 * 4 + 2] = a02 * b40 + a12 * b41 + a22 * b42 + a32 * b43 + a42;
                a[4 * 4 + 3] = a03 * b40 + a13 * b41 + a23 * b42 + a33 * b43 + a43;
                this._type = 0 /* Unknown */;
            };
            Object.defineProperty(ColorMatrix.prototype, "alphaMultiplier", {
                get: function () {
                    return this._data[15];
                },
                enumerable: true,
                configurable: true
            });
            ColorMatrix.prototype.hasOnlyAlphaMultiplier = function () {
                var m = this._data;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 &&
                    m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 &&
                    m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 &&
                    m[12] == 0 && m[13] == 0 && m[14] == 0 && m[16] == 0 &&
                    m[17] == 0 && m[18] == 0 && m[19] == 0;
            };
            ColorMatrix.prototype.equals = function (other) {
                if (!other) {
                    return false;
                }
                else if (this._type === other._type && this._type === 1 /* Identity */) {
                    return true;
                }
                var a = this._data;
                var b = other._data;
                for (var i = 0; i < 20; i++) {
                    if (Math.abs(a[i] - b[i]) > 0.001) {
                        return false;
                    }
                }
                return true;
            };
            ColorMatrix.prototype.toSVGFilterMatrix = function () {
                var m = this._data;
                return [m[0], m[4], m[8], m[12], m[16],
                    m[1], m[5], m[9], m[13], m[17],
                    m[2], m[6], m[10], m[14], m[18],
                    m[3], m[7], m[11], m[15], m[19]].join(" ");
            };
            return ColorMatrix;
        }(Filter));
        GFX.ColorMatrix = ColorMatrix;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='module.ts' />
/// <reference path='utilities.ts' />
/// <reference path='settings.ts'/>
/// <reference path='geometry.ts'/>
/// <reference path='regionAllocator.ts'/>
/// <reference path='nodes.ts'/>
/// <reference path='renderables/renderables.ts'/>
/// <reference path='filters.ts'/>
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Canvas2D;
        (function (Canvas2D) {
            var assert = Shumway.Debug.assert;
            var originalSave = CanvasRenderingContext2D.prototype.save;
            var originalClip = CanvasRenderingContext2D.prototype.clip;
            var originalFill = CanvasRenderingContext2D.prototype.fill;
            var originalStroke = CanvasRenderingContext2D.prototype.stroke;
            var originalRestore = CanvasRenderingContext2D.prototype.restore;
            var originalBeginPath = CanvasRenderingContext2D.prototype.beginPath;
            function debugSave() {
                if (this.stackDepth === undefined) {
                    this.stackDepth = 0;
                }
                if (this.clipStack === undefined) {
                    this.clipStack = [0];
                }
                else {
                    this.clipStack.push(0);
                }
                this.stackDepth++;
                originalSave.call(this);
            }
            function debugRestore() {
                this.stackDepth--;
                this.clipStack.pop();
                originalRestore.call(this);
            }
            function debugFill() {
                assert(!this.buildingClippingRegionDepth);
                originalFill.apply(this, arguments);
            }
            function debugStroke() {
                assert(GFX.debugClipping.value || !this.buildingClippingRegionDepth);
                originalStroke.apply(this, arguments);
            }
            function debugBeginPath() {
                originalBeginPath.call(this);
            }
            function debugClip() {
                if (this.clipStack === undefined) {
                    this.clipStack = [0];
                }
                this.clipStack[this.clipStack.length - 1]++;
                if (GFX.debugClipping.value) {
                    this.strokeStyle = Shumway.ColorStyle.Pink;
                    this.stroke.apply(this, arguments);
                }
                else {
                    originalClip.apply(this, arguments);
                }
            }
            function notifyReleaseChanged() {
                if (release) {
                    CanvasRenderingContext2D.prototype.save = originalSave;
                    CanvasRenderingContext2D.prototype.clip = originalClip;
                    CanvasRenderingContext2D.prototype.fill = originalFill;
                    CanvasRenderingContext2D.prototype.stroke = originalStroke;
                    CanvasRenderingContext2D.prototype.restore = originalRestore;
                    CanvasRenderingContext2D.prototype.beginPath = originalBeginPath;
                }
                else {
                    CanvasRenderingContext2D.prototype.save = debugSave;
                    CanvasRenderingContext2D.prototype.clip = debugClip;
                    CanvasRenderingContext2D.prototype.fill = debugFill;
                    CanvasRenderingContext2D.prototype.stroke = debugStroke;
                    CanvasRenderingContext2D.prototype.restore = debugRestore;
                    CanvasRenderingContext2D.prototype.beginPath = debugBeginPath;
                }
            }
            Canvas2D.notifyReleaseChanged = notifyReleaseChanged;
            CanvasRenderingContext2D.prototype.enterBuildingClippingRegion = function () {
                if (!this.buildingClippingRegionDepth) {
                    this.buildingClippingRegionDepth = 0;
                }
                this.buildingClippingRegionDepth++;
            };
            CanvasRenderingContext2D.prototype.leaveBuildingClippingRegion = function () {
                this.buildingClippingRegionDepth--;
            };
        })(Canvas2D = GFX.Canvas2D || (GFX.Canvas2D = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Canvas2D;
        (function (Canvas2D) {
            var clamp = Shumway.NumberUtilities.clamp;
            var isFirefox = navigator.userAgent.indexOf('Firefox') != -1;
            /**
             * Scale blur radius for each quality level. The scale constants were gathered
             * experimentally.
             */
            function getBlurScale(ratio, quality) {
                var blurScale = ratio / 2; // For some reason we always have to scale by 1/2 first.
                switch (quality) {
                    case 0:
                        return 0;
                    case 1:
                        return blurScale / 2.7;
                    case 2:
                        return blurScale / 1.28;
                    case 3:
                    default:
                        return blurScale;
                }
            }
            var Filters = /** @class */ (function () {
                function Filters() {
                }
                /**
                 * Creates an SVG element and defines filters that are referenced in |canvas.filter| properties. We cannot
                 * inline CSS filters because they don't expose independent blurX and blurY properties.
                 * This only works in Firefox, and you have to set the 'canvas.filters.enabled' equal to |true|.
                 */
                Filters._prepareSVGFilters = function () {
                    if (Filters._svgBlurFilter) {
                        return;
                    }
                    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttribute("style", "display:block;width:0px;height:0px");
                    var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                    // Blur Filter
                    var blurFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                    blurFilter.setAttribute("id", "svgBlurFilter");
                    var feGaussianFilter = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
                    feGaussianFilter.setAttribute("stdDeviation", "0 0");
                    blurFilter.appendChild(feGaussianFilter);
                    defs.appendChild(blurFilter);
                    Filters._svgBlurFilter = feGaussianFilter;
                    // Drop Shadow Filter
                    var dropShadowFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                    dropShadowFilter.setAttribute("id", "svgDropShadowFilter");
                    feGaussianFilter = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
                    feGaussianFilter.setAttribute("in", "SourceAlpha");
                    feGaussianFilter.setAttribute("stdDeviation", "3");
                    dropShadowFilter.appendChild(feGaussianFilter);
                    Filters._svgDropshadowFilterBlur = feGaussianFilter;
                    var feOffset = document.createElementNS("http://www.w3.org/2000/svg", "feOffset");
                    feOffset.setAttribute("dx", "0");
                    feOffset.setAttribute("dy", "0");
                    feOffset.setAttribute("result", "offsetblur");
                    dropShadowFilter.appendChild(feOffset);
                    Filters._svgDropshadowFilterOffset = feOffset;
                    var feFlood = document.createElementNS("http://www.w3.org/2000/svg", "feFlood");
                    feFlood.setAttribute("flood-color", "rgba(0,0,0,1)");
                    dropShadowFilter.appendChild(feFlood);
                    Filters._svgDropshadowFilterFlood = feFlood;
                    var feComposite = document.createElementNS("http://www.w3.org/2000/svg", "feComposite");
                    feComposite.setAttribute("in2", "offsetblur");
                    feComposite.setAttribute("operator", "in");
                    dropShadowFilter.appendChild(feComposite);
                    feComposite = document.createElementNS("http://www.w3.org/2000/svg", "feComposite");
                    feComposite.setAttribute("in2", "SourceAlpha");
                    feComposite.setAttribute("operator", "out");
                    feComposite.setAttribute("result", "outer");
                    dropShadowFilter.appendChild(feComposite);
                    var feMerge = document.createElementNS("http://www.w3.org/2000/svg", "feMerge");
                    var feMergeNode = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
                    feMerge.appendChild(feMergeNode);
                    feMergeNode = document.createElementNS("http://www.w3.org/2000/svg", "feMergeNode");
                    feMerge.appendChild(feMergeNode);
                    Filters._svgDropshadowMergeNode = feMergeNode;
                    dropShadowFilter.appendChild(feMerge);
                    defs.appendChild(dropShadowFilter);
                    var colorMatrixFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                    colorMatrixFilter.setAttribute("id", "svgColorMatrixFilter");
                    var feColorMatrix = document.createElementNS("http://www.w3.org/2000/svg", "feColorMatrix");
                    // Color interpolation in linear RGB doesn't seem to match Flash's results.
                    feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
                    feColorMatrix.setAttribute("in", "SourceGraphic");
                    feColorMatrix.setAttribute("type", "matrix");
                    colorMatrixFilter.appendChild(feColorMatrix);
                    feComposite = document.createElementNS("http://www.w3.org/2000/svg", "feComposite");
                    feComposite.setAttribute("in2", "SourceAlpha");
                    feComposite.setAttribute("operator", "in");
                    colorMatrixFilter.appendChild(feComposite);
                    defs.appendChild(colorMatrixFilter);
                    Filters._svgColorMatrixFilter = feColorMatrix;
                    svg.appendChild(defs);
                    document.documentElement.appendChild(svg);
                };
                Filters._applyFilter = function (ratio, context, filter) {
                    if (!Filters._svgFiltersAreSupported) {
                        return;
                    }
                    Filters._prepareSVGFilters();
                    Filters._removeFilter(context);
                    var scale = ratio;
                    if (filter instanceof GFX.BlurFilter) {
                        var blurFilter = filter;
                        var blurScale = getBlurScale(ratio, blurFilter.quality);
                        Filters._svgBlurFilter.setAttribute("stdDeviation", blurFilter.blurX * blurScale + " " +
                            blurFilter.blurY * blurScale);
                        context.filter = "url(#svgBlurFilter)";
                    }
                    else if (filter instanceof GFX.DropshadowFilter) {
                        var dropshadowFilter = filter;
                        var blurScale = getBlurScale(ratio, dropshadowFilter.quality);
                        Filters._svgDropshadowFilterBlur.setAttribute("stdDeviation", dropshadowFilter.blurX * blurScale + " " +
                            dropshadowFilter.blurY * blurScale);
                        Filters._svgDropshadowFilterOffset.setAttribute("dx", String(Math.cos(dropshadowFilter.angle * Math.PI / 180) * dropshadowFilter.distance * scale));
                        Filters._svgDropshadowFilterOffset.setAttribute("dy", String(Math.sin(dropshadowFilter.angle * Math.PI / 180) * dropshadowFilter.distance * scale));
                        Filters._svgDropshadowFilterFlood.setAttribute("flood-color", Shumway.ColorUtilities.rgbaToCSSStyle(((dropshadowFilter.color << 8) | Math.round(255 * dropshadowFilter.alpha))));
                        Filters._svgDropshadowMergeNode.setAttribute("in", dropshadowFilter.knockout ? "outer" : "SourceGraphic");
                        context.filter = "url(#svgDropShadowFilter)";
                    }
                    else if (filter instanceof GFX.ColorMatrix) {
                        var colorMatrix = filter;
                        Filters._svgColorMatrixFilter.setAttribute("values", colorMatrix.toSVGFilterMatrix());
                        context.filter = "url(#svgColorMatrixFilter)";
                    }
                };
                Filters._removeFilter = function (context) {
                    // For some reason, setting this to the default empty string "" does
                    // not work, it expects "none".
                    context.filter = "none";
                };
                Filters._applyColorMatrix = function (context, colorMatrix) {
                    if (colorMatrix.isIdentity()) {
                        context.globalAlpha = 1;
                        context.globalColorMatrix = null;
                    }
                    else if (colorMatrix.hasOnlyAlphaMultiplier()) {
                        context.globalAlpha = clamp(colorMatrix.alphaMultiplier, 0, 1);
                        context.globalColorMatrix = null;
                    }
                    else {
                        context.globalAlpha = 1;
                        if (Filters._svgFiltersAreSupported) {
                            Filters._applyFilter(1, context, colorMatrix);
                            context.globalColorMatrix = null;
                        }
                        else {
                            context.globalColorMatrix = colorMatrix;
                        }
                    }
                };
                Filters._svgFiltersAreSupported = !!Object.getOwnPropertyDescriptor(CanvasRenderingContext2D.prototype, "filter");
                return Filters;
            }());
            Canvas2D.Filters = Filters;
            if (GFX.filters && Filters._svgFiltersAreSupported) {
                // Temporary hack to work around a bug that prevents SVG filters to work for off-screen canvases.
                if (!('registerScratchCanvas' in window)) {
                    window['registerScratchCanvas'] = function (scratchCanvas) {
                        scratchCanvas.style.display = 'none';
                        document.body.appendChild(scratchCanvas);
                    };
                }
            }
            /**
             * Match up FLash blend modes with Canvas blend operations:
             *
             * See: http://kaourantin.net/2005/09/some-word-on-blend-modes-in-flash.html
             */
            function getCompositeOperation(blendMode) {
                // TODO:
                // These Flash blend modes have no canvas equivalent:
                // - BlendMode.Subtract
                // - BlendMode.Invert
                // - BlendMode.Shader
                // - BlendMode.Add is similar to BlendMode.Screen
                // These blend modes are actually Porter-Duff compositing operators.
                // The backdrop is the nearest parent with blendMode set to layer.
                // When there is no LAYER parent, they are ignored (treated as NORMAL).
                // - BlendMode.Alpha (destination-in)
                // - BlendMode.Erase (destination-out)
                // - BlendMode.Layer [defines backdrop]
                var compositeOp = "source-over";
                switch (blendMode) {
                    case GFX.BlendMode.Normal:
                    case GFX.BlendMode.Layer:
                        return compositeOp;
                    case GFX.BlendMode.Multiply:
                        compositeOp = "multiply";
                        break;
                    case GFX.BlendMode.Add:
                    case GFX.BlendMode.Screen:
                        compositeOp = "screen";
                        break;
                    case GFX.BlendMode.Lighten:
                        compositeOp = "lighten";
                        break;
                    case GFX.BlendMode.Darken:
                        compositeOp = "darken";
                        break;
                    case GFX.BlendMode.Difference:
                        compositeOp = "difference";
                        break;
                    case GFX.BlendMode.Overlay:
                        compositeOp = "overlay";
                        break;
                    case GFX.BlendMode.HardLight:
                        compositeOp = "hard-light";
                        break;
                    case GFX.BlendMode.Alpha:
                        compositeOp = "destination-in";
                        break;
                    case GFX.BlendMode.Erase:
                        compositeOp = "destination-out";
                        break;
                    default:
                        release || Shumway.Debug.somewhatImplemented("Blend Mode: " + GFX.BlendMode[blendMode]);
                }
                return compositeOp;
            }
            /**
             * Clip target? Some blend modes like destination-in that affect all target pixels are very slow otherwise.
             */
            function blendModeShouldClip(blendMode) {
                switch (blendMode) {
                    case GFX.BlendMode.Alpha:
                        return true;
                    default:
                        return false;
                }
            }
            var Canvas2DSurfaceRegion = /** @class */ (function () {
                function Canvas2DSurfaceRegion(surface, region, w, h) {
                    this.surface = surface;
                    this.region = region;
                    this.w = w;
                    this.h = h;
                    // ...
                }
                Canvas2DSurfaceRegion.prototype.free = function () {
                    this.surface.free(this);
                };
                Canvas2DSurfaceRegion._ensureCopyCanvasSize = function (w, h) {
                    var canvas;
                    if (!Canvas2DSurfaceRegion._copyCanvasContext) {
                        canvas = document.createElement("canvas");
                        if (typeof registerScratchCanvas !== "undefined") {
                            registerScratchCanvas(canvas);
                        }
                        canvas.width = Shumway.IntegerUtilities.nearestPowerOfTwo(w);
                        canvas.height = Shumway.IntegerUtilities.nearestPowerOfTwo(h);
                        Canvas2DSurfaceRegion._copyCanvasContext = canvas.getContext("2d");
                    }
                    else {
                        canvas = Canvas2DSurfaceRegion._copyCanvasContext.canvas;
                        if (canvas.width < w || canvas.height < h) {
                            canvas.width = Shumway.IntegerUtilities.nearestPowerOfTwo(w);
                            canvas.height = Shumway.IntegerUtilities.nearestPowerOfTwo(h);
                        }
                    }
                };
                Canvas2DSurfaceRegion.prototype.draw = function (source, x, y, w, h, colorMatrix, blendMode, filters, devicePixelRatio) {
                    this.context.setTransform(1, 0, 0, 1, 0, 0);
                    var sourceContext, copyContext, sx = 0, sy = 0;
                    // Handle copying from and to the same canvas.
                    if (source.context.canvas === this.context.canvas) {
                        Canvas2DSurfaceRegion._ensureCopyCanvasSize(w, h);
                        copyContext = Canvas2DSurfaceRegion._copyCanvasContext;
                        copyContext.clearRect(0, 0, w, h);
                        copyContext.drawImage(source.surface.canvas, source.region.x, source.region.y, w, h, 0, 0, w, h);
                        sourceContext = copyContext;
                        sx = 0;
                        sy = 0;
                    }
                    else {
                        sourceContext = source.surface.context;
                        sx = source.region.x;
                        sy = source.region.y;
                    }
                    var canvas = this.context.canvas;
                    var clip = blendModeShouldClip(blendMode);
                    if (clip) {
                        this.context.save();
                        this.context.beginPath();
                        this.context.rect(x, y, w, h);
                        this.context.clip();
                    }
                    this.context.globalAlpha = 1;
                    this.context.globalCompositeOperation = getCompositeOperation(blendMode);
                    if (filters) {
                        if (colorMatrix && !colorMatrix.isIdentity()) {
                            filters = filters.concat(colorMatrix);
                        }
                        var i = 0;
                        if (filters.length > 1) {
                            // If there are more than one filter defined on this node, we create another temporary
                            // surface and keep drawing back and forth between them till all filters are applied,
                            // except of the last one which gets applied when actually drawing into the target after
                            // this block, to safe a drawImage call.
                            var dx = void 0, dy = void 0, _cc = void 0, _sx = void 0, _sy = void 0;
                            if (copyContext) {
                                _cc = copyContext;
                                copyContext = sourceContext;
                                sourceContext = _cc;
                            }
                            else {
                                Canvas2DSurfaceRegion._ensureCopyCanvasSize(w, h);
                                copyContext = Canvas2DSurfaceRegion._copyCanvasContext;
                                dx = 0;
                                dy = 0;
                            }
                            for (; i < filters.length - 1; i++) {
                                copyContext.clearRect(0, 0, w, h);
                                Filters._applyFilter(devicePixelRatio, copyContext, filters[i]);
                                copyContext.drawImage(sourceContext.canvas, sx, sy, w, h, dx, dy, w, h);
                                Filters._removeFilter(copyContext);
                                _cc = copyContext;
                                _sx = sx;
                                _sy = sy;
                                copyContext = sourceContext;
                                sourceContext = _cc;
                                sx = dx;
                                sy = dx;
                                dx = _sx;
                                dy = _sy;
                            }
                            Filters._removeFilter(sourceContext);
                            Filters._removeFilter(copyContext);
                        }
                        Filters._applyFilter(devicePixelRatio, this.context, filters[i]);
                    }
                    this.context.drawImage(sourceContext.canvas, sx, sy, w, h, x, y, w, h);
                    this.context.globalCompositeOperation = getCompositeOperation(GFX.BlendMode.Normal);
                    Filters._removeFilter(this.context);
                    if (clip) {
                        this.context.restore();
                    }
                };
                Object.defineProperty(Canvas2DSurfaceRegion.prototype, "context", {
                    get: function () {
                        return this.surface.context;
                    },
                    enumerable: true,
                    configurable: true
                });
                Canvas2DSurfaceRegion.prototype.resetTransform = function () {
                    this.surface.context.setTransform(1, 0, 0, 1, 0, 0);
                };
                Canvas2DSurfaceRegion.prototype.reset = function () {
                    var context = this.surface.context;
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.fillStyle = '#000000';
                    context.strokeStyle = '#000000';
                    context.globalAlpha = 1;
                    context.globalColorMatrix = null;
                    context.globalCompositeOperation = getCompositeOperation(GFX.BlendMode.Normal);
                };
                Canvas2DSurfaceRegion.prototype.fill = function (fillStyle) {
                    var context = this.surface.context, region = this.region;
                    context.fillStyle = fillStyle;
                    context.fillRect(region.x, region.y, region.w, region.h);
                };
                Canvas2DSurfaceRegion.prototype.clear = function (rectangle) {
                    var context = this.surface.context, region = this.region;
                    if (!rectangle) {
                        rectangle = region;
                    }
                    context.clearRect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
                };
                return Canvas2DSurfaceRegion;
            }());
            Canvas2D.Canvas2DSurfaceRegion = Canvas2DSurfaceRegion;
            var Canvas2DSurface = /** @class */ (function () {
                function Canvas2DSurface(canvas, regionAllocator) {
                    this.canvas = canvas;
                    this.context = canvas.getContext("2d");
                    this.w = canvas.width;
                    this.h = canvas.height;
                    this._regionAllocator = regionAllocator;
                }
                Canvas2DSurface.prototype.allocate = function (w, h) {
                    var region = this._regionAllocator.allocate(w, h);
                    if (region) {
                        return new Canvas2DSurfaceRegion(this, region, w, h);
                    }
                    return null;
                };
                Canvas2DSurface.prototype.free = function (surfaceRegion) {
                    this._regionAllocator.free(surfaceRegion.region);
                };
                return Canvas2DSurface;
            }());
            Canvas2D.Canvas2DSurface = Canvas2DSurface;
        })(Canvas2D = GFX.Canvas2D || (GFX.Canvas2D = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Canvas2D;
        (function (Canvas2D) {
            var assert = Shumway.Debug.assert;
            var Rectangle = Shumway.GFX.Geometry.Rectangle;
            var Point = Shumway.GFX.Geometry.Point;
            var Matrix = Shumway.GFX.Geometry.Matrix;
            var BlendMode = Shumway.GFX.BlendMode;
            var clamp = Shumway.NumberUtilities.clamp;
            var pow2 = Shumway.NumberUtilities.pow2;
            var writer = null; // new IndentingWriter(false, dumpLine);
            var MIN_CACHE_LEVELS = 5;
            var MAX_CACHE_LEVELS = 3;
            var MipMapLevel = /** @class */ (function () {
                function MipMapLevel(surfaceRegion, scale) {
                    this.surfaceRegion = surfaceRegion;
                    this.scale = scale;
                    // ...
                }
                return MipMapLevel;
            }());
            Canvas2D.MipMapLevel = MipMapLevel;
            var MipMap = /** @class */ (function () {
                function MipMap(renderer, node, surfaceRegionAllocator, size) {
                    this._node = node;
                    this._levels = [];
                    this._surfaceRegionAllocator = surfaceRegionAllocator;
                    this._size = size;
                    this._renderer = renderer;
                }
                MipMap.prototype.getLevel = function (matrix) {
                    var matrixScale = Math.max(matrix.getAbsoluteScaleX(), matrix.getAbsoluteScaleY());
                    var level = 0;
                    if (matrixScale !== 1) {
                        level = clamp(Math.round(Math.log(matrixScale) / Math.LN2), -MIN_CACHE_LEVELS, MAX_CACHE_LEVELS);
                    }
                    if (!(this._node.hasFlags(512 /* Scalable */))) {
                        level = clamp(level, -MIN_CACHE_LEVELS, 0);
                    }
                    var scale = pow2(level);
                    var levelIndex = MIN_CACHE_LEVELS + level;
                    var mipLevel = this._levels[levelIndex];
                    if (!mipLevel) {
                        var bounds = this._node.getBounds();
                        var scaledBounds = bounds.clone();
                        scaledBounds.scale(scale, scale);
                        scaledBounds.snap();
                        var surfaceRegion = this._surfaceRegionAllocator.allocate(scaledBounds.w, scaledBounds.h, null);
                        // surfaceRegion.fill(ColorStyle.randomStyle());
                        var region = surfaceRegion.region;
                        mipLevel = this._levels[levelIndex] = new MipMapLevel(surfaceRegion, scale);
                        var surface = (mipLevel.surfaceRegion.surface);
                        var context = surface.context;
                        //        context.save();
                        //        context.beginPath();
                        //        context.rect(region.x, region.y, region.w, region.h);
                        //        context.clip();
                        //        context.setTransform(scale, 0, 0, scale, region.x - scaledBounds.x, region.y - scaledBounds.y);
                        var state = new RenderState(surfaceRegion);
                        state.clip.set(region);
                        state.matrix.setElements(scale, 0, 0, scale, region.x - scaledBounds.x, region.y - scaledBounds.y);
                        state.flags |= 64 /* IgnoreNextRenderWithCache */;
                        this._renderer.renderNodeWithState(this._node, state);
                        state.free();
                        // context.restore();
                    }
                    return mipLevel;
                };
                return MipMap;
            }());
            Canvas2D.MipMap = MipMap;
            var FillRule;
            (function (FillRule) {
                FillRule[FillRule["NonZero"] = 0] = "NonZero";
                FillRule[FillRule["EvenOdd"] = 1] = "EvenOdd";
            })(FillRule = Canvas2D.FillRule || (Canvas2D.FillRule = {}));
            var Canvas2DRendererOptions = /** @class */ (function (_super) {
                __extends(Canvas2DRendererOptions, _super);
                function Canvas2DRendererOptions() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    /**
                     * Whether to force snapping matrices to device pixels.
                     */
                    _this.snapToDevicePixels = true;
                    /**
                     * Whether to force image smoothing when drawing images.
                     */
                    _this.imageSmoothing = true;
                    /**
                     * Whether to enable blending.
                     */
                    _this.blending = true;
                    /**
                     * Whether to enable debugging of layers.
                     */
                    _this.debugLayers = false;
                    /**
                     * Whether to enable masking.
                     */
                    _this.masking = true;
                    /**
                     * Whether to enable filters.
                     */
                    _this.filters = true;
                    /**
                     * Whether to cache shapes as images.
                     */
                    _this.cacheShapes = false;
                    /**
                     * Shapes above this size are not cached.
                     */
                    _this.cacheShapesMaxSize = 256;
                    /**
                     * Number of times a shape is rendered before it's elligible for caching.
                     */
                    _this.cacheShapesThreshold = 16;
                    /**
                     * Enables alpha layer for the canvas context.
                     */
                    _this.alpha = false;
                    return _this;
                }
                return Canvas2DRendererOptions;
            }(GFX.RendererOptions));
            Canvas2D.Canvas2DRendererOptions = Canvas2DRendererOptions;
            var RenderFlags;
            (function (RenderFlags) {
                RenderFlags[RenderFlags["None"] = 0] = "None";
                RenderFlags[RenderFlags["IgnoreNextLayer"] = 1] = "IgnoreNextLayer";
                RenderFlags[RenderFlags["RenderMask"] = 2] = "RenderMask";
                RenderFlags[RenderFlags["IgnoreMask"] = 4] = "IgnoreMask";
                RenderFlags[RenderFlags["PaintStencil"] = 8] = "PaintStencil";
                RenderFlags[RenderFlags["PaintClip"] = 16] = "PaintClip";
                RenderFlags[RenderFlags["IgnoreRenderable"] = 32] = "IgnoreRenderable";
                RenderFlags[RenderFlags["IgnoreNextRenderWithCache"] = 64] = "IgnoreNextRenderWithCache";
                RenderFlags[RenderFlags["CacheShapes"] = 256] = "CacheShapes";
                RenderFlags[RenderFlags["PaintFlashing"] = 512] = "PaintFlashing";
                RenderFlags[RenderFlags["PaintBounds"] = 1024] = "PaintBounds";
                RenderFlags[RenderFlags["PaintDirtyRegion"] = 2048] = "PaintDirtyRegion";
                RenderFlags[RenderFlags["ImageSmoothing"] = 4096] = "ImageSmoothing";
                RenderFlags[RenderFlags["PixelSnapping"] = 8192] = "PixelSnapping";
            })(RenderFlags = Canvas2D.RenderFlags || (Canvas2D.RenderFlags = {}));
            var MAX_VIEWPORT = Rectangle.createMaxI16();
            /**
             * Render state.
             */
            var RenderState = /** @class */ (function (_super) {
                __extends(RenderState, _super);
                function RenderState(target) {
                    var _this = _super.call(this) || this;
                    _this.clip = Rectangle.createEmpty();
                    _this.clipList = [];
                    _this.clipPath = null;
                    _this.flags = 0 /* None */;
                    _this.target = null;
                    _this.matrix = Matrix.createIdentity();
                    _this.colorMatrix = GFX.ColorMatrix.createIdentity();
                    RenderState.allocationCount++;
                    _this.target = target;
                    return _this;
                }
                RenderState.prototype.set = function (state) {
                    this.clip.set(state.clip);
                    this.clipPath = state.clipPath;
                    this.target = state.target;
                    this.matrix.set(state.matrix);
                    this.colorMatrix.set(state.colorMatrix);
                    this.flags = state.flags;
                    Shumway.ArrayUtilities.copyFrom(this.clipList, state.clipList);
                };
                RenderState.prototype.clone = function () {
                    var state = RenderState.allocate();
                    if (!state) {
                        state = new RenderState(this.target);
                    }
                    state.set(this);
                    return state;
                };
                RenderState.allocate = function () {
                    var dirtyStack = RenderState._dirtyStack;
                    var state = null;
                    if (dirtyStack.length) {
                        state = dirtyStack.pop();
                    }
                    return state;
                };
                RenderState.prototype.free = function () {
                    this.clipPath = null;
                    RenderState._dirtyStack.push(this);
                };
                RenderState.prototype.transform = function (transform) {
                    var state = this.clone();
                    state.matrix.preMultiply(transform.getMatrix());
                    if (transform.hasColorMatrix()) {
                        state.colorMatrix.multiply(transform.getColorMatrix());
                    }
                    return state;
                };
                RenderState.prototype.hasFlags = function (flags) {
                    return (this.flags & flags) === flags;
                };
                RenderState.prototype.removeFlags = function (flags) {
                    this.flags &= ~flags;
                };
                RenderState.prototype.toggleFlags = function (flags, on) {
                    if (on) {
                        this.flags |= flags;
                    }
                    else {
                        this.flags &= ~flags;
                    }
                };
                RenderState.prototype.beginClipPath = function (transform) {
                    this.target.context.save();
                    this.clipPath = new Path2D();
                };
                RenderState.prototype.applyClipPath = function () {
                    var context = this.target.context;
                    // Coords in clipPath are defined in global space, so have to reset the current transform, ...
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    // ... apply the clip ...
                    context.clip(this.clipPath);
                    // ... and finally restore the current transform.
                    var matrix = this.matrix;
                    context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                };
                RenderState.prototype.closeClipPath = function () {
                    this.target.context.restore();
                };
                RenderState.allocationCount = 0;
                RenderState._dirtyStack = [];
                return RenderState;
            }(GFX.State));
            Canvas2D.RenderState = RenderState;
            /**
             * Stats for each rendered frame.
             */
            var FrameInfo = /** @class */ (function () {
                function FrameInfo() {
                    this._count = 0;
                    this.shapes = 0;
                    this.groups = 0;
                    this.culledNodes = 0;
                }
                FrameInfo.prototype.enter = function (state) {
                    Shumway.GFX.enterTimeline("Frame", { frame: this._count });
                    this._count++;
                    if (!writer) {
                        return;
                    }
                    writer.enter("> Frame: " + this._count);
                    this._enterTime = performance.now();
                    this.shapes = 0;
                    this.groups = 0;
                    this.culledNodes = 0;
                };
                FrameInfo.prototype.leave = function () {
                    Shumway.GFX.leaveTimeline("Frame");
                    if (!writer) {
                        return;
                    }
                    writer.writeLn("Shapes: " + this.shapes + ", Groups: " + this.groups + ", Culled Nodes: " + this.culledNodes);
                    writer.writeLn("Elapsed: " + (performance.now() - this._enterTime).toFixed(2));
                    writer.writeLn("Rectangle: " + Rectangle.allocationCount + ", Matrix: " + Matrix.allocationCount + ", State: " + RenderState.allocationCount);
                    writer.leave("<");
                };
                return FrameInfo;
            }());
            Canvas2D.FrameInfo = FrameInfo;
            var Canvas2DRenderer = /** @class */ (function (_super) {
                __extends(Canvas2DRenderer, _super);
                function Canvas2DRenderer(container, stage, options) {
                    if (options === void 0) { options = new Canvas2DRendererOptions(); }
                    var _this = _super.call(this, container, stage, options) || this;
                    _this._visited = 0;
                    _this._frameInfo = new FrameInfo();
                    _this._fontSize = 0;
                    /**
                     * Stack of rendering layers. Stage video lives at the bottom of this stack.
                     */
                    _this._layers = [];
                    if (container instanceof HTMLCanvasElement) {
                        var canvas = container;
                        _this._viewport = new Rectangle(0, 0, canvas.width, canvas.height);
                        _this._target = _this._createTarget(canvas);
                    }
                    else {
                        _this._addLayer("Background Layer");
                        var canvasLayer = _this._addLayer("Canvas Layer");
                        var canvas_1 = document.createElement("canvas");
                        canvasLayer.appendChild(canvas_1);
                        _this._viewport = new Rectangle(0, 0, container.scrollWidth, container.scrollHeight);
                        var self_8 = _this;
                        stage.addEventListener(1 /* OnStageBoundsChanged */, function () {
                            self_8._onStageBoundsChanged(canvas_1);
                        });
                        _this._onStageBoundsChanged(canvas_1);
                    }
                    Canvas2DRenderer._prepareSurfaceAllocators();
                    return _this;
                }
                Canvas2DRenderer.prototype._addLayer = function (name) {
                    var div = document.createElement("div");
                    div.style.position = "absolute";
                    div.style.overflow = "hidden";
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.zIndex = this._layers.length + '';
                    this._container.appendChild(div);
                    this._layers.push(div);
                    return div;
                };
                Object.defineProperty(Canvas2DRenderer.prototype, "_backgroundVideoLayer", {
                    get: function () {
                        return this._layers[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Canvas2DRenderer.prototype._createTarget = function (canvas) {
                    return new Canvas2D.Canvas2DSurfaceRegion(new Canvas2D.Canvas2DSurface(canvas), new GFX.RegionAllocator.Region(0, 0, canvas.width, canvas.height), canvas.width, canvas.height);
                };
                /**
                 * If the stage bounds have changed, we have to resize all of our layers, canvases and more ...
                 */
                Canvas2DRenderer.prototype._onStageBoundsChanged = function (canvas) {
                    var stageBounds = this._stage.getBounds(true);
                    stageBounds.snap();
                    var ratio = this._devicePixelRatio = window.devicePixelRatio || 1;
                    var w = (stageBounds.w / ratio) + 'px';
                    var h = (stageBounds.h / ratio) + 'px';
                    for (var i = 0; i < this._layers.length; i++) {
                        var layer = this._layers[i];
                        layer.style.width = w;
                        layer.style.height = h;
                    }
                    canvas.width = stageBounds.w;
                    canvas.height = stageBounds.h;
                    canvas.style.position = "absolute";
                    canvas.style.width = w;
                    canvas.style.height = h;
                    this._target = this._createTarget(canvas);
                    this._fontSize = 10 * this._devicePixelRatio;
                };
                Canvas2DRenderer._prepareSurfaceAllocators = function () {
                    if (Canvas2DRenderer._initializedCaches) {
                        return;
                    }
                    var minSurfaceSize = 1024;
                    Canvas2DRenderer._surfaceCache = new GFX.SurfaceRegionAllocator.SimpleAllocator(function (w, h) {
                        var canvas = document.createElement("canvas");
                        if (typeof registerScratchCanvas !== "undefined") {
                            registerScratchCanvas(canvas);
                        }
                        // Surface caches are at least this size.
                        var W = Math.max(minSurfaceSize, w);
                        var H = Math.max(minSurfaceSize, h);
                        canvas.width = W;
                        canvas.height = H;
                        var allocator = null;
                        if (w >= 1024 / 2 || h >= 1024 / 2) {
                            // The requested size is very large, so create a single grid allocator
                            // with there requested size. This will only hold one image.
                            allocator = new GFX.RegionAllocator.GridAllocator(W, H, W, H);
                        }
                        else {
                            allocator = new GFX.RegionAllocator.BucketAllocator(W, H);
                        }
                        return new Canvas2D.Canvas2DSurface(canvas, allocator);
                    });
                    Canvas2DRenderer._shapeCache = new GFX.SurfaceRegionAllocator.SimpleAllocator(function (w, h) {
                        var canvas = document.createElement("canvas");
                        if (typeof registerScratchCanvas !== "undefined") {
                            registerScratchCanvas(canvas);
                        }
                        var W = minSurfaceSize, H = minSurfaceSize;
                        canvas.width = W;
                        canvas.height = H;
                        // Shape caches can be compact since regions are never freed explicitly.
                        // AMBIGUOUS
                        var allocator = new GFX.RegionAllocator.CompactAllocator(W, H);
                        return new Canvas2D.Canvas2DSurface(canvas, allocator);
                    });
                    Canvas2DRenderer._initializedCaches = true;
                };
                /**
                 * Main render function.
                 */
                Canvas2DRenderer.prototype.render = function () {
                    var stage = this._stage;
                    var target = this._target;
                    var options = this._options;
                    var viewport = this._viewport;
                    // stage.visit(new TracingNodeVisitor(new IndentingWriter()), null);
                    target.reset();
                    target.context.save();
                    target.context.beginPath();
                    target.context.rect(viewport.x, viewport.y, viewport.w, viewport.h);
                    target.context.clip();
                    this._renderStageToTarget(target, stage, viewport);
                    target.reset();
                    if (options.paintViewport) {
                        target.context.beginPath();
                        target.context.rect(viewport.x, viewport.y, viewport.w, viewport.h);
                        target.context.strokeStyle = "#FF4981";
                        target.context.lineWidth = 2;
                        target.context.stroke();
                    }
                    target.context.restore();
                };
                Canvas2DRenderer.prototype.renderNode = function (node, clip, matrix) {
                    var state = new RenderState(this._target);
                    state.clip.set(clip);
                    state.flags = 256 /* CacheShapes */;
                    state.matrix.set(matrix);
                    node.visit(this, state);
                    state.free();
                };
                Canvas2DRenderer.prototype.renderNodeWithState = function (node, state) {
                    node.visit(this, state);
                };
                Canvas2DRenderer.prototype._renderWithCache = function (node, state) {
                    var matrix = state.matrix;
                    var bounds = node.getBounds();
                    if (bounds.isEmpty()) {
                        return false;
                    }
                    var cacheShapesMaxSize = this._options.cacheShapesMaxSize;
                    var matrixScale = Math.max(matrix.getAbsoluteScaleX(), matrix.getAbsoluteScaleY());
                    var renderCount = 100;
                    var paintClip = !!(state.flags & 16 /* PaintClip */);
                    var paintStencil = !!(state.flags & 8 /* PaintStencil */);
                    var paintFlashing = !!(state.flags & 512 /* PaintFlashing */);
                    if (!state.hasFlags(256 /* CacheShapes */)) {
                        return false;
                    }
                    if (paintStencil || paintClip || !state.colorMatrix.isIdentity() ||
                        node.hasFlags(256 /* Dynamic */)) {
                        return false;
                    }
                    if (renderCount < this._options.cacheShapesThreshold ||
                        bounds.w * matrixScale > cacheShapesMaxSize ||
                        bounds.h * matrixScale > cacheShapesMaxSize) {
                        return false;
                    }
                    var mipMap = node.properties["mipMap"];
                    if (!mipMap) {
                        mipMap = node.properties["mipMap"] = new MipMap(this, node, Canvas2DRenderer._shapeCache, cacheShapesMaxSize);
                    }
                    var mipMapLevel = mipMap.getLevel(matrix);
                    var mipMapLevelSurfaceRegion = (mipMapLevel.surfaceRegion);
                    var region = mipMapLevelSurfaceRegion.region;
                    if (mipMapLevel) {
                        var context = state.target.context;
                        context.imageSmoothingEnabled = context.mozImageSmoothingEnabled = true;
                        context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                        context.drawImage(mipMapLevelSurfaceRegion.surface.canvas, region.x, region.y, region.w, region.h, bounds.x, bounds.y, bounds.w, bounds.h);
                        return true;
                    }
                    return false;
                };
                Canvas2DRenderer.prototype._intersectsClipList = function (node, state) {
                    var boundsAABB = node.getBounds(true);
                    var intersects = false;
                    state.matrix.transformRectangleAABB(boundsAABB);
                    if (state.clip.intersects(boundsAABB)) {
                        intersects = true;
                    }
                    var list = state.clipList;
                    if (intersects && list.length) {
                        intersects = false;
                        for (var i = 0; i < list.length; i++) {
                            if (boundsAABB.intersects(list[i])) {
                                intersects = true;
                                break;
                            }
                        }
                    }
                    boundsAABB.free();
                    return intersects;
                };
                Canvas2DRenderer.prototype.visitGroup = function (node, state) {
                    this._frameInfo.groups++;
                    var bounds = node.getBounds();
                    if (node.hasFlags(4 /* IsMask */) && !(state.flags & 4 /* IgnoreMask */)) {
                        return;
                    }
                    if (!node.hasFlags(1 /* Visible */)) {
                        return;
                    }
                    var ignoreNextLayer = state.flags & 1 /* IgnoreNextLayer */;
                    if (!ignoreNextLayer && (((node.getLayer().blendMode !== BlendMode.Normal || node.getLayer().mask) &&
                        this._options.blending) ||
                        (node.getLayer().filters && this._options.filters))) {
                        state = state.clone();
                        state.flags |= 1 /* IgnoreNextLayer */;
                        state.clipList = [];
                        this._renderLayer(node, state);
                        state.free();
                    }
                    else {
                        if (ignoreNextLayer) {
                            state.removeFlags(1 /* IgnoreNextLayer */);
                        }
                        if (this._intersectsClipList(node, state)) {
                            var clips = null;
                            var children = node.getChildren();
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                var transform = child.getTransform();
                                var childState = state.transform(transform);
                                childState.toggleFlags(4096 /* ImageSmoothing */, child.hasFlags(64 /* ImageSmoothing */));
                                if (child.clip > 0) {
                                    clips = clips || new Uint8Array(children.length); // MEMORY: Don't allocate here.
                                    clips[child.clip + i]++;
                                    var clipState = childState.clone();
                                    /*
                                     * We can't cull the clip because clips outside of the viewport still need to act
                                     * as clipping masks. For now we just expand the cull bounds, but a better approach
                                     * would be to cull the clipped nodes and skip creating the clipping region
                                     * alltogether. For this we would need to keep track of the bounds of the current
                                     * clipping region.
                                     */
                                    // clipState.clip.set(MAX_VIEWPORT);
                                    clipState.flags |= 16 /* PaintClip */;
                                    clipState.beginClipPath(transform.getMatrix());
                                    child.visit(this, clipState);
                                    clipState.applyClipPath();
                                    clipState.free();
                                }
                                else {
                                    child.visit(this, childState);
                                }
                                if (clips && clips[i] > 0) {
                                    while (clips[i]--) {
                                        state.closeClipPath();
                                    }
                                }
                                childState.free();
                            }
                        }
                        else {
                            this._frameInfo.culledNodes++;
                        }
                    }
                    this._renderDebugInfo(node, state);
                };
                Canvas2DRenderer.prototype._renderDebugInfo = function (node, state) {
                    if (!(state.flags & 1024 /* PaintBounds */)) {
                        return;
                    }
                    var context = state.target.context;
                    var bounds = node.getBounds(true);
                    var style = node.properties["style"];
                    if (!style) {
                        style = node.properties["style"] = Shumway.ColorStyle.randomStyle();
                    }
                    context.strokeStyle = style;
                    state.matrix.transformRectangleAABB(bounds);
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    var drawDetails = false;
                    if (drawDetails && bounds.w > 32 && bounds.h > 32) {
                        context.textAlign = "center";
                        context.textBaseline = "middle";
                        context.font = this._fontSize + "px Arial";
                        var debugText = "" + node.id;
                        context.fillText(debugText, bounds.x + bounds.w / 2, bounds.y + bounds.h / 2);
                    }
                    bounds.free();
                    var matrix = state.matrix;
                    bounds = node.getBounds();
                    var p = Canvas2DRenderer._debugPoints;
                    state.matrix.transformRectangle(bounds, p);
                    // Doing it this way is a lot faster than strokeRect.
                    context.lineWidth = 1;
                    context.beginPath();
                    context.moveTo(p[0].x, p[0].y);
                    context.lineTo(p[1].x, p[1].y);
                    context.lineTo(p[2].x, p[2].y);
                    context.lineTo(p[3].x, p[3].y);
                    context.lineTo(p[0].x, p[0].y);
                    context.stroke();
                };
                Canvas2DRenderer.prototype.visitStage = function (node, state) {
                    var context = state.target.context;
                    var bounds = node.getBounds(true);
                    state.matrix.transformRectangleAABB(bounds);
                    bounds.intersect(state.clip);
                    state.target.reset();
                    state = state.clone();
                    if (node.dirtyRegion) {
                        state.clipList.length = 0;
                        node.dirtyRegion.gatherOptimizedRegions(state.clipList);
                        context.save();
                        if (state.clipList.length) {
                            context.beginPath();
                            for (var i = 0; i < state.clipList.length; i++) {
                                var clip = state.clipList[i];
                                context.rect(clip.x, clip.y, clip.w, clip.h);
                            }
                            context.clip();
                        }
                        else {
                            context.restore();
                            state.free();
                            return;
                        }
                    }
                    if (this._options.clear) {
                        state.target.clear(state.clip);
                    }
                    // Fill background
                    if (!node.hasFlags(2 /* Transparent */) && node.color) {
                        if (!(state.flags & 32 /* IgnoreRenderable */)) {
                            this._container.style.backgroundColor = node.color.toCSSStyle();
                        }
                    }
                    this.visitGroup(node, state);
                    if (node.dirtyRegion) {
                        context.restore();
                        state.target.reset();
                        context.globalAlpha = 0.8;
                        if (state.hasFlags(2048 /* PaintDirtyRegion */)) {
                            node.dirtyRegion.render(state.target.context);
                        }
                        node.dirtyRegion.clear();
                    }
                    state.free();
                };
                Canvas2DRenderer.prototype.visitShape = function (node, state) {
                    if (!this._intersectsClipList(node, state)) {
                        return;
                    }
                    var matrix = state.matrix;
                    if (state.flags & 8192 /* PixelSnapping */) {
                        matrix = matrix.clone();
                        matrix.snap();
                    }
                    var context = state.target.context;
                    Canvas2D.Filters._applyColorMatrix(context, state.colorMatrix);
                    // Only paint if it is visible.
                    if (node.source instanceof GFX.RenderableVideo) {
                        this.visitRenderableVideo(node.source, state);
                    }
                    else if (context.globalAlpha > 0) {
                        this.visitRenderable(node.source, state, node.ratio);
                    }
                    if (state.flags & 8192 /* PixelSnapping */) {
                        matrix.free();
                    }
                    Canvas2D.Filters._removeFilter(context);
                };
                /**
                 * We don't actually draw the video like normal renderables, although we could.
                 * Instead, we add the video element underneeth the canvas at layer zero and set
                 * the appropriate css transform to move it into place.
                 */
                Canvas2DRenderer.prototype.visitRenderableVideo = function (node, state) {
                    if (!node.video || !node.video.videoWidth) {
                        return; // video is not ready
                    }
                    var ratio = this._devicePixelRatio;
                    var matrix = state.matrix.clone();
                    matrix.scale(1 / ratio, 1 / ratio);
                    var bounds = node.getBounds();
                    var videoMatrix = Shumway.GFX.Geometry.Matrix.createIdentity();
                    videoMatrix.scale(bounds.w / node.video.videoWidth, bounds.h / node.video.videoHeight);
                    matrix.preMultiply(videoMatrix);
                    videoMatrix.free();
                    var cssTransform = matrix.toCSSTransform();
                    node.video.style.transformOrigin = "0 0";
                    node.video.style.transform = cssTransform;
                    var videoLayer = this._backgroundVideoLayer;
                    if (videoLayer !== node.video.parentElement) {
                        videoLayer.appendChild(node.video);
                        node.addEventListener(2 /* RemovedFromStage */, function removeVideo(node) {
                            release || assert(videoLayer === node.video.parentElement);
                            videoLayer.removeChild(node.video);
                            node.removeEventListener(2 /* RemovedFromStage */, removeVideo);
                        });
                    }
                    matrix.free();
                };
                Canvas2DRenderer.prototype.visitRenderable = function (node, state, ratio) {
                    var bounds = node.getBounds();
                    if (state.flags & 32 /* IgnoreRenderable */) {
                        return;
                    }
                    if (bounds.isEmpty()) {
                        return;
                    }
                    if (state.hasFlags(64 /* IgnoreNextRenderWithCache */)) {
                        state.removeFlags(64 /* IgnoreNextRenderWithCache */);
                    }
                    else {
                        if (this._renderWithCache(node, state)) {
                            return;
                        }
                    }
                    var matrix = state.matrix;
                    var context = state.target.context;
                    var paintClip = !!(state.flags & 16 /* PaintClip */);
                    var paintStencil = !!(state.flags & 8 /* PaintStencil */);
                    var paintFlashing = !release && !!(state.flags & 512 /* PaintFlashing */);
                    context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                    var paintStart = 0;
                    if (paintFlashing) {
                        paintStart = performance.now();
                    }
                    this._frameInfo.shapes++;
                    context.imageSmoothingEnabled = context.mozImageSmoothingEnabled = state.hasFlags(4096 /* ImageSmoothing */);
                    var renderCount = node.properties["renderCount"] || 0;
                    var cacheShapesMaxSize = this._options.cacheShapesMaxSize;
                    node.properties["renderCount"] = ++renderCount;
                    node.render(context, ratio, null, paintClip ? state.clipPath : null, paintStencil);
                    if (paintFlashing) {
                        var elapsed = performance.now() - paintStart;
                        context.fillStyle = Shumway.ColorStyle.gradientColor(0.1 / elapsed);
                        context.globalAlpha = 0.3 + 0.1 * Math.random();
                        context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                    }
                };
                Canvas2DRenderer.prototype._renderLayer = function (node, state) {
                    var layer = node.getLayer();
                    var mask = layer.mask;
                    if (!mask) {
                        var clip = Rectangle.allocate();
                        var target = this._renderToTemporarySurface(node, node.getLayerBounds(!!this._options.filters), state, clip, state.target.surface);
                        if (target) {
                            state.target.draw(target, clip.x, clip.y, clip.w, clip.h, state.colorMatrix, this._options.blending ? layer.blendMode : BlendMode.Normal, this._options.filters ? layer.filters : null, this._devicePixelRatio);
                            target.free();
                        }
                        clip.free();
                    }
                    else {
                        var paintStencil = !node.hasFlags(16 /* CacheAsBitmap */) || !mask.hasFlags(16 /* CacheAsBitmap */);
                        this._renderWithMask(node, mask, layer.blendMode, paintStencil, state);
                    }
                };
                Canvas2DRenderer.prototype._renderWithMask = function (node, mask, blendMode, stencil, state) {
                    var maskMatrix = mask.getTransform().getConcatenatedMatrix(true);
                    // If the mask doesn't have a parent then it's matrix doesn't include the pixel density
                    // scaling and we have to factor it in separately.
                    if (!mask.parent) {
                        maskMatrix = maskMatrix.scale(this._devicePixelRatio, this._devicePixelRatio);
                    }
                    var aAABB = node.getBounds().clone();
                    state.matrix.transformRectangleAABB(aAABB);
                    aAABB.snap();
                    if (aAABB.isEmpty()) {
                        return;
                    }
                    var bAABB = mask.getBounds().clone();
                    maskMatrix.transformRectangleAABB(bAABB);
                    bAABB.snap();
                    if (bAABB.isEmpty()) {
                        return;
                    }
                    var clip = state.clip.clone();
                    clip.intersect(aAABB);
                    clip.intersect(bAABB);
                    clip.snap();
                    // The masked area is empty, so nothing to do here.
                    if (clip.isEmpty()) {
                        return;
                    }
                    var aState = state.clone();
                    aState.clip.set(clip);
                    var a = this._renderToTemporarySurface(node, node.getBounds(), aState, Rectangle.createEmpty(), null);
                    aState.free();
                    var bState = state.clone();
                    bState.clip.set(clip);
                    bState.matrix = maskMatrix;
                    bState.flags |= 4 /* IgnoreMask */;
                    if (stencil) {
                        bState.flags |= 8 /* PaintStencil */;
                    }
                    var b = this._renderToTemporarySurface(mask, mask.getBounds(), bState, Rectangle.createEmpty(), a.surface);
                    bState.free();
                    a.draw(b, 0, 0, clip.w, clip.h, bState.colorMatrix, BlendMode.Alpha, null, this._devicePixelRatio);
                    var matrix = state.matrix;
                    state.target.draw(a, clip.x, clip.y, clip.w, clip.h, aState.colorMatrix, blendMode, null, this._devicePixelRatio);
                    b.free();
                    a.free();
                };
                Canvas2DRenderer.prototype._renderStageToTarget = function (target, node, clip) {
                    Rectangle.allocationCount = Matrix.allocationCount = RenderState.allocationCount = 0;
                    var state = new RenderState(target);
                    state.clip.set(clip);
                    if (!this._options.paintRenderable) {
                        state.flags |= 32 /* IgnoreRenderable */;
                    }
                    if (this._options.paintBounds) {
                        state.flags |= 1024 /* PaintBounds */;
                    }
                    if (this._options.paintDirtyRegion) {
                        state.flags |= 2048 /* PaintDirtyRegion */;
                    }
                    if (this._options.paintFlashing) {
                        state.flags |= 512 /* PaintFlashing */;
                    }
                    if (this._options.cacheShapes) {
                        state.flags |= 256 /* CacheShapes */;
                    }
                    if (this._options.imageSmoothing) {
                        state.flags |= 4096 /* ImageSmoothing */;
                    }
                    if (this._options.snapToDevicePixels) {
                        state.flags |= 8192 /* PixelSnapping */;
                    }
                    this._frameInfo.enter(state);
                    node.visit(this, state);
                    this._frameInfo.leave();
                };
                Canvas2DRenderer.prototype._renderToTemporarySurface = function (node, bounds, state, clip, excludeSurface) {
                    var matrix = state.matrix;
                    var boundsAABB = bounds.clone();
                    matrix.transformRectangleAABB(boundsAABB);
                    boundsAABB.snap();
                    clip.set(boundsAABB);
                    clip.intersect(state.clip);
                    clip.snap();
                    if (clip.isEmpty()) {
                        return null;
                    }
                    var target = this._allocateSurface(clip.w, clip.h, excludeSurface);
                    var region = target.region;
                    // Region bounds may be smaller than the allocated surface region.
                    var surfaceRegionBounds = new Rectangle(region.x, region.y, clip.w, clip.h);
                    target.context.setTransform(1, 0, 0, 1, 0, 0);
                    target.clear();
                    matrix = matrix.clone();
                    matrix.translate(surfaceRegionBounds.x - clip.x, surfaceRegionBounds.y - clip.y);
                    // Clip region bounds so we don't paint outside.
                    target.context.save();
                    // We can't do this because we could be clipping some other temporary region in the same
                    // context.
                    // TODO: but we have to, otherwise we overwrite textures that we might need. This happens in
                    // _renderWithMask, which is why we currently force the allocation of a whole second surface
                    // to avoid it. So, we need to find a solution here.
                    //target.context.beginPath();
                    //target.context.rect(surfaceRegionBounds.x, surfaceRegionBounds.y, surfaceRegionBounds.w,
                    //                    surfaceRegionBounds.h);
                    //target.context.clip();
                    state = state.clone();
                    state.target = target;
                    state.matrix = matrix;
                    state.clip.set(surfaceRegionBounds);
                    node.visit(this, state);
                    state.free();
                    target.context.restore();
                    return target;
                };
                Canvas2DRenderer.prototype._allocateSurface = function (w, h, excludeSurface) {
                    var surface = (Canvas2DRenderer._surfaceCache.allocate(w, h, excludeSurface));
                    if (!release) {
                        surface.fill("#FF4981");
                    }
                    // let color = "rgba(" + (Math.random() * 255 | 0) + ", " + (Math.random() * 255 | 0) + ", " + (Math.random() * 255 | 0) + ", 1)"
                    // surface.fill(color);
                    return surface;
                };
                Canvas2DRenderer.prototype.screenShot = function (bounds, stageContent, disableHidpi) {
                    if (stageContent) {
                        // HACK: Weird way to get to the real content, but oh well...
                        var contentStage = this._stage.content.groupChild.child;
                        assert(contentStage instanceof GFX.Stage);
                        bounds = contentStage.content.getBounds(true);
                        // Figure out the device bounds.
                        contentStage.content.getTransform().getConcatenatedMatrix().transformRectangleAABB(bounds);
                        // If it's zoomed in, clip by the viewport.
                        bounds.intersect(this._viewport);
                    }
                    if (!bounds) {
                        bounds = new Rectangle(0, 0, this._target.w, this._target.h);
                    }
                    var outputWidth = bounds.w;
                    var outputHeight = bounds.h;
                    var pixelRatio = this._devicePixelRatio;
                    if (disableHidpi) {
                        outputWidth /= pixelRatio;
                        outputHeight /= pixelRatio;
                        pixelRatio = 1;
                    }
                    var canvas = document.createElement("canvas");
                    canvas.width = outputWidth;
                    canvas.height = outputHeight;
                    var context = canvas.getContext("2d");
                    context.fillStyle = this._container.style.backgroundColor;
                    context.fillRect(0, 0, outputWidth, outputHeight);
                    context.drawImage(this._target.context.canvas, bounds.x, bounds.y, bounds.w, bounds.h, 0, 0, outputWidth, outputHeight);
                    return new GFX.ScreenShot(canvas.toDataURL('image/png'), outputWidth, outputHeight, pixelRatio);
                };
                Canvas2DRenderer._initializedCaches = false;
                Canvas2DRenderer._debugPoints = Point.createEmptyPoints(4);
                return Canvas2DRenderer;
            }(GFX.Renderer));
            Canvas2D.Canvas2DRenderer = Canvas2DRenderer;
        })(Canvas2D = GFX.Canvas2D || (GFX.Canvas2D = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var assert = Shumway.Debug.assert;
        var Point = GFX.Geometry.Point;
        var Matrix = GFX.Geometry.Matrix;
        var Rectangle = GFX.Geometry.Rectangle;
        var UIState = /** @class */ (function () {
            function UIState() {
            }
            UIState.prototype.onMouseUp = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onMouseDown = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onMouseMove = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onMouseWheel = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onMouseClick = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onKeyUp = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onKeyDown = function (easel, event) {
                easel.state = this;
            };
            UIState.prototype.onKeyPress = function (easel, event) {
                easel.state = this;
            };
            return UIState;
        }());
        GFX.UIState = UIState;
        var StartState = /** @class */ (function (_super) {
            __extends(StartState, _super);
            function StartState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._keyCodes = [];
                return _this;
            }
            StartState.prototype.onMouseDown = function (easel, event) {
                if (event.altKey) {
                    easel.state = new DragState(easel.worldView, easel.getMousePosition(event, null), easel.worldView.getTransform().getMatrix(true));
                }
                else {
                    //        easel.state = new MouseDownState();
                }
            };
            StartState.prototype.onMouseClick = function (easel, event) {
            };
            StartState.prototype.onKeyDown = function (easel, event) {
                this._keyCodes[event.keyCode] = true;
            };
            StartState.prototype.onKeyUp = function (easel, event) {
                this._keyCodes[event.keyCode] = false;
            };
            return StartState;
        }(UIState));
        function normalizeWheelSpeed(event) {
            var normalized;
            if (event.wheelDelta) {
                normalized = (event.wheelDelta % 120 - 0) == -0 ? event.wheelDelta / 120 : event.wheelDelta / 12;
            }
            else {
                var rawAmmount = event.deltaY ? event.deltaY : event.detail;
                normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);
            }
            return normalized;
        }
        var PersistentState = /** @class */ (function (_super) {
            __extends(PersistentState, _super);
            function PersistentState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._keyCodes = [];
                _this._paused = false;
                _this._mousePosition = new Point(0, 0);
                return _this;
            }
            PersistentState.prototype.onMouseMove = function (easel, event) {
                this._mousePosition = easel.getMousePosition(event, null);
                this._update(easel);
            };
            PersistentState.prototype.onMouseDown = function (easel, event) {
            };
            PersistentState.prototype.onMouseClick = function (easel, event) {
            };
            PersistentState.prototype.onMouseWheel = function (easel, event) {
                var ticks = (event.type === 'DOMMouseScroll') ? -event.detail : event.wheelDelta / 40;
                if (event.altKey) {
                    event.preventDefault();
                    var p = easel.getMousePosition(event, null);
                    var m = easel.worldView.getTransform().getMatrix(true);
                    var s = 1 + ticks / 1000;
                    m.translate(-p.x, -p.y);
                    m.scale(s, s);
                    m.translate(p.x, p.y);
                    easel.worldView.getTransform().setMatrix(m);
                }
            };
            PersistentState.prototype.onKeyPress = function (easel, event) {
                if (!event.altKey) {
                    return;
                }
                var code = event.keyCode || event.which;
                console.info("onKeyPress Code: " + code);
                switch (code) {
                    case 248:// O
                        this._paused = !this._paused;
                        event.preventDefault();
                        break;
                    case 223:// S
                        easel.toggleOption("paintRenderable");
                        event.preventDefault();
                        break;
                    case 8730:// V
                        easel.toggleOption("paintViewport");
                        event.preventDefault();
                        break;
                    case 8747:// B
                        easel.toggleOption("paintBounds");
                        event.preventDefault();
                        break;
                    case 8706:// D
                        easel.toggleOption("paintDirtyRegion");
                        event.preventDefault();
                        break;
                    case 231:// C
                        easel.toggleOption("clear");
                        event.preventDefault();
                        break;
                    case 402:// F
                        easel.toggleOption("paintFlashing");
                        event.preventDefault();
                        break;
                }
                this._update(easel);
            };
            PersistentState.prototype.onKeyDown = function (easel, event) {
                this._keyCodes[event.keyCode] = true;
                this._update(easel);
            };
            PersistentState.prototype.onKeyUp = function (easel, event) {
                this._keyCodes[event.keyCode] = false;
                this._update(easel);
            };
            PersistentState.prototype._update = function (easel) {
                easel.paused = this._paused;
                if (easel.getOption("paintViewport")) {
                    var w = GFX.viewportLoupeDiameter.value, h = GFX.viewportLoupeDiameter.value;
                    easel.viewport = new Rectangle(this._mousePosition.x - w / 2, this._mousePosition.y - h / 2, w, h);
                }
                else {
                    easel.viewport = null;
                }
            };
            return PersistentState;
        }(UIState));
        var MouseDownState = /** @class */ (function (_super) {
            __extends(MouseDownState, _super);
            function MouseDownState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._startTime = Date.now();
                return _this;
            }
            MouseDownState.prototype.onMouseMove = function (easel, event) {
                if (Date.now() - this._startTime < 10) {
                    return;
                }
                var node = easel.queryNodeUnderMouse(event);
                if (node) {
                    easel.state = new DragState(node, easel.getMousePosition(event, null), node.getTransform().getMatrix(true));
                }
            };
            MouseDownState.prototype.onMouseUp = function (easel, event) {
                easel.state = new StartState();
                easel.selectNodeUnderMouse(event);
            };
            return MouseDownState;
        }(UIState));
        var DragState = /** @class */ (function (_super) {
            __extends(DragState, _super);
            function DragState(target, startPosition, startMatrix) {
                var _this = _super.call(this) || this;
                _this._target = target;
                _this._startPosition = startPosition;
                _this._startMatrix = startMatrix;
                return _this;
            }
            DragState.prototype.onMouseMove = function (easel, event) {
                event.preventDefault();
                var p = easel.getMousePosition(event, null);
                p.sub(this._startPosition);
                this._target.getTransform().setMatrix(this._startMatrix.clone().translate(p.x, p.y));
                easel.state = this;
            };
            DragState.prototype.onMouseUp = function (easel, event) {
                easel.state = new StartState();
            };
            return DragState;
        }(UIState));
        var Easel = /** @class */ (function () {
            function Easel(container, disableHiDPI, backgroundColor) {
                if (disableHiDPI === void 0) { disableHiDPI = false; }
                if (backgroundColor === void 0) { backgroundColor = undefined; }
                this._state = new StartState();
                this._persistentState = new PersistentState();
                this.paused = false;
                this.viewport = null;
                this._selectedNodes = [];
                this._isRendering = false;
                this._rAF = undefined;
                this._eventListeners = Object.create(null);
                this._fullScreen = false;
                release || assert(container && container.children.length === 0, "Easel container must be empty.");
                this._container = container;
                this._stage = new GFX.Stage(512, 512, false);
                this._worldView = this._stage.content;
                this._world = new GFX.Group();
                this._worldView.addChild(this._world);
                this._disableHiDPI = disableHiDPI;
                // Create stage container.
                var stageContainer = document.createElement("div");
                stageContainer.style.position = "absolute";
                stageContainer.style.width = "100%";
                stageContainer.style.height = "100%";
                stageContainer.style.zIndex = "0";
                container.appendChild(stageContainer);
                // Create hud container, that lives on top of the stage.
                if (GFX.hud.value && Shumway.Tools) {
                    var hudContainer = document.createElement("div");
                    hudContainer.style.position = "absolute";
                    hudContainer.style.width = "100%";
                    hudContainer.style.height = "100%";
                    hudContainer.style.pointerEvents = "none";
                    var fpsContainer = document.createElement("div");
                    fpsContainer.style.position = "absolute";
                    fpsContainer.style.width = "100%";
                    fpsContainer.style.height = "20px";
                    fpsContainer.style.pointerEvents = "none";
                    hudContainer.appendChild(fpsContainer);
                    container.appendChild(hudContainer);
                    this._fps = new Shumway.Tools.Mini.FPS(fpsContainer);
                }
                else {
                    this._fps = null;
                }
                var transparent = backgroundColor === 0;
                this.transparent = transparent;
                var cssBackgroundColor = backgroundColor === undefined ? "#14171a" :
                    backgroundColor === 0 ? 'transparent' :
                        Shumway.ColorUtilities.rgbaToCSSStyle(backgroundColor);
                this._options = new GFX.Canvas2D.Canvas2DRendererOptions();
                this._options.alpha = transparent;
                this._renderer = new GFX.Canvas2D.Canvas2DRenderer(stageContainer, this._stage, this._options);
                this._listenForContainerSizeChanges();
                this._onMouseUp = this._onMouseUp.bind(this);
                this._onMouseDown = this._onMouseDown.bind(this);
                this._onMouseMove = this._onMouseMove.bind(this);
                var self = this;
                window.addEventListener("mouseup", function (event) {
                    self._state.onMouseUp(self, event);
                    self._render();
                }, false);
                window.addEventListener("mousemove", function (event) {
                    self._state.onMouseMove(self, event);
                    self._persistentState.onMouseMove(self, event);
                }, false);
                function handleMouseWheel(event) {
                    self._state.onMouseWheel(self, event);
                    self._persistentState.onMouseWheel(self, event);
                }
                window.addEventListener('DOMMouseScroll', handleMouseWheel);
                window.addEventListener("mousewheel", handleMouseWheel);
                container.addEventListener("mousedown", function (event) {
                    self._state.onMouseDown(self, event);
                });
                window.addEventListener("keydown", function (event) {
                    self._state.onKeyDown(self, event);
                    if (self._state !== self._persistentState) {
                        self._persistentState.onKeyDown(self, event);
                    }
                }, false);
                window.addEventListener("keypress", function (event) {
                    self._state.onKeyPress(self, event);
                    if (self._state !== self._persistentState) {
                        self._persistentState.onKeyPress(self, event);
                    }
                }, false);
                window.addEventListener("keyup", function (event) {
                    self._state.onKeyUp(self, event);
                    if (self._state !== self._persistentState) {
                        self._persistentState.onKeyUp(self, event);
                    }
                }, false);
            }
            Easel.prototype._listenForContainerSizeChanges = function () {
                var pollInterval = 1000;
                var w = this._containerWidth;
                var h = this._containerHeight;
                this._onContainerSizeChanged();
                var self = this;
                setInterval(function () {
                    if (w !== self._containerWidth || h !== self._containerHeight) {
                        self._onContainerSizeChanged();
                        w = self._containerWidth;
                        h = self._containerHeight;
                    }
                }, pollInterval);
            };
            Easel.prototype._onContainerSizeChanged = function () {
                var ratio = this.getRatio();
                var sw = Math.ceil(this._containerWidth * ratio);
                var sh = Math.ceil(this._containerHeight * ratio);
                this._stage.setBounds(new Rectangle(0, 0, sw, sh));
                this._stage.content.setBounds(new Rectangle(0, 0, sw, sh));
                this._worldView.getTransform().setMatrix(new Matrix(ratio, 0, 0, ratio, 0, 0));
                this._dispatchEvent('resize');
            };
            /**
             * Primitive event dispatching features.
             */
            Easel.prototype.addEventListener = function (type, listener) {
                if (!this._eventListeners[type]) {
                    this._eventListeners[type] = [];
                }
                this._eventListeners[type].push(listener);
            };
            Easel.prototype._dispatchEvent = function (type) {
                var listeners = this._eventListeners[type];
                if (!listeners) {
                    return;
                }
                for (var i = 0; i < listeners.length; i++) {
                    listeners[i]();
                }
            };
            Easel.prototype.startRendering = function () {
                if (this._isRendering) {
                    return;
                }
                this._isRendering = true;
                var self = this;
                this._rAF = requestAnimationFrame(function tick() {
                    self.render();
                    self._rAF = requestAnimationFrame(tick);
                });
            };
            Easel.prototype.stopRendering = function () {
                if (this._isRendering) {
                    this._isRendering = false;
                    cancelAnimationFrame(this._rAF);
                }
            };
            Object.defineProperty(Easel.prototype, "state", {
                set: function (state) {
                    this._state = state;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Easel.prototype, "cursor", {
                set: function (cursor) {
                    this._container.style.cursor = cursor;
                },
                enumerable: true,
                configurable: true
            });
            Easel.prototype._render = function () {
                GFX.RenderableVideo.checkForVideoUpdates();
                var mustRender = (this._stage.readyToRender() || GFX.forcePaint.value) && !this.paused;
                var renderTime = 0;
                if (mustRender) {
                    var renderer = this._renderer;
                    if (this.viewport) {
                        renderer.viewport = this.viewport;
                    }
                    else {
                        renderer.viewport = this._stage.getBounds();
                    }
                    this._dispatchEvent("render");
                    GFX.enterTimeline("Render");
                    renderTime = performance.now();
                    renderer.render();
                    renderTime = performance.now() - renderTime;
                    GFX.leaveTimeline("Render");
                }
                if (this._fps) {
                    this._fps.tickAndRender(!mustRender, renderTime);
                }
            };
            Easel.prototype.render = function () {
                this._render();
            };
            Object.defineProperty(Easel.prototype, "world", {
                get: function () {
                    return this._world;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Easel.prototype, "worldView", {
                get: function () {
                    return this._worldView;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Easel.prototype, "stage", {
                get: function () {
                    return this._stage;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Easel.prototype, "options", {
                get: function () {
                    return this._options;
                },
                enumerable: true,
                configurable: true
            });
            Easel.prototype.getDisplayParameters = function () {
                var ratio = this.getRatio();
                return {
                    stageWidth: this._containerWidth,
                    stageHeight: this._containerHeight,
                    pixelRatio: ratio,
                    screenWidth: window.screen ? window.screen.width : 640,
                    screenHeight: window.screen ? window.screen.height : 480
                };
            };
            Easel.prototype.toggleOption = function (name) {
                var option = this._options;
                option[name] = !option[name];
            };
            Easel.prototype.getOption = function (name) {
                return this._options[name];
            };
            Easel.prototype.getRatio = function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var backingStoreRatio = 1;
                var ratio = 1;
                if (devicePixelRatio !== backingStoreRatio &&
                    !this._disableHiDPI) {
                    ratio = devicePixelRatio / backingStoreRatio;
                }
                return ratio;
            };
            Object.defineProperty(Easel.prototype, "_containerWidth", {
                get: function () {
                    return this._container.clientWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Easel.prototype, "_containerHeight", {
                get: function () {
                    return this._container.clientHeight;
                },
                enumerable: true,
                configurable: true
            });
            Easel.prototype.queryNodeUnderMouse = function (event) {
                return this._world;
            };
            Easel.prototype.selectNodeUnderMouse = function (event) {
                var frame = this.queryNodeUnderMouse(event);
                if (frame) {
                    this._selectedNodes.push(frame);
                }
                this._render();
            };
            Easel.prototype.getMousePosition = function (event, coordinateSpace) {
                var container = this._container;
                var bRect = container.getBoundingClientRect();
                var ratio = this.getRatio();
                var x = ratio * (event.clientX - bRect.left) * (container.scrollWidth / bRect.width);
                var y = ratio * (event.clientY - bRect.top) * (container.scrollHeight / bRect.height);
                var p = new Point(x, y);
                if (!coordinateSpace) {
                    return p;
                }
                var m = Matrix.createIdentity();
                coordinateSpace.getTransform().getConcatenatedMatrix().inverse(m);
                m.transformPoint(p);
                return p;
            };
            Easel.prototype.getMouseWorldPosition = function (event) {
                return this.getMousePosition(event, this._world);
            };
            Easel.prototype._onMouseDown = function (event) {
                // this._renderers.forEach(renderer => renderer.render());
            };
            Easel.prototype._onMouseUp = function (event) {
            };
            Easel.prototype._onMouseMove = function (event) {
            };
            Easel.prototype.screenShot = function (bounds, stageContent, disableHidpi) {
                return this._renderer.screenShot(bounds, stageContent, disableHidpi);
            };
            return Easel;
        }());
        GFX.Easel = Easel;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Matrix = Shumway.GFX.Geometry.Matrix;
        var Layout;
        (function (Layout) {
            Layout[Layout["Simple"] = 0] = "Simple";
        })(Layout = GFX.Layout || (GFX.Layout = {}));
        var TreeRendererOptions = /** @class */ (function (_super) {
            __extends(TreeRendererOptions, _super);
            function TreeRendererOptions() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.layout = 0 /* Simple */;
                return _this;
            }
            return TreeRendererOptions;
        }(GFX.RendererOptions));
        GFX.TreeRendererOptions = TreeRendererOptions;
        var TreeRenderer = /** @class */ (function (_super) {
            __extends(TreeRenderer, _super);
            function TreeRenderer(container, stage, options) {
                if (options === void 0) { options = new TreeRendererOptions(); }
                var _this = _super.call(this, container, stage, options) || this;
                _this._canvas = document.createElement("canvas");
                _this._container.appendChild(_this._canvas);
                _this._context = _this._canvas.getContext("2d");
                _this._listenForContainerSizeChanges();
                return _this;
            }
            TreeRenderer.prototype._listenForContainerSizeChanges = function () {
                var pollInterval = 10;
                var w = this._containerWidth;
                var h = this._containerHeight;
                this._onContainerSizeChanged();
                var self = this;
                setInterval(function () {
                    if (w !== self._containerWidth || h !== self._containerHeight) {
                        self._onContainerSizeChanged();
                        w = self._containerWidth;
                        h = self._containerHeight;
                    }
                }, pollInterval);
            };
            TreeRenderer.prototype._getRatio = function () {
                var devicePixelRatio = window.devicePixelRatio || 1;
                var backingStoreRatio = 1;
                var ratio = 1;
                if (devicePixelRatio !== backingStoreRatio) {
                    ratio = devicePixelRatio / backingStoreRatio;
                }
                return ratio;
            };
            TreeRenderer.prototype._onContainerSizeChanged = function () {
                var ratio = this._getRatio();
                var w = Math.ceil(this._containerWidth * ratio);
                var h = Math.ceil(this._containerHeight * ratio);
                var canvas = this._canvas;
                if (ratio > 0) {
                    canvas.width = w * ratio;
                    canvas.height = h * ratio;
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                }
                else {
                    canvas.width = w;
                    canvas.height = h;
                }
            };
            Object.defineProperty(TreeRenderer.prototype, "_containerWidth", {
                get: function () {
                    return this._container.clientWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TreeRenderer.prototype, "_containerHeight", {
                get: function () {
                    return this._container.clientHeight;
                },
                enumerable: true,
                configurable: true
            });
            TreeRenderer.prototype.render = function () {
                var context = this._context;
                context.save();
                context.clearRect(0, 0, this._canvas.width, this._canvas.height);
                context.scale(1, 1);
                if (this._options.layout === 0 /* Simple */) {
                    this._renderNodeSimple(this._context, this._stage, Matrix.createIdentity());
                }
                context.restore();
            };
            TreeRenderer.prototype._renderNodeSimple = function (context, root, transform) {
                var self = this;
                context.save();
                var fontHeight = 16;
                context.font = fontHeight + "px Arial";
                context.fillStyle = "white";
                var x = 0, y = 0;
                var w = 20, h = fontHeight, hPadding = 2, wColPadding = 8;
                var colX = 0;
                var maxX = 0;
                function visit(node) {
                    var children = node.getChildren();
                    if (node.hasFlags(4096 /* Dirty */)) {
                        context.fillStyle = "red";
                    }
                    else {
                        context.fillStyle = "white";
                    }
                    var l = String(node.id);
                    if (node instanceof GFX.RenderableText) {
                        l = "T" + l;
                    }
                    else if (node instanceof GFX.RenderableShape) {
                        l = "S" + l;
                    }
                    else if (node instanceof GFX.RenderableBitmap) {
                        l = "B" + l;
                    }
                    else if (node instanceof GFX.RenderableVideo) {
                        l = "V" + l;
                    }
                    if (node instanceof GFX.Renderable) {
                        l = l + " [" + node._parents.length + "]";
                    }
                    var t = context.measureText(l).width;
                    // context.fillRect(x, y, t, h);
                    context.fillText(l, x, y);
                    if (children) {
                        x += t + 4;
                        maxX = Math.max(maxX, x + w);
                        for (var i = 0; i < children.length; i++) {
                            visit(children[i]);
                            if (i < children.length - 1) {
                                y += h + hPadding;
                                if (y > self._canvas.height) {
                                    context.fillStyle = "gray";
                                    // context.fillRect(maxX + 4, 0, 2, self._canvas.height);
                                    x = x - colX + maxX + wColPadding;
                                    colX = maxX + wColPadding;
                                    y = 0;
                                    context.fillStyle = "white";
                                }
                            }
                        }
                        x -= t + 4;
                    }
                }
                visit(root);
                context.restore();
            };
            return TreeRenderer;
        }(GFX.Renderer));
        GFX.TreeRenderer = TreeRenderer;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Remoting;
    (function (Remoting) {
        var GFX;
        (function (GFX) {
            var BlurFilter = Shumway.GFX.BlurFilter;
            var DropshadowFilter = Shumway.GFX.DropshadowFilter;
            var Shape = Shumway.GFX.Shape;
            var Group = Shumway.GFX.Group;
            var RenderableShape = Shumway.GFX.RenderableShape;
            var RenderableMorphShape = Shumway.GFX.RenderableMorphShape;
            var RenderableBitmap = Shumway.GFX.RenderableBitmap;
            var RenderableVideo = Shumway.GFX.RenderableVideo;
            var RenderableText = Shumway.GFX.RenderableText;
            var ColorMatrix = Shumway.GFX.ColorMatrix;
            var ShapeData = Shumway.ShapeData;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var Stage = Shumway.GFX.Stage;
            var Matrix = Shumway.GFX.Geometry.Matrix;
            var Rectangle = Shumway.GFX.Geometry.Rectangle;
            var assert = Shumway.Debug.assert;
            var writer = null; // new IndentingWriter();
            var GFXChannelSerializer = /** @class */ (function () {
                function GFXChannelSerializer() {
                }
                GFXChannelSerializer.prototype.writeMouseEvent = function (event, point) {
                    var output = this.output;
                    output.writeInt(300 /* MouseEvent */);
                    var typeId = Shumway.Remoting.MouseEventNames.indexOf(event.type);
                    output.writeInt(typeId);
                    output.writeFloat(point.x);
                    output.writeFloat(point.y);
                    output.writeInt(event.buttons);
                    var flags = (event.ctrlKey ? 1 /* CtrlKey */ : 0) |
                        (event.altKey ? 2 /* AltKey */ : 0) |
                        (event.shiftKey ? 4 /* ShiftKey */ : 0);
                    output.writeInt(flags);
                };
                GFXChannelSerializer.prototype.writeKeyboardEvent = function (event) {
                    var output = this.output;
                    output.writeInt(301 /* KeyboardEvent */);
                    var typeId = Shumway.Remoting.KeyboardEventNames.indexOf(event.type);
                    output.writeInt(typeId);
                    output.writeInt(event.keyCode);
                    output.writeInt(event.charCode);
                    output.writeInt(event.location);
                    var flags = (event.ctrlKey ? 1 /* CtrlKey */ : 0) |
                        (event.altKey ? 2 /* AltKey */ : 0) |
                        (event.shiftKey ? 4 /* ShiftKey */ : 0);
                    output.writeInt(flags);
                };
                GFXChannelSerializer.prototype.writeFocusEvent = function (type) {
                    var output = this.output;
                    output.writeInt(302 /* FocusEvent */);
                    output.writeInt(type);
                };
                return GFXChannelSerializer;
            }());
            GFX.GFXChannelSerializer = GFXChannelSerializer;
            var GFXChannelDeserializerContext = /** @class */ (function () {
                function GFXChannelDeserializerContext(easelHost, root, transparent) {
                    var stage = this.stage = new Stage(128, 512);
                    if (typeof registerInspectorStage !== "undefined") {
                        registerInspectorStage(stage);
                    }
                    function updateStageBounds(node) {
                        var stageBounds = node.getBounds(true);
                        // Easel stage is the root stage and is not scaled, our stage is so
                        // we need to scale down.
                        var ratio = easelHost.easel.getRatio();
                        stageBounds.scale(1 / ratio, 1 / ratio);
                        stageBounds.snap();
                        stage.setBounds(stageBounds);
                    }
                    updateStageBounds(easelHost.stage);
                    easelHost.stage.addEventListener(1 /* OnStageBoundsChanged */, updateStageBounds);
                    easelHost.content = stage.content;
                    if (transparent) {
                        this.stage.setFlags(2 /* Transparent */);
                    }
                    root.addChild(this.stage);
                    this._nodes = [];
                    this._assets = [];
                    this._easelHost = easelHost;
                    this._canvas = document.createElement("canvas");
                    this._context = this._canvas.getContext("2d");
                }
                GFXChannelDeserializerContext.prototype._registerAsset = function (id, symbolId, asset) {
                    if (typeof registerInspectorAsset !== "undefined") {
                        registerInspectorAsset(id, symbolId, asset);
                    }
                    if (!release && this._assets[id]) {
                        Shumway.Debug.warning("Asset already exists: " + id + ". old:", this._assets[id], "new: " + asset);
                    }
                    this._assets[id] = asset;
                };
                GFXChannelDeserializerContext.prototype._makeNode = function (id) {
                    if (id === -1) {
                        return null;
                    }
                    var node = null;
                    if (id & 134217728 /* Asset */) {
                        id &= ~134217728 /* Asset */;
                        node = this._assets[id].wrap();
                    }
                    else {
                        node = this._nodes[id];
                    }
                    release || assert(node, "Node " + node + " of " + id + " has not been sent yet.");
                    return node;
                };
                GFXChannelDeserializerContext.prototype._getAsset = function (id) {
                    return this._assets[id];
                };
                GFXChannelDeserializerContext.prototype._getBitmapAsset = function (id) {
                    return this._assets[id];
                };
                GFXChannelDeserializerContext.prototype._getVideoAsset = function (id) {
                    return this._assets[id];
                };
                GFXChannelDeserializerContext.prototype._getTextAsset = function (id) {
                    return this._assets[id];
                };
                GFXChannelDeserializerContext.prototype.registerFont = function (syncId, data, resolve) {
                    Shumway.registerCSSFont(syncId, data, !inFirefox);
                    if (inFirefox) {
                        resolve(null);
                    }
                    else {
                        window.setTimeout(resolve, 400);
                    }
                };
                GFXChannelDeserializerContext.prototype.registerImage = function (syncId, symbolId, imageType, data, alphaData, resolve) {
                    this._registerAsset(syncId, symbolId, this._decodeImage(imageType, data, alphaData, resolve));
                };
                GFXChannelDeserializerContext.prototype.registerVideo = function (syncId) {
                    this._registerAsset(syncId, 0, new RenderableVideo(syncId, this));
                };
                /**
                 * Creates an Image element to decode JPG|PNG|GIF data passed in as a buffer.
                 *
                 * The resulting image is stored as the drawing source of a new RenderableBitmap, which is
                 * returned.
                 * Once the image is loaded, the RenderableBitmap's bounds are updated and the provided
                 * oncomplete callback is invoked with the image dimensions.
                 */
                GFXChannelDeserializerContext.prototype._decodeImage = function (type, data, alphaData, oncomplete) {
                    var image = new Image();
                    var asset = RenderableBitmap.FromImage(image, -1, -1);
                    image.src = URL.createObjectURL(new Blob([data], { type: Shumway.getMIMETypeForImageType(type) }));
                    image.onload = function () {
                        release || assert(!asset.parent);
                        asset.setBounds(new Rectangle(0, 0, image.width, image.height));
                        if (alphaData) {
                            asset.mask(alphaData);
                        }
                        asset.invalidate();
                        oncomplete({ width: image.width, height: image.height });
                    };
                    image.onerror = function () {
                        oncomplete(null);
                    };
                    return asset;
                };
                GFXChannelDeserializerContext.prototype.sendVideoPlaybackEvent = function (assetId, eventType, data) {
                    this._easelHost.sendVideoPlaybackEvent(assetId, eventType, data);
                };
                return GFXChannelDeserializerContext;
            }());
            GFX.GFXChannelDeserializerContext = GFXChannelDeserializerContext;
            var GFXChannelDeserializer = /** @class */ (function () {
                function GFXChannelDeserializer() {
                }
                GFXChannelDeserializer.prototype.read = function () {
                    var tag = 0;
                    var input = this.input;
                    var data = {
                        bytesAvailable: input.bytesAvailable,
                        updateGraphics: 0,
                        updateBitmapData: 0,
                        updateTextContent: 0,
                        updateFrame: 0,
                        updateStage: 0,
                        updateCurrentMouseTarget: 0,
                        updateNetStream: 0,
                        registerFont: 0,
                        drawToBitmap: 0,
                        requestBitmapData: 0,
                        decodeImage: 0
                    };
                    Shumway.GFX.enterTimeline("GFXChannelDeserializer.read", data);
                    while (input.bytesAvailable > 0) {
                        tag = input.readInt();
                        switch (tag) {
                            case 0 /* EOF */:
                                Shumway.GFX.leaveTimeline("GFXChannelDeserializer.read");
                                return;
                            case 101 /* UpdateGraphics */:
                                data.updateGraphics++;
                                this._readUpdateGraphics();
                                break;
                            case 102 /* UpdateBitmapData */:
                                data.updateBitmapData++;
                                this._readUpdateBitmapData();
                                break;
                            case 103 /* UpdateTextContent */:
                                data.updateTextContent++;
                                this._readUpdateTextContent();
                                break;
                            case 100 /* UpdateFrame */:
                                data.updateFrame++;
                                this._readUpdateFrame();
                                break;
                            case 104 /* UpdateStage */:
                                data.updateStage++;
                                this._readUpdateStage();
                                break;
                            case 107 /* UpdateCurrentMouseTarget */:
                                data.updateCurrentMouseTarget++;
                                this._readUpdateCurrentMouseTarget();
                                break;
                            case 105 /* UpdateNetStream */:
                                data.updateNetStream++;
                                this._readUpdateNetStream();
                                break;
                            case 200 /* DrawToBitmap */:
                                data.drawToBitmap++;
                                this._readDrawToBitmap();
                                break;
                            case 106 /* RequestBitmapData */:
                                data.requestBitmapData++;
                                this._readRequestBitmapData();
                                break;
                            default:
                                release || assert(false, 'Unknown MessageReader tag: ' + tag);
                                break;
                        }
                    }
                    Shumway.GFX.leaveTimeline("GFXChannelDeserializer.read");
                };
                GFXChannelDeserializer.prototype._readMatrix = function () {
                    var input = this.input;
                    var matrix = GFXChannelDeserializer._temporaryReadMatrix;
                    var a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0;
                    switch (input.readInt()) {
                        case 1 /* ScaleAndTranslationOnly */:
                            a = input.readFloat();
                            d = input.readFloat(); // Fallthrough
                        case 0 /* TranslationOnly */:
                            tx = input.readFloat() / 20;
                            ty = input.readFloat() / 20;
                            break;
                        case 2 /* UniformScaleAndTranslationOnly */:
                            a = d = input.readFloat();
                            tx = input.readFloat() / 20;
                            ty = input.readFloat() / 20;
                            break;
                        case 3 /* All */:
                            a = input.readFloat();
                            b = input.readFloat();
                            c = input.readFloat();
                            d = input.readFloat();
                            tx = input.readFloat() / 20;
                            ty = input.readFloat() / 20;
                            break;
                    }
                    matrix.setElements(a, b, c, d, tx, ty);
                    return matrix;
                };
                GFXChannelDeserializer.prototype._readRectangle = function () {
                    var input = this.input;
                    var rectangle = GFXChannelDeserializer._temporaryReadRectangle;
                    rectangle.setElements(input.readInt() / 20, input.readInt() / 20, input.readInt() / 20, input.readInt() / 20);
                    return rectangle;
                };
                GFXChannelDeserializer.prototype._readColorMatrix = function () {
                    var input = this.input;
                    var colorMatrix = GFXChannelDeserializer._temporaryReadColorMatrix;
                    var rm = 1, gm = 1, bm = 1, am = 1;
                    var ro = 0, go = 0, bo = 0, ao = 0;
                    switch (input.readInt()) {
                        case 0 /* Identity */:
                            return GFXChannelDeserializer._temporaryReadColorMatrixIdentity;
                            break;
                        case 1 /* AlphaMultiplierOnly */:
                            am = input.readFloat();
                            break;
                        case 2 /* AlphaMultiplierWithOffsets */:
                            rm = 0;
                            gm = 0;
                            bm = 0;
                            am = input.readFloat();
                            ro = input.readInt();
                            go = input.readInt();
                            bo = input.readInt();
                            ao = input.readInt();
                            break;
                        case 3 /* All */:
                            rm = input.readFloat();
                            gm = input.readFloat();
                            bm = input.readFloat();
                            am = input.readFloat();
                            ro = input.readInt();
                            go = input.readInt();
                            bo = input.readInt();
                            ao = input.readInt();
                            break;
                    }
                    colorMatrix.setMultipliersAndOffsets(rm, gm, bm, am, ro, go, bo, ao);
                    return colorMatrix;
                };
                GFXChannelDeserializer.prototype._readAsset = function () {
                    var assetId = this.input.readInt();
                    var asset = this.inputAssets[assetId];
                    this.inputAssets[assetId] = null;
                    return asset;
                };
                GFXChannelDeserializer.prototype._readUpdateGraphics = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getAsset(id);
                    var bounds = this._readRectangle();
                    var pathData = ShapeData.FromPlainObject(this._readAsset());
                    var numTextures = input.readInt();
                    var textures = [];
                    for (var i = 0; i < numTextures; i++) {
                        var bitmapId = input.readInt();
                        textures.push(context._getBitmapAsset(bitmapId));
                    }
                    if (asset) {
                        asset.update(pathData, textures, bounds);
                    }
                    else {
                        var renderable = void 0;
                        if (pathData.morphCoordinates) {
                            renderable = new RenderableMorphShape(id, pathData, textures, bounds);
                        }
                        else {
                            renderable = new RenderableShape(id, pathData, textures, bounds);
                        }
                        for (var i = 0; i < textures.length; i++) {
                            textures[i] && textures[i].addRenderableParent(renderable);
                        }
                        context._registerAsset(id, symbolId, renderable);
                    }
                };
                GFXChannelDeserializer.prototype._readUpdateBitmapData = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getBitmapAsset(id);
                    var bounds = this._readRectangle();
                    var type = input.readInt();
                    var dataBuffer = DataBuffer.FromPlainObject(this._readAsset());
                    if (!asset) {
                        asset = RenderableBitmap.FromDataBuffer(type, dataBuffer, bounds);
                        context._registerAsset(id, symbolId, asset);
                    }
                    else {
                        asset.updateFromDataBuffer(type, dataBuffer);
                    }
                    if (this.output) {
                        // TODO: Write image data to output.
                    }
                };
                GFXChannelDeserializer.prototype._readUpdateTextContent = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var symbolId = input.readInt();
                    var asset = context._getTextAsset(id);
                    var bounds = this._readRectangle();
                    var matrix = this._readMatrix();
                    var backgroundColor = input.readInt();
                    var borderColor = input.readInt();
                    var autoSize = input.readInt();
                    var wordWrap = input.readBoolean();
                    var scrollV = input.readInt();
                    var scrollH = input.readInt();
                    var plainText = this._readAsset();
                    var textRunData = DataBuffer.FromPlainObject(this._readAsset());
                    var coords = null;
                    var numCoords = input.readInt();
                    if (numCoords) {
                        coords = new DataBuffer(numCoords * 4);
                        input.readBytes(coords, 0, numCoords * 4);
                    }
                    if (!asset) {
                        asset = new RenderableText(bounds);
                        asset.setContent(plainText, textRunData, matrix, coords);
                        asset.setStyle(backgroundColor, borderColor, scrollV, scrollH);
                        asset.reflow(autoSize, wordWrap);
                        context._registerAsset(id, symbolId, asset);
                    }
                    else {
                        asset.setBounds(bounds);
                        asset.setContent(plainText, textRunData, matrix, coords);
                        asset.setStyle(backgroundColor, borderColor, scrollV, scrollH);
                        asset.reflow(autoSize, wordWrap);
                    }
                    if (this.output) {
                        var rect = asset.textRect;
                        this.output.writeInt(rect.w * 20);
                        this.output.writeInt(rect.h * 20);
                        this.output.writeInt(rect.x * 20);
                        var lines = asset.lines;
                        var numLines = lines.length;
                        this.output.writeInt(numLines);
                        for (var i = 0; i < numLines; i++) {
                            this._writeLineMetrics(lines[i]);
                        }
                    }
                };
                GFXChannelDeserializer.prototype._writeLineMetrics = function (line) {
                    release || assert(this.output);
                    this.output.writeInt(line.x);
                    this.output.writeInt(line.width);
                    this.output.writeInt(line.ascent);
                    this.output.writeInt(line.descent);
                    this.output.writeInt(line.leading);
                };
                GFXChannelDeserializer.prototype._readUpdateStage = function () {
                    var context = this.context;
                    var id = this.input.readInt();
                    if (!context._nodes[id]) {
                        context._nodes[id] = context.stage.content;
                    }
                    var color = this.input.readInt();
                    var bounds = this._readRectangle();
                    // TODO: Need to updateContentMatrix on stage here.
                    context.stage.content.setBounds(bounds);
                    context.stage.color = Shumway.Color.FromARGB(color);
                    context.stage.align = this.input.readInt();
                    context.stage.scaleMode = this.input.readInt();
                    var displayState = this.input.readInt();
                    context._easelHost.fullscreen = displayState === 0 || displayState === 1;
                };
                GFXChannelDeserializer.prototype._readUpdateCurrentMouseTarget = function () {
                    var context = this.context;
                    var currentMouseTarget = this.input.readInt();
                    var cursor = this.input.readInt();
                    context._easelHost.cursor = Shumway.UI.toCSSCursor(cursor);
                };
                GFXChannelDeserializer.prototype._readUpdateNetStream = function () {
                    var context = this.context;
                    var id = this.input.readInt();
                    var asset = context._getVideoAsset(id);
                    var rectangle = this._readRectangle();
                    if (!asset) {
                        context.registerVideo(id);
                        asset = context._getVideoAsset(id);
                    }
                    asset.setBounds(rectangle);
                };
                GFXChannelDeserializer.prototype._readFilters = function (node) {
                    var input = this.input;
                    var count = input.readInt();
                    var filters = [];
                    if (count) {
                        for (var i = 0; i < count; i++) {
                            var type = input.readInt();
                            switch (type) {
                                case Remoting.FilterType.Blur:
                                    filters.push(new BlurFilter(input.readFloat(), // blurX
                                    input.readFloat(), // blurY
                                    input.readInt() // quality
                                    ));
                                    break;
                                case Remoting.FilterType.DropShadow:
                                    filters.push(new DropshadowFilter(input.readFloat(), // alpha
                                    input.readFloat(), // angle
                                    input.readFloat(), // blurX
                                    input.readFloat(), // blurY
                                    input.readInt(), // color
                                    input.readFloat(), // distance
                                    input.readBoolean(), // hideObject
                                    input.readBoolean(), // inner
                                    input.readBoolean(), // knockout
                                    input.readInt(), // quality
                                    input.readFloat() // strength
                                    ));
                                    break;
                                case Remoting.FilterType.ColorMatrix:
                                    var matrix = new Float32Array(20);
                                    matrix[0] = input.readFloat();
                                    matrix[4] = input.readFloat();
                                    matrix[8] = input.readFloat();
                                    matrix[12] = input.readFloat();
                                    matrix[16] = input.readFloat() / 255;
                                    matrix[1] = input.readFloat();
                                    matrix[5] = input.readFloat();
                                    matrix[9] = input.readFloat();
                                    matrix[13] = input.readFloat();
                                    matrix[17] = input.readFloat() / 255;
                                    ;
                                    matrix[2] = input.readFloat();
                                    matrix[6] = input.readFloat();
                                    matrix[10] = input.readFloat();
                                    matrix[14] = input.readFloat();
                                    matrix[18] = input.readFloat() / 255;
                                    ;
                                    matrix[3] = input.readFloat();
                                    matrix[7] = input.readFloat();
                                    matrix[11] = input.readFloat();
                                    matrix[15] = input.readFloat();
                                    matrix[19] = input.readFloat() / 255;
                                    filters.push(new ColorMatrix(matrix));
                                    break;
                                default:
                                    Shumway.Debug.somewhatImplemented(Remoting.FilterType[type]);
                                    break;
                            }
                        }
                        node.getLayer().filters = filters;
                    }
                };
                GFXChannelDeserializer.prototype._readUpdateFrame = function () {
                    var input = this.input;
                    var context = this.context;
                    var id = input.readInt();
                    var ratio = 0;
                    writer && writer.writeLn("Receiving UpdateFrame: " + id);
                    var node = context._nodes[id];
                    if (!node) {
                        node = context._nodes[id] = new Group();
                    }
                    var hasBits = input.readInt();
                    if (hasBits & 1 /* HasMatrix */) {
                        node.getTransform().setMatrix(this._readMatrix());
                    }
                    if (hasBits & 8 /* HasColorTransform */) {
                        node.getTransform().setColorMatrix(this._readColorMatrix());
                    }
                    if (hasBits & 64 /* HasMask */) {
                        var maskId = input.readInt();
                        node.getLayer().mask = maskId >= 0 ? context._makeNode(maskId) : null;
                    }
                    if (hasBits & 128 /* HasClip */) {
                        node.clip = input.readInt();
                    }
                    if (hasBits & 32 /* HasMiscellaneousProperties */) {
                        ratio = input.readInt() / 0xffff;
                        release || assert(ratio >= 0 && ratio <= 1);
                        node.getLayer().blendMode = input.readInt();
                        this._readFilters(node);
                        node.toggleFlags(1 /* Visible */, input.readBoolean());
                        node.toggleFlags(16 /* CacheAsBitmap */, input.readBoolean());
                        node.toggleFlags(32 /* PixelSnapping */, !!input.readInt()); // TODO: support `auto`.
                        node.toggleFlags(64 /* ImageSmoothing */, !!input.readInt());
                    }
                    if (hasBits & 4 /* HasChildren */) {
                        var count = input.readInt();
                        var container = node;
                        container.clearChildren();
                        for (var i = 0; i < count; i++) {
                            var childId = input.readInt();
                            var child = context._makeNode(childId);
                            release || assert(child, "Child " + childId + " of " + id + " has not been sent yet.");
                            container.addChild(child);
                        }
                    }
                    if (ratio) {
                        var group = node;
                        var child = group.getChildren()[0];
                        if (child instanceof Shape) {
                            child.ratio = ratio;
                        }
                    }
                };
                GFXChannelDeserializer.prototype._readDrawToBitmap = function () {
                    var input = this.input;
                    var context = this.context;
                    var targetId = input.readInt();
                    var sourceId = input.readInt();
                    var hasBits = input.readInt();
                    var matrix;
                    var colorMatrix;
                    var clipRect;
                    if (hasBits & 1 /* HasMatrix */) {
                        matrix = this._readMatrix().clone();
                    }
                    else {
                        matrix = Matrix.createIdentity();
                    }
                    if (hasBits & 8 /* HasColorTransform */) {
                        colorMatrix = this._readColorMatrix();
                    }
                    if (hasBits & 16 /* HasClipRect */) {
                        clipRect = this._readRectangle();
                    }
                    var blendMode = input.readInt();
                    input.readBoolean(); // Smoothing
                    var target = context._getBitmapAsset(targetId);
                    var source = context._makeNode(sourceId);
                    if (!target) {
                        context._registerAsset(targetId, -1, RenderableBitmap.FromNode(source, matrix, colorMatrix, blendMode, clipRect));
                    }
                    else {
                        target.drawNode(source, matrix, colorMatrix, blendMode, clipRect);
                    }
                };
                GFXChannelDeserializer.prototype._readRequestBitmapData = function () {
                    var input = this.input;
                    var output = this.output;
                    var context = this.context;
                    var id = input.readInt();
                    var renderableBitmap = context._getBitmapAsset(id);
                    renderableBitmap.readImageData(output);
                };
                /**
                 * Used to avoid extra allocation, don't ever leak a reference to this object.
                 */
                GFXChannelDeserializer._temporaryReadMatrix = Matrix.createIdentity();
                /**
                 * Used to avoid extra allocation, don't ever leak a reference to this object.
                 */
                GFXChannelDeserializer._temporaryReadRectangle = Rectangle.createEmpty();
                /**
                 * Used to avoid extra allocation, don't ever leak a reference to this object.
                 */
                GFXChannelDeserializer._temporaryReadColorMatrix = ColorMatrix.createIdentity();
                GFXChannelDeserializer._temporaryReadColorMatrixIdentity = ColorMatrix.createIdentity();
                return GFXChannelDeserializer;
            }());
            GFX.GFXChannelDeserializer = GFXChannelDeserializer;
        })(GFX = Remoting.GFX || (Remoting.GFX = {}));
    })(Remoting = Shumway.Remoting || (Shumway.Remoting = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Point = Shumway.GFX.Geometry.Point;
        var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
        // Set to -1 to enable events for right button.
        GFX.ContextMenuButton = 2;
        var EaselHost = /** @class */ (function () {
            function EaselHost(easel) {
                this._easel = easel;
                var group = easel.world;
                var transparent = easel.transparent;
                this._group = group;
                this._content = null;
                this._fullscreen = false;
                this._context = new Shumway.Remoting.GFX.GFXChannelDeserializerContext(this, this._group, transparent);
                this._addEventListeners();
                Shumway.registerFallbackFont();
            }
            EaselHost.prototype.onSendUpdates = function (update, asssets) {
                throw new Error('This method is abstract');
            };
            Object.defineProperty(EaselHost.prototype, "easel", {
                get: function () {
                    return this._easel;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EaselHost.prototype, "stage", {
                get: function () {
                    return this._easel.stage;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EaselHost.prototype, "content", {
                set: function (value) {
                    this._content = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EaselHost.prototype, "cursor", {
                set: function (cursor) {
                    this._easel.cursor = cursor;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EaselHost.prototype, "fullscreen", {
                set: function (value) {
                    if (this._fullscreen !== value) {
                        this._fullscreen = value;
                        // TODO refactor to have a normal two-way communication service/api
                        // HACK for now
                        if (typeof ShumwayCom !== 'undefined' && ShumwayCom.setFullscreen) {
                            ShumwayCom.setFullscreen(value);
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            EaselHost.prototype._mouseEventListener = function (event) {
                if (event.button === GFX.ContextMenuButton) {
                    // Disable all events for right button -- usually it triggers context menu.
                    return;
                }
                // let position = this._easel.getMouseWorldPosition(event);
                var position = this._easel.getMousePosition(event, this._content);
                var point = new Point(position.x, position.y);
                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeMouseEvent(event, point);
                this.onSendUpdates(buffer, []);
            };
            EaselHost.prototype._keyboardEventListener = function (event) {
                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeKeyboardEvent(event);
                this.onSendUpdates(buffer, []);
            };
            EaselHost.prototype._addEventListeners = function () {
                var mouseEventListener = this._mouseEventListener.bind(this);
                var keyboardEventListener = this._keyboardEventListener.bind(this);
                var mouseEvents = EaselHost._mouseEvents;
                for (var i = 0; i < mouseEvents.length; i++) {
                    window.addEventListener(mouseEvents[i], mouseEventListener);
                }
                var keyboardEvents = EaselHost._keyboardEvents;
                for (var i = 0; i < keyboardEvents.length; i++) {
                    window.addEventListener(keyboardEvents[i], keyboardEventListener);
                }
                this._addFocusEventListeners();
                this._easel.addEventListener('resize', this._resizeEventListener.bind(this));
            };
            EaselHost.prototype._sendFocusEvent = function (type) {
                var buffer = new DataBuffer();
                var serializer = new Shumway.Remoting.GFX.GFXChannelSerializer();
                serializer.output = buffer;
                serializer.writeFocusEvent(type);
                this.onSendUpdates(buffer, []);
            };
            EaselHost.prototype._addFocusEventListeners = function () {
                var self = this;
                document.addEventListener('visibilitychange', function (event) {
                    self._sendFocusEvent(document.hidden ?
                        0 /* DocumentHidden */ :
                        1 /* DocumentVisible */);
                });
                window.addEventListener('focus', function (event) {
                    self._sendFocusEvent(3 /* WindowFocus */);
                });
                window.addEventListener('blur', function (event) {
                    self._sendFocusEvent(2 /* WindowBlur */);
                });
            };
            EaselHost.prototype._resizeEventListener = function () {
                this.onDisplayParameters(this._easel.getDisplayParameters());
            };
            EaselHost.prototype.onDisplayParameters = function (params) {
                throw new Error('This method is abstract');
            };
            EaselHost.prototype.processUpdates = function (updates, assets, output) {
                if (output === void 0) { output = null; }
                var deserializer = new Shumway.Remoting.GFX.GFXChannelDeserializer();
                deserializer.input = updates;
                deserializer.inputAssets = assets;
                deserializer.output = output;
                deserializer.context = this._context;
                deserializer.read();
            };
            EaselHost.prototype.processVideoControl = function (id, eventType, data) {
                var context = this._context;
                var asset = context._getVideoAsset(id);
                if (!asset) {
                    if (eventType !== 1 /* Init */) {
                        return undefined;
                    }
                    context.registerVideo(id);
                    asset = context._getVideoAsset(id);
                }
                return asset.processControlRequest(eventType, data);
            };
            EaselHost.prototype.processRegisterFont = function (syncId, data, resolve) {
                this._context.registerFont(syncId, data, resolve);
            };
            EaselHost.prototype.processRegisterImage = function (syncId, symbolId, imageType, data, alphaData, resolve) {
                this._context.registerImage(syncId, symbolId, imageType, data, alphaData, resolve);
            };
            EaselHost.prototype.processFSCommand = function (command, args) {
                if (typeof ShumwayCom !== 'undefined' && ShumwayCom.environment === ShumwayEnvironment.TEST) {
                    ShumwayCom.processFSCommand(command, args);
                }
            };
            EaselHost.prototype.processFrame = function () {
                if (typeof ShumwayCom !== 'undefined' && ShumwayCom.environment === ShumwayEnvironment.TEST) {
                    ShumwayCom.processFrame();
                }
            };
            EaselHost.prototype.onVideoPlaybackEvent = function (id, eventType, data) {
                throw new Error('This method is abstract');
            };
            EaselHost.prototype.sendVideoPlaybackEvent = function (id, eventType, data) {
                this.onVideoPlaybackEvent(id, eventType, data);
            };
            EaselHost._mouseEvents = Shumway.Remoting.MouseEventNames;
            EaselHost._keyboardEvents = Shumway.Remoting.KeyboardEventNames;
            return EaselHost;
        }());
        GFX.EaselHost = EaselHost;
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Window;
        (function (Window) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var WindowEaselHost = /** @class */ (function (_super) {
                __extends(WindowEaselHost, _super);
                function WindowEaselHost(easel, peer) {
                    var _this = _super.call(this, easel) || this;
                    _this._peer = peer;
                    _this._peer.onSyncMessage = function (msg) {
                        return this._onWindowMessage(msg, false);
                    }.bind(_this);
                    _this._peer.onAsyncMessage = function (msg) {
                        this._onWindowMessage(msg, true);
                    }.bind(_this);
                    return _this;
                }
                WindowEaselHost.prototype.onSendUpdates = function (updates, assets) {
                    var bytes = updates.getBytes();
                    this._peer.postAsyncMessage({
                        type: 'gfx',
                        updates: bytes,
                        assets: assets
                    }, [bytes.buffer]);
                };
                WindowEaselHost.prototype.onDisplayParameters = function (params) {
                    this._peer.postAsyncMessage({
                        type: 'displayParameters',
                        params: params
                    });
                };
                WindowEaselHost.prototype.onVideoPlaybackEvent = function (id, eventType, data) {
                    this._peer.postAsyncMessage({
                        type: 'videoPlayback',
                        id: id,
                        eventType: eventType,
                        data: data
                    });
                };
                WindowEaselHost.prototype._sendRegisterFontResponse = function (requestId, result) {
                    this._peer.postAsyncMessage({
                        type: 'registerFontResponse',
                        requestId: requestId,
                        result: result
                    });
                };
                WindowEaselHost.prototype._sendRegisterImageResponse = function (requestId, result) {
                    this._peer.postAsyncMessage({
                        type: 'registerImageResponse',
                        requestId: requestId,
                        result: result
                    });
                };
                WindowEaselHost.prototype._onWindowMessage = function (data, async) {
                    var result;
                    if (typeof data === 'object' && data !== null) {
                        if (data.type === 'player') {
                            var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                            if (async) {
                                this.processUpdates(updates, data.assets);
                            }
                            else {
                                var output = new DataBuffer();
                                this.processUpdates(updates, data.assets, output);
                                result = output.toPlainObject();
                            }
                        }
                        else if (data.type === 'frame') {
                            this.processFrame();
                        }
                        else if (data.type === 'videoControl') {
                            result = this.processVideoControl(data.id, data.eventType, data.data);
                        }
                        else if (data.type === 'registerFont') {
                            this.processRegisterFont(data.syncId, data.data, this._sendRegisterFontResponse.bind(this, data.requestId));
                        }
                        else if (data.type === 'registerImage') {
                            this.processRegisterImage(data.syncId, data.symbolId, data.imageType, data.data, data.alphaData, this._sendRegisterImageResponse.bind(this, data.requestId));
                        }
                        else if (data.type === 'fscommand') {
                            this.processFSCommand(data.command, data.args);
                        }
                        else {
                            // release || Debug.assertUnreachable("Unhandled remoting event " + data.type);
                        }
                    }
                    return result;
                };
                return WindowEaselHost;
            }(GFX.EaselHost));
            Window.WindowEaselHost = WindowEaselHost;
        })(Window = GFX.Window || (GFX.Window = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Test;
        (function (Test) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var PlainObjectDataBuffer = Shumway.ArrayUtilities.PlainObjectDataBuffer;
            var MovieRecordObjectType;
            (function (MovieRecordObjectType) {
                MovieRecordObjectType[MovieRecordObjectType["Undefined"] = 0] = "Undefined";
                MovieRecordObjectType[MovieRecordObjectType["Null"] = 1] = "Null";
                MovieRecordObjectType[MovieRecordObjectType["True"] = 2] = "True";
                MovieRecordObjectType[MovieRecordObjectType["False"] = 3] = "False";
                MovieRecordObjectType[MovieRecordObjectType["Number"] = 4] = "Number";
                MovieRecordObjectType[MovieRecordObjectType["String"] = 5] = "String";
                MovieRecordObjectType[MovieRecordObjectType["Array"] = 6] = "Array";
                MovieRecordObjectType[MovieRecordObjectType["Object"] = 7] = "Object";
                MovieRecordObjectType[MovieRecordObjectType["ArrayBuffer"] = 8] = "ArrayBuffer";
                MovieRecordObjectType[MovieRecordObjectType["Uint8Array"] = 9] = "Uint8Array";
                MovieRecordObjectType[MovieRecordObjectType["PlainObjectDataBufferLE"] = 10] = "PlainObjectDataBufferLE";
                MovieRecordObjectType[MovieRecordObjectType["PlainObjectDataBufferBE"] = 11] = "PlainObjectDataBufferBE";
                MovieRecordObjectType[MovieRecordObjectType["Int32Array"] = 12] = "Int32Array";
            })(MovieRecordObjectType || (MovieRecordObjectType = {}));
            function writeUint8Array(buffer, data) {
                buffer.writeInt(data.length);
                buffer.writeRawBytes(data);
            }
            // Borrowed from other frame typed arrays does not match current global
            // objects, so instanceof does not work.
            function isInstanceOfTypedArray(obj, name) {
                return ('byteLength' in obj) &&
                    ('buffer' in obj) &&
                    (obj.constructor && obj.constructor.name) === name;
            }
            function isInstanceOfArrayBuffer(obj) {
                return ('byteLength' in obj) &&
                    (obj.constructor && obj.constructor.name) === 'ArrayBuffer';
            }
            function serializeObj(obj) {
                function serialize(item) {
                    switch (typeof item) {
                        case 'undefined':
                            buffer.writeByte(MovieRecordObjectType.Undefined);
                            break;
                        case 'boolean':
                            buffer.writeByte(item ? MovieRecordObjectType.True : MovieRecordObjectType.False);
                            break;
                        case 'number':
                            buffer.writeByte(MovieRecordObjectType.Number);
                            buffer.writeDouble(item);
                            break;
                        case 'string':
                            buffer.writeByte(MovieRecordObjectType.String);
                            buffer.writeUTF(item);
                            break;
                        default:// 'object'
                            if (item === null) {
                                buffer.writeByte(MovieRecordObjectType.Null);
                                break;
                            }
                            if (Array.isArray(item)) {
                                buffer.writeByte(MovieRecordObjectType.Array);
                                buffer.writeInt(item.length);
                                for (var i = 0; i < item.length; i++) {
                                    serialize(item[i]);
                                }
                            }
                            else if (isInstanceOfTypedArray(item, 'Uint8Array')) {
                                buffer.writeByte(MovieRecordObjectType.Uint8Array);
                                writeUint8Array(buffer, item);
                            }
                            else if (('length' in item) && ('buffer' in item) && ('littleEndian' in item)) {
                                buffer.writeByte(item.littleEndian ?
                                    MovieRecordObjectType.PlainObjectDataBufferLE :
                                    MovieRecordObjectType.PlainObjectDataBufferBE);
                                writeUint8Array(buffer, new Uint8Array(item.buffer, 0, item.length));
                            }
                            else if (isInstanceOfArrayBuffer(item)) {
                                buffer.writeByte(MovieRecordObjectType.ArrayBuffer);
                                writeUint8Array(buffer, new Uint8Array(item));
                            }
                            else if (isInstanceOfTypedArray(item, 'Int32Array')) {
                                buffer.writeByte(MovieRecordObjectType.Int32Array);
                                writeUint8Array(buffer, new Uint8Array(item.buffer, item.byteOffset, item.byteLength));
                            }
                            else {
                                if (!Shumway.isNullOrUndefined(item.buffer) &&
                                    isInstanceOfArrayBuffer(item.buffer) &&
                                    (typeof item.byteOffset === 'number')) {
                                    throw new Error('Some unsupported TypedArray is used');
                                }
                                buffer.writeByte(MovieRecordObjectType.Object);
                                for (var key in item) {
                                    buffer.writeUTF(key);
                                    serialize(item[key]);
                                }
                                buffer.writeUTF('');
                            }
                            break;
                    }
                }
                var buffer = new DataBuffer();
                serialize(obj);
                return buffer.getBytes();
            }
            var MovieRecordType;
            (function (MovieRecordType) {
                MovieRecordType[MovieRecordType["None"] = 0] = "None";
                MovieRecordType[MovieRecordType["PlayerCommand"] = 1] = "PlayerCommand";
                MovieRecordType[MovieRecordType["PlayerCommandAsync"] = 2] = "PlayerCommandAsync";
                MovieRecordType[MovieRecordType["Frame"] = 3] = "Frame";
                MovieRecordType[MovieRecordType["Font"] = 4] = "Font";
                MovieRecordType[MovieRecordType["Image"] = 5] = "Image";
                MovieRecordType[MovieRecordType["FSCommand"] = 6] = "FSCommand";
            })(MovieRecordType = Test.MovieRecordType || (Test.MovieRecordType = {}));
            var MovieRecorder = /** @class */ (function () {
                function MovieRecorder(maxRecordingSize) {
                    this._maxRecordingSize = maxRecordingSize;
                    this._recording = new DataBuffer();
                    this._recordingStarted = 0;
                    this._recording.writeRawBytes(new Uint8Array([0x4D, 0x53, 0x57, 0x46]));
                    this._stopped = false;
                }
                MovieRecorder.prototype.stop = function () {
                    this._stopped = true;
                };
                MovieRecorder.prototype.getRecording = function () {
                    return new Blob([this._recording.getBytes()], { type: 'application/octet-stream' });
                };
                MovieRecorder.prototype.dump = function () {
                    var parser = new MovieRecordParser(this._recording.getBytes());
                    parser.dump();
                };
                MovieRecorder.prototype._createRecord = function (type, buffer) {
                    if (this._stopped) {
                        return;
                    }
                    if (this._recording.length + 8 + (buffer ? buffer.length : 0) >= this._maxRecordingSize) {
                        console.error('Recording limit reached');
                        this._stopped = true;
                        return;
                    }
                    if (this._recordingStarted === 0) {
                        this._recordingStarted = Date.now();
                        this._recording.writeInt(0);
                    }
                    else {
                        this._recording.writeInt(Date.now() - this._recordingStarted);
                    }
                    this._recording.writeInt(type);
                    if (buffer !== null) {
                        this._recording.writeInt(buffer.length);
                        this._recording.writeRawBytes(buffer.getBytes());
                    }
                    else {
                        this._recording.writeInt(0);
                    }
                };
                MovieRecorder.prototype.recordPlayerCommand = function (async, updates, assets) {
                    var buffer = new DataBuffer();
                    writeUint8Array(buffer, updates);
                    buffer.writeInt(assets.length);
                    assets.forEach(function (a) {
                        var data = serializeObj(a);
                        writeUint8Array(buffer, data);
                    });
                    this._createRecord(async ? 2 /* PlayerCommandAsync */ : 1 /* PlayerCommand */, buffer);
                };
                MovieRecorder.prototype.recordFrame = function () {
                    this._createRecord(3 /* Frame */, null);
                };
                MovieRecorder.prototype.recordFont = function (syncId, data) {
                    var buffer = new DataBuffer();
                    buffer.writeInt(syncId);
                    writeUint8Array(buffer, serializeObj(data));
                    this._createRecord(4 /* Font */, buffer);
                };
                MovieRecorder.prototype.recordImage = function (syncId, symbolId, imageType, data, alphaData) {
                    var buffer = new DataBuffer();
                    buffer.writeInt(syncId);
                    buffer.writeInt(symbolId);
                    buffer.writeInt(imageType);
                    writeUint8Array(buffer, serializeObj(data));
                    writeUint8Array(buffer, serializeObj(alphaData));
                    this._createRecord(5 /* Image */, buffer);
                };
                MovieRecorder.prototype.recordFSCommand = function (command, args) {
                    var buffer = new DataBuffer();
                    buffer.writeUTF(command);
                    buffer.writeUTF(args || '');
                    this._createRecord(6 /* FSCommand */, buffer);
                };
                return MovieRecorder;
            }());
            Test.MovieRecorder = MovieRecorder;
            function readUint8Array(buffer) {
                var data = new DataBuffer();
                var length = buffer.readInt();
                buffer.readBytes(data, 0, length);
                return data.getBytes();
            }
            function deserializeObj(source) {
                var buffer = new DataBuffer();
                var length = source.readInt();
                source.readBytes(buffer, 0, length);
                return deserializeObjImpl(buffer);
            }
            function deserializeObjImpl(buffer) {
                var type = buffer.readByte();
                switch (type) {
                    case MovieRecordObjectType.Undefined:
                        return undefined;
                    case MovieRecordObjectType.Null:
                        return null;
                    case MovieRecordObjectType.True:
                        return true;
                    case MovieRecordObjectType.False:
                        return false;
                    case MovieRecordObjectType.Number:
                        return buffer.readDouble();
                    case MovieRecordObjectType.String:
                        return buffer.readUTF();
                    case MovieRecordObjectType.Array:
                        var arr = [];
                        var length_8 = buffer.readInt();
                        for (var i = 0; i < length_8; i++) {
                            arr[i] = deserializeObjImpl(buffer);
                        }
                        return arr;
                    case MovieRecordObjectType.Object:
                        var obj = {};
                        var key = void 0;
                        while ((key = buffer.readUTF())) {
                            obj[key] = deserializeObjImpl(buffer);
                        }
                        return obj;
                    case MovieRecordObjectType.ArrayBuffer:
                        return readUint8Array(buffer).buffer;
                    case MovieRecordObjectType.Uint8Array:
                        return readUint8Array(buffer);
                    case MovieRecordObjectType.PlainObjectDataBufferBE:
                    case MovieRecordObjectType.PlainObjectDataBufferLE:
                        var data = readUint8Array(buffer);
                        return new PlainObjectDataBuffer(data.buffer, data.length, type === MovieRecordObjectType.PlainObjectDataBufferLE);
                    case MovieRecordObjectType.Int32Array:
                        return new Int32Array(readUint8Array(buffer).buffer);
                    default:
                        release || Shumway.Debug.assert(false);
                        return undefined;
                }
            }
            var MovieRecordParser = /** @class */ (function () {
                function MovieRecordParser(data) {
                    this._buffer = new DataBuffer();
                    this._buffer.writeRawBytes(data);
                    this._buffer.position = 4;
                }
                MovieRecordParser.prototype.readNextRecord = function () {
                    if (this._buffer.position >= this._buffer.length) {
                        return 0 /* None */;
                    }
                    var timestamp = this._buffer.readInt();
                    var type = this._buffer.readInt();
                    var length = this._buffer.readInt();
                    var data = null;
                    if (length > 0) {
                        data = new DataBuffer();
                        this._buffer.readBytes(data, 0, length);
                    }
                    this.currentTimestamp = timestamp;
                    this.currentType = type;
                    this.currentData = data;
                    return type;
                };
                MovieRecordParser.prototype.parsePlayerCommand = function () {
                    var updates = readUint8Array(this.currentData);
                    var assetsLength = this.currentData.readInt();
                    var assets = [];
                    for (var i = 0; i < assetsLength; i++) {
                        assets.push(deserializeObj(this.currentData));
                    }
                    return { updates: updates, assets: assets };
                };
                MovieRecordParser.prototype.parseFSCommand = function () {
                    var command = this.currentData.readUTF();
                    var args = this.currentData.readUTF();
                    return { command: command, args: args };
                };
                MovieRecordParser.prototype.parseFont = function () {
                    var syncId = this.currentData.readInt();
                    var data = deserializeObj(this.currentData);
                    return { syncId: syncId, data: data };
                };
                MovieRecordParser.prototype.parseImage = function () {
                    var syncId = this.currentData.readInt();
                    var symbolId = this.currentData.readInt();
                    var imageType = this.currentData.readInt();
                    var data = deserializeObj(this.currentData);
                    var alphaData = deserializeObj(this.currentData);
                    return { syncId: syncId, symbolId: symbolId, imageType: imageType, data: data, alphaData: alphaData };
                };
                MovieRecordParser.prototype.dump = function () {
                    var type;
                    while ((type = this.readNextRecord())) {
                        console.log('record ' + type + ' @' + this.currentTimestamp);
                        switch (type) {
                            case 1 /* PlayerCommand */:
                            case 2 /* PlayerCommandAsync */:
                                console.log(this.parsePlayerCommand());
                                break;
                            case 6 /* FSCommand */:
                                console.log(this.parseFSCommand());
                                break;
                            case 4 /* Font */:
                                console.log(this.parseFont());
                                break;
                            case 5 /* Image */:
                                console.log(this.parseImage());
                                break;
                        }
                    }
                };
                return MovieRecordParser;
            }());
            Test.MovieRecordParser = MovieRecordParser;
        })(Test = GFX.Test || (GFX.Test = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Test;
        (function (Test) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var MINIMAL_TIMER_INTERVAL = 5;
            var PlaybackEaselHost = /** @class */ (function (_super) {
                __extends(PlaybackEaselHost, _super);
                function PlaybackEaselHost(easel) {
                    var _this = _super.call(this, easel) || this;
                    _this.ignoreTimestamps = false;
                    _this.alwaysRenderFrame = false;
                    _this.cpuTimeUpdates = 0;
                    _this.cpuTimeRendering = 0;
                    _this.onComplete = null;
                    return _this;
                }
                Object.defineProperty(PlaybackEaselHost.prototype, "cpuTime", {
                    get: function () {
                        return this.cpuTimeUpdates + this.cpuTimeRendering;
                    },
                    enumerable: true,
                    configurable: true
                });
                PlaybackEaselHost.prototype.playUrl = function (url) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', url, true);
                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function () {
                        this.playBytes(new Uint8Array(xhr.response));
                    }.bind(this);
                    xhr.send();
                };
                PlaybackEaselHost.prototype.playBytes = function (data) {
                    this._parser = new Test.MovieRecordParser(data);
                    this._lastTimestamp = 0;
                    this._parseNext();
                };
                PlaybackEaselHost.prototype.onSendUpdates = function (updates, assets) {
                    // Ignoring
                };
                PlaybackEaselHost.prototype.onDisplayParameters = function (params) {
                    // Ignoring
                };
                PlaybackEaselHost.prototype.onVideoPlaybackEvent = function (id, eventType, data) {
                    // Ignoring
                };
                PlaybackEaselHost.prototype._parseNext = function () {
                    var type = this._parser.readNextRecord();
                    if (type !== 0 /* None */) {
                        var runRecordBound = this._runRecord.bind(this);
                        var interval = this._parser.currentTimestamp - this._lastTimestamp;
                        this._lastTimestamp = this._parser.currentTimestamp;
                        if (interval < MINIMAL_TIMER_INTERVAL) {
                            // Records are too close to each other, running on next script turn.
                            Promise.resolve(undefined).then(runRecordBound);
                        }
                        else if (this.ignoreTimestamps) {
                            setTimeout(runRecordBound);
                        }
                        else {
                            setTimeout(runRecordBound, interval);
                        }
                    }
                    else {
                        if (this.onComplete) {
                            this.onComplete();
                        }
                    }
                };
                PlaybackEaselHost.prototype._runRecord = function () {
                    var data;
                    var start = performance.now();
                    switch (this._parser.currentType) {
                        case 1 /* PlayerCommand */:
                        case 2 /* PlayerCommandAsync */:
                            data = this._parser.parsePlayerCommand();
                            var async = this._parser.currentType === 2 /* PlayerCommandAsync */;
                            var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                            if (async) {
                                this.processUpdates(updates, data.assets);
                            }
                            else {
                                var output = new DataBuffer();
                                this.processUpdates(updates, data.assets, output);
                            }
                            break;
                        case 3 /* Frame */:
                            this.processFrame();
                            break;
                        case 4 /* Font */:
                            data = this._parser.parseFont();
                            this.processRegisterFont(data.syncId, data.data, function () {
                            });
                            break;
                        case 5 /* Image */:
                            data = this._parser.parseImage();
                            this.processRegisterImage(data.syncId, data.symbolId, data.imageType, data.data, data.alphaData, function () {
                            });
                            break;
                        case 6 /* FSCommand */:
                            data = this._parser.parseFSCommand();
                            this.processFSCommand(data.command, data.args);
                            break;
                        default:
                            throw new Error('Invalid movie record type');
                    }
                    this.cpuTimeUpdates += performance.now() - start;
                    if (this._parser.currentType === 3 /* Frame */ &&
                        this.alwaysRenderFrame) {
                        requestAnimationFrame(this._renderFrameJustAfterRAF.bind(this));
                    }
                    else {
                        this._parseNext();
                    }
                };
                PlaybackEaselHost.prototype._renderFrameJustAfterRAF = function () {
                    var start = performance.now();
                    this.easel.render();
                    this.cpuTimeRendering += performance.now() - start;
                    this._parseNext();
                };
                return PlaybackEaselHost;
            }(GFX.EaselHost));
            Test.PlaybackEaselHost = PlaybackEaselHost;
        })(Test = GFX.Test || (GFX.Test = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var Test;
        (function (Test) {
            var WindowEaselHost = Shumway.GFX.Window.WindowEaselHost;
            var RecordingEaselHost = /** @class */ (function (_super) {
                __extends(RecordingEaselHost, _super);
                function RecordingEaselHost(easel, peer, recordingLimit) {
                    if (recordingLimit === void 0) { recordingLimit = 0; }
                    var _this = _super.call(this, easel, peer) || this;
                    _this._recorder = null;
                    _this._recorder = new Test.MovieRecorder(recordingLimit);
                    return _this;
                }
                Object.defineProperty(RecordingEaselHost.prototype, "recorder", {
                    get: function () {
                        return this._recorder;
                    },
                    enumerable: true,
                    configurable: true
                });
                RecordingEaselHost.prototype._onWindowMessage = function (data, async) {
                    release || Shumway.Debug.assert(typeof data === 'object' && data !== null);
                    var type = data.type;
                    switch (type) {
                        case 'player':
                            this._recorder.recordPlayerCommand(async, data.updates, data.assets);
                            break;
                        case 'frame':
                            this._recorder.recordFrame();
                            break;
                        case 'registerFont':
                            this._recorder.recordFont(data.syncId, data.data);
                            break;
                        case 'registerImage':
                            this._recorder.recordImage(data.syncId, data.symbolId, data.imageType, data.data, data.alphaData);
                            break;
                        case 'fscommand':
                            this._recorder.recordFSCommand(data.command, data.args);
                            break;
                    }
                    return _super.prototype._onWindowMessage.call(this, data, async);
                };
                return RecordingEaselHost;
            }(WindowEaselHost));
            Test.RecordingEaselHost = RecordingEaselHost;
        })(Test = GFX.Test || (GFX.Test = {}));
    })(GFX = Shumway.GFX || (Shumway.GFX = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='2d/debug.ts'/>
/// <reference path='2d/surface.ts'/>
/// <reference path='2d/2d.ts'/>
/// <reference path='easel.ts'/>
/// <reference path='debug/tree.ts'/>
/// <reference path='remotingGfx.ts' />
/// <reference path='easelHost.ts' />
/// <reference path='window/windowEaselHost.ts' />
/// <reference path='test/recorder.ts' />
/// <reference path='test/playbackEaselHost.ts' />
/// <reference path='test/recordingEaselHost.ts' />
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Player;
    (function (Player) {
        Player.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer("Player") : null;
        Player.counter = new Shumway.Metrics.Counter(!release);
        Player.writer = null; // new IndentingWriter();
        function enterTimeline(name, data) {
            Player.writer && Player.writer.enter(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.enter(name, data);
        }
        Player.enterTimeline = enterTimeline;
        function leaveTimeline(name, data) {
            Player.writer && Player.writer.leave(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.leave(name, data);
        }
        Player.leaveTimeline = leaveTimeline;
    })(Player = Shumway.Player || (Shumway.Player = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var OptionSet = Shumway.Options.OptionSet;
    var shumwayOptions = Shumway.Settings.shumwayOptions;
    Shumway.playerOptions = shumwayOptions.register(new OptionSet("Player Options"));
    Shumway.frameEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("enableFrames", "Enable Frame Execution", "boolean", true, "Enable frame execution."));
    Shumway.timerEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("enableTimers", "Enable Timers", "boolean", true, "Enable timer events."));
    Shumway.pumpEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option("enablePump", "Enable Pump", "boolean", true, "Enable display tree serialization."));
    Shumway.pumpRateOption = Shumway.playerOptions.register(new Shumway.Options.Option("pumpRate", "Pump Rate", "number", 60, "Number of times / second that the display list is synchronized.", {
        range: {
            min: 1,
            max: 120,
            step: 1
        }
    }));
    Shumway.frameRateOption = Shumway.playerOptions.register(new Shumway.Options.Option("frameRate", "Frame Rate", "number", -1, "Override a movie's frame rate, set to -1 to use the movies default frame rate.", {
        range: {
            min: -1,
            max: 120,
            step: 1
        }
    }));
    Shumway.tracePlayerOption = Shumway.playerOptions.register(new Shumway.Options.Option("tp", "Trace Player", "number", 0, "Trace player every n frames.", {
        range: {
            min: 0,
            max: 512,
            step: 1
        }
    }));
    Shumway.traceMouseEventOption = Shumway.playerOptions.register(new Shumway.Options.Option("tme", "Trace Mouse Events", "boolean", false, "Trace mouse events."));
    Shumway.frameRateMultiplierOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Frame Rate Multiplier", "number", 1, "Play frames at a faster rate.", {
        range: {
            min: 1,
            max: 16,
            step: 1
        }
    }));
    Shumway.dontSkipFramesOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Disables Frame Skipping", "boolean", false, "Play all frames, e.g. no skipping frame during throttle."));
    Shumway.playAllSymbolsOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbols", "boolean", false, "Plays all SWF symbols automatically."));
    Shumway.playSymbolOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Number", "number", 0, "Select symbol by Id.", {
        range: {
            min: 0,
            max: 20000,
            step: 1
        }
    }));
    Shumway.playSymbolFrameDurationOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Duration", "number", 0, "How many frames to play, 0 for all frames of the movie clip.", {
        range: {
            min: 0,
            max: 128,
            step: 1
        }
    }));
    Shumway.playSymbolCountOption = Shumway.playerOptions.register(new Shumway.Options.Option("", "Play Symbol Count", "number", -1, "Select symbol count.", {
        range: {
            min: -1,
            max: 20000,
            step: 1
        }
    }));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var FrameScheduler = /** @class */ (function () {
        function FrameScheduler() {
            this._expectedNextFrameAt = performance.now();
            this._drawStats = [];
            this._drawStatsSum = 0;
            this._drawStarted = 0;
            this._drawsSkipped = 0;
            this._expectedNextFrameAt = performance.now();
            this._onTime = true;
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        }
        Object.defineProperty(FrameScheduler.prototype, "shallSkipDraw", {
            get: function () {
                if (this._drawsSkipped >= FrameScheduler.MAX_DRAWS_TO_SKIP) {
                    return false;
                }
                var averageDraw = this._drawStats.length < FrameScheduler.STATS_TO_REMEMBER ? 0 :
                    this._drawStatsSum / this._drawStats.length;
                var estimatedDrawEnd = performance.now() + averageDraw;
                return estimatedDrawEnd + FrameScheduler.INTERVAL_PADDING_MS > this._expectedNextFrameAt;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameScheduler.prototype, "nextFrameIn", {
            get: function () {
                return Math.max(0, this._expectedNextFrameAt - performance.now());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameScheduler.prototype, "isOnTime", {
            get: function () {
                return this._onTime;
            },
            enumerable: true,
            configurable: true
        });
        FrameScheduler.prototype.startFrame = function (frameRate) {
            var interval = 1000 / frameRate;
            var adjustedInterval = interval;
            var delta = this._onTimeDelta + this._delta;
            if (delta !== 0) {
                if (delta < 0) {
                    adjustedInterval *= FrameScheduler.SPEED_ADJUST_RATE;
                }
                else if (delta > 0) {
                    adjustedInterval /= FrameScheduler.SPEED_ADJUST_RATE;
                }
                this._onTimeDelta += (interval - adjustedInterval);
            }
            this._expectedNextFrameAt += adjustedInterval;
            this._onTime = true;
        };
        FrameScheduler.prototype.endFrame = function () {
            var estimatedNextFrameStart = performance.now() + FrameScheduler.INTERVAL_PADDING_MS;
            if (estimatedNextFrameStart > this._expectedNextFrameAt) {
                if (this._trackDelta) {
                    this._onTimeDelta += (this._expectedNextFrameAt - estimatedNextFrameStart);
                    console.log(this._onTimeDelta);
                }
                this._expectedNextFrameAt = estimatedNextFrameStart;
                this._onTime = false;
            }
        };
        FrameScheduler.prototype.startDraw = function () {
            this._drawsSkipped = 0;
            this._drawStarted = performance.now();
        };
        FrameScheduler.prototype.endDraw = function () {
            var drawTime = performance.now() - this._drawStarted;
            this._drawStats.push(drawTime);
            this._drawStatsSum += drawTime;
            while (this._drawStats.length > FrameScheduler.STATS_TO_REMEMBER) {
                this._drawStatsSum -= this._drawStats.shift();
            }
        };
        FrameScheduler.prototype.skipDraw = function () {
            this._drawsSkipped++;
        };
        FrameScheduler.prototype.setDelta = function (value) {
            if (!this._trackDelta) {
                return;
            }
            this._delta = value;
        };
        FrameScheduler.prototype.startTrackDelta = function () {
            this._trackDelta = true;
        };
        FrameScheduler.prototype.endTrackDelta = function () {
            if (!this._trackDelta) {
                return;
            }
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        };
        FrameScheduler.STATS_TO_REMEMBER = 50;
        FrameScheduler.MAX_DRAWS_TO_SKIP = 2;
        FrameScheduler.INTERVAL_PADDING_MS = 4;
        FrameScheduler.SPEED_ADJUST_RATE = 0.9;
        return FrameScheduler;
    }());
    Shumway.FrameScheduler = FrameScheduler;
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Remoting;
    (function (Remoting) {
        var Player;
        (function (Player) {
            var flash = Shumway.flash;
            var BlendMode = flash.display.BlendMode;
            var PixelSnapping = flash.display.PixelSnapping;
            var Bounds = Shumway.Bounds;
            var MouseCursor = flash.ui.MouseCursor;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var assert = Shumway.Debug.assert;
            var writer = Shumway.Player.writer;
            var PlayerChannelSerializer = /** @class */ (function () {
                function PlayerChannelSerializer() {
                    this.phase = 0 /* Objects */;
                    this.roots = null;
                    this.output = new DataBuffer();
                    this.outputAssets = [];
                }
                PlayerChannelSerializer.prototype.remoteObjects = function () {
                    this.phase = 0 /* Objects */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline("remoting objects");
                        this.writeDirtyDisplayObjects(roots[i], false);
                        Shumway.Player.leaveTimeline("remoting objects");
                    }
                };
                PlayerChannelSerializer.prototype.remoteReferences = function () {
                    this.phase = 1 /* References */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline("remoting references");
                        this.writeDirtyDisplayObjects(roots[i], true);
                        Shumway.Player.leaveTimeline("remoting references");
                    }
                };
                PlayerChannelSerializer.prototype.writeEOF = function () {
                    this.output.writeInt(0 /* EOF */);
                };
                /**
                 * Serializes dirty display objects starting at the specified root |displayObject| node.
                 */
                PlayerChannelSerializer.prototype.writeDirtyDisplayObjects = function (displayObject, clearDirtyDescendentsFlag) {
                    var self = this;
                    var roots = this.roots;
                    displayObject.visit(function (displayObject) {
                        if (displayObject._hasAnyDirtyFlags(1023 /* Dirty */)) {
                            self.writeUpdateFrame(displayObject);
                            // Collect more roots?
                            if (roots && displayObject.mask) {
                                var root = displayObject.mask._findFurthestAncestorOrSelf();
                                Shumway.ArrayUtilities.pushUnique(roots, root);
                            }
                        }
                        // TODO: Checking if we need to write assets this way is kinda expensive, do better here.
                        self.writeDirtyAssets(displayObject);
                        var hasDirtyDescendents = displayObject._hasFlags(536870912 /* DirtyDescendents */);
                        if (hasDirtyDescendents) {
                            if (clearDirtyDescendentsFlag) {
                                // We need this flag to make sure we don't clear the flag in the first remoting pass.
                                displayObject._removeFlags(536870912 /* DirtyDescendents */);
                            }
                            return 0 /* Continue */;
                        }
                        // We can skip visiting descendents since they are not dirty.
                        return 2 /* Skip */;
                    }, 0 /* None */);
                };
                PlayerChannelSerializer.prototype.writeStage = function (stage) {
                    if (!stage._isDirty) {
                        return;
                    }
                    writer && writer.writeLn("Sending Stage");
                    var serializer = this;
                    this.output.writeInt(104 /* UpdateStage */);
                    this.output.writeInt(stage._id);
                    this.output.writeInt(stage.color);
                    this._writeRectangle(new Bounds(0, 0, stage.stageWidth * 20, stage.stageHeight * 20));
                    this.output.writeInt(flash.display.StageAlign.toNumber(stage.align));
                    this.output.writeInt(flash.display.StageScaleMode.toNumber(stage.scaleMode));
                    this.output.writeInt(flash.display.StageDisplayState.toNumber(stage.displayState));
                    stage._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeCurrentMouseTarget = function (stage, currentMouseTarget) {
                    this.output.writeInt(107 /* UpdateCurrentMouseTarget */);
                    var sec = stage._sec;
                    var Mouse = sec.ui.Mouse;
                    var cursor = Mouse._cursor;
                    if (currentMouseTarget) {
                        var SimpleButton = sec.display.SimpleButton;
                        var Sprite = sec.display.Sprite;
                        this.output.writeInt(currentMouseTarget._id);
                        if (cursor === MouseCursor.AUTO) {
                            var node = currentMouseTarget;
                            do {
                                if (SimpleButton.axIsType(node) ||
                                    (Sprite.axIsType(node) && node.buttonMode) &&
                                        currentMouseTarget.useHandCursor) {
                                    cursor = MouseCursor.BUTTON;
                                    break;
                                }
                                node = node._parent;
                            } while (node && node !== stage);
                        }
                    }
                    else {
                        this.output.writeInt(-1);
                    }
                    this.output.writeInt(MouseCursor.toNumber(cursor));
                };
                PlayerChannelSerializer.prototype.writeGraphics = function (graphics) {
                    if (!graphics._isDirty) {
                        return;
                    }
                    var textures = graphics.getUsedTextures();
                    var numTextures = textures.length;
                    for (var i = 0; i < numTextures; i++) {
                        textures[i] && this.writeBitmapData(textures[i]);
                    }
                    this.output.writeInt(101 /* UpdateGraphics */);
                    this.output.writeInt(graphics._id);
                    this.output.writeInt(-1);
                    this._writeRectangle(graphics._getContentBounds());
                    this._writeAsset(graphics.getGraphicsData().toPlainObject());
                    this.output.writeInt(numTextures);
                    for (var i = 0; i < numTextures; i++) {
                        this.output.writeInt(textures[i] ? textures[i]._id : -1);
                    }
                    graphics._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeNetStream = function (netStream, bounds) {
                    if (!netStream._isDirty) {
                        return;
                    }
                    writer && writer.writeLn("Sending NetStream: " + netStream._id);
                    this.output.writeInt(105 /* UpdateNetStream */);
                    this.output.writeInt(netStream._id);
                    this._writeRectangle(bounds);
                    netStream._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeDisplayObjectRoot = function (displayObject) {
                    release || assert(!this.roots);
                    this.roots = [displayObject];
                    this.remoteObjects();
                    this.remoteReferences();
                };
                PlayerChannelSerializer.prototype.writeBitmapData = function (bitmapData) {
                    if (!bitmapData._isDirty) {
                        return;
                    }
                    writer && writer.writeLn("Sending BitmapData: " + bitmapData._id);
                    this.output.writeInt(102 /* UpdateBitmapData */);
                    this.output.writeInt(bitmapData._id);
                    this.output.writeInt(bitmapData._symbol ? bitmapData._symbol.id : -1);
                    this._writeRectangle(bitmapData._getContentBounds());
                    this.output.writeInt(bitmapData._type);
                    this._writeAsset(bitmapData.getDataBuffer().toPlainObject());
                    bitmapData._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeTextContent = function (textContent) {
                    if (!(textContent.flags & 15 /* Dirty */)) {
                        return;
                    }
                    writer && writer.writeLn("Sending TextContent: " + textContent._id);
                    this.output.writeInt(103 /* UpdateTextContent */);
                    this.output.writeInt(textContent._id);
                    this.output.writeInt(-1);
                    this._writeRectangle(textContent.bounds);
                    var identity = textContent._sec.geom.FROZEN_IDENTITY_MATRIX;
                    this._writeMatrix(textContent.matrix || identity);
                    this.output.writeInt(textContent.backgroundColor);
                    this.output.writeInt(textContent.borderColor);
                    this.output.writeInt(textContent.autoSize);
                    this.output.writeBoolean(textContent.wordWrap);
                    this.output.writeInt(textContent.scrollV);
                    this.output.writeInt(textContent.scrollH);
                    this._writeAsset(textContent.plainText);
                    this._writeAsset(textContent.textRunData.toPlainObject());
                    var coords = textContent.coords;
                    if (coords) {
                        var numCoords = coords.length;
                        this.output.writeInt(numCoords);
                        for (var i = 0; i < numCoords; i++) {
                            this.output.writeInt(coords[i]);
                        }
                    }
                    else {
                        this.output.writeInt(0);
                    }
                    textContent.flags &= ~15 /* Dirty */;
                };
                /**
                 * Writes the number of display objects this display object clips.
                 */
                PlayerChannelSerializer.prototype.writeClippedObjectsCount = function (displayObject) {
                    if (displayObject._clipDepth > 0 && displayObject._parent) {
                        // Clips in GFX land don't use absolute clip depth numbers. Instead we need to encode
                        // the number of siblings you want to clip. If children are removed or added, GFX clip
                        // values need to be recomputed.
                        var i = displayObject._parent.getChildIndex(displayObject);
                        var j = displayObject._parent.getClipDepthIndex(displayObject._clipDepth);
                        // An invalid SWF can contain a clipping mask that doesn't clip anything, but pretends to.
                        if (j - i < 0) {
                            this.output.writeInt(-1);
                            return;
                        }
                        for (var k = i + 1; k <= i; k++) {
                            // assert(displayObject._parent.getChildAt(k)._depth > displayObject._depth && displayObject._parent.getChildAt(k)._depth <= displayObject._clipDepth);
                        }
                        this.output.writeInt(j - i);
                    }
                    else {
                        this.output.writeInt(-1);
                    }
                };
                PlayerChannelSerializer.prototype.writeUpdateFrame = function (displayObject) {
                    // Write Header
                    this.output.writeInt(100 /* UpdateFrame */);
                    this.output.writeInt(displayObject._id);
                    writer && writer.writeLn("Sending UpdateFrame: " + displayObject.debugName(true));
                    var hasMask = false;
                    var hasMatrix = displayObject._hasDirtyFlags(1 /* DirtyMatrix */);
                    var hasColorTransform = displayObject._hasDirtyFlags(64 /* DirtyColorTransform */);
                    var hasMiscellaneousProperties = displayObject._hasDirtyFlags(512 /* DirtyMiscellaneousProperties */);
                    var video = null;
                    if (displayObject._sec.media.Video.axIsType(displayObject)) {
                        video = displayObject;
                    }
                    // Check if any children need to be written. These are remoting children, not just display object children.
                    var hasRemotableChildren = false;
                    if (this.phase === 1 /* References */) {
                        hasRemotableChildren = displayObject._hasAnyDirtyFlags(2 /* DirtyChildren */ |
                            4 /* DirtyGraphics */ |
                            16 /* DirtyBitmapData */ |
                            32 /* DirtyNetStream */ |
                            8 /* DirtyTextContent */);
                        hasMask = displayObject._hasDirtyFlags(128 /* DirtyMask */);
                    }
                    var bitmap = null;
                    if (displayObject._sec.display.Bitmap.axIsType(displayObject)) {
                        bitmap = displayObject;
                    }
                    // Checks if the computed clip value needs to be written.
                    var hasClip = displayObject._hasDirtyFlags(256 /* DirtyClipDepth */);
                    // Write Has Bits
                    var hasBits = 0;
                    hasBits |= hasMatrix ? 1 /* HasMatrix */ : 0;
                    hasBits |= hasColorTransform ? 8 /* HasColorTransform */ : 0;
                    hasBits |= hasMask ? 64 /* HasMask */ : 0;
                    hasBits |= hasClip ? 128 /* HasClip */ : 0;
                    hasBits |= hasMiscellaneousProperties ? 32 /* HasMiscellaneousProperties */ : 0;
                    hasBits |= hasRemotableChildren ? 4 /* HasChildren */ : 0;
                    this.output.writeInt(hasBits);
                    // Write Properties
                    if (hasMatrix) {
                        this._writeMatrix(displayObject._getMatrix());
                    }
                    if (hasColorTransform) {
                        this._writeColorTransform(displayObject._colorTransform);
                    }
                    if (hasMask) {
                        this.output.writeInt(displayObject.mask ? displayObject.mask._id : -1);
                    }
                    if (hasClip) {
                        this.writeClippedObjectsCount(displayObject);
                    }
                    if (hasMiscellaneousProperties) {
                        this.output.writeInt(displayObject._ratio);
                        this.output.writeInt(BlendMode.toNumber(displayObject._blendMode));
                        this._writeFilters(displayObject._filters);
                        this.output.writeBoolean(displayObject._hasFlags(1 /* Visible */));
                        this.output.writeBoolean(displayObject.cacheAsBitmap);
                        if (bitmap) {
                            this.output.writeInt(PixelSnapping.toNumber(bitmap.pixelSnapping));
                            this.output.writeInt(bitmap.smoothing ? 1 : 0);
                        }
                        else {
                            // For non-bitmaps, write null-defaults that cause flags not to be set in the GFX backend.
                            this.output.writeInt(PixelSnapping.toNumber(PixelSnapping.NEVER));
                            this.output.writeInt(0);
                        }
                    }
                    var graphics = displayObject._getGraphics();
                    var textContent = displayObject._getTextContent();
                    if (hasRemotableChildren) {
                        writer && writer.enter("Children: {");
                        if (bitmap) {
                            if (bitmap.bitmapData) {
                                this.output.writeInt(1);
                                this.output.writeInt(134217728 /* Asset */ | bitmap.bitmapData._id);
                            }
                            else {
                                this.output.writeInt(0);
                            }
                        }
                        else if (video) {
                            if (video._netStream) {
                                this.output.writeInt(1);
                                this.output.writeInt(134217728 /* Asset */ | video._netStream._id);
                            }
                            else {
                                this.output.writeInt(0);
                            }
                        }
                        else {
                            // Check if we have a graphics or text object and write that as a child first.
                            var count = (graphics || textContent) ? 1 : 0;
                            var children = displayObject._children;
                            if (children) {
                                count += children.length;
                            }
                            this.output.writeInt(count);
                            if (graphics) {
                                writer && writer.writeLn("Reference Graphics: " + graphics._id);
                                this.output.writeInt(134217728 /* Asset */ | graphics._id);
                            }
                            else if (textContent) {
                                writer && writer.writeLn("Reference TextContent: " + textContent._id);
                                this.output.writeInt(134217728 /* Asset */ | textContent._id);
                            }
                            // Write all the display object children.
                            if (children) {
                                for (var i = 0; i < children.length; i++) {
                                    writer && writer.writeLn("Reference DisplayObject: " + children[i].debugName());
                                    this.output.writeInt(children[i]._id);
                                    // Make sure children with a clip depth are getting visited.
                                    if (children[i]._clipDepth >= 0) {
                                        children[i]._setDirtyFlags(256 /* DirtyClipDepth */);
                                    }
                                }
                            }
                        }
                        writer && writer.leave("}");
                    }
                    if (this.phase === 1 /* References */) {
                        displayObject._removeDirtyFlags(1023 /* Dirty */);
                    }
                };
                /**
                 * Visit remotable child objects that are not otherwise visited.
                 */
                PlayerChannelSerializer.prototype.writeDirtyAssets = function (displayObject) {
                    var graphics = displayObject._getGraphics();
                    if (graphics) {
                        this.writeGraphics(graphics);
                        return;
                    }
                    var textContent = displayObject._getTextContent();
                    if (textContent) {
                        this.writeTextContent(textContent);
                        return;
                    }
                    var bitmap = null;
                    if (displayObject._sec.display.Bitmap.axIsType(displayObject)) {
                        bitmap = displayObject;
                        if (bitmap.bitmapData) {
                            this.writeBitmapData(bitmap.bitmapData);
                        }
                        return;
                    }
                    var video = null;
                    if (displayObject._sec.media.Video.axIsType(displayObject)) {
                        video = displayObject;
                        if (video._netStream) {
                            this.writeNetStream(video._netStream, video._getContentBounds());
                        }
                        return;
                    }
                };
                PlayerChannelSerializer.prototype.writeDrawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                    if (matrix === void 0) { matrix = null; }
                    if (colorTransform === void 0) { colorTransform = null; }
                    if (blendMode === void 0) { blendMode = null; }
                    if (clipRect === void 0) { clipRect = null; }
                    if (smoothing === void 0) { smoothing = false; }
                    this.output.writeInt(200 /* DrawToBitmap */);
                    this.output.writeInt(bitmapData._id);
                    if (bitmapData._sec.display.BitmapData.axIsType(source)) {
                        this.output.writeInt(134217728 /* Asset */ | source._id);
                    }
                    else {
                        this.output.writeInt(source._id);
                    }
                    var hasBits = 0;
                    hasBits |= matrix ? 1 /* HasMatrix */ : 0;
                    hasBits |= colorTransform ? 8 /* HasColorTransform */ : 0;
                    hasBits |= clipRect ? 16 /* HasClipRect */ : 0;
                    this.output.writeInt(hasBits);
                    if (matrix) {
                        this._writeMatrix(matrix);
                    }
                    if (colorTransform) {
                        this._writeColorTransform(colorTransform);
                    }
                    if (clipRect) {
                        this._writeRectangle(Bounds.FromRectangle(clipRect));
                    }
                    this.output.writeInt(BlendMode.toNumber(blendMode));
                    this.output.writeBoolean(smoothing);
                };
                PlayerChannelSerializer.prototype._writeMatrix = function (matrix) {
                    if (matrix.b === 0 && matrix.c === 0) {
                        if (matrix.a === 1 && matrix.d === 1) {
                            this.output.writeInt(0 /* TranslationOnly */);
                            this.output.write2Floats(matrix.tx, matrix.ty);
                        }
                        else {
                            if (matrix.a === matrix.d) {
                                this.output.writeInt(2 /* UniformScaleAndTranslationOnly */);
                                this.output.writeFloat(matrix.a);
                            }
                            else {
                                this.output.writeInt(1 /* ScaleAndTranslationOnly */);
                                this.output.write2Floats(matrix.a, matrix.d);
                            }
                            this.output.write2Floats(matrix.tx, matrix.ty);
                        }
                    }
                    else {
                        this.output.writeInt(3 /* All */);
                        this.output.write6Floats(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                    }
                };
                PlayerChannelSerializer.prototype._writeRectangle = function (bounds) {
                    var output = this.output;
                    // TODO: check if we should write bounds instead. Depends on what's more useful in GFX-land.
                    output.write4Ints(bounds.xMin, bounds.yMin, bounds.width, bounds.height);
                };
                PlayerChannelSerializer.prototype._writeAsset = function (asset) {
                    this.output.writeInt(this.outputAssets.length);
                    this.outputAssets.push(asset);
                };
                PlayerChannelSerializer.prototype._writeFilters = function (filters) {
                    if (!filters || filters.length === 0) {
                        this.output.writeInt(0);
                        return;
                    }
                    var sec = filters[0]._sec;
                    var count = 0;
                    var blurFilterClass = sec.filters.BlurFilter;
                    var dropShadowFilterClass = sec.filters.DropShadowFilter;
                    var glowFilterClass = sec.filters.GlowFilter;
                    var colorMatrixFilterClass = sec.filters.ColorMatrixFilter;
                    for (var i = 0; i < filters.length; i++) {
                        if (blurFilterClass.axIsType(filters[i]) ||
                            dropShadowFilterClass.axIsType(filters[i]) ||
                            glowFilterClass.axIsType(filters[i]) ||
                            colorMatrixFilterClass.axIsType(filters[i])) {
                            count++;
                        }
                        else {
                            Shumway.Debug.somewhatImplemented(filters[i].toString());
                        }
                    }
                    this.output.writeInt(count);
                    for (var i = 0; i < filters.length; i++) {
                        var filter = filters[i];
                        if (blurFilterClass.axIsType(filter)) {
                            var blurFilter = filter;
                            this.output.writeInt(Remoting.FilterType.Blur);
                            this.output.writeFloat(blurFilter.blurX);
                            this.output.writeFloat(blurFilter.blurY);
                            this.output.writeInt(blurFilter.quality);
                        }
                        else if (dropShadowFilterClass.axIsType(filter)) {
                            var dropShadowFilter = filter;
                            this.output.writeInt(Remoting.FilterType.DropShadow);
                            this.output.writeFloat(dropShadowFilter.alpha);
                            this.output.writeFloat(dropShadowFilter.angle);
                            this.output.writeFloat(dropShadowFilter.blurX);
                            this.output.writeFloat(dropShadowFilter.blurY);
                            this.output.writeInt(dropShadowFilter.color);
                            this.output.writeFloat(dropShadowFilter.distance);
                            this.output.writeBoolean(dropShadowFilter.hideObject);
                            this.output.writeBoolean(dropShadowFilter.inner);
                            this.output.writeBoolean(dropShadowFilter.knockout);
                            this.output.writeInt(dropShadowFilter.quality);
                            this.output.writeFloat(dropShadowFilter.strength);
                        }
                        else if (glowFilterClass.axIsType(filter)) {
                            var glowFilter = filter;
                            this.output.writeInt(Remoting.FilterType.DropShadow);
                            this.output.writeFloat(glowFilter.alpha);
                            this.output.writeFloat(0); // angle
                            this.output.writeFloat(glowFilter.blurX);
                            this.output.writeFloat(glowFilter.blurY);
                            this.output.writeInt(glowFilter.color);
                            this.output.writeFloat(0); // distance
                            this.output.writeBoolean(false); // hideObject
                            this.output.writeBoolean(glowFilter.inner);
                            this.output.writeBoolean(glowFilter.knockout);
                            this.output.writeInt(glowFilter.quality);
                            this.output.writeFloat(glowFilter.strength);
                        }
                        else if (colorMatrixFilterClass.axIsType(filter)) {
                            var matrix = filter.matrix;
                            this.output.writeInt(Remoting.FilterType.ColorMatrix);
                            for (var j = 0; j < 20; j++) {
                                this.output.writeFloat(matrix[j]);
                            }
                        }
                    }
                };
                PlayerChannelSerializer.prototype._writeColorTransform = function (colorTransform) {
                    var output = this.output;
                    var rM = colorTransform.redMultiplier;
                    var gM = colorTransform.greenMultiplier;
                    var bM = colorTransform.blueMultiplier;
                    var aM = colorTransform.alphaMultiplier;
                    var rO = colorTransform.redOffset;
                    var gO = colorTransform.greenOffset;
                    var bO = colorTransform.blueOffset;
                    var aO = colorTransform.alphaOffset;
                    var identityOffset = rO === gO && gO === bO && bO === aO && aO === 0;
                    var identityColorMultiplier = rM === gM && gM === bM && bM === 1;
                    if (identityOffset && identityColorMultiplier) {
                        if (aM === 1) {
                            output.writeInt(0 /* Identity */);
                        }
                        else {
                            output.writeInt(1 /* AlphaMultiplierOnly */);
                            output.writeFloat(aM);
                        }
                    }
                    else {
                        var zeroNonAlphaMultipliers = rM === 0 && gM === 0 && bM === 0;
                        if (zeroNonAlphaMultipliers) {
                            output.writeInt(2 /* AlphaMultiplierWithOffsets */);
                            output.writeFloat(aM);
                            output.writeInt(rO);
                            output.writeInt(gO);
                            output.writeInt(bO);
                            output.writeInt(aO);
                        }
                        else {
                            output.writeInt(3 /* All */);
                            output.writeFloat(rM);
                            output.writeFloat(gM);
                            output.writeFloat(bM);
                            output.writeFloat(aM);
                            output.writeInt(rO);
                            output.writeInt(gO);
                            output.writeInt(bO);
                            output.writeInt(aO);
                        }
                    }
                };
                PlayerChannelSerializer.prototype.writeRequestBitmapData = function (bitmapData) {
                    writer && writer.writeLn("Sending BitmapData Request");
                    this.output.writeInt(106 /* RequestBitmapData */);
                    this.output.writeInt(bitmapData._id);
                };
                return PlayerChannelSerializer;
            }());
            Player.PlayerChannelSerializer = PlayerChannelSerializer;
            var PlayerChannelDeserializer = /** @class */ (function () {
                function PlayerChannelDeserializer(sec, input, inputAssets) {
                    this.sec = sec;
                    this.input = input;
                    this.inputAssets = inputAssets;
                    // ..
                }
                PlayerChannelDeserializer.prototype.read = function () {
                    var input = this.input;
                    var tag = input.readInt();
                    switch (tag) {
                        case 300 /* MouseEvent */:
                            return this._readMouseEvent();
                        case 301 /* KeyboardEvent */:
                            return this._readKeyboardEvent();
                        case 302 /* FocusEvent */:
                            return this._readFocusEvent();
                    }
                    release || assert(false, 'Unknown MessageReader tag: ' + tag);
                };
                PlayerChannelDeserializer.prototype._readFocusEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    return {
                        tag: 302 /* FocusEvent */,
                        type: typeId
                    };
                };
                PlayerChannelDeserializer.prototype._readMouseEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.MouseEventNames[typeId];
                    var pX = input.readFloat();
                    var pY = input.readFloat();
                    var buttons = input.readInt();
                    var flags = input.readInt();
                    return {
                        tag: 300 /* MouseEvent */,
                        type: type,
                        point: this.sec.geom.Point.create([pX, pY]),
                        ctrlKey: !!(flags & 1 /* CtrlKey */),
                        altKey: !!(flags & 2 /* AltKey */),
                        shiftKey: !!(flags & 4 /* ShiftKey */),
                        buttons: buttons
                    };
                };
                PlayerChannelDeserializer.prototype._readKeyboardEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.KeyboardEventNames[typeId];
                    var keyCode = input.readInt();
                    var charCode = input.readInt();
                    var location = input.readInt();
                    var flags = input.readInt();
                    return {
                        tag: 301 /* KeyboardEvent */,
                        type: type,
                        keyCode: keyCode,
                        charCode: charCode,
                        location: location,
                        ctrlKey: !!(flags & 1 /* CtrlKey */),
                        altKey: !!(flags & 2 /* AltKey */),
                        shiftKey: !!(flags & 4 /* ShiftKey */)
                    };
                };
                return PlayerChannelDeserializer;
            }());
            Player.PlayerChannelDeserializer = PlayerChannelDeserializer;
        })(Player = Remoting.Player || (Remoting.Player = {}));
    })(Remoting = Shumway.Remoting || (Shumway.Remoting = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Player;
    (function (Player_1) {
        var assert = Shumway.Debug.assert;
        var somewhatImplemented = Shumway.Debug.somewhatImplemented;
        var flash = Shumway.flash;
        var Event = flash.events.Event;
        var MouseEventDispatcher = flash.ui.MouseEventDispatcher;
        var KeyboardEventDispatcher = flash.ui.KeyboardEventDispatcher;
        /**
         * Base class implementation of the IGFXServer. The different transports shall
         * inherit this class
         */
        var GFXServiceBase = /** @class */ (function () {
            function GFXServiceBase(sec) {
                this._observers = [];
                this.sec = sec;
            }
            GFXServiceBase.prototype.addObserver = function (observer) {
                this._observers.push(observer);
            };
            GFXServiceBase.prototype.removeObserver = function (observer) {
                var i = this._observers.indexOf(observer);
                if (i >= 0) {
                    this._observers.splice(i, 1);
                }
            };
            GFXServiceBase.prototype.update = function (updates, assets) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.updateAndGet = function (updates, assets) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.frame = function () {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.videoControl = function (id, eventType, data) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.registerFont = function (syncId, data) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.registerImage = function (syncId, symbolId, imageType, data, alphaData) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.fscommand = function (command, args) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.processUpdates = function (updates, assets) {
                var deserializer = new Shumway.Remoting.Player.PlayerChannelDeserializer(this.sec, updates, assets);
                var message = deserializer.read();
                switch (message.tag) {
                    case 301 /* KeyboardEvent */:
                        this._observers.forEach(function (observer) {
                            observer.keyboardEvent(message);
                        });
                        break;
                    case 300 /* MouseEvent */:
                        this._observers.forEach(function (observer) {
                            observer.mouseEvent(message);
                        });
                        break;
                    case 302 /* FocusEvent */:
                        this._observers.forEach(function (observer) {
                            observer.focusEvent(message);
                        });
                        break;
                }
            };
            GFXServiceBase.prototype.processDisplayParameters = function (displayParameters) {
                this._observers.forEach(function (observer) {
                    observer.displayParameters(displayParameters);
                });
            };
            GFXServiceBase.prototype.processVideoEvent = function (id, eventType, data) {
                this._observers.forEach(function (observer) {
                    observer.videoEvent(id, eventType, data);
                });
            };
            return GFXServiceBase;
        }());
        Player_1.GFXServiceBase = GFXServiceBase;
        /**
         * Helper class to handle GFXService notifications/events and forward them to
         * the Player object.
         */
        var GFXServiceObserver = /** @class */ (function () {
            function GFXServiceObserver(player) {
                this._videoEventListeners = [];
                this._player = player;
                this._keyboardEventDispatcher = new KeyboardEventDispatcher();
                this._mouseEventDispatcher = new MouseEventDispatcher();
                this._writer = new Shumway.IndentingWriter();
            }
            GFXServiceObserver.prototype.videoEvent = function (id, eventType, data) {
                var listener = this._videoEventListeners[id];
                Shumway.Debug.assert(listener, 'Video event listener is not found');
                listener(eventType, data);
            };
            GFXServiceObserver.prototype.displayParameters = function (displayParameters) {
                this._player._stage.setStageContainerSize(displayParameters.stageWidth, displayParameters.stageHeight, displayParameters.pixelRatio);
            };
            GFXServiceObserver.prototype.focusEvent = function (data) {
                var message = data;
                var focusType = message.type;
                switch (focusType) {
                    case 0 /* DocumentHidden */:
                        this._player._isPageVisible = false;
                        break;
                    case 1 /* DocumentVisible */:
                        this._player._isPageVisible = true;
                        break;
                    case 2 /* WindowBlur */:
                        // TODO: This is purposely disabled so that applications don't pause when they are out of
                        // focus while the debugging window is open.
                        // EventDispatcher.broadcastEventDispatchQueue.dispatchEvent(Event.getBroadcastInstance(Event.DEACTIVATE));
                        this._player._hasFocus = false;
                        break;
                    case 3 /* WindowFocus */:
                        var events = this._player.sec.events;
                        events.broadcastEventDispatchQueue.dispatchEvent(events.getBroadcastInstance(Event.ACTIVATE));
                        this._player._hasFocus = true;
                        break;
                }
            };
            GFXServiceObserver.prototype.keyboardEvent = function (data) {
                var message = data;
                // If the stage doesn't have a focus then dispatch events on the stage
                // directly.
                var target = this._player._stage.focus ? this._player._stage.focus : this._player._stage;
                this._keyboardEventDispatcher.target = target;
                this._keyboardEventDispatcher.dispatchKeyboardEvent(message);
            };
            GFXServiceObserver.prototype.mouseEvent = function (data) {
                var message = data;
                this._mouseEventDispatcher.stage = this._player._stage;
                var target = this._mouseEventDispatcher.handleMouseEvent(message);
                if (Shumway.traceMouseEventOption.value) {
                    this._writer.writeLn("Mouse Event: type: " + message.type + ", point: " + message.point + ", target: " + target + (target ? ", name: " + target._name : ""));
                    if (message.type === "click" && target) {
                        target.debugTrace();
                    }
                }
                this._player.currentMouseTarget = this._mouseEventDispatcher.currentTarget;
            };
            GFXServiceObserver.prototype.registerEventListener = function (id, listener) {
                this._videoEventListeners[id] = listener;
            };
            return GFXServiceObserver;
        }());
        /**
         * Shumway Player
         *
         * This class brings everything together. Loads the swf, runs the event loop and
         * synchronizes the frame tree with the display list.
         */
        var Player = /** @class */ (function () {
            function Player(sec, gfxService) {
                this._framesPlayed = 0;
                /**
                 * Time since the last time we've synchronized the display list.
                 */
                this._lastPumpTime = 0;
                /**
                 * Page Visibility API visible state.
                 */
                this._isPageVisible = true;
                /**
                 * Page focus state.
                 */
                this._hasFocus = true;
                /**
                 * Stage current mouse target.
                 */
                this._currentMouseTarget = null;
                /**
                 * Indicates whether the |currentMouseTarget| has changed since the last time it was synchronized.
                 */
                this._currentMouseTargetIsDirty = true;
                /**
                 * Page URL that hosts SWF.
                 */
                this._pageUrl = null;
                /**
                 * SWF URL.
                 */
                this._swfUrl = null;
                /**
                 * Loader URL, can be different from SWF URL.
                 */
                this._loaderUrl = null;
                this._crossDomainSWFLoadingWhitelist = [];
                this.sec = sec;
                sec.player = this;
                // Freeze in debug builds.
                release || Object.defineProperty(this, 'sec', { value: sec });
                release || Shumway.Debug.assert(gfxService);
                this._writer = new Shumway.IndentingWriter();
                this._gfxService = gfxService;
                this._gfxServiceObserver = new GFXServiceObserver(this);
                this._gfxService.addObserver(this._gfxServiceObserver);
            }
            Object.defineProperty(Player.prototype, "framesPlayed", {
                get: function () {
                    return this._framesPlayed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, "currentMouseTarget", {
                set: function (value) {
                    if (this._currentMouseTarget !== value) {
                        this._currentMouseTargetIsDirty = true;
                    }
                    this._currentMouseTarget = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, "stage", {
                /**
                 * Movie stage object.
                 */
                get: function () {
                    return this._stage;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Whether we can get away with rendering at a lower rate.
             */
            Player.prototype._shouldThrottleDownRendering = function () {
                return !this._isPageVisible;
            };
            /**
             * Whether we can get away with executing frames at a lower rate.
             */
            Player.prototype._shouldThrottleDownFrameExecution = function () {
                return !this._isPageVisible;
            };
            Object.defineProperty(Player.prototype, "pageUrl", {
                get: function () {
                    return this._pageUrl;
                },
                set: function (value) {
                    this._pageUrl = value || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, "loaderUrl", {
                get: function () {
                    return this._loaderUrl;
                },
                set: function (value) {
                    this._loaderUrl = value || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, "swfUrl", {
                get: function () {
                    return this._swfUrl;
                },
                enumerable: true,
                configurable: true
            });
            Player.prototype.load = function (url, buffer) {
                release || assert(!this._loader, "Can't load twice.");
                this._swfUrl = url;
                this._stage = this.sec.display.Stage.create();
                var loader = this._loader = this.sec.display.Loader.getRootLoader();
                var loaderInfo = this._loaderInfo = loader.contentLoaderInfo;
                if (Shumway.playAllSymbolsOption.value) {
                    // @ivanpopelyshev : how did it work?
                    // TODO: add it back
                    // this._playAllSymbols();
                    loaderInfo._allowCodeExecution = false;
                }
                else {
                    this._enterRootLoadingLoop();
                }
                var resolvedURL = Shumway.FileLoadingService.instance.resolveUrl(url);
                this.addToSWFLoadingWhitelist(resolvedURL, false, true);
                var context = this.createLoaderContext();
                if (buffer) {
                    var byteArray = this.sec.utils.ByteArray.create([buffer]);
                    this._loader.loadBytes(byteArray, context);
                    this._loader.contentLoaderInfo._url = resolvedURL;
                }
                else {
                    this._loader.load(this.sec.net.URLRequest.create([url]), context);
                }
            };
            Player.prototype.createLoaderContext = function () {
                var loaderContext = this.sec.system.LoaderContext.create();
                // @ivanpopelyshev: createObject
                // if (this.movieParams) {
                // 	let parameters: any = this.sec.createObject();
                // 	for (let i in this.movieParams) {
                // 		parameters.axSetPublicProperty(i, this.movieParams[i]);
                // 	}
                // 	(loaderContext as any).parameters = <Shumway.AVMX.AS.ASObject>parameters;
                // }
                return loaderContext;
            };
            Player.prototype._pumpDisplayListUpdates = function () {
                this.syncDisplayObject(this._stage, true);
            };
            Player.prototype.syncDisplayObject = function (displayObject, async) {
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                if (this.sec.display.Stage.axIsType(displayObject)) {
                    var stage = displayObject;
                    serializer.writeStage(stage);
                    if (this._currentMouseTargetIsDirty) {
                        serializer.writeCurrentMouseTarget(stage, this._currentMouseTarget);
                        this._currentMouseTargetIsDirty = false;
                    }
                }
                serializer.writeDisplayObjectRoot(displayObject);
                serializer.writeEOF();
                Player_1.enterTimeline("remoting assets");
                var output;
                if (async) {
                    this._gfxService.update(serializer.output, serializer.outputAssets);
                }
                else {
                    output = this._gfxService.updateAndGet(serializer.output, serializer.outputAssets).clone();
                }
                Player_1.leaveTimeline("remoting assets");
                return output;
            };
            Player.prototype.requestBitmapData = function (bitmapData) {
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.writeRequestBitmapData(bitmapData);
                serializer.writeEOF();
                return this._gfxService.updateAndGet(serializer.output, serializer.outputAssets).clone();
            };
            Player.prototype.drawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                if (matrix === void 0) { matrix = null; }
                if (colorTransform === void 0) { colorTransform = null; }
                if (blendMode === void 0) { blendMode = null; }
                if (clipRect === void 0) { clipRect = null; }
                if (smoothing === void 0) { smoothing = false; }
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.writeBitmapData(bitmapData);
                if (this.sec.display.BitmapData.axIsType(source)) {
                    serializer.writeBitmapData(source);
                }
                else {
                    serializer.writeDisplayObjectRoot(source);
                }
                serializer.writeDrawToBitmap(bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing);
                serializer.writeEOF();
                Player_1.enterTimeline("sendUpdates");
                this._gfxService.updateAndGet(serializer.output, serializer.outputAssets);
                Player_1.leaveTimeline("sendUpdates");
            };
            Player.prototype.registerEventListener = function (id, listener) {
                this._gfxServiceObserver.registerEventListener(id, listener);
            };
            Player.prototype.notifyVideoControl = function (id, eventType, data) {
                return this._gfxService.videoControl(id, eventType, data);
            };
            Player.prototype.executeFSCommand = function (command, args) {
                switch (command) {
                    case 'quit':
                        this._leaveEventLoop();
                        break;
                    default:
                        somewhatImplemented('FSCommand ' + command);
                }
                this._gfxService.fscommand(command, args);
            };
            Player.prototype.requestRendering = function () {
                this._pumpDisplayListUpdates();
            };
            /**
             * Update the frame container with the latest changes from the display list.
             */
            Player.prototype._pumpUpdates = function () {
                if (!Shumway.dontSkipFramesOption.value) {
                    if (this._shouldThrottleDownRendering()) {
                        return;
                    }
                    var timeSinceLastPump = performance.now() - this._lastPumpTime;
                    if (timeSinceLastPump < (1000 / Shumway.pumpRateOption.value)) {
                        return;
                    }
                }
                Player_1.enterTimeline("pump");
                if (Shumway.pumpEnabledOption.value) {
                    this._pumpDisplayListUpdates();
                    this._lastPumpTime = performance.now();
                }
                Player_1.leaveTimeline("pump");
            };
            Player.prototype._leaveSyncLoop = function () {
                release || assert(this._frameTimeout > -1);
                clearInterval(this._frameTimeout);
            };
            Player.prototype._getFrameInterval = function () {
                var frameRate = Shumway.frameRateOption.value;
                if (frameRate < 0) {
                    frameRate = this._stage.frameRate;
                }
                return Math.floor(1000 / frameRate);
            };
            Player.prototype._enterEventLoop = function () {
                this._eventLoopIsRunning = true;
                var self = this;
                function tick() {
                    // TODO: change this to the mode described in
                    // http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/
                    self._frameTimeout = setTimeout(tick, self._getFrameInterval());
                    self._eventLoopTick();
                }
                if (!isNaN(this.initStartTime)) {
                    console.info('Time from init start to main event loop start: ' +
                        (Date.now() - this.initStartTime));
                }
                tick();
            };
            Player.prototype._leaveEventLoop = function () {
                release || assert(this._eventLoopIsRunning);
                clearTimeout(this._frameTimeout);
                this._eventLoopIsRunning = false;
            };
            Player.prototype._enterRootLoadingLoop = function () {
                var self = this;
                var rootLoader = this.sec.display.Loader.getRootLoader();
                rootLoader._setStage(this._stage);
                function rootLoadingLoop() {
                    var loaderInfo = rootLoader.contentLoaderInfo;
                    if (!loaderInfo._file) {
                        setTimeout(rootLoadingLoop, self._getFrameInterval());
                        return;
                    }
                    var stage = self._stage;
                    var bgcolor = self.defaultStageColor !== undefined ?
                        self.defaultStageColor :
                        loaderInfo._file.backgroundColor;
                    stage._loaderInfo = loaderInfo;
                    stage.align = self.stageAlign || '';
                    if (!self.stageScale || flash.display.StageScaleMode.toNumber(self.stageScale) < 0) {
                        stage.scaleMode = flash.display.StageScaleMode.SHOW_ALL;
                    }
                    else {
                        stage.scaleMode = self.stageScale;
                    }
                    stage.frameRate = loaderInfo.frameRate;
                    stage.setStageWidth(loaderInfo.width);
                    stage.setStageHeight(loaderInfo.height);
                    stage.setStageColor(Shumway.ColorUtilities.RGBAToARGB(bgcolor));
                    if (self.displayParameters) {
                        self._gfxServiceObserver.displayParameters(self.displayParameters);
                    }
                    self._enterEventLoop();
                }
                rootLoadingLoop();
            };
            Player.prototype.start = function (params) {
                params = params || {};
                var options = {
                    width: params.width || 800,
                    height: params.height || 600,
                    backgroundColor: params.backgroundColor,
                    frameRate: params.frameRate || 24,
                };
                this._stage = this.sec.display.Stage.create();
                var loader = this._loader = this.sec.display.Loader.getRootLoader();
                var loaderInfo = this._loaderInfo = loader.contentLoaderInfo;
                loader._content = this.sec.display.DisplayObjectContainer.create();
                loader._loadStatus = 3;
                var stage = this._stage;
                var bgcolor = this.defaultStageColor !== undefined ?
                    this.defaultStageColor :
                    params.backgroundColor;
                this._loaderInfo = loaderInfo;
                stage.align = this.stageAlign || '';
                if (!this.stageScale || flash.display.StageScaleMode.toNumber(this.stageScale) < 0) {
                    stage.scaleMode = flash.display.StageScaleMode.SHOW_ALL;
                }
                else {
                    stage.scaleMode = this.stageScale;
                }
                stage.frameRate = options.frameRate;
                stage.setStageWidth(options.width);
                stage.setStageHeight(options.height);
                stage.setStageColor(Shumway.ColorUtilities.RGBAToARGB(bgcolor));
                if (this.displayParameters) {
                    this._gfxServiceObserver.displayParameters(this.displayParameters);
                }
                this._enterEventLoop();
            };
            Player.prototype._eventLoopTick = function () {
                var runFrameScripts = !Shumway.playAllSymbolsOption.value;
                var dontSkipFrames = Shumway.dontSkipFramesOption.value;
                if (!dontSkipFrames && (!Shumway.frameEnabledOption.value && runFrameScripts ||
                    this._shouldThrottleDownFrameExecution())) {
                    return;
                }
                // The stage is required for frame event cycle processing.
                var displayObjectClass = this.sec.display;
                displayObjectClass._stage = this._stage;
                // Until the root SWF is initialized, only process Loader events.
                // Once the root loader's content is created, directly process all events again to avoid
                // further delay in initialization.
                var loaderClass = this.sec.display.Loader;
                if (!loaderClass.getRootLoader().content) {
                    loaderClass.processEvents();
                    if (!loaderClass.getRootLoader().content) {
                        return;
                    }
                }
                for (var i = 0; i < Shumway.frameRateMultiplierOption.value; i++) {
                    Player_1.enterTimeline("eventLoop");
                    var start = performance.now();
                    displayObjectClass.performFrameNavigation(true, runFrameScripts);
                    Player_1.counter.count("performFrameNavigation", 1, performance.now() - start);
                    loaderClass.processEvents();
                    Player_1.leaveTimeline("eventLoop");
                }
                this._framesPlayed++;
                if (Shumway.tracePlayerOption.value > 0 && (this._framesPlayed % Shumway.tracePlayerOption.value === 0)) {
                    this._tracePlayer();
                }
                this._stage.render();
                this._pumpUpdates();
                this._gfxService.frame();
            };
            Player.prototype._tracePlayer = function () {
                this._writer.writeLn("Frame: " +
                    String(this._framesPlayed).padLeft(' ', 4) + ": " + Shumway.IntegerUtilities.toHEX(this._stage.hashCode()) + " " +
                    String(this._stage.getAncestorCount()).padLeft(' ', 4));
            };
            Player.prototype.registerFont = function (symbol, data) {
                release || assert(symbol.syncId);
                symbol.resolveAssetPromise = new Shumway.PromiseWrapper(); // TODO no need for wrapper here, change to Promise
                this._gfxService.registerFont(symbol.syncId, data).then(function (result) {
                    symbol.resolveAssetPromise.resolve(result);
                });
                // Fonts are immediately available in Firefox, so we can just mark the symbol as ready.
                if (inFirefox) {
                    symbol.ready = true;
                }
                else {
                    symbol.resolveAssetPromise.then(symbol.resolveAssetCallback, null);
                }
            };
            Player.prototype.registerImage = function (symbol, imageType, data, alphaData) {
                release || assert(symbol.syncId);
                symbol.resolveAssetPromise = new Shumway.PromiseWrapper(); // TODO no need for wrapper here, change to Promise
                this._gfxService.registerImage(symbol.syncId, symbol.id, imageType, data, alphaData).then(function (result) {
                    symbol.resolveAssetPromise.resolve(result);
                });
                symbol.resolveAssetPromise.then(symbol.resolveAssetCallback, null);
            };
            Player.prototype.addToSWFLoadingWhitelist = function (domain, insecure, ownDomain) {
                if (domain.indexOf('/') < 0) {
                    this._crossDomainSWFLoadingWhitelist.push({
                        protocol: 'http:',
                        hostname: domain,
                        insecure: insecure,
                        ownDomain: ownDomain
                    });
                    return;
                }
                try {
                    var url = new window.URL(domain);
                    this._crossDomainSWFLoadingWhitelist.push({
                        protocol: url.protocol,
                        hostname: url.hostname,
                        insecure: insecure,
                        ownDomain: ownDomain
                    });
                }
                catch (e) {
                }
            };
            Player.prototype.checkDomainForSWFLoading = function (domain) {
                var url;
                try {
                    url = new window.URL(domain);
                }
                catch (e) {
                    return 2 /* Failed */;
                }
                var result = 2 /* Failed */;
                this._crossDomainSWFLoadingWhitelist.some(function (entry) {
                    var success;
                    if (url.hostname !== entry.hostname && entry.hostname !== '*') {
                        success = false;
                    }
                    else if (entry.insecure) {
                        success = true;
                    }
                    else {
                        // The HTTPS SWF has to be more protected than it's whitelisted HTTP equivalent.
                        success = url.protocol === 'https:' || entry.protocol !== 'https:';
                    }
                    if (success) {
                        result = entry.ownDomain ?
                            0 /* OwnDomain */ :
                            1 /* Remote */;
                        return true;
                    }
                    return false;
                }, this);
                return result;
            };
            return Player;
        }());
        Player_1.Player = Player;
    })(Player = Shumway.Player || (Shumway.Player = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Player;
    (function (Player) {
        var ShumwayComExternalInterface = /** @class */ (function () {
            function ShumwayComExternalInterface() {
            }
            Object.defineProperty(ShumwayComExternalInterface.prototype, "enabled", {
                get: function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComExternalInterface.prototype.initJS = function (callback) {
                ShumwayCom.externalCom({ action: 'init' });
                ShumwayCom.setExternalCallback(function (call) {
                    return callback(call.functionName, call.args);
                });
                this._externalCallback = callback;
            };
            ShumwayComExternalInterface.prototype.registerCallback = function (functionName) {
                var cmd = { action: 'register', functionName: functionName, remove: false };
                ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.unregisterCallback = function (functionName) {
                var cmd = { action: 'register', functionName: functionName, remove: true };
                ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.eval = function (expression) {
                var cmd = { action: 'eval', expression: expression };
                return ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.call = function (request) {
                var cmd = { action: 'call', request: request };
                return ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.getId = function () {
                var cmd = { action: 'getId' };
                return ShumwayCom.externalCom(cmd);
            };
            return ShumwayComExternalInterface;
        }());
        Player.ShumwayComExternalInterface = ShumwayComExternalInterface;
        var ShumwayComFileLoadingService = /** @class */ (function () {
            function ShumwayComFileLoadingService() {
                this._baseUrl = null;
                this._nextSessionId = 1; // 0 - is reserved
                this._sessions = [];
            }
            ShumwayComFileLoadingService.prototype.init = function (baseUrl) {
                this._baseUrl = baseUrl;
                var service = this;
                ShumwayCom.setLoadFileCallback(function (args) {
                    var session = service._sessions[args.sessionId];
                    if (session) {
                        service._notifySession(session, args);
                    }
                });
            };
            ShumwayComFileLoadingService.prototype._notifySession = function (session, args) {
                var sessionId = args.sessionId;
                switch (args.topic) {
                    case "open":
                        session.onopen();
                        break;
                    case "close":
                        session.onclose();
                        this._sessions[sessionId] = null;
                        console.log('Session #' + sessionId + ': closed');
                        break;
                    case "error":
                        session.onerror && session.onerror(args.error);
                        break;
                    case "progress":
                        console.log('Session #' + sessionId + ': loaded ' + args.loaded + '/' + args.total);
                        var data = args.array;
                        if (!(data instanceof Uint8Array)) {
                            data = new Uint8Array(data);
                        }
                        session.onprogress && session.onprogress(data, { bytesLoaded: args.loaded, bytesTotal: args.total });
                        break;
                }
            };
            ShumwayComFileLoadingService.prototype.createSession = function () {
                var sessionId = this._nextSessionId++;
                var service = this;
                var session = {
                    open: function (request) {
                        var path = service.resolveUrl(request.url);
                        console.log('Session #' + sessionId + ': loading ' + path);
                        ShumwayCom.loadFile({
                            url: path, method: request.method,
                            mimeType: request.mimeType, postData: request.data,
                            checkPolicyFile: request.checkPolicyFile, sessionId: sessionId
                        });
                    },
                    close: function () {
                        if (service._sessions[sessionId]) {
                            ShumwayCom.abortLoad(sessionId);
                        }
                    }
                };
                return (this._sessions[sessionId] = session);
            };
            ShumwayComFileLoadingService.prototype.resolveUrl = function (url) {
                return new window.URL(url, this._baseUrl).href;
            };
            ShumwayComFileLoadingService.prototype.navigateTo = function (url, target) {
                ShumwayCom.navigateTo({
                    url: this.resolveUrl(url),
                    target: target
                });
            };
            return ShumwayComFileLoadingService;
        }());
        Player.ShumwayComFileLoadingService = ShumwayComFileLoadingService;
        var ShumwayComClipboardService = /** @class */ (function () {
            function ShumwayComClipboardService() {
            }
            ShumwayComClipboardService.prototype.setClipboard = function (data) {
                ShumwayCom.setClipboard(data);
            };
            return ShumwayComClipboardService;
        }());
        Player.ShumwayComClipboardService = ShumwayComClipboardService;
        var ShumwayComTelemetryService = /** @class */ (function () {
            function ShumwayComTelemetryService() {
            }
            ShumwayComTelemetryService.prototype.reportTelemetry = function (data) {
                ShumwayCom.reportTelemetry(data);
            };
            return ShumwayComTelemetryService;
        }());
        Player.ShumwayComTelemetryService = ShumwayComTelemetryService;
        var BrowserFileLoadingService = /** @class */ (function () {
            function BrowserFileLoadingService() {
            }
            BrowserFileLoadingService.prototype.createSession = function () {
                var service = this;
                var reader;
                return {
                    open: function (request) {
                        var self = this;
                        var path = service.resolveUrl(request.url);
                        console.log('FileLoadingService: loading ' + path + ", data: " + request.data);
                        reader = new Shumway.BinaryFileReader(path, request.method, request.mimeType, request.data);
                        reader.readChunked(service._fileReadChunkSize, function (data, progress) {
                            self.onprogress(data, { bytesLoaded: progress.loaded, bytesTotal: progress.total });
                        }, function (e) {
                            self.onerror(e);
                        }, self.onopen, self.onclose, self.onhttpstatus);
                    },
                    close: function () {
                        reader.abort();
                        reader = null;
                    }
                };
            };
            BrowserFileLoadingService.prototype.init = function (baseUrl, fileReadChunkSize) {
                if (fileReadChunkSize === void 0) { fileReadChunkSize = 0; }
                this._baseUrl = baseUrl;
                this._fileReadChunkSize = fileReadChunkSize;
            };
            BrowserFileLoadingService.prototype.resolveUrl = function (url) {
                return new window.URL(url, this._baseUrl).href;
            };
            BrowserFileLoadingService.prototype.navigateTo = function (url, target) {
                window.open(this.resolveUrl(url), target || '_blank');
            };
            return BrowserFileLoadingService;
        }());
        Player.BrowserFileLoadingService = BrowserFileLoadingService;
        var ShumwayComResourcesLoadingService = /** @class */ (function () {
            function ShumwayComResourcesLoadingService(preload) {
                this._pendingPromises = [];
                if (preload) {
                    this.load(0 /* BuiltinAbc */);
                    this.load(1 /* PlayerglobalAbcs */);
                    this.load(2 /* PlayerglobalManifest */);
                }
                ShumwayCom.setSystemResourceCallback(this._onSystemResourceCallback.bind(this));
            }
            ShumwayComResourcesLoadingService.prototype._onSystemResourceCallback = function (id, data) {
                this._pendingPromises[id].resolve(data);
            };
            ShumwayComResourcesLoadingService.prototype.load = function (id) {
                var result = this._pendingPromises[id];
                if (!result) {
                    result = new Shumway.PromiseWrapper();
                    this._pendingPromises[id] = result;
                    ShumwayCom.loadSystemResource(id);
                }
                return result.promise;
            };
            return ShumwayComResourcesLoadingService;
        }());
        Player.ShumwayComResourcesLoadingService = ShumwayComResourcesLoadingService;
        var BrowserSystemResourcesLoadingService = /** @class */ (function () {
            function BrowserSystemResourcesLoadingService(builtinPath, viewerPlayerglobalInfo, shellPath) {
                this.builtinPath = builtinPath;
                this.viewerPlayerglobalInfo = viewerPlayerglobalInfo;
                this.shellPath = shellPath;
            }
            BrowserSystemResourcesLoadingService.prototype.load = function (id) {
                switch (id) {
                    case 0 /* BuiltinAbc */:
                        return this._promiseFile(this.builtinPath, 'arraybuffer');
                    case 1 /* PlayerglobalAbcs */:
                        return this._promiseFile(this.viewerPlayerglobalInfo.abcs, 'arraybuffer');
                    case 2 /* PlayerglobalManifest */:
                        return this._promiseFile(this.viewerPlayerglobalInfo.catalog, 'json');
                    case 3 /* ShellAbc */:
                        return this._promiseFile(this.shellPath, 'arraybuffer');
                    default:
                        return Promise.reject(new Error('Unsupported system resource id: ' + id));
                }
            };
            BrowserSystemResourcesLoadingService.prototype._promiseFile = function (path, responseType) {
                return new Promise(function (resolve, reject) {
                    Shumway.SWF.enterTimeline('Load file', path);
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path);
                    xhr.responseType = responseType;
                    xhr.onload = function () {
                        Shumway.SWF.leaveTimeline();
                        var response = xhr.response;
                        if (response) {
                            if (responseType === 'json' && xhr.responseType !== 'json') {
                                // some browsers (e.g. Safari) have no idea what json is
                                response = JSON.parse(response);
                            }
                            resolve(response);
                        }
                        else {
                            reject('Unable to load ' + path + ': ' + xhr.statusText);
                        }
                    };
                    xhr.onerror = function () {
                        Shumway.SWF.leaveTimeline();
                        reject('Unable to load: xhr error');
                    };
                    xhr.send();
                });
            };
            return BrowserSystemResourcesLoadingService;
        }());
        Player.BrowserSystemResourcesLoadingService = BrowserSystemResourcesLoadingService;
        function qualifyLocalConnectionName(connectionName, assertNoPrefix) {
            release || Shumway.Debug.assert(typeof connectionName === 'string');
            // Connection names that don't start with "_" must be qualified with a domain prefix,
            // followed by ":". The prefix is supplied automatically based on the currently running
            // script. Only for LocalConnection#send is it allowed to already be contained in the name.
            if (!release && assertNoPrefix) {
                Shumway.Debug.assert(connectionName.indexOf(':') === -1);
            }
            if (connectionName[0] !== '_') {
                if (connectionName.indexOf(':') === -1) {
                    var currentURL = new jsGlobal.URL(Shumway.flash.system.currentDomain().system._currentDomain.url);
                    connectionName = currentURL.hostname + ':' + connectionName;
                }
                // Note: for LocalConnection#send, the name can contain an arbitrary number of ":" chars,
                // so no validity check is required.
                if (!release && assertNoPrefix) {
                    Shumway.Debug.assert(connectionName.split(':').length === 2);
                }
            }
            return connectionName;
        }
        var BaseLocalConnectionService = /** @class */ (function () {
            function BaseLocalConnectionService() {
                this._localConnections = Object.create(null);
            }
            BaseLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return false;
            };
            BaseLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.send = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                connectionName = qualifyLocalConnectionName(connectionName, false);
                release || Shumway.Debug.assert(typeof methodName === 'string');
                release || Shumway.Debug.assert(argsBuffer instanceof ArrayBuffer);
                var self = this;
                function invokeMessageHandler() {
                    var status = self.hasConnection(connectionName) ? 'status' : 'error';
                    var statusEvent = new sender.sec.flash.events.StatusEvent('status', false, false, null, status);
                    try {
                        sender.dispatchEvent(statusEvent);
                    }
                    catch (e) {
                        console.warn("Exception encountered during statusEvent handling in LocalConnection" +
                            " sender.", e);
                    }
                    if (status === 'error') {
                        // If no receiver is found for the connectionName, we're done.
                        return;
                    }
                    release || Shumway.Debug.assert(typeof senderDomain === 'string');
                    release || Shumway.Debug.assert(typeof senderIsSecure === 'boolean');
                    self._sendMessage(connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure);
                }
                Promise.resolve(true).then(invokeMessageHandler);
            };
            BaseLocalConnectionService.prototype.allowDomains = function (connectionName, receiver, domains, secure) {
                Shumway.Debug.somewhatImplemented('LocalConnection#allowDomain');
            };
            return BaseLocalConnectionService;
        }());
        Player.BaseLocalConnectionService = BaseLocalConnectionService;
        var ShumwayComLocalConnectionService = /** @class */ (function (_super) {
            __extends(ShumwayComLocalConnectionService, _super);
            function ShumwayComLocalConnectionService() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ShumwayComLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                release || Shumway.Debug.assert(receiver);
                if (this.hasConnection(connectionName)) {
                    return -2 /* AlreadyTaken */;
                }
                function callback(methodName, argsBuffer) {
                    try {
                        receiver.handleMessage(methodName, argsBuffer);
                        return null;
                    }
                    catch (e) {
                        console.log('error under handleMessage: ', e);
                        return e;
                    }
                }
                var result = ShumwayCom.getLocalConnectionService().createLocalConnection(connectionName, callback);
                if (result !== 0 /* Success */) {
                    return result;
                }
                this._localConnections[connectionName] = receiver;
                return 0 /* Success */;
            };
            ShumwayComLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    return -1 /* NotConnected */;
                }
                ShumwayCom.getLocalConnectionService().closeLocalConnection(connectionName);
                delete this._localConnections[connectionName];
                return 0 /* Success */;
            };
            ShumwayComLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return ShumwayCom.getLocalConnectionService().hasLocalConnection(connectionName);
            };
            ShumwayComLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                var service = ShumwayCom.getLocalConnectionService();
                service.sendLocalConnectionMessage(connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure);
            };
            ShumwayComLocalConnectionService.prototype.allowDomains = function (connectionName, receiver, domains, secure) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    console.warn('Trying to allow domains for invalid connection ' + connectionName);
                    return;
                }
                ShumwayCom.getLocalConnectionService().allowDomainsForLocalConnection(connectionName, domains, secure);
            };
            return ShumwayComLocalConnectionService;
        }(BaseLocalConnectionService));
        Player.ShumwayComLocalConnectionService = ShumwayComLocalConnectionService;
        var PlayerInternalLocalConnectionService = /** @class */ (function (_super) {
            __extends(PlayerInternalLocalConnectionService, _super);
            function PlayerInternalLocalConnectionService() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PlayerInternalLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                release || Shumway.Debug.assert(receiver);
                if (this._localConnections[connectionName]) {
                    return -2 /* AlreadyTaken */;
                }
                this._localConnections[connectionName] = receiver;
                return 0 /* Success */;
            };
            PlayerInternalLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    return -1 /* NotConnected */;
                }
                delete this._localConnections[connectionName];
                return 0 /* Success */;
            };
            PlayerInternalLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return connectionName in this._localConnections;
            };
            PlayerInternalLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderURL) {
                var receiver = this._localConnections[connectionName];
                release || Shumway.Debug.assert(receiver);
                try {
                    receiver.handleMessage(methodName, argsBuffer);
                }
                catch (e) {
                    Shumway.Debug.warning('Unexpected error encountered while sending LocalConnection message.');
                }
            };
            return PlayerInternalLocalConnectionService;
        }(BaseLocalConnectionService));
        Player.PlayerInternalLocalConnectionService = PlayerInternalLocalConnectionService;
    })(Player = Shumway.Player || (Shumway.Player = {}));
})(Shumway || (Shumway = {}));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var Player;
    (function (Player_2) {
        var Window;
        (function (Window) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var WindowGFXService = /** @class */ (function (_super) {
                __extends(WindowGFXService, _super);
                function WindowGFXService(sec, peer) {
                    var _this = _super.call(this, sec) || this;
                    _this._peer = peer;
                    _this._peer.onAsyncMessage = function (msg) {
                        this.onWindowMessage(msg);
                    }.bind(_this);
                    _this._assetDecodingRequests = [];
                    return _this;
                }
                WindowGFXService.prototype.update = function (updates, assets) {
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets,
                        result: undefined
                    };
                    var transferList = [bytes.buffer];
                    this._peer.postAsyncMessage(message, transferList);
                };
                WindowGFXService.prototype.updateAndGet = function (updates, assets) {
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets,
                        result: undefined
                    };
                    var result = this._peer.sendSyncMessage(message);
                    return DataBuffer.FromPlainObject(result);
                };
                WindowGFXService.prototype.frame = function () {
                    this._peer.postAsyncMessage({
                        type: 'frame'
                    });
                };
                WindowGFXService.prototype.videoControl = function (id, eventType, data) {
                    var message = {
                        type: 'videoControl',
                        id: id,
                        eventType: eventType,
                        data: data,
                        result: undefined
                    };
                    return this._peer.sendSyncMessage(message);
                };
                WindowGFXService.prototype.registerFont = function (syncId, data) {
                    var requestId = this._assetDecodingRequests.length;
                    var result = new Shumway.PromiseWrapper();
                    this._assetDecodingRequests[requestId] = result;
                    var message = {
                        type: 'registerFont',
                        syncId: syncId,
                        data: data,
                        requestId: requestId
                    };
                    // Unfortunately we have to make this message synchronously since scripts in the same frame
                    // might rely on it being available in the gfx backend when requesting text measurements.
                    // Just another disadvantage of not doing our our own text shaping.
                    this._peer.sendSyncMessage(message);
                    return result.promise;
                };
                WindowGFXService.prototype.registerImage = function (syncId, symbolId, imageType, data, alphaData) {
                    var requestId = this._assetDecodingRequests.length;
                    var result = new Shumway.PromiseWrapper();
                    this._assetDecodingRequests[requestId] = result;
                    var message = {
                        type: 'registerImage',
                        syncId: syncId,
                        symbolId: symbolId,
                        imageType: imageType,
                        data: data,
                        alphaData: alphaData,
                        requestId: requestId
                    };
                    this._peer.postAsyncMessage(message);
                    return result.promise;
                };
                WindowGFXService.prototype.fscommand = function (command, args) {
                    this._peer.postAsyncMessage({
                        type: 'fscommand',
                        command: command,
                        args: args
                    });
                };
                WindowGFXService.prototype.onWindowMessage = function (data) {
                    if (typeof data === 'object' && data !== null) {
                        switch (data.type) {
                            case 'gfx':
                                var DataBuffer_1 = Shumway.ArrayUtilities.DataBuffer;
                                var updates = DataBuffer_1.FromArrayBuffer(data.updates.buffer);
                                this.processUpdates(updates, data.assets);
                                break;
                            case 'videoPlayback':
                                this.processVideoEvent(data.id, data.eventType, data.data);
                                break;
                            case 'displayParameters':
                                this.processDisplayParameters(data.params);
                                break;
                            case 'registerFontResponse':
                            case 'registerImageResponse':
                                var request = this._assetDecodingRequests[data.requestId];
                                release || Shumway.Debug.assert(request);
                                delete this._assetDecodingRequests[data.requestId];
                                request.resolve(data.result);
                                break;
                            case 'options':
                                Shumway.Settings.setSettings(data.settings);
                                break;
                        }
                    }
                };
                return WindowGFXService;
            }(Player_2.GFXServiceBase));
            Window.WindowGFXService = WindowGFXService;
        })(Window = Player_2.Window || (Player_2.Window = {}));
    })(Player = Shumway.Player || (Shumway.Player = {}));
})(Shumway || (Shumway = {}));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='module.ts' />
///<reference path='settings.ts' />
///<reference path='frameScheduler.ts' />
///<reference path='remotingPlayer.ts' />
///<reference path='player.ts' />
///<reference path='external.ts' />
///<reference path='window/windowPlayer.ts' />
///<reference path="base/references.ts"/>
///<reference path="tools/references.ts"/>
///<reference path="swf/references.ts"/>
///<reference path="rtmp/references.ts"/>
///<reference path="flash-legacy/references.ts"/>
///<reference path="gfx-base/references.ts"/>
///<reference path="gfx/references.ts"/>
///<reference path="player-legacy/references.ts"/>
//# sourceMappingURL=pixi-swf.js.map